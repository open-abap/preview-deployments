"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkopen_table_maintenance"] = self["webpackChunkopen_table_maintenance"] || []).push([["output_cl_ixml_clas_locals_mjs"],{

/***/ "./output/cl_ixml.clas.locals.mjs":
/*!****************************************!*\
  !*** ./output/cl_ixml.clas.locals.mjs ***!
  \****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"lcl_document\": () => (/* binding */ lcl_document),\n/* harmony export */   \"lcl_encoding\": () => (/* binding */ lcl_encoding),\n/* harmony export */   \"lcl_escape\": () => (/* binding */ lcl_escape),\n/* harmony export */   \"lcl_istream\": () => (/* binding */ lcl_istream),\n/* harmony export */   \"lcl_named_node_map\": () => (/* binding */ lcl_named_node_map),\n/* harmony export */   \"lcl_node\": () => (/* binding */ lcl_node),\n/* harmony export */   \"lcl_node_iterator\": () => (/* binding */ lcl_node_iterator),\n/* harmony export */   \"lcl_node_list\": () => (/* binding */ lcl_node_list),\n/* harmony export */   \"lcl_ostream\": () => (/* binding */ lcl_ostream),\n/* harmony export */   \"lcl_parser\": () => (/* binding */ lcl_parser),\n/* harmony export */   \"lcl_renderer\": () => (/* binding */ lcl_renderer),\n/* harmony export */   \"lcl_stream_factory\": () => (/* binding */ lcl_stream_factory)\n/* harmony export */ });\nconst {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ \"./output/cx_root.clas.mjs\"));\n// cl_ixml.clas.locals_imp.abap\nclass lcl_escape {\n  static INTERNAL_TYPE = 'CLAS';\n  static IMPLEMENTED_INTERFACES = [];\n  static ATTRIBUTES = {};\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    return this;\n  }\n  async unescape_value(INPUT) {\n    return lcl_escape.unescape_value(INPUT);\n  }\n  static async unescape_value(INPUT) {\n    let rv_value = new abap.types.String({qualifiedName: \"STRING\"});\n    let iv_value = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.iv_value) {iv_value.set(INPUT.iv_value);}\n    rv_value.set(iv_value);\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.Character(1).set('&'), of: new abap.types.Character(5).set('&amp;')});\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.Character(1).set('<'), of: new abap.types.Character(4).set('&lt;')});\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.Character(1).set('>'), of: new abap.types.Character(4).set('&gt;')});\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.Character(1).set('\"'), of: new abap.types.Character(6).set('&quot;')});\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.String().set(`'`), of: new abap.types.Character(6).set('&apos;')});\n    return rv_value;\n  }\n  async escape_value(INPUT) {\n    return lcl_escape.escape_value(INPUT);\n  }\n  static async escape_value(INPUT) {\n    let rv_value = new abap.types.String({qualifiedName: \"STRING\"});\n    let iv_value = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.iv_value) {iv_value.set(INPUT.iv_value);}\n    rv_value.set(iv_value);\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.Character(5).set('&amp;'), of: new abap.types.Character(1).set('&')});\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.Character(4).set('&lt;'), of: new abap.types.Character(1).set('<')});\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.Character(4).set('&gt;'), of: new abap.types.Character(1).set('>')});\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.Character(6).set('&quot;'), of: new abap.types.Character(1).set('\"')});\n    abap.statements.replace({target: rv_value, all: true, with: new abap.types.Character(6).set('&apos;'), of: new abap.types.String().set(`'`)});\n    return rv_value;\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_ESCAPE'] = lcl_escape;\nclass lcl_node_iterator {\n  static INTERNAL_TYPE = 'CLAS';\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_NODE_ITERATOR\"];\n  static ATTRIBUTES = {\"MV_POINTER\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"I\"});}, \"visibility\": \"U\", \"is_constant\": \" \"},\n  \"MT_LIST\": {\"type\": () => {return abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"}), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_node_iterator=>ty_list\");}, \"visibility\": \"U\", \"is_constant\": \" \"}};\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mv_pointer = new abap.types.Integer({qualifiedName: \"I\"});\n    this.mt_list = abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"}), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_node_iterator=>ty_list\");\n    let it_list = abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"}), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_node_iterator=>ty_list\");\n    if (INPUT && INPUT.it_list) {it_list.set(INPUT.it_list);}\n    this.mt_list.set(it_list);\n    this.mv_pointer.set(new abap.types.Integer().set(1));\n    return this;\n  }\n  async if_ixml_node_iterator$reset() {\n    this.mv_pointer.set(new abap.types.Integer().set(1));\n  }\n  async if_ixml_node_iterator$get_next() {\n    let rval = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    abap.statements.readTable(this.mt_list,{index: this.mv_pointer,\n      into: rval});\n    this.mv_pointer.set(abap.operators.add(this.mv_pointer,new abap.types.Integer().set(1)));\n    return rval;\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_NODE_ITERATOR'] = lcl_node_iterator;\nlcl_node_iterator.ty_list = abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"}), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_node_iterator=>ty_list\");\nclass lcl_encoding {\n  static INTERNAL_TYPE = 'CLAS';\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_ENCODING\"];\n  static ATTRIBUTES = {};\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.if_ixml_encoding$co_platform_endian = abap.Classes['IF_IXML_ENCODING'].if_ixml_encoding$co_platform_endian;\n    return this;\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_ENCODING'] = lcl_encoding;\nlcl_encoding.if_ixml_encoding$co_platform_endian = new abap.types.String({qualifiedName: \"STRING\"});\nlcl_encoding.if_ixml_encoding$co_platform_endian.set('a');\nclass lcl_named_node_map {\n  static INTERNAL_TYPE = 'CLAS';\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_NAMED_NODE_MAP\"];\n  static ATTRIBUTES = {\"MT_LIST\": {\"type\": () => {return abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"}), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"\");}, \"visibility\": \"U\", \"is_constant\": \" \"}};\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mt_list = abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"}), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"\");\n    return this;\n  }\n  async if_ixml_named_node_map$create_iterator() {\n    let iterator = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\n    iterator.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE_ITERATOR']()).constructor_({it_list: this.mt_list}));\n    return iterator;\n  }\n  async if_ixml_named_node_map$get_length() {\n    let val = new abap.types.Integer({qualifiedName: \"I\"});\n    val.set(abap.builtin.lines({val: this.mt_list}));\n    return val;\n  }\n  async if_ixml_named_node_map$get_named_item_ns(INPUT) {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let li_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    for await (const unique29 of abap.statements.loop(this.mt_list)) {\n      li_node.set(unique29);\n      if (abap.compare.eq((await li_node.get().if_ixml_node$get_name()), name)) {\n        val.set(li_node);\n        return val;\n      }\n    }\n    return val;\n  }\n  async if_ixml_named_node_map$get_named_item(INPUT) {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return val;\n  }\n  async if_ixml_named_node_map$remove_named_item(INPUT) {\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n  }\n  async if_ixml_named_node_map$set_named_item_ns(INPUT) {\n    let node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    if (INPUT && INPUT.node) {node.set(INPUT.node);}\n    abap.statements.append({source: node, target: this.mt_list});\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_NAMED_NODE_MAP'] = lcl_named_node_map;\nclass lcl_node_list {\n  static INTERNAL_TYPE = 'CLAS';\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_NODE_LIST\"];\n  static ATTRIBUTES = {\"MT_LIST\": {\"type\": () => {return abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"}), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"\");}, \"visibility\": \"U\", \"is_constant\": \" \"}};\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mt_list = abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"}), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"\");\n    return this;\n  }\n  async append(INPUT) {\n    let ii_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    if (INPUT && INPUT.ii_node) {ii_node.set(INPUT.ii_node);}\n    abap.statements.assert(abap.compare.initial(ii_node) === false);\n    abap.statements.append({source: ii_node, target: this.mt_list});\n  }\n  async remove(INPUT) {\n    let ii_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    if (INPUT && INPUT.ii_node) {ii_node.set(INPUT.ii_node);}\n    abap.statements.readTable(this.mt_list,{withKey: (i) => {return abap.compare.eq(i.table_line, ii_node);},\n      withKeyValue: [{key: (i) => {return i.table_line}, value: ii_node}],\n      usesTableLine: true,\n      withKeySimple: {\"table_line\": ii_node}});\n    if (abap.compare.eq(abap.builtin.sy.get().subrc, new abap.types.Integer().set(0))) {\n      await abap.statements.deleteInternal(this.mt_list,{index: abap.builtin.sy.get().tabix});\n    }\n  }\n  async if_ixml_node_list$get_length() {\n    let length = new abap.types.Integer({qualifiedName: \"I\"});\n    length.set(abap.builtin.lines({val: this.mt_list}));\n    return length;\n  }\n  async if_ixml_node_list$create_iterator() {\n    let rval = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\n    rval.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE_ITERATOR']()).constructor_({it_list: this.mt_list}));\n    return rval;\n  }\n  async if_ixml_node_list$get_item(INPUT) {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    let index = new abap.types.Integer({qualifiedName: \"I\"});\n    if (INPUT && INPUT.index) {index.set(INPUT.index);}\n    abap.statements.readTable(this.mt_list,{index: index,\n      into: val});\n    return val;\n  }\n  async if_ixml_node_list$create_rev_iterator_filtered(INPUT) {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\n    let filter = new abap.types.Character(4);\n    if (INPUT && INPUT.filter) {filter = INPUT.filter;}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return val;\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_NODE_LIST'] = lcl_node_list;\nclass lcl_node {\n  static INTERNAL_TYPE = 'CLAS';\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_ELEMENT\",\"IF_IXML_NODE\"];\n  static ATTRIBUTES = {\"MV_NAME\": {\"type\": () => {return new abap.types.String({qualifiedName: \"STRING\"});}, \"visibility\": \"U\", \"is_constant\": \" \"},\n  \"MV_NAMESPACE\": {\"type\": () => {return new abap.types.String({qualifiedName: \"STRING\"});}, \"visibility\": \"U\", \"is_constant\": \" \"},\n  \"MV_VALUE\": {\"type\": () => {return new abap.types.String({qualifiedName: \"STRING\"});}, \"visibility\": \"U\", \"is_constant\": \" \"},\n  \"MO_CHILDREN\": {\"type\": () => {return new abap.types.ABAPObject({qualifiedName: \"LCL_NODE_LIST\"});}, \"visibility\": \"U\", \"is_constant\": \" \"},\n  \"MI_PARENT\": {\"type\": () => {return new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});}, \"visibility\": \"U\", \"is_constant\": \" \"},\n  \"MI_ATTRIBUTES\": {\"type\": () => {return new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NAMED_NODE_MAP\"});}, \"visibility\": \"U\", \"is_constant\": \" \"}};\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mv_name = new abap.types.String({qualifiedName: \"STRING\"});\n    this.mv_namespace = new abap.types.String({qualifiedName: \"STRING\"});\n    this.mv_value = new abap.types.String({qualifiedName: \"STRING\"});\n    this.mo_children = new abap.types.ABAPObject({qualifiedName: \"LCL_NODE_LIST\"});\n    this.mi_parent = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    this.mi_attributes = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NAMED_NODE_MAP\"});\n    this.if_ixml_node$co_node_element = abap.Classes['IF_IXML_NODE'].if_ixml_node$co_node_element;\n    this.if_ixml_node$co_node_text = abap.Classes['IF_IXML_NODE'].if_ixml_node$co_node_text;\n    let ii_parent = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    if (INPUT && INPUT.ii_parent) {ii_parent.set(INPUT.ii_parent);}\n    this.mo_children.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE_LIST']()).constructor_());\n    this.mi_attributes.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NAMED_NODE_MAP']()).constructor_());\n    this.mi_parent.set(ii_parent);\n    if (abap.compare.initial(this.mi_parent) === false) {\n      await ii_parent.get().if_ixml_node$append_child({new_child: this.me});\n    }\n    return this;\n  }\n  async if_ixml_element$get_attribute_node_ns(INPUT) {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ATTRIBUTE\"});\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let uri = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.uri) {uri.set(INPUT.uri);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return val;\n  }\n  async if_ixml_node$get_next() {\n    let rval = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return rval;\n  }\n  async if_ixml_node$get_namespace_prefix() {\n    let rv_prefix = new abap.types.String({qualifiedName: \"STRING\"});\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return rv_prefix;\n  }\n  async if_ixml_node$get_namespace_uri() {\n    let rval = new abap.types.String({qualifiedName: \"STRING\"});\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return rval;\n  }\n  async if_ixml_element$get_attributes() {\n    let attr = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NAMED_NODE_MAP\"});\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return attr;\n  }\n  async if_ixml_element$get_next() {\n    let next = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return next;\n  }\n  async if_ixml_element$get_name() {\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return name;\n  }\n  async if_ixml_element$append_child(INPUT) {\n    let rc = new abap.types.Integer({qualifiedName: \"I\"});\n    let new_child = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    if (INPUT && INPUT.new_child) {new_child.set(INPUT.new_child);}\n    let lo_node = new abap.types.ABAPObject({qualifiedName: \"LCL_NODE\"});\n    await abap.statements.cast(lo_node, new_child);\n    lo_node.get().mi_parent.set(this.me);\n    await this.mo_children.get().append({ii_node: new_child});\n    return rc;\n  }\n  async if_ixml_element$clone() {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return val;\n  }\n  async if_ixml_element$create_filter_node_type(INPUT) {\n    let val = new abap.types.DataReference(new abap.types.Character(4));\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return val;\n  }\n  async if_ixml_element$remove_attribute_ns(INPUT) {\n    let foo = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.foo) {foo.set(INPUT.foo);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n  }\n  async if_ixml_element$create_iterator() {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return val;\n  }\n  async if_ixml_element$find_from_name_ns(INPUT) {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let namespace = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\n    let uri = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.uri) {uri.set(INPUT.uri);}\n    let depth = new abap.types.Integer({qualifiedName: \"I\"});\n    if (INPUT && INPUT.depth) {depth.set(INPUT.depth);}\n    let li_iterator = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\n    let li_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    let li_children = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_LIST\"});\n    let lt_nodes = abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"}), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"\");\n    let li_top = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    abap.statements.append({source: this.me, target: lt_nodes});\n    for await (const unique30 of abap.statements.loop(lt_nodes)) {\n      li_top.set(unique30);\n      li_children.set((await li_top.get().if_ixml_node$get_children()));\n      li_iterator.set((await li_children.get().if_ixml_node_list$create_iterator()));\n      const indexBackup1 = abap.builtin.sy.get().index.get();\n      let unique31 = 1;\n      while (true) {\n        abap.builtin.sy.get().index.set(unique31++);\n        li_node.set((await li_iterator.get().if_ixml_node_iterator$get_next()));\n        if (abap.compare.initial(li_node)) {\n          break;\n        }\n        if (abap.compare.eq((await li_node.get().if_ixml_node$get_name()), name)) {\n          await abap.statements.cast(val, li_node);\n          abap.builtin.sy.get().index.set(indexBackup1);\n          return val;\n        }\n        abap.statements.append({source: li_node, target: lt_nodes});\n      }\n      abap.builtin.sy.get().index.set(indexBackup1);\n    }\n    return val;\n  }\n  async if_ixml_element$find_from_name(INPUT) {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let namespace = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\n    let depth = new abap.types.Integer({qualifiedName: \"I\"});\n    if (INPUT && INPUT.depth) {depth.set(INPUT.depth);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return val;\n  }\n  async if_ixml_element$get_attribute_node(INPUT) {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ATTRIBUTE\"});\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return val;\n  }\n  async if_ixml_element$get_attribute_ns(INPUT) {\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let uri = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.uri) {uri.set(INPUT.uri);}\n    let li_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    li_node.set((await (await this.if_ixml_node$get_attributes()).get().if_ixml_named_node_map$get_named_item_ns({name: name})));\n    if (abap.compare.initial(li_node) === false) {\n      val.set((await li_node.get().if_ixml_node$get_value()));\n    }\n    return val;\n  }\n  async if_ixml_element$get_attribute(INPUT) {\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let namespace = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return val;\n  }\n  async if_ixml_element$get_children() {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_LIST\"});\n    val.set((await this.if_ixml_node$get_children()));\n    return val;\n  }\n  async if_ixml_element$get_elements_by_tag_name(INPUT) {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_COLLECTION\"});\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return val;\n  }\n  async if_ixml_element$get_elements_by_tag_name_ns(INPUT) {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_COLLECTION\"});\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let uri = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.uri) {uri.set(INPUT.uri);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return val;\n  }\n  async if_ixml_element$get_first_child() {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    val.set((await this.if_ixml_node$get_first_child()));\n    return val;\n  }\n  async if_ixml_element$get_value() {\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\n    val.set((await this.if_ixml_node$get_value()));\n    return val;\n  }\n  async if_ixml_element$remove_attribute(INPUT) {\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n  }\n  async if_ixml_element$remove_node() {\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n  }\n  async if_ixml_element$render(INPUT) {\n    let ostream = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_OSTREAM\"});\n    if (INPUT && INPUT.ostream) {ostream.set(INPUT.ostream);}\n    let li_iterator = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\n    let li_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    let li_element = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\n    let lv_attributes = new abap.types.String({qualifiedName: \"STRING\"});\n    let lv_ns = new abap.types.String({qualifiedName: \"STRING\"});\n    li_iterator.set((await this.mi_attributes.get().if_ixml_named_node_map$create_iterator()));\n    const indexBackup1 = abap.builtin.sy.get().index.get();\n    let unique32 = 1;\n    while (true) {\n      abap.builtin.sy.get().index.set(unique32++);\n      li_node.set((await li_iterator.get().if_ixml_node_iterator$get_next()));\n      if (abap.compare.initial(li_node)) {\n        break;\n      }\n      lv_attributes.set(abap.operators.concat(lv_attributes,abap.operators.concat(new abap.types.String().set(` `),abap.operators.concat((await li_node.get().if_ixml_node$get_name()),abap.operators.concat(new abap.types.Character(2).set('=\"'),abap.operators.concat((await li_node.get().if_ixml_node$get_value()),new abap.types.Character(1).set('\"')))))));\n    }\n    abap.builtin.sy.get().index.set(indexBackup1);\n    if (abap.compare.initial(this.mv_namespace) === false) {\n      lv_ns.set(abap.operators.concat(this.mv_namespace,new abap.types.Character(1).set(':')));\n    }\n    if (abap.compare.ne(this.mv_name, new abap.types.Character(5).set('#text'))) {\n      await ostream.get().if_ixml_ostream$write_string({string: abap.operators.concat(new abap.types.Character(1).set('<'),abap.operators.concat(lv_ns,abap.operators.concat(this.mv_name,lv_attributes)))});\n      if (abap.compare.gt((await (await this.if_ixml_node$get_children()).get().if_ixml_node_list$get_length()), new abap.types.Integer().set(0)) || abap.compare.initial(this.mv_value) === false) {\n        await ostream.get().if_ixml_ostream$write_string({string: new abap.types.Character(1).set('>')});\n      }\n    }\n    li_iterator.set((await (await this.if_ixml_node$get_children()).get().if_ixml_node_list$create_iterator()));\n    const indexBackup2 = abap.builtin.sy.get().index.get();\n    let unique33 = 1;\n    while (true) {\n      abap.builtin.sy.get().index.set(unique33++);\n      await abap.statements.cast(li_element, (await li_iterator.get().if_ixml_node_iterator$get_next()));\n      if (abap.compare.initial(li_element)) {\n        break;\n      }\n      await li_element.get().if_ixml_element$render({ostream: ostream});\n    }\n    abap.builtin.sy.get().index.set(indexBackup2);\n    if (abap.compare.gt((await (await this.if_ixml_node$get_children()).get().if_ixml_node_list$get_length()), new abap.types.Integer().set(0)) || abap.compare.initial(this.mv_value) === false) {\n      await ostream.get().if_ixml_ostream$write_string({string: (await abap.Classes['CLAS-CL_IXML-LCL_ESCAPE'].escape_value({iv_value: this.mv_value}))});\n      if (abap.compare.ne(this.mv_name, new abap.types.Character(5).set('#text'))) {\n        await ostream.get().if_ixml_ostream$write_string({string: abap.operators.concat(new abap.types.Character(2).set('</'),abap.operators.concat(lv_ns,abap.operators.concat(this.mv_name,new abap.types.Character(1).set('>'))))});\n      }\n    } else {\n      await ostream.get().if_ixml_ostream$write_string({string: new abap.types.Character(2).set('/>')});\n    }\n  }\n  async if_ixml_element$set_attribute_node_ns(INPUT) {\n    let attr = new abap.types.Character(4);\n    if (INPUT && INPUT.attr) {attr = INPUT.attr;}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n  }\n  async if_ixml_element$set_attribute(INPUT) {\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let namespace = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\n    let value = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\n    await this.if_ixml_element$set_attribute_ns({name: name, value: value});\n  }\n  async if_ixml_element$set_attribute_ns(INPUT) {\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let prefix = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}\n    let value = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\n    let lo_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    lo_node.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_());\n    await lo_node.get().if_ixml_node$set_name({name: name});\n    await lo_node.get().if_ixml_node$set_value({value: value});\n    await this.mi_attributes.get().if_ixml_named_node_map$set_named_item_ns({node: lo_node});\n  }\n  async if_ixml_element$set_value(INPUT) {\n    let rc = new abap.types.Integer({qualifiedName: \"I\"});\n    let value = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\n    await this.if_ixml_node$set_value({value: value});\n    return rc;\n  }\n  async if_ixml_node$set_namespace_prefix(INPUT) {\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.val) {val.set(INPUT.val);}\n    this.mv_namespace.set(val);\n  }\n  async if_ixml_node$append_child(INPUT) {\n    let new_child = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    if (INPUT && INPUT.new_child) {new_child.set(INPUT.new_child);}\n    let lo_node = new abap.types.ABAPObject({qualifiedName: \"LCL_NODE\"});\n    await abap.statements.cast(lo_node, new_child);\n    lo_node.get().mi_parent.set(this.me);\n    await this.mo_children.get().append({ii_node: new_child});\n  }\n  async if_ixml_node$get_attributes() {\n    let map = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NAMED_NODE_MAP\"});\n    map.set(this.mi_attributes);\n    return map;\n  }\n  async if_ixml_node$get_first_child() {\n    let node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    node.set((await this.mo_children.get().if_ixml_node_list$get_item({index: new abap.types.Integer().set(1)})));\n    return node;\n  }\n  async if_ixml_node$get_children() {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_LIST\"});\n    val.set(this.mo_children);\n    return val;\n  }\n  async if_ixml_node$query_interface(INPUT) {\n    let rval = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_UNKNOWN\"});\n    let foo = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.foo) {foo.set(INPUT.foo);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return rval;\n  }\n  async if_ixml_node$remove_node() {\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n  }\n  async if_ixml_node$get_parent() {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    val.set(this.mi_parent);\n    return val;\n  }\n  async if_ixml_node$replace_child(INPUT) {\n    let new_child = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.new_child) {new_child.set(INPUT.new_child);}\n    let old_child = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.old_child) {old_child.set(INPUT.old_child);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n  }\n  async if_ixml_node$get_name() {\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\n    val.set(this.mv_name);\n    return val;\n  }\n  async if_ixml_node$get_depth() {\n    let val = new abap.types.Integer({qualifiedName: \"I\"});\n    let li_iterator = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\n    let li_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    let lv_max = new abap.types.Integer({qualifiedName: \"I\"});\n    if (abap.compare.eq((await this.mo_children.get().if_ixml_node_list$get_length()), new abap.types.Integer().set(0))) {\n      val.set(new abap.types.Integer().set(0));\n    } else {\n      li_iterator.set((await this.mo_children.get().if_ixml_node_list$create_iterator()));\n      const indexBackup1 = abap.builtin.sy.get().index.get();\n      let unique34 = 1;\n      while (true) {\n        abap.builtin.sy.get().index.set(unique34++);\n        li_node.set((await li_iterator.get().if_ixml_node_iterator$get_next()));\n        if (abap.compare.initial(li_node)) {\n          break;\n        }\n        if (abap.compare.gt((await li_node.get().if_ixml_node$get_depth()), lv_max)) {\n          lv_max.set((await li_node.get().if_ixml_node$get_depth()));\n        }\n      }\n      abap.builtin.sy.get().index.set(indexBackup1);\n      val.set(abap.operators.add(lv_max,new abap.types.Integer().set(1)));\n    }\n    return val;\n  }\n  async if_ixml_node$is_leaf() {\n    let val = new abap.types.Character(1, {\"qualifiedName\":\"ABAP_BOOL\",\"ddicName\":\"ABAP_BOOL\"});\n    val.set(abap.builtin.boolc(abap.compare.eq((await this.mo_children.get().if_ixml_node_list$get_length()), new abap.types.Integer().set(0))));\n    return val;\n  }\n  async if_ixml_node$get_namespace() {\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\n    val.set(this.mv_namespace);\n    return val;\n  }\n  async if_ixml_node$get_value() {\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\n    let li_iterator = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\n    let li_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    let lv_max = new abap.types.Integer({qualifiedName: \"I\"});\n    if (abap.compare.eq((await this.mo_children.get().if_ixml_node_list$get_length()), new abap.types.Integer().set(0))) {\n      val.set(this.mv_value);\n    } else {\n      li_iterator.set((await this.mo_children.get().if_ixml_node_list$create_iterator()));\n      const indexBackup1 = abap.builtin.sy.get().index.get();\n      let unique35 = 1;\n      while (true) {\n        abap.builtin.sy.get().index.set(unique35++);\n        li_node.set((await li_iterator.get().if_ixml_node_iterator$get_next()));\n        if (abap.compare.initial(li_node)) {\n          break;\n        }\n        val.set(abap.operators.concat(val,(await li_node.get().if_ixml_node$get_value())));\n      }\n      abap.builtin.sy.get().index.set(indexBackup1);\n    }\n    return val;\n  }\n  async if_ixml_node$get_type() {\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return val;\n  }\n  async if_ixml_node$set_name(INPUT) {\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    this.mv_name.set(name);\n  }\n  async if_ixml_node$remove_child(INPUT) {\n    let child = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    if (INPUT && INPUT.child) {child.set(INPUT.child);}\n    await this.mo_children.get().remove({ii_node: child});\n  }\n  async if_ixml_node$set_value(INPUT) {\n    let value = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\n    this.mv_value.set(value);\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_NODE'] = lcl_node;\nlcl_node.if_ixml_node$co_node_element = new abap.types.Integer({qualifiedName: \"I\"});\nlcl_node.if_ixml_node$co_node_element.set(0);\nlcl_node.if_ixml_node$co_node_text = new abap.types.Integer({qualifiedName: \"I\"});\nlcl_node.if_ixml_node$co_node_text.set(0);\nclass lcl_document {\n  static INTERNAL_TYPE = 'CLAS';\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_DOCUMENT\",\"IF_IXML_NODE\"];\n  static ATTRIBUTES = {\"MI_NODE\": {\"type\": () => {return new abap.types.ABAPObject({qualifiedName: \"LCL_NODE\"});}, \"visibility\": \"U\", \"is_constant\": \" \"}};\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mi_node = new abap.types.ABAPObject({qualifiedName: \"LCL_NODE\"});\n    this.if_ixml_node$co_node_element = abap.Classes['IF_IXML_NODE'].if_ixml_node$co_node_element;\n    this.if_ixml_node$co_node_text = abap.Classes['IF_IXML_NODE'].if_ixml_node$co_node_text;\n    this.mi_node.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_());\n    await this.mi_node.get().if_ixml_node$set_name({name: new abap.types.Character(9).set('#document')});\n    return this;\n  }\n  async if_ixml_node$get_namespace_prefix() {\n    let rv_prefix = new abap.types.String({qualifiedName: \"STRING\"});\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return rv_prefix;\n  }\n  async if_ixml_node$get_next() {\n    let rval = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return rval;\n  }\n  async if_ixml_node$get_namespace_uri() {\n    let rval = new abap.types.String({qualifiedName: \"STRING\"});\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return rval;\n  }\n  async if_ixml_node$append_child(INPUT) {\n    let new_child = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    if (INPUT && INPUT.new_child) {new_child.set(INPUT.new_child);}\n    let lo_node = new abap.types.ABAPObject({qualifiedName: \"LCL_NODE\"});\n    await abap.statements.cast(lo_node, new_child);\n    lo_node.get().mi_parent.set(this.me);\n    await this.mi_node.get().if_ixml_node$append_child({new_child: new_child});\n  }\n  async if_ixml_node$set_namespace_prefix(INPUT) {\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.val) {val.set(INPUT.val);}\n    await this.mi_node.get().if_ixml_node$set_namespace_prefix({val: val});\n  }\n  async if_ixml_node$get_attributes() {\n    let map = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NAMED_NODE_MAP\"});\n    map.set((await this.mi_node.get().if_ixml_node$get_attributes()));\n    return map;\n  }\n  async if_ixml_node$get_first_child() {\n    let node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    node.set((await this.mi_node.get().if_ixml_node$get_first_child()));\n    return node;\n  }\n  async if_ixml_node$get_children() {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_LIST\"});\n    val.set((await this.mi_node.get().if_ixml_node$get_children()));\n    return val;\n  }\n  async if_ixml_node$query_interface(INPUT) {\n    let rval = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_UNKNOWN\"});\n    let foo = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.foo) {foo.set(INPUT.foo);}\n    await this.mi_node.get().if_ixml_node$query_interface({foo: foo});\n    return rval;\n  }\n  async if_ixml_node$remove_node() {\n    await this.mi_node.get().if_ixml_node$remove_node();\n  }\n  async if_ixml_node$get_parent() {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    val.set((await this.mi_node.get().if_ixml_node$get_parent()));\n    return val;\n  }\n  async if_ixml_node$replace_child(INPUT) {\n    let new_child = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.new_child) {new_child.set(INPUT.new_child);}\n    let old_child = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.old_child) {old_child.set(INPUT.old_child);}\n    await this.mi_node.get().if_ixml_node$replace_child({new_child: new_child, old_child: old_child});\n  }\n  async if_ixml_node$get_name() {\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\n    val.set((await this.mi_node.get().if_ixml_node$get_name()));\n    return val;\n  }\n  async if_ixml_node$get_depth() {\n    let val = new abap.types.Integer({qualifiedName: \"I\"});\n    val.set((await this.mi_node.get().if_ixml_node$get_depth()));\n    return val;\n  }\n  async if_ixml_node$is_leaf() {\n    let val = new abap.types.Character(1, {\"qualifiedName\":\"ABAP_BOOL\",\"ddicName\":\"ABAP_BOOL\"});\n    val.set((await this.mi_node.get().if_ixml_node$is_leaf()));\n    return val;\n  }\n  async if_ixml_node$get_namespace() {\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\n    val.set((await this.mi_node.get().if_ixml_node$get_namespace()));\n    return val;\n  }\n  async if_ixml_node$get_value() {\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\n    val.set((await this.mi_node.get().if_ixml_node$get_value()));\n    return val;\n  }\n  async if_ixml_node$get_type() {\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\n    val.set((await this.mi_node.get().if_ixml_node$get_type()));\n    return val;\n  }\n  async if_ixml_node$set_name(INPUT) {\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    await this.mi_node.get().if_ixml_node$set_name({name: name});\n  }\n  async if_ixml_node$remove_child(INPUT) {\n    let child = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    if (INPUT && INPUT.child) {child.set(INPUT.child);}\n    await this.mi_node.get().if_ixml_node$remove_child({child: child});\n  }\n  async if_ixml_node$set_value(INPUT) {\n    let value = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\n    await this.mi_node.get().if_ixml_node$set_value({value: value});\n  }\n  async if_ixml_document$set_encoding(INPUT) {\n    let encoding = new abap.types.ABAPObject();\n    if (INPUT && INPUT.encoding) {encoding.set(INPUT.encoding);}\n    return;\n  }\n  async if_ixml_document$set_standalone(INPUT) {\n    let standalone = new abap.types.Character(1, {\"qualifiedName\":\"ABAP_BOOL\",\"ddicName\":\"ABAP_BOOL\"});\n    if (INPUT && INPUT.standalone) {standalone.set(INPUT.standalone);}\n    return;\n  }\n  async if_ixml_document$set_namespace_prefix(INPUT) {\n    let prefix = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}\n    return;\n  }\n  async if_ixml_document$append_child(INPUT) {\n    let new_child = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    if (INPUT && INPUT.new_child) {new_child.set(INPUT.new_child);}\n    await this.if_ixml_node$append_child({new_child: new_child});\n  }\n  async if_ixml_document$get_first_child() {\n    let child = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return child;\n  }\n  async if_ixml_document$create_attribute_ns(INPUT) {\n    let element = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ATTRIBUTE\"});\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let prefix = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return element;\n  }\n  async if_ixml_document$create_element_ns(INPUT) {\n    let element = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let prefix = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}\n    element.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_());\n    await element.get().if_ixml_node$set_name({name: name});\n    await element.get().if_ixml_node$set_namespace_prefix({val: prefix});\n    return element;\n  }\n  async if_ixml_document$create_element(INPUT) {\n    let element = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    element.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_());\n    await element.get().if_ixml_node$set_name({name: name});\n    return element;\n  }\n  async if_ixml_document$create_iterator_filtered(INPUT) {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\n    let input = new abap.types.Character(4);\n    if (INPUT && INPUT.input) {input = INPUT.input;}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return val;\n  }\n  async if_ixml_document$create_filter_and(INPUT) {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_FILTER\"});\n    let filter1 = new abap.types.Character(4);\n    if (INPUT && INPUT.filter1) {filter1 = INPUT.filter1;}\n    let filter2 = new abap.types.Character(4);\n    if (INPUT && INPUT.filter2) {filter2 = INPUT.filter2;}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return val;\n  }\n  async if_ixml_document$create_iterator() {\n    let rval = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return rval;\n  }\n  async if_ixml_document$create_filter_node_type(INPUT) {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_FILTER\"});\n    let typ = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.typ) {typ.set(INPUT.typ);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return val;\n  }\n  async if_ixml_document$create_simple_element_ns(INPUT) {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let parent = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    if (INPUT && INPUT.parent) {parent.set(INPUT.parent);}\n    let prefix = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}\n    let li_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    val.set((await this.if_ixml_document$create_simple_element({name: name, parent: parent})));\n    await abap.statements.cast(li_node, val);\n    await li_node.get().if_ixml_node$set_namespace_prefix({val: prefix});\n    return val;\n  }\n  async if_ixml_document$create_filter_attribute(INPUT) {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_FILTER\"});\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return val;\n  }\n  async if_ixml_document$create_simple_element(INPUT) {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let parent = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    if (INPUT && INPUT.parent) {parent.set(INPUT.parent);}\n    val.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_({ii_parent: parent}));\n    await val.get().if_ixml_node$set_name({name: name});\n    return val;\n  }\n  async if_ixml_document$find_from_name(INPUT) {\n    let element = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let namespace = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(35).set('todo, use find_from_name_ns instead')));\n    return element;\n  }\n  async if_ixml_document$find_from_name_ns(INPUT) {\n    let element = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\n    let depth = new abap.types.Integer({qualifiedName: \"I\"});\n    if (INPUT && INPUT.depth) {depth.set(INPUT.depth);}\n    let uri = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.uri) {uri.set(INPUT.uri);}\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    element.set((await this.mi_node.get().if_ixml_element$find_from_name_ns({name: name, depth: depth, namespace: new abap.types.Character(1).set('')})));\n    return element;\n  }\n  async if_ixml_document$find_from_path(INPUT) {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\n    let path = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.path) {path.set(INPUT.path);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return val;\n  }\n  async if_ixml_document$get_elements_by_tag_name_ns(INPUT) {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_COLLECTION\"});\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let namespace = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\n    let uri = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.uri) {uri.set(INPUT.uri);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return val;\n  }\n  async if_ixml_document$get_elements_by_tag_name(INPUT) {\n    let val = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_COLLECTION\"});\n    let depth = new abap.types.Integer({qualifiedName: \"I\"});\n    if (INPUT && INPUT.depth) {depth.set(INPUT.depth);}\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let namespace = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.namespace) {namespace.set(INPUT.namespace);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return val;\n  }\n  async if_ixml_document$get_root() {\n    let node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    node.set(this.mi_node);\n    return node;\n  }\n  async if_ixml_document$get_root_element() {\n    let root = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\n    root.set(this.mi_node);\n    return root;\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_DOCUMENT'] = lcl_document;\nlcl_document.if_ixml_node$co_node_element = new abap.types.Integer({qualifiedName: \"I\"});\nlcl_document.if_ixml_node$co_node_element.set(0);\nlcl_document.if_ixml_node$co_node_text = new abap.types.Integer({qualifiedName: \"I\"});\nlcl_document.if_ixml_node$co_node_text.set(0);\nclass lcl_renderer {\n  static INTERNAL_TYPE = 'CLAS';\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_RENDERER\"];\n  static ATTRIBUTES = {\"MI_OSTREAM\": {\"type\": () => {return new abap.types.ABAPObject({qualifiedName: \"IF_IXML_OSTREAM\"});}, \"visibility\": \"U\", \"is_constant\": \" \"},\n  \"MI_DOCUMENT\": {\"type\": () => {return new abap.types.ABAPObject({qualifiedName: \"IF_IXML_DOCUMENT\"});}, \"visibility\": \"U\", \"is_constant\": \" \"}};\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mi_ostream = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_OSTREAM\"});\n    this.mi_document = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_DOCUMENT\"});\n    let ostream = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_OSTREAM\"});\n    if (INPUT && INPUT.ostream) {ostream.set(INPUT.ostream);}\n    let document = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_DOCUMENT\"});\n    if (INPUT && INPUT.document) {document.set(INPUT.document);}\n    this.mi_ostream.set(ostream);\n    this.mi_document.set(document);\n    return this;\n  }\n  async if_ixml_renderer$render() {\n    let li_root = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\n    let li_element = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ELEMENT\"});\n    let li_children = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_LIST\"});\n    let li_iterator = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE_ITERATOR\"});\n    li_root.set((await this.mi_document.get().if_ixml_document$get_root_element()));\n    li_children.set((await li_root.get().if_ixml_element$get_children()));\n    li_iterator.set((await li_children.get().if_ixml_node_list$create_iterator()));\n    const indexBackup1 = abap.builtin.sy.get().index.get();\n    let unique36 = 1;\n    while (true) {\n      abap.builtin.sy.get().index.set(unique36++);\n      await abap.statements.cast(li_element, (await li_iterator.get().if_ixml_node_iterator$get_next()));\n      if (abap.compare.initial(li_element)) {\n        break;\n      }\n      await li_element.get().if_ixml_element$render({ostream: this.mi_ostream});\n    }\n    abap.builtin.sy.get().index.set(indexBackup1);\n  }\n  async if_ixml_renderer$set_normalizing(INPUT) {\n    let normal = new abap.types.Character(1, {\"qualifiedName\":\"ABAP_BOOL\",\"ddicName\":\"ABAP_BOOL\"});\n    if (INPUT && INPUT.normal) {normal.set(INPUT.normal);}\n    return;\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_RENDERER'] = lcl_renderer;\nclass lcl_ostream {\n  static INTERNAL_TYPE = 'CLAS';\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_OSTREAM\"];\n  static ATTRIBUTES = {\"MV_STRING\": {\"type\": () => {return new abap.types.String({qualifiedName: \"STRING\"});}, \"visibility\": \"U\", \"is_constant\": \" \"}};\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mv_string = new abap.types.String({qualifiedName: \"STRING\"});\n    return this;\n  }\n  async if_ixml_ostream$write_string(INPUT) {\n    let rval = new abap.types.Integer({qualifiedName: \"I\"});\n    let string = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.string) {string.set(INPUT.string);}\n    this.mv_string.set(abap.operators.concat(this.mv_string,string));\n    return rval;\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_OSTREAM'] = lcl_ostream;\nclass lcl_istream {\n  static INTERNAL_TYPE = 'CLAS';\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_ISTREAM\"];\n  static ATTRIBUTES = {\"MV_XML\": {\"type\": () => {return new abap.types.String({qualifiedName: \"STRING\"});}, \"visibility\": \"U\", \"is_constant\": \" \"}};\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mv_xml = new abap.types.String({qualifiedName: \"STRING\"});\n    let iv_xml = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.iv_xml) {iv_xml.set(INPUT.iv_xml);}\n    this.mv_xml.set(iv_xml);\n    return this;\n  }\n  async if_ixml_istream$close() {\n    return;\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_ISTREAM'] = lcl_istream;\nclass lcl_stream_factory {\n  static INTERNAL_TYPE = 'CLAS';\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_STREAM_FACTORY\"];\n  static ATTRIBUTES = {};\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    return this;\n  }\n  async if_ixml_stream_factory$create_ostream_cstring(INPUT) {\n    let stream = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_OSTREAM\"});\n    let string = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.string) {string.set(INPUT.string);}\n    stream.set(await (new abap.Classes['CLAS-CL_IXML-LCL_OSTREAM']()).constructor_());\n    stream.get().mv_string = INPUT.string;\n    await stream.get().if_ixml_ostream$write_string({string: new abap.types.Character(39).set('<?xml version=\"1.0\" encoding=\"utf-16\"?>')});\n    return stream;\n  }\n  async if_ixml_stream_factory$create_ostream_xstring(INPUT) {\n    let stream = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_OSTREAM\"});\n    let string = new abap.types.XString({qualifiedName: \"XSTRING\"});\n    if (INPUT && INPUT.string) {string.set(INPUT.string);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return stream;\n  }\n  async if_ixml_stream_factory$create_istream_xstring(INPUT) {\n    let stream = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ISTREAM\"});\n    let xml = new abap.types.XString({qualifiedName: \"XSTRING\"});\n    if (INPUT && INPUT.xml) {xml.set(INPUT.xml);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return stream;\n  }\n  async if_ixml_stream_factory$create_istream_string(INPUT) {\n    let stream = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ISTREAM\"});\n    let xml = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.xml) {xml.set(INPUT.xml);}\n    stream.set(await (new abap.Classes['CLAS-CL_IXML-LCL_ISTREAM']()).constructor_({iv_xml: xml}));\n    return stream;\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_STREAM_FACTORY'] = lcl_stream_factory;\nclass lcl_parser {\n  static INTERNAL_TYPE = 'CLAS';\n  static IMPLEMENTED_INTERFACES = [\"IF_IXML_PARSER\"];\n  static ATTRIBUTES = {\"MI_ISTREAM\": {\"type\": () => {return new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ISTREAM\"});}, \"visibility\": \"U\", \"is_constant\": \" \"},\n  \"MI_DOCUMENT\": {\"type\": () => {return new abap.types.ABAPObject({qualifiedName: \"IF_IXML_DOCUMENT\"});}, \"visibility\": \"U\", \"is_constant\": \" \"},\n  \"LC_REGEX_TAG\": {\"type\": () => {return new abap.types.String({qualifiedName: \"STRING\"});}, \"visibility\": \"U\", \"is_constant\": \"X\"},\n  \"LC_REGEX_ATTR\": {\"type\": () => {return new abap.types.String({qualifiedName: \"STRING\"});}, \"visibility\": \"U\", \"is_constant\": \"X\"}};\n  async constructor_(INPUT) {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mi_istream = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ISTREAM\"});\n    this.mi_document = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_DOCUMENT\"});\n    this.if_ixml_parser$co_no_validation = abap.Classes['IF_IXML_PARSER'].if_ixml_parser$co_no_validation;\n    this.lc_regex_tag = lcl_parser.lc_regex_tag;\n    this.lc_regex_attr = lcl_parser.lc_regex_attr;\n    let istream = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_ISTREAM\"});\n    if (INPUT && INPUT.istream) {istream.set(INPUT.istream);}\n    let document = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_DOCUMENT\"});\n    if (INPUT && INPUT.document) {document.set(INPUT.document);}\n    this.mi_istream.set(istream);\n    this.mi_document.set(document);\n    return this;\n  }\n  async if_ixml_parser$set_validating(INPUT) {\n    let rval = new abap.types.Character(1, {\"qualifiedName\":\"ABAP_BOOL\",\"ddicName\":\"ABAP_BOOL\"});\n    let mode = new abap.types.Integer({qualifiedName: \"I\"});\n    if (INPUT && INPUT.mode) {mode.set(INPUT.mode);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n    return rval;\n  }\n  async if_ixml_parser$parse() {\n    let subrc = new abap.types.Integer({qualifiedName: \"I\"});\n    let lv_xml = new abap.types.String({qualifiedName: \"STRING\"});\n    let lv_offset = new abap.types.Integer({qualifiedName: \"I\"});\n    let lv_value = new abap.types.String({qualifiedName: \"STRING\"});\n    let lv_name = new abap.types.String({qualifiedName: \"STRING\"});\n    let lv_namespace = new abap.types.String({qualifiedName: \"STRING\"});\n    let ls_match = new abap.types.Structure({\"line\": new abap.types.Integer(), \"offset\": new abap.types.Integer(), \"length\": new abap.types.Integer(), \"submatches\": abap.types.TableFactory.construct(new abap.types.Structure({\"offset\": new abap.types.Integer(), \"length\": new abap.types.Integer()}, \"SUBMATCH_RESULT\", \"SUBMATCH_RESULT\"), {\"withHeader\":false,\"keyType\":\"USER\",\"secondary\":[]}, \"SUBMATCH_RESULT_TAB\")}, \"MATCH_RESULT\", \"MATCH_RESULT\");\n    let ls_submatch = new abap.types.Structure({\"offset\": new abap.types.Integer(), \"length\": new abap.types.Integer()}, \"SUBMATCH_RESULT\", \"SUBMATCH_RESULT\");\n    let lo_parent = new abap.types.ABAPObject({qualifiedName: \"LCL_NODE\"});\n    let lo_node = new abap.types.ABAPObject({qualifiedName: \"LCL_NODE\"});\n    await abap.statements.cast(lo_parent, (await this.mi_document.get().if_ixml_document$get_root()));\n    lv_xml.set(this.mi_istream.get().mv_xml);\n    abap.statements.replace({target: lv_xml, all: true, with: new abap.types.String().set(``), of: new abap.types.String().set(`\\n`)});\n    const indexBackup1 = abap.builtin.sy.get().index.get();\n    let unique37 = 1;\n    while (abap.compare.initial(lv_xml) === false) {\n      abap.builtin.sy.get().index.set(unique37++);\n      abap.statements.clear(lo_node);\n      if (abap.compare.cp(lv_xml, new abap.types.Character(7).set('<?xml *'))) {\n        abap.statements.find(lv_xml, {find: new abap.types.Character(2).set('?>'), first: true, offset: lv_offset});\n        abap.statements.assert(abap.compare.gt(lv_offset, new abap.types.Integer().set(0)));\n        lv_offset.set(abap.operators.add(lv_offset,new abap.types.Integer().set(2)));\n      } else if (abap.compare.cp(lv_xml, new abap.types.Character(2).set('<*'))) {\n        abap.statements.find(lv_xml, {regex: lcl_parser.lc_regex_tag, first: true, results: ls_match});\n        abap.statements.assert(abap.compare.eq(ls_match.get().offset, new abap.types.Integer().set(0)));\n        abap.statements.readTable(ls_match.get().submatches,{index: new abap.types.Integer().set(1),\n          into: ls_submatch});\n        abap.statements.assert(abap.compare.eq(abap.builtin.sy.get().subrc, new abap.types.Integer().set(0)));\n        lv_name.set(lv_xml.getOffset({offset: ls_submatch.get().offset, length: ls_submatch.get().length}));\n        if (abap.compare.cp(lv_xml, new abap.types.Character(3).set('</*'))) {\n          await abap.statements.cast(lo_parent, (await lo_parent.get().if_ixml_node$get_parent()));\n        } else {\n          lo_node.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_({ii_parent: lo_parent}));\n          if (abap.compare.ca(lv_name, new abap.types.Character(1).set(':'))) {\n            abap.statements.split({source: lv_name, at: new abap.types.Character(1).set(':'), targets: [lv_namespace,lv_name]});\n            await lo_node.get().if_ixml_node$set_namespace_prefix({val: lv_namespace});\n          }\n          await lo_node.get().if_ixml_node$set_name({name: lv_name});\n          lo_parent.set(lo_node);\n        }\n        await this.parse_attributes({ii_node: lo_node, iv_xml: lv_xml, is_match: ls_match});\n        lv_offset.set(ls_match.get().length);\n        if (abap.compare.cp(lv_xml, new abap.types.Character(3).set('*/>'))) {\n          await abap.statements.cast(lo_parent, (await lo_parent.get().if_ixml_node$get_parent()));\n        }\n      } else {\n        abap.statements.find(lv_xml, {find: new abap.types.Character(1).set('<'), first: true, offset: lv_offset});\n        lv_value.set(lv_xml.getOffset({length: lv_offset}));\n        lo_node.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_({ii_parent: lo_parent}));\n        await lo_node.get().if_ixml_node$set_name({name: new abap.types.Character(5).set('#text')});\n        await lo_node.get().if_ixml_node$set_value({value: (await abap.Classes['CLAS-CL_IXML-LCL_ESCAPE'].unescape_value({iv_value: lv_value}))});\n      }\n      lv_xml.set(lv_xml.getOffset({offset: lv_offset}));\n      abap.statements.condense(lv_xml, {nogaps: false});\n    }\n    abap.builtin.sy.get().index.set(indexBackup1);\n    return subrc;\n  }\n  async parse_attributes(INPUT) {\n    let ii_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    if (INPUT && INPUT.ii_node) {ii_node.set(INPUT.ii_node);}\n    let iv_xml = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.iv_xml) {iv_xml.set(INPUT.iv_xml);}\n    let is_match = new abap.types.Structure({\"line\": new abap.types.Integer(), \"offset\": new abap.types.Integer(), \"length\": new abap.types.Integer(), \"submatches\": abap.types.TableFactory.construct(new abap.types.Structure({\"offset\": new abap.types.Integer(), \"length\": new abap.types.Integer()}, \"SUBMATCH_RESULT\", \"SUBMATCH_RESULT\"), {\"withHeader\":false,\"keyType\":\"USER\",\"secondary\":[]}, \"SUBMATCH_RESULT_TAB\")}, \"MATCH_RESULT\", \"MATCH_RESULT\");\n    if (INPUT && INPUT.is_match) {is_match.set(INPUT.is_match);}\n    let ls_submatch = new abap.types.Structure({\"offset\": new abap.types.Integer(), \"length\": new abap.types.Integer()}, \"SUBMATCH_RESULT\", \"SUBMATCH_RESULT\");\n    let lv_name = new abap.types.String({qualifiedName: \"STRING\"});\n    let lv_value = new abap.types.String({qualifiedName: \"STRING\"});\n    let lv_xml = new abap.types.String({qualifiedName: \"STRING\"});\n    let li_node = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_NODE\"});\n    let lv_offset = new abap.types.Integer({qualifiedName: \"I\"});\n    let lv_length = new abap.types.Integer({qualifiedName: \"I\"});\n    if (abap.compare.eq(abap.builtin.lines({val: is_match.get().submatches}), new abap.types.Integer().set(1))) {\n      return;\n    }\n    lv_xml.set(iv_xml.getOffset({length: is_match.get().length}));\n    const indexBackup1 = abap.builtin.sy.get().index.get();\n    let unique38 = 1;\n    while (true) {\n      abap.builtin.sy.get().index.set(unique38++);\n      abap.statements.find(lv_xml, {regex: lcl_parser.lc_regex_attr, first: true, offset: lv_offset, length: lv_length, submatches: [lv_name,lv_value]});\n      if (abap.compare.ne(abap.builtin.sy.get().subrc, new abap.types.Integer().set(0))) {\n        abap.builtin.sy.get().index.set(indexBackup1);\n        return;\n      }\n      li_node.set(await (new abap.Classes['CLAS-CL_IXML-LCL_NODE']()).constructor_());\n      await li_node.get().if_ixml_node$set_name({name: lv_name});\n      await li_node.get().if_ixml_node$set_value({value: lv_value});\n      await (await ii_node.get().if_ixml_node$get_attributes()).get().if_ixml_named_node_map$set_named_item_ns({node: li_node});\n      lv_offset.set(abap.operators.add(lv_offset,lv_length));\n      lv_xml.set(lv_xml.getOffset({offset: lv_offset}));\n    }\n    abap.builtin.sy.get().index.set(indexBackup1);\n  }\n  async if_ixml_parser$set_normalizing(INPUT) {\n    let normal = new abap.types.Character(1, {\"qualifiedName\":\"ABAP_BOOL\",\"ddicName\":\"ABAP_BOOL\"});\n    if (INPUT && INPUT.normal) {normal.set(INPUT.normal);}\n    return;\n  }\n  async if_ixml_parser$num_errors() {\n    let errors = new abap.types.Integer({qualifiedName: \"I\"});\n    return errors;\n    return errors;\n  }\n  async if_ixml_parser$add_strip_space_element() {\n    return;\n  }\n  async if_ixml_parser$get_error(INPUT) {\n    let error = new abap.types.ABAPObject({qualifiedName: \"IF_IXML_PARSE_ERROR\"});\n    let index = new abap.types.Integer({qualifiedName: \"I\"});\n    if (INPUT && INPUT.index) {index.set(INPUT.index);}\n    return error;\n    return error;\n  }\n}\nabap.Classes['CLAS-CL_IXML-LCL_PARSER'] = lcl_parser;\nlcl_parser.lc_regex_tag = new abap.types.String({qualifiedName: \"STRING\"});\nlcl_parser.lc_regex_tag.set('<\\\\/?([\\\\w:]+)( [\\\\w:]+=\"[\\\\w\\\\.:\\\\/]+\")*/?>');\nlcl_parser.lc_regex_attr = new abap.types.String({qualifiedName: \"STRING\"});\nlcl_parser.lc_regex_attr.set('([\\\\w:]+)=\"([\\\\w\\\\.:\\\\/]+)\"');\nlcl_parser.if_ixml_parser$co_no_validation = new abap.types.Integer({qualifiedName: \"I\"});\nlcl_parser.if_ixml_parser$co_no_validation.set(0);\n\n//# sourceMappingURL=cl_ixml.clas.locals.mjs.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://open-table-maintenance/./output/cl_ixml.clas.locals.mjs?");

/***/ })

}]);