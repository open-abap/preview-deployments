"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkopen_table_maintenance"] = self["webpackChunkopen_table_maintenance"] || []).push([["output_kernel_unit_runner_clas_mjs"],{

/***/ "./output/kernel_unit_runner.clas.mjs":
/*!********************************************!*\
  !*** ./output/kernel_unit_runner.clas.mjs ***!
  \********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"kernel_unit_runner\": () => (/* binding */ kernel_unit_runner)\n/* harmony export */ });\nconst {cx_root} = await __webpack_require__.e(/*! import() */ \"output_cx_root_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ \"./output/cx_root.clas.mjs\"));\n// kernel_unit_runner.clas.abap\nconst constant_30 = new abap.types.Integer().set(30);\nclass kernel_unit_runner {\n  async constructor_() {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.gc_status = kernel_unit_runner.gc_status;\n    return this;\n  }\n  async get_location(INPUT) {\n    return kernel_unit_runner.get_location(INPUT);\n  }\n  static async get_location(INPUT) {\n    let rv_location = new abap.types.String();\n    let ix_error = new abap.types.ABAPObject({qualifiedName: \"CX_ROOT\"});\n    if (INPUT && INPUT.ix_error) {ix_error.set(INPUT.ix_error);}\n    let lv_stack = new abap.types.String();\n    let lt_lines = new abap.types.Table(new abap.types.String(), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    let lv_found = new abap.types.Character({qualifiedName: \"ABAP_BOOL\"});\n    lv_stack.set(INPUT.ix_error.get().stack);\n    abap.statements.split({source: lv_stack, at: new abap.types.String().set(`\\n`), table: lt_lines});\n    for (const unique70 of abap.statements.loop(lt_lines)) {\n      lv_stack.set(unique70);\n      if (abap.compare.cp(lv_stack, new abap.types.Character({length: 21}).set('*cl_abap_unit_assert*'))) {\n        lv_found.set(abap.builtin.abap_true);\n        continue;\n      } else if (abap.compare.eq(lv_found, abap.builtin.abap_true)) {\n        abap.statements.replace({target:lv_stack, all:false, with: new abap.types.Character({length: 0}).set(''),of: new abap.types.String().set(`at `)});\n        rv_location.set(abap.builtin.condense({val: lv_stack}));\n        break;\n      }\n    }\n    return rv_location;\n  }\n  async to_json(INPUT) {\n    return kernel_unit_runner.to_json(INPUT);\n  }\n  static async to_json(INPUT) {\n    let rv_json = new abap.types.String();\n    let it_list = new abap.types.Table(new abap.types.Structure({class_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>class_name\"}), testclass_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>testclass_name\"}), method_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>method_name\"}), expected: new abap.types.String(), actual: new abap.types.String(), status: new abap.types.String(), runtime: new abap.types.Integer(), message: new abap.types.String(), js_location: new abap.types.String()}, \"kernel_unit_runner=>ty_result_item\"), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    if (INPUT && INPUT.it_list) {it_list.set(INPUT.it_list);}\n    let ls_list = new abap.types.Structure({class_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>class_name\"}), testclass_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>testclass_name\"}), method_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>method_name\"}), expected: new abap.types.String(), actual: new abap.types.String(), status: new abap.types.String(), runtime: new abap.types.Integer(), message: new abap.types.String(), js_location: new abap.types.String()}, \"kernel_unit_runner=>ty_result_item\");\n    let lt_strings = new abap.types.Table(new abap.types.String(), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    let lv_string = new abap.types.String();\n    let lv_message = new abap.types.String();\n    for (const unique71 of abap.statements.loop(it_list)) {\n      ls_list.set(unique71);\n      lv_message.set(ls_list.get().message);\n      abap.statements.replace({target:lv_message, all:true, with: new abap.types.String().set(`\\\"`),of: new abap.types.String().set(`\"`)});\n      lv_string.set(new abap.types.String().set(`\\{\"class_name\": \"${ls_list.get().class_name.get()}\",\"testclass_name\": \"${ls_list.get().testclass_name.get()}\",\"method_name\": \"${ls_list.get().method_name.get()}\",\"expected\": \"${ls_list.get().expected.get()}\",\"actual\": \"${ls_list.get().actual.get()}\",\"status\": \"${ls_list.get().status.get()}\",\"runtime\": ${ls_list.get().runtime.get()},\"message\": \"${lv_message.get()}\",\"js_location\": \"${ls_list.get().js_location.get()}\"\\}`));\n      abap.statements.append({source: lv_string, target: lt_strings});\n    }\n    abap.statements.concatenate({source: [lt_strings], target: rv_json, separatedBy: new abap.types.Character({length: 1}).set(','), lines: true});\n    rv_json.set(abap.operators.concat(new abap.types.Character({length: 1}).set('['),abap.operators.concat(rv_json,new abap.types.Character({length: 1}).set(']'))));\n    return rv_json;\n  }\n  async unique_classes(INPUT) {\n    return kernel_unit_runner.unique_classes(INPUT);\n  }\n  static async unique_classes(INPUT) {\n    let rt_classes = new abap.types.Table(new abap.types.Structure({class_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>class_name\"}), testclass_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>testclass_name\"})}, \"kernel_unit_runner=>ty_class_item\"), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    let it_input = new abap.types.Table(new abap.types.Structure({class_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>class_name\"}), testclass_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>testclass_name\"}), method_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>method_name\"})}, \"kernel_unit_runner=>ty_input_item\"), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    if (INPUT && INPUT.it_input) {it_input.set(INPUT.it_input);}\n    let ls_input = new abap.types.Structure({class_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>class_name\"}), testclass_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>testclass_name\"}), method_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>method_name\"})}, \"kernel_unit_runner=>ty_input_item\");\n    let ls_class = new abap.types.Structure({class_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>class_name\"}), testclass_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>testclass_name\"})}, \"kernel_unit_runner=>ty_class_item\");\n    for (const unique72 of abap.statements.loop(it_input)) {\n      ls_input.set(unique72);\n      abap.statements.moveCorresponding(ls_input, ls_class);\n      abap.statements.insertInternal({data: ls_class, table: rt_classes});\n    }\n    abap.statements.sort(rt_classes,{});\n    abap.statements.deleteInternal(rt_classes,{adjacent: true});\n    return rt_classes;\n  }\n  async run(INPUT) {\n    return kernel_unit_runner.run(INPUT);\n  }\n  static async run(INPUT) {\n    let rs_result = new abap.types.Structure({list: new abap.types.Table(new abap.types.Structure({class_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>class_name\"}), testclass_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>testclass_name\"}), method_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>method_name\"}), expected: new abap.types.String(), actual: new abap.types.String(), status: new abap.types.String(), runtime: new abap.types.Integer(), message: new abap.types.String(), js_location: new abap.types.String()}, \"kernel_unit_runner=>ty_result_item\"), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]}), json: new abap.types.String()}, \"kernel_unit_runner=>ty_result\");\n    let it_input = new abap.types.Table(new abap.types.Structure({class_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>class_name\"}), testclass_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>testclass_name\"}), method_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>method_name\"})}, \"kernel_unit_runner=>ty_input_item\"), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    if (INPUT && INPUT.it_input) {it_input.set(INPUT.it_input);}\n    let ls_input = new abap.types.Structure({class_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>class_name\"}), testclass_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>testclass_name\"}), method_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>method_name\"})}, \"kernel_unit_runner=>ty_input_item\");\n    let lv_time = new abap.types.Integer();\n    let lo_obj = new abap.types.ABAPObject();\n    let lv_name = new abap.types.String();\n    let lt_classes = new abap.types.Table(new abap.types.Structure({class_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>class_name\"}), testclass_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>testclass_name\"})}, \"kernel_unit_runner=>ty_class_item\"), {\"withHeader\":false,\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]});\n    let ls_class = new abap.types.Structure({class_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>class_name\"}), testclass_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>testclass_name\"})}, \"kernel_unit_runner=>ty_class_item\");\n    let lx_root = new abap.types.ABAPObject({qualifiedName: \"CX_ROOT\"});\n    let lx_assert = new abap.types.ABAPObject({qualifiedName: \"KERNEL_CX_ASSERT\"});\n    let fs_ls_result_ = new abap.types.FieldSymbol(new abap.types.Structure({class_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>class_name\"}), testclass_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>testclass_name\"}), method_name: new abap.types.Character({length: 30, qualifiedName: \"kernel_unit_runner=>method_name\"}), expected: new abap.types.String(), actual: new abap.types.String(), status: new abap.types.String(), runtime: new abap.types.Integer(), message: new abap.types.String(), js_location: new abap.types.String()}, \"kernel_unit_runner=>ty_result_item\"));\n    lt_classes.set((await this.unique_classes({it_input: it_input})));\n    for (const unique73 of abap.statements.loop(lt_classes)) {\n      ls_class.set(unique73);\n      lv_name.set(new abap.types.String().set(`CLAS-${ls_class.get().class_name.get()}-${ls_class.get().testclass_name.get()}`));\n      if (abap.Classes[lv_name.get()] === undefined) { throw new abap.Classes['CX_SY_CREATE_OBJECT_ERROR']; }\n      lo_obj.set(await (new abap.Classes[lv_name.get()]()).constructor_());\n      try {\n        if (lo_obj.get().class_setup === undefined && abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'] === undefined) { throw \"CX_SY_DYN_CALL_ILLEGAL_METHOD not found\"; }\n        if (lo_obj.get().class_setup === undefined) { throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'](); }\n        await lo_obj.get().class_setup();\n      } catch (e) {\n        if (e instanceof abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD']) {\n        } else {\n          throw e;\n        }\n      }\n      for (const unique74 of abap.statements.loop(it_input,{where: (i) => {return abap.compare.eq(i.class_name, ls_class.get().class_name) && abap.compare.eq(i.testclass_name, ls_class.get().testclass_name);}})) {\n        ls_input.set(unique74);\n        fs_ls_result_.assign(rs_result.get().list.appendInitial());\n        abap.statements.moveCorresponding(ls_input, fs_ls_result_);\n        try {\n          if (lo_obj.get().setup === undefined && abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'] === undefined) { throw \"CX_SY_DYN_CALL_ILLEGAL_METHOD not found\"; }\n          if (lo_obj.get().setup === undefined) { throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'](); }\n          await lo_obj.get().setup();\n        } catch (e) {\n          if (e instanceof abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD']) {\n          } else {\n            throw e;\n          }\n        }\n        abap.statements.getRunTime(lv_time);\n        try {\n          if (lo_obj.get()[ls_input.get().method_name.get().toLowerCase()] === undefined && abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'] === undefined) { throw \"CX_SY_DYN_CALL_ILLEGAL_METHOD not found\"; }\n          if (lo_obj.get()[ls_input.get().method_name.get().toLowerCase()] === undefined) { throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'](); }\n          await lo_obj.get()[ls_input.get().method_name.get().toLowerCase()]();\n          fs_ls_result_.get().status.set(kernel_unit_runner.gc_status.get().success);\n        } catch (e) {\n          if (e instanceof abap.Classes['KERNEL_CX_ASSERT']) {\n            lx_assert.set(e);\n            fs_ls_result_.get().status.set(kernel_unit_runner.gc_status.get().failed);\n            fs_ls_result_.get().actual.set(lx_assert.get().actual);\n            fs_ls_result_.get().expected.set(lx_assert.get().expected);\n            fs_ls_result_.get().message.set(lx_assert.get().message);\n            fs_ls_result_.get().js_location.set((await this.get_location({ix_error: lx_assert})));\n          } else if (e instanceof abap.Classes['CX_ROOT']) {\n            lx_root.set(e);\n            fs_ls_result_.get().status.set(kernel_unit_runner.gc_status.get().failed);\n            fs_ls_result_.get().message.set(new abap.types.String().set(`Some exception raised`));\n            fs_ls_result_.get().js_location.set((await this.get_location({ix_error: lx_root})));\n          } else {\n            throw e;\n          }\n        }\n        abap.statements.getRunTime(lv_time);\n        fs_ls_result_.get().runtime.set(lv_time);\n        try {\n          if (lo_obj.get().teardown === undefined && abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'] === undefined) { throw \"CX_SY_DYN_CALL_ILLEGAL_METHOD not found\"; }\n          if (lo_obj.get().teardown === undefined) { throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'](); }\n          await lo_obj.get().teardown();\n        } catch (e) {\n          if (e instanceof abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD']) {\n          } else {\n            throw e;\n          }\n        }\n      }\n      try {\n        if (lo_obj.get().class_teardown === undefined && abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'] === undefined) { throw \"CX_SY_DYN_CALL_ILLEGAL_METHOD not found\"; }\n        if (lo_obj.get().class_teardown === undefined) { throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'](); }\n        await lo_obj.get().class_teardown();\n      } catch (e) {\n        if (e instanceof abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD']) {\n        } else {\n          throw e;\n        }\n      }\n    }\n    rs_result.get().json.set((await this.to_json({it_list: rs_result.get().list})));\n    return rs_result;\n  }\n}\nabap.Classes['KERNEL_UNIT_RUNNER'] = kernel_unit_runner;\nkernel_unit_runner.gc_status = new abap.types.Structure({success: new abap.types.String(), failed: new abap.types.String(), skipped: new abap.types.String()});\nkernel_unit_runner.gc_status.get().success.set('SUCCESS');\nkernel_unit_runner.gc_status.get().failed.set('FAILED');\nkernel_unit_runner.gc_status.get().skipped.set('SKIPPED');\n\n//# sourceMappingURL=kernel_unit_runner.clas.mjs.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://open-table-maintenance/./output/kernel_unit_runner.clas.mjs?");

/***/ })

}]);