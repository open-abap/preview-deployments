/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@abaplint/runtime/build/src/abap_regex.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/abap_regex.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ABAPRegExp = void 0;
// https://github.com/TooTallNate/pcre-to-regexp/blob/master/src/index.ts
class ABAPRegExp {
    // converts from ABAP specific regex to javascript regex
    static convert(input) {
        let ret = input;
        ret = ret.replace(/\[\[:punct:\]\]/g, "[@%\\.\\,\\-\\{\\}\\[\\]\\:\\!\\?\\(\\)\\;\\']");
        // https://github.com/micromatch/posix-character-classes#posix-character-classes
        ret = ret.replace(/\[\^\[:print:\]\]/g, "[\\x00-\\x1F\\x7F]");
        ret = ret.replace("[[:space:]]", "\\s");
        return ret;
    }
    static escapeRegExp(text) {
        return text.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
    }
}
exports.ABAPRegExp = ABAPRegExp;
//# sourceMappingURL=abap_regex.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/binary_search.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/binary_search.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.binarySearchTo = exports.binarySearchFrom = exports.binarySearchFromRow = void 0;
/* eslint-disable max-len */
const compare_1 = __webpack_require__(/*! ./compare */ "./node_modules/@abaplint/runtime/build/src/compare/index.js");
const types_1 = __webpack_require__(/*! ./types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
/** input indexes = javascript indexes,
    output index = javascript index */
function binarySearchFromRow(array, left, right, keyField, keyValue, usesTableLine) {
    if (right <= 0) {
        return 0;
    }
    //  console.dir("start: " + left + ", " + right);
    const isStructured = array[0] instanceof types_1.Structure;
    while (right - left > 1) {
        const middle = Math.floor(((right - left) / 2) + left);
        //    console.dir(left + ", " + right + ", " + middle);
        const a = array[middle];
        let row = undefined;
        if (usesTableLine === false && isStructured === true) {
            row = a.get();
        }
        else {
            row = isStructured ? { table_line: a, ...a.get() } : { table_line: a };
        }
        if ((0, compare_1.ge)(keyField(row), keyValue)) {
            right = middle;
        }
        else {
            left = middle;
        }
        //    console.dir(left + ", " + right);
    }
    const a = array[left];
    let row = undefined;
    if (usesTableLine === false && isStructured === true) {
        row = a.get();
    }
    else {
        row = isStructured ? { table_line: a, ...a.get() } : { table_line: a };
    }
    if ((0, compare_1.le)(keyValue, keyField(row))) {
        //    console.dir("choose left");
        return left;
    }
    return right;
}
exports.binarySearchFromRow = binarySearchFromRow;
function binarySearchFrom(array, left, right, keyField, keyValue) {
    while (right - left > 1) {
        const middle = Math.floor(((right - left) / 2) + left);
        if ((0, compare_1.ge)(array[middle].get()[keyField], keyValue)) {
            right = middle;
        }
        else {
            left = middle;
        }
    }
    return right;
}
exports.binarySearchFrom = binarySearchFrom;
function binarySearchTo(array, left, right, keyField, keyValue) {
    while (right - left > 1) {
        const middle = Math.floor(((right - left) / 2) + left);
        if ((0, compare_1.le)(array[middle].get()[keyField], keyValue)) {
            left = middle;
        }
        else {
            right = middle;
        }
    }
    return right;
}
exports.binarySearchTo = binarySearchTo;
//# sourceMappingURL=binary_search.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/abs.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/abs.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.abs = void 0;
/* eslint-disable radix */
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function abs(input) {
    let num_in = undefined;
    if (typeof input.val === "number") {
        num_in = input.val;
    }
    else if (typeof input.val === "string") {
        num_in = parseFloat(input.val);
    }
    else if (input.val instanceof types_1.Float) {
        num_in = input.val.getRaw();
    }
    else {
        num_in = parseFloat(input.val.get().toString());
    }
    const ret = Math.abs(num_in);
    return ret;
}
exports.abs = abs;
//# sourceMappingURL=abs.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/boolc.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/boolc.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.boolc = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function boolc(input) {
    if (input === true) {
        return new types_1.String().set("X");
    }
    else if (input === false || input === undefined) {
        return new types_1.String().set(" ");
    }
    else if (input.val instanceof types_1.String && input.val.get().trim() === "") {
        return new types_1.String().set(" ");
    }
    else if (input.val instanceof types_1.Character && input.val.get().trim() === "") {
        return new types_1.String().set(" ");
    }
    else {
        return new types_1.String().set("X");
    }
}
exports.boolc = boolc;
//# sourceMappingURL=boolc.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/ceil.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/ceil.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ceil = void 0;
/* eslint-disable radix */
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function ceil(input) {
    let num_in = undefined;
    if (typeof input.val === "number") {
        num_in = input.val;
    }
    else if (typeof input.val === "string") {
        num_in = parseFloat(input.val);
    }
    else if (input.val instanceof types_1.Float) {
        num_in = input.val.getRaw();
    }
    else {
        num_in = parseFloat(input.val.get().toString());
    }
    return Math.ceil(num_in);
}
exports.ceil = ceil;
//# sourceMappingURL=ceil.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/concat_lines_of.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/concat_lines_of.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.concat_lines_of = void 0;
const string_1 = __webpack_require__(/*! ../types/string */ "./node_modules/@abaplint/runtime/build/src/types/string.js");
function concat_lines_of(input) {
    let s = input.sep;
    if (s === undefined) {
        s = "";
    }
    else if (typeof s !== "string") {
        s = s.get();
    }
    return new string_1.String().set(input.table.array().map(e => e.get()).join(s));
}
exports.concat_lines_of = concat_lines_of;
//# sourceMappingURL=concat_lines_of.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/condense.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/condense.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.condense = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function condense(input) {
    let str = typeof input.val === "string" ? input.val : input.val.get().toString();
    let from = " ";
    if (input.from) {
        from = typeof input.from === "string" ? input.from : input.from.get().toString();
    }
    let to = " ";
    if (input.to) {
        to = typeof input.to === "string" ? input.to : input.to.get().toString();
    }
    let del = " ";
    if (input.del) {
        del = typeof input.del === "string" ? input.del : input.del.get().toString();
    }
    const beginning = new RegExp(`[${del}]+$`);
    const end = new RegExp(`^[${del}]+`);
    str = str.replace(beginning, "");
    str = str.replace(end, "");
    for (const f of from.split("")) {
        str = str.replace(new RegExp(f.replace(".", "\\."), "g"), to);
    }
    return new types_1.String().set(str.replace(/ {2,}/g, " "));
}
exports.condense = condense;
//# sourceMappingURL=condense.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/contains.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/contains.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.contains = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function contains(input) {
    if (input.case !== undefined
        || input.off !== undefined
        || input.len !== undefined
        || input.occ !== undefined) {
        throw "runtime, contains() todo";
    }
    let ret = " ";
    if (input.regex) {
        ret = input.val.get().match(input.regex.get()) !== null ? "X" : " ";
    }
    else if (input.sub) {
        ret = input.val.get().includes(input.sub.get()) ? "X" : " ";
    }
    else if (input.start) {
        ret = input.val.get().startsWith(input.start.get()) ? "X" : " ";
    }
    else if (input.end) {
        ret = input.val.get().endsWith(input.end.get()) ? "X" : " ";
    }
    return new types_1.String().set(ret);
}
exports.contains = contains;
//# sourceMappingURL=contains.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/cos.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/cos.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cos = void 0;
/* eslint-disable radix */
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function cos(input) {
    let num_in = undefined;
    if (typeof input.val === "number") {
        num_in = input.val;
    }
    else if (typeof input.val === "string") {
        num_in = parseFloat(input.val);
    }
    else if (input.val instanceof types_1.Float) {
        num_in = input.val.getRaw();
    }
    else {
        num_in = parseFloat(input.val.get().toString());
    }
    return Math.cos(num_in);
}
exports.cos = cos;
//# sourceMappingURL=cos.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/count.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/count.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.count = void 0;
const compare_1 = __webpack_require__(/*! ../compare */ "./node_modules/@abaplint/runtime/build/src/compare/index.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function count(input) {
    let found = 0;
    let val = input.val.get();
    if (input.off) {
        const off = input.off.get();
        val = val.substring(off);
    }
    if (input.len) {
        const len = input.len.get();
        val = val.substring(0, len);
    }
    let reg = "";
    if (input.sub) {
        reg = input.sub.get();
        reg = reg.replace(/\*/g, "\\*");
    }
    else if (input.regex) {
        reg = input.regex.get();
    }
    else if (input.pcre) {
        reg = input.pcre.get();
    }
    let options = "g";
    if (input.case && (0, compare_1.initial)(input.case)) {
        options += "i";
    }
    if (val !== "") {
        const res = val.match(new RegExp(reg, options));
        if (res) {
            found = res.length;
        }
    }
    return new types_1.Integer().set(found);
}
exports.count = count;
//# sourceMappingURL=count.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/count_any_of.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/count_any_of.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.count_any_of = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function count_any_of(input) {
    let found = 0;
    const val = input.val.get();
    const sub = input.sub.get();
    if (sub !== "") {
        for (const char of sub.split("")) {
            const match = val.match(new RegExp(char, "g"));
            found += match?.length || 0;
        }
    }
    return new types_1.Integer().set(found);
}
exports.count_any_of = count_any_of;
//# sourceMappingURL=count_any_of.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/escape.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/escape.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escape = void 0;
/* eslint-disable @typescript-eslint/ban-types */
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function escape(input) {
    let val = typeof input.val === "string" ? input.val : input.val.get();
    const format = typeof input.format === "number" ? input.format : input.format.get();
    // todo, optimize/cache regexes
    switch (format) {
        case 1: // e_xml_attr
            val = val.replace(/&/g, "&amp;");
            val = val.replace(/</g, "&lt;");
            val = val.replace(/"/g, "&quot;");
            val = val.replace(/'/g, "&apos;");
            break;
        case 4: // e_html_text
            val = val.replace(/&/g, "&amp;");
            val = val.replace(/</g, "&lt;");
            val = val.replace(/>/g, "&gt;");
            break;
        case 5: // e_html_attr
            val = val.replace(/&/g, "&amp;");
            val = val.replace(/</g, "&lt;");
            val = val.replace(/>/g, "&gt;");
            val = val.replace(/"/g, "&quot;");
            val = val.replace(/'/g, "&#39;");
            break;
        case 12: // e_url
            val = encodeURI(val);
            break;
        case 8: // e_html_js
            val = val.replace(/"/g, "\\\"");
            val = val.replace(/'/g, "\\'");
            break;
        case 24: // e_json_string
            val = val.replace(/"/g, "\\\"");
            val = val.replace(/\n/g, "\\n");
            break;
        default:
        // todo, runtime error
    }
    return new types_1.String().set(val);
}
exports.escape = escape;
//# sourceMappingURL=escape.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/find.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/find.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.find = void 0;
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function find(input) {
    let val = typeof input.val === "string" ? input.val : input.val.get();
    if (input.len !== undefined) {
        throw "transpiler find(), todo len";
    }
    if (input.regex || input.pcre) {
        if (input.off !== undefined) {
            throw "transpiler find(), todo off regex";
        }
        const caseInput = typeof input.case === "string" ? input.case : input.case?.get();
        let regex = "";
        if (input.regex) {
            regex = typeof input.regex === "string" ? input.regex : input.regex.get();
        }
        else if (input.pcre) {
            regex = typeof input.pcre === "string" ? input.pcre : input.pcre.get();
        }
        const flags = caseInput !== "X" ? "i" : "";
        const reg = new RegExp(regex, flags);
        const ret = val.match(reg)?.index;
        if (ret !== undefined) {
            return new types_1.Integer().set(ret);
        }
        else {
            return new types_1.Integer().set(-1);
        }
    }
    else {
        const sub = typeof input.sub === "string" ? input.sub : input.sub?.get();
        let off = typeof input.off === "number" ? input.off : input.off?.get() || 0;
        let occ = typeof input.occ === "number" ? input.occ : input.occ?.get();
        if (occ === 0) {
            (0, throw_error_1.throwError)("CX_SY_STRG_PAR_VAL");
        }
        else if (occ === undefined) {
            occ = 1;
        }
        let negative = false;
        if (occ < 0) {
            negative = true;
            let reversed = "";
            // this is faster than doing val.split("").reverse().join("")
            for (const character of val) {
                reversed = character + reversed;
            }
            val = reversed;
            occ = Math.abs(occ);
        }
        let found = -1;
        for (let i = 0; i < occ; i++) {
            found = val.indexOf(sub || "", off);
            if (found >= 0) {
                off = found + 1;
            }
        }
        if (negative === true && found >= 0) {
            found = val.length - found - 1;
        }
        return new types_1.Integer().set(found);
    }
}
exports.find = find;
//# sourceMappingURL=find.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/floor.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/floor.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.floor = void 0;
/* eslint-disable radix */
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function floor(input) {
    let num_in = undefined;
    if (typeof input.val === "number") {
        num_in = input.val;
    }
    else if (typeof input.val === "string") {
        num_in = parseFloat(input.val);
    }
    else if (input.val instanceof types_1.Float) {
        num_in = input.val.getRaw();
    }
    else {
        num_in = parseFloat(input.val.get().toString());
    }
    return Math.floor(num_in);
}
exports.floor = floor;
//# sourceMappingURL=floor.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/frac.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/frac.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.frac = void 0;
/* eslint-disable radix */
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function frac(input) {
    let num_in = undefined;
    let ret = 0;
    let pre = "0.";
    if (typeof input.val === "number") {
        num_in = input.val;
    }
    else if (typeof input.val === "string") {
        num_in = parseFloat(input.val);
    }
    else if (input.val instanceof types_1.DecFloat34
        || input.val instanceof types_1.Float) {
        num_in = input.val.getRaw();
    }
    else {
        num_in = parseFloat(input.val.get().toString());
    }
    const numSplit = num_in.toString().split(".");
    if (numSplit.length === 2) {
        if (num_in < 0) {
            pre = "-0.";
        }
        ret = parseFloat(pre + numSplit[1]);
    }
    if (input.val instanceof types_1.DecFloat34) {
        return new types_1.DecFloat34().set(ret);
    }
    else if (input.val instanceof types_1.Float) {
        return new types_1.Float().set(ret);
    }
    else {
        return ret;
    }
}
exports.frac = frac;
//# sourceMappingURL=frac.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.$_vertical_tab = exports.$_newline = exports.$_horizontal_tab = exports.$_formfeed = exports.$_cr_lf = exports.$_backspace = exports.space = exports.abap_undefined = exports.abap_false = exports.abap_true = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
__exportStar(__webpack_require__(/*! ./abs */ "./node_modules/@abaplint/runtime/build/src/builtin/abs.js"), exports);
__exportStar(__webpack_require__(/*! ./boolc */ "./node_modules/@abaplint/runtime/build/src/builtin/boolc.js"), exports);
__exportStar(__webpack_require__(/*! ./ceil */ "./node_modules/@abaplint/runtime/build/src/builtin/ceil.js"), exports);
__exportStar(__webpack_require__(/*! ./concat_lines_of */ "./node_modules/@abaplint/runtime/build/src/builtin/concat_lines_of.js"), exports);
__exportStar(__webpack_require__(/*! ./condense */ "./node_modules/@abaplint/runtime/build/src/builtin/condense.js"), exports);
__exportStar(__webpack_require__(/*! ./contains */ "./node_modules/@abaplint/runtime/build/src/builtin/contains.js"), exports);
__exportStar(__webpack_require__(/*! ./cos */ "./node_modules/@abaplint/runtime/build/src/builtin/cos.js"), exports);
__exportStar(__webpack_require__(/*! ./count_any_of */ "./node_modules/@abaplint/runtime/build/src/builtin/count_any_of.js"), exports);
__exportStar(__webpack_require__(/*! ./count */ "./node_modules/@abaplint/runtime/build/src/builtin/count.js"), exports);
__exportStar(__webpack_require__(/*! ./escape */ "./node_modules/@abaplint/runtime/build/src/builtin/escape.js"), exports);
__exportStar(__webpack_require__(/*! ./find */ "./node_modules/@abaplint/runtime/build/src/builtin/find.js"), exports);
__exportStar(__webpack_require__(/*! ./floor */ "./node_modules/@abaplint/runtime/build/src/builtin/floor.js"), exports);
__exportStar(__webpack_require__(/*! ./frac */ "./node_modules/@abaplint/runtime/build/src/builtin/frac.js"), exports);
__exportStar(__webpack_require__(/*! ./insert */ "./node_modules/@abaplint/runtime/build/src/builtin/insert.js"), exports);
__exportStar(__webpack_require__(/*! ./ipow */ "./node_modules/@abaplint/runtime/build/src/builtin/ipow.js"), exports);
__exportStar(__webpack_require__(/*! ./lines */ "./node_modules/@abaplint/runtime/build/src/builtin/lines.js"), exports);
__exportStar(__webpack_require__(/*! ./match */ "./node_modules/@abaplint/runtime/build/src/builtin/match.js"), exports);
__exportStar(__webpack_require__(/*! ./matches */ "./node_modules/@abaplint/runtime/build/src/builtin/matches.js"), exports);
__exportStar(__webpack_require__(/*! ./nmax */ "./node_modules/@abaplint/runtime/build/src/builtin/nmax.js"), exports);
__exportStar(__webpack_require__(/*! ./nmin */ "./node_modules/@abaplint/runtime/build/src/builtin/nmin.js"), exports);
__exportStar(__webpack_require__(/*! ./numofchar */ "./node_modules/@abaplint/runtime/build/src/builtin/numofchar.js"), exports);
__exportStar(__webpack_require__(/*! ./repeat */ "./node_modules/@abaplint/runtime/build/src/builtin/repeat.js"), exports);
__exportStar(__webpack_require__(/*! ./replace */ "./node_modules/@abaplint/runtime/build/src/builtin/replace.js"), exports);
__exportStar(__webpack_require__(/*! ./reverse */ "./node_modules/@abaplint/runtime/build/src/builtin/reverse.js"), exports);
__exportStar(__webpack_require__(/*! ./round */ "./node_modules/@abaplint/runtime/build/src/builtin/round.js"), exports);
__exportStar(__webpack_require__(/*! ./segment */ "./node_modules/@abaplint/runtime/build/src/builtin/segment.js"), exports);
__exportStar(__webpack_require__(/*! ./shift_right */ "./node_modules/@abaplint/runtime/build/src/builtin/shift_right.js"), exports);
__exportStar(__webpack_require__(/*! ./shift_left */ "./node_modules/@abaplint/runtime/build/src/builtin/shift_left.js"), exports);
__exportStar(__webpack_require__(/*! ./sign */ "./node_modules/@abaplint/runtime/build/src/builtin/sign.js"), exports);
__exportStar(__webpack_require__(/*! ./sin */ "./node_modules/@abaplint/runtime/build/src/builtin/sin.js"), exports);
__exportStar(__webpack_require__(/*! ./sqrt */ "./node_modules/@abaplint/runtime/build/src/builtin/sqrt.js"), exports);
__exportStar(__webpack_require__(/*! ./strlen */ "./node_modules/@abaplint/runtime/build/src/builtin/strlen.js"), exports);
__exportStar(__webpack_require__(/*! ./substring_after */ "./node_modules/@abaplint/runtime/build/src/builtin/substring_after.js"), exports);
__exportStar(__webpack_require__(/*! ./substring_before */ "./node_modules/@abaplint/runtime/build/src/builtin/substring_before.js"), exports);
__exportStar(__webpack_require__(/*! ./substring */ "./node_modules/@abaplint/runtime/build/src/builtin/substring.js"), exports);
__exportStar(__webpack_require__(/*! ./sy */ "./node_modules/@abaplint/runtime/build/src/builtin/sy.js"), exports);
__exportStar(__webpack_require__(/*! ./tan */ "./node_modules/@abaplint/runtime/build/src/builtin/tan.js"), exports);
__exportStar(__webpack_require__(/*! ./to_lower */ "./node_modules/@abaplint/runtime/build/src/builtin/to_lower.js"), exports);
__exportStar(__webpack_require__(/*! ./to_mixed */ "./node_modules/@abaplint/runtime/build/src/builtin/to_mixed.js"), exports);
__exportStar(__webpack_require__(/*! ./to_upper */ "./node_modules/@abaplint/runtime/build/src/builtin/to_upper.js"), exports);
__exportStar(__webpack_require__(/*! ./translate */ "./node_modules/@abaplint/runtime/build/src/builtin/translate.js"), exports);
__exportStar(__webpack_require__(/*! ./trunc */ "./node_modules/@abaplint/runtime/build/src/builtin/trunc.js"), exports);
__exportStar(__webpack_require__(/*! ./xstrlen */ "./node_modules/@abaplint/runtime/build/src/builtin/xstrlen.js"), exports);
exports.abap_true = new types_1.Character(1, { qualifiedName: "ABAP_BOOL", ddicName: "ABAP_BOOL" }).set("X").setConstant();
exports.abap_false = new types_1.Character(1, { qualifiedName: "ABAP_BOOL", ddicName: "ABAP_BOOL" }).set("").setConstant();
exports.abap_undefined = new types_1.Character(1, { qualifiedName: "ABAP_BOOL", ddicName: "ABAP_BOOL" }).set("-").setConstant();
exports.space = new types_1.Character(1, { qualifiedName: "ABAP_BOOL", ddicName: "ABAP_BOOL" }).set(" ").setConstant();
exports.$_backspace = new types_1.Character(1).set("\b").setConstant();
exports.$_cr_lf = new types_1.Character(2).set("\r\n").setConstant();
exports.$_formfeed = new types_1.Character(1).set("\f").setConstant();
exports.$_horizontal_tab = new types_1.Character(1).set("\t").setConstant();
exports.$_newline = new types_1.Character(1).set("\n").setConstant();
exports.$_vertical_tab = new types_1.Character(1).set("\v").setConstant();
/*
export const $_maxchar = new Character(1).set(Buffer.from("FDFF", "hex").toString()).setConstant();
export const $_minchar = new Character(1).set(Buffer.from("0000", "hex").toString()).setConstant();
*/ 
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/insert.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/insert.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.insert = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function insert(input) {
    let offset = 0;
    if (input.off) {
        offset = input.off.get();
    }
    const value = input.val.getOffset({ offset: 0, length: offset }).get() +
        input.sub.get() +
        input.val.getOffset({ offset: offset }).get();
    return new types_1.String().set(value);
}
exports.insert = insert;
//# sourceMappingURL=insert.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/ipow.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/ipow.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ipow = void 0;
function ipow(input) {
    let base = undefined;
    if (typeof input.base === "number") {
        base = input.base;
    }
    else if (typeof input.base === "string") {
        base = parseFloat(input.base);
    }
    else {
        base = parseFloat(input.base.get().toString());
    }
    let exp = undefined;
    if (typeof input.exp === "number") {
        exp = input.exp;
    }
    else if (typeof input.exp === "string") {
        exp = parseFloat(input.exp);
    }
    else {
        exp = parseFloat(input.exp.get().toString());
    }
    return Math.pow(base, exp).toFixed(0);
}
exports.ipow = ipow;
//# sourceMappingURL=ipow.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/lines.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/lines.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lines = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function lines(input) {
    if (input.val instanceof types_1.FieldSymbol) {
        if (input.val.getPointer() === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        return lines({ val: input.val.getPointer() });
    }
    return new types_1.Integer().set(input.val.getArrayLength());
}
exports.lines = lines;
//# sourceMappingURL=lines.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/match.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/match.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.match = void 0;
const string_1 = __webpack_require__(/*! ../types/string */ "./node_modules/@abaplint/runtime/build/src/types/string.js");
function match(input) {
    const val = typeof input.val === "string" ? input.val : input.val.get();
    let reg = "";
    if (typeof input.regex === "string") {
        reg = input.regex;
    }
    else {
        reg = input.regex.get();
    }
    const r = new RegExp(reg);
    const res = val.match(r);
    let ret = "";
    if (res && res[0]) {
        ret = res[0];
    }
    return new string_1.String().set(ret);
}
exports.match = match;
//# sourceMappingURL=match.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/matches.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/matches.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.matches = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function matches(input) {
    if (input.pcre === undefined && input.regex === undefined) {
        throw "matches(), todo";
    }
    const val = typeof input.val === "string" ? input.val : input.val.get();
    let reg = "";
    if (input.regex) {
        if (typeof input.regex === "string") {
            reg = input.regex;
        }
        else {
            reg = input.regex.get();
        }
    }
    else if (input.pcre) {
        if (typeof input.pcre === "string") {
            reg = input.pcre;
        }
        else {
            reg = input.pcre.get();
        }
    }
    const r = new RegExp("^" + reg + "$");
    const res = val.match(r);
    if (res !== null) {
        return new types_1.Character().set("X");
    }
    else {
        return new types_1.Character().set(" ");
    }
}
exports.matches = matches;
//# sourceMappingURL=matches.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/nmax.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/nmax.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nmax = void 0;
const _parse_1 = __webpack_require__(/*! ../operators/_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function nmax(input) {
    const values = [];
    values.push((0, _parse_1.parse)(input.val1));
    values.push((0, _parse_1.parse)(input.val2));
    if (input.val3) {
        values.push((0, _parse_1.parse)(input.val3));
    }
    if (input.val4) {
        values.push((0, _parse_1.parse)(input.val4));
    }
    if (input.val5) {
        values.push((0, _parse_1.parse)(input.val5));
    }
    if (input.val6) {
        values.push((0, _parse_1.parse)(input.val6));
    }
    if (input.val7) {
        values.push((0, _parse_1.parse)(input.val7));
    }
    if (input.val8) {
        values.push((0, _parse_1.parse)(input.val8));
    }
    if (input.val9) {
        values.push((0, _parse_1.parse)(input.val9));
    }
    values.sort((a, b) => (b - a));
    return new types_1.Float().set(values[0]);
}
exports.nmax = nmax;
//# sourceMappingURL=nmax.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/nmin.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/nmin.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nmin = void 0;
const _parse_1 = __webpack_require__(/*! ../operators/_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function nmin(input) {
    const values = [];
    values.push((0, _parse_1.parse)(input.val1));
    values.push((0, _parse_1.parse)(input.val2));
    if (input.val3) {
        values.push((0, _parse_1.parse)(input.val3));
    }
    if (input.val4) {
        values.push((0, _parse_1.parse)(input.val4));
    }
    if (input.val5) {
        values.push((0, _parse_1.parse)(input.val5));
    }
    if (input.val6) {
        values.push((0, _parse_1.parse)(input.val6));
    }
    if (input.val7) {
        values.push((0, _parse_1.parse)(input.val7));
    }
    if (input.val8) {
        values.push((0, _parse_1.parse)(input.val8));
    }
    if (input.val9) {
        values.push((0, _parse_1.parse)(input.val9));
    }
    values.sort((a, b) => (a - b));
    return new types_1.Float().set(values[0]);
}
exports.nmin = nmin;
//# sourceMappingURL=nmin.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/numofchar.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/numofchar.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.numofchar = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function numofchar(input) {
    let str = "";
    if (typeof input.val === "string") {
        str = input.val;
    }
    else {
        str = input.val.get();
    }
    str = str.trimEnd();
    return new types_1.Integer().set(str.length);
}
exports.numofchar = numofchar;
//# sourceMappingURL=numofchar.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/repeat.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/repeat.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.repeat = void 0;
const string_1 = __webpack_require__(/*! ../types/string */ "./node_modules/@abaplint/runtime/build/src/types/string.js");
function repeat(input) {
    const val = typeof input.val === "string" ? input.val : input.val.get();
    return new string_1.String().set(val.repeat(input.occ.get()));
}
exports.repeat = repeat;
//# sourceMappingURL=repeat.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/replace.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/replace.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.replace = void 0;
const string_1 = __webpack_require__(/*! ../types/string */ "./node_modules/@abaplint/runtime/build/src/types/string.js");
const abap_regex_1 = __webpack_require__(/*! ../abap_regex */ "./node_modules/@abaplint/runtime/build/src/abap_regex.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function replace(input) {
    let val = undefined;
    if (typeof input.val === "string") {
        val = input.val;
    }
    else if (input.val instanceof types_1.Character) {
        val = input.val.getTrimEnd();
    }
    else {
        val = input.val.get();
    }
    let wi = undefined;
    if (typeof input.with === "string") {
        wi = input.with;
    }
    else if (input.with instanceof types_1.Character) {
        wi = input.with.getTrimEnd();
    }
    else if (input.with) {
        wi = input.with.get();
    }
    let sub = undefined;
    if (typeof input.sub === "string") {
        sub = input.sub;
    }
    else if (input.sub instanceof types_1.Character) {
        sub = input.sub.getTrimEnd();
    }
    else if (input.sub) {
        sub = input.sub.get();
    }
    if (sub !== undefined) {
        sub = abap_regex_1.ABAPRegExp.escapeRegExp(sub);
    }
    if (typeof input.regex === "string") {
        sub = new RegExp(abap_regex_1.ABAPRegExp.convert(input.regex), "g");
    }
    else if (input.regex) {
        sub = new RegExp(abap_regex_1.ABAPRegExp.convert(input.regex.get()), "g");
    }
    if (input.off && input.len && typeof input.val === "string") {
        const offset = input.off.get();
        const length = input.len.get();
        val = val.substring(0, offset) + wi + val.substring(offset + length);
    }
    else if (input.off && input.len && !(typeof input.val === "string")) {
        const offset = input.off.get();
        const length = input.len.get();
        val = input.val.getOffset({ offset: 0, length: offset }).get() +
            wi +
            input.val.getOffset({ offset: offset + length }).get();
    }
    else if (input.occ === undefined && sub && wi !== undefined) {
        if (typeof sub === "string") {
            sub = new RegExp(sub);
        }
        val = val.replace(sub, wi);
    }
    else if (input.occ && input.occ.get() === 0 && sub && wi !== undefined) {
        if (typeof sub === "string") {
            sub = new RegExp(sub, "g");
        }
        val = val.replace(sub, wi);
    }
    return new string_1.String().set(val);
}
exports.replace = replace;
//# sourceMappingURL=replace.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/reverse.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/reverse.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reverse = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function reverse(input) {
    let val = "";
    if (typeof input.val === "string") {
        val = input.val;
    }
    else {
        val = input.val.get();
    }
    val = val.split("").reverse().join("");
    return new types_1.String().set(val);
}
exports.reverse = reverse;
//# sourceMappingURL=reverse.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/round.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/round.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.round = void 0;
const _parse_1 = __webpack_require__(/*! ../operators/_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function round(input) {
    let mode = input.mode;
    if (mode === undefined) {
        mode = 2;
    }
    else if (typeof mode !== "number") {
        mode = mode?.get();
    }
    const val = (0, _parse_1.parse)(input.val);
    const dec = (0, _parse_1.parse)(input.dec);
    if (dec !== 0) {
        throw "round(), todo, handle decimals";
    }
    const ret = new types_1.Float();
    switch (mode) {
        case 1:
            ret.set(Math.ceil(val));
            break;
        case 2:
            ret.set(Math.round(val));
            break;
        case 4:
            ret.set(-Math.round(-val));
            break;
        case 5:
            ret.set(Math.trunc(val));
            break;
        case 6:
            ret.set(Math.floor(val));
            break;
        default:
            throw "round(), unknown mode: " + mode;
    }
    return ret;
}
exports.round = round;
//# sourceMappingURL=round.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/segment.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/segment.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.segment = void 0;
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function segment(input) {
    let val = input.val;
    if (typeof val !== "string") {
        val = val.get();
    }
    let sep = input.sep;
    if (typeof sep !== "string") {
        sep = sep.get();
    }
    let index = input.index;
    if (typeof index !== "number") {
        index = index.get();
    }
    if (index === 0 || sep.length === 0) {
        (0, throw_error_1.throwError)("CX_SY_STRG_PAR_VAL");
    }
    const array = val.split(sep);
    if (index < 0) {
        array.reverse();
        index = Math.abs(index);
    }
    if (index > array.length) {
        (0, throw_error_1.throwError)("CX_SY_STRG_PAR_VAL");
    }
    return new types_1.String().set(array[index - 1]);
}
exports.segment = segment;
//# sourceMappingURL=segment.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/shift_left.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/shift_left.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shift_left = void 0;
const string_1 = __webpack_require__(/*! ../types/string */ "./node_modules/@abaplint/runtime/build/src/types/string.js");
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
function shift_left(input) {
    let val = typeof input.val === "string" ? input.val : input.val.get();
    if (input.sub) {
        const sub = typeof input.sub === "string" ? input.sub : input.sub.get();
        while (val.startsWith(sub)) {
            val = val.substr(sub.length);
        }
    }
    else if (input.places) {
        let places = typeof input.places === "string" ? input.places : input.places.get();
        if (typeof places === "string") {
            places = parseInt(places, 10);
        }
        if (places > val.length) {
            (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
        }
        val = val.substring(places);
    }
    else if (input.circular) {
        const leftShifts = input.circular.get() % val.length;
        val = val.slice(leftShifts) + val.slice(0, leftShifts);
    }
    else {
        return shift_left({ val: input.val, sub: " " });
    }
    return new string_1.String().set(val);
}
exports.shift_left = shift_left;
//# sourceMappingURL=shift_left.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/shift_right.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/shift_right.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shift_right = void 0;
const string_1 = __webpack_require__(/*! ../types/string */ "./node_modules/@abaplint/runtime/build/src/types/string.js");
function shift_right(input) {
    let val = typeof input.val === "string" ? input.val : input.val.get();
    if (input.sub) {
        const sub = typeof input.sub === "string" ? input.sub : input.sub.get();
        while (val.endsWith(sub)) {
            val = val.substr(0, val.length - sub.length);
        }
    }
    else if (input.places) {
        throw new Error("shift_right todo");
    }
    else if (input.circular) {
        throw new Error("shift_right todo");
    }
    else {
        return shift_right({ val: input.val, sub: " " });
    }
    return new string_1.String().set(val);
}
exports.shift_right = shift_right;
//# sourceMappingURL=shift_right.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/sign.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/sign.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sign = void 0;
function sign(input) {
    let num_in = undefined;
    if (typeof input.val === "number") {
        num_in = input.val;
    }
    else if (typeof input.val === "string") {
        num_in = parseFloat(input.val);
    }
    else {
        num_in = parseFloat(input.val.get().toString());
    }
    return Math.sign(num_in);
}
exports.sign = sign;
//# sourceMappingURL=sign.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/sin.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/sin.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sin = void 0;
/* eslint-disable radix */
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function sin(input) {
    let num_in = undefined;
    if (typeof input.val === "number") {
        num_in = input.val;
    }
    else if (typeof input.val === "string") {
        num_in = parseFloat(input.val);
    }
    else if (input.val instanceof types_1.Float) {
        num_in = input.val.getRaw();
    }
    else {
        num_in = parseFloat(input.val.get().toString());
    }
    return Math.sin(num_in);
}
exports.sin = sin;
//# sourceMappingURL=sin.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/sqrt.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/sqrt.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sqrt = void 0;
/* eslint-disable radix */
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function sqrt(input) {
    let num_in = undefined;
    if (typeof input.val === "number") {
        num_in = input.val;
    }
    else if (typeof input.val === "string") {
        num_in = parseFloat(input.val);
    }
    else if (input.val instanceof types_1.Float) {
        num_in = input.val.getRaw();
    }
    else {
        num_in = parseFloat(input.val.get().toString());
    }
    return Math.sqrt(num_in);
}
exports.sqrt = sqrt;
//# sourceMappingURL=sqrt.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/strlen.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/strlen.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.strlen = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function strlen(input) {
    let str = "";
    if (typeof input.val === "string") {
        str = input.val;
    }
    else if (input.val instanceof types_1.Character) {
        str = input.val.getTrimEnd();
    }
    else {
        str = input.val.get();
    }
    return new types_1.Integer().set(str.length);
}
exports.strlen = strlen;
//# sourceMappingURL=strlen.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/substring.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/substring.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.substring = void 0;
const string_1 = __webpack_require__(/*! ../types/string */ "./node_modules/@abaplint/runtime/build/src/types/string.js");
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
function substring(input) {
    let off = input?.off?.get();
    if (off === undefined) {
        off = 0;
    }
    else if (off < 0) {
        (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
    }
    const len = input?.len?.get();
    if (len && len < 0) {
        (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
    }
    if (typeof input.val === "string") {
        return new string_1.String().set(input.val.substr(off, len));
    }
    else {
        return input.val.getOffset({ offset: off, length: len });
    }
}
exports.substring = substring;
//# sourceMappingURL=substring.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/substring_after.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/substring_after.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.substring_after = void 0;
const abap_regex_1 = __webpack_require__(/*! ../abap_regex */ "./node_modules/@abaplint/runtime/build/src/abap_regex.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const string_1 = __webpack_require__(/*! ../types/string */ "./node_modules/@abaplint/runtime/build/src/types/string.js");
function substring_after(input) {
    let val = typeof input.val === "string" ? input.val : input.val.get();
    if (input.val instanceof types_1.Character) {
        val = input.val.getTrimEnd();
    }
    let reg = "";
    if (typeof input.regex === "string") {
        reg = input.regex;
    }
    else if (typeof input.pcre === "string") {
        reg = input.pcre;
    }
    else if (input?.regex) {
        reg = input.regex.get();
    }
    else if (input?.pcre) {
        reg = input.pcre.get();
    }
    else if (typeof input.sub === "string") {
        reg = abap_regex_1.ABAPRegExp.escapeRegExp(input.sub);
    }
    else if (input?.sub) {
        reg = abap_regex_1.ABAPRegExp.escapeRegExp(input.sub.get());
    }
    const r = new RegExp(reg + "(.*)");
    const res = val.match(r);
    let ret = "";
    if (res && res[1]) {
        ret = res[1];
    }
    return new string_1.String().set(ret);
}
exports.substring_after = substring_after;
//# sourceMappingURL=substring_after.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/substring_before.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/substring_before.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.substring_before = void 0;
const abap_regex_1 = __webpack_require__(/*! ../abap_regex */ "./node_modules/@abaplint/runtime/build/src/abap_regex.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const string_1 = __webpack_require__(/*! ../types/string */ "./node_modules/@abaplint/runtime/build/src/types/string.js");
function substring_before(input) {
    let val = "";
    if (typeof input.val === "string") {
        val = input.val;
    }
    else if (input.val instanceof types_1.Character) {
        val = input.val.getTrimEnd();
    }
    else {
        val = input.val.get();
    }
    let reg = "";
    if (typeof input.regex === "string") {
        reg = input.regex;
    }
    else if (input?.regex) {
        reg = input.regex.get();
    }
    else if (typeof input.sub === "string") {
        reg = abap_regex_1.ABAPRegExp.escapeRegExp(input.sub);
    }
    else if (input?.sub) {
        reg = abap_regex_1.ABAPRegExp.escapeRegExp(input.sub.get());
    }
    const r = new RegExp("(.*?)" + reg);
    const res = val.match(r);
    let ret = "";
    if (res && res[1]) {
        ret = res[1];
    }
    return new string_1.String().set(ret);
}
exports.substring_before = substring_before;
//# sourceMappingURL=substring_before.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/sy.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/sy.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sy = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
exports.sy = new types_1.Structure({
    abcde: new types_1.Character(26).set("ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
    datlo: new types_1.Date(),
    datum: new types_1.Date(),
    dbcnt: new types_1.Integer(),
    fdpos: new types_1.Integer(),
    host: new types_1.Character(32).set("localhost"),
    index: new types_1.Integer(),
    langu: new types_1.Character(1).set("E"),
    mandt: new types_1.Character(3).set("123"),
    msgid: new types_1.Character(20),
    msgno: new types_1.Numc({ length: 3 }),
    msgty: new types_1.Character(1),
    msgv1: new types_1.Character(50),
    msgv2: new types_1.Character(50),
    msgv3: new types_1.Character(50),
    msgv4: new types_1.Character(50),
    subrc: new types_1.Integer(),
    sysid: new types_1.Character(3).set("ABC"),
    tabix: new types_1.Integer(),
    tfill: new types_1.Integer(),
    timlo: new types_1.Time(),
    tzone: new types_1.Integer(), // 0 = UTC
    uname: new types_1.Character(12).set("USERNAME"),
    uzeit: new types_1.Time(),
    dbsys: new types_1.Character(10),
});
//# sourceMappingURL=sy.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/tan.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/tan.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tan = void 0;
/* eslint-disable radix */
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function tan(input) {
    let num_in = undefined;
    if (typeof input.val === "number") {
        num_in = input.val;
    }
    else if (typeof input.val === "string") {
        num_in = parseFloat(input.val);
    }
    else if (input.val instanceof types_1.Float) {
        num_in = input.val.getRaw();
    }
    else {
        num_in = parseFloat(input.val.get().toString());
    }
    return Math.tan(num_in);
}
exports.tan = tan;
//# sourceMappingURL=tan.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/to_lower.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/to_lower.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.to_lower = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function to_lower(input) {
    const val = typeof input.val === "string" ? input.val : input.val.get();
    if (input.val instanceof types_1.Character) {
        return new types_1.Character(input.val.getLength()).set(val.toLowerCase());
    }
    else {
        return new types_1.String().set(val.toLowerCase());
    }
}
exports.to_lower = to_lower;
//# sourceMappingURL=to_lower.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/to_mixed.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/to_mixed.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.to_mixed = void 0;
/* eslint-disable @typescript-eslint/ban-types */
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function to_mixed(input) {
    let sep = input.sep;
    if (sep === undefined) {
        sep = "_";
    }
    if (typeof sep !== "string") {
        sep = sep.get();
    }
    if (sep.length === 0) {
        (0, throw_error_1.throwError)("CX_SY_STRG_PAR_VAL");
    }
    const min = 1;
    if (min < 0) {
        (0, throw_error_1.throwError)("CX_SY_STRG_PAR_VAL");
    }
    let val = input.val;
    if (typeof val !== "string") {
        val = val.get();
    }
    val = val.substring(0, min) + val.substring(min).toLowerCase();
    if (input.case) {
        if (typeof input.case === "string") {
            if (input.case === input.case.toLowerCase()) {
                val = val.substring(0, 1).toLowerCase() + val.substring(1);
            }
        }
        else {
            if (input.case.get() === input.case.get().toLowerCase()) {
                val = val.substring(0, 1).toLowerCase() + val.substring(1);
            }
        }
    }
    const length = sep.length;
    const regex = new RegExp(sep + "\\w");
    while (val.match(regex)) {
        val = val.replace(regex, (x) => {
            return x.substring(length).toUpperCase();
        });
    }
    return new types_1.String().set(val);
}
exports.to_mixed = to_mixed;
//# sourceMappingURL=to_mixed.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/to_upper.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/to_upper.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.to_upper = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function to_upper(input) {
    const val = typeof input.val === "string" ? input.val : input.val.get();
    if (input.val instanceof types_1.Character) {
        return new types_1.Character(input.val.getLength()).set(val.toUpperCase());
    }
    else {
        return new types_1.String().set(val.toUpperCase());
    }
}
exports.to_upper = to_upper;
//# sourceMappingURL=to_upper.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/translate.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/translate.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.translate = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const string_1 = __webpack_require__(/*! ../types/string */ "./node_modules/@abaplint/runtime/build/src/types/string.js");
function translate(input) {
    let val = typeof input.val === "string" ? input.val : input.val.get();
    const from = typeof input.from === "string" ? input.from : input.from.get();
    let to = typeof input.to === "string" ? input.to : input.to.get();
    if (input.to instanceof types_1.Character) {
        to = input.to.getTrimEnd();
    }
    const fromSplit = from.split("");
    const toSplit = to.split("");
    const chars = {};
    for (let i = 0; i < fromSplit.length; i++) {
        chars[fromSplit[i]] = toSplit[i] || "";
    }
    const reg = new RegExp("[" + from + "]", "g");
    val = val.replace(reg, m => chars[m] || "");
    return new string_1.String().set(val);
}
exports.translate = translate;
//# sourceMappingURL=translate.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/trunc.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/trunc.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.trunc = void 0;
/* eslint-disable radix */
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function trunc(input) {
    let num_in = undefined;
    if (typeof input.val === "number") {
        num_in = input.val;
    }
    else if (typeof input.val === "string") {
        num_in = parseFloat(input.val);
    }
    else if (input.val instanceof types_1.Float) {
        num_in = input.val.getRaw();
    }
    else {
        num_in = parseFloat(input.val.get().toString());
    }
    return Math.trunc(num_in);
}
exports.trunc = trunc;
//# sourceMappingURL=trunc.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/builtin/xstrlen.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/builtin/xstrlen.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.xstrlen = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function xstrlen(input) {
    if (typeof input.val === "string") {
        return new types_1.Integer().set(input.val.length / 2);
    }
    else {
        return new types_1.Integer().set(input.val.get().length / 2);
    }
}
exports.xstrlen = xstrlen;
//# sourceMappingURL=xstrlen.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/classic_error.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/classic_error.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassicError = void 0;
class ClassicError extends Error {
    constructor(input) {
        super();
        this.classic = input.classic;
    }
}
exports.ClassicError = ClassicError;
//# sourceMappingURL=classic_error.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/clone.js":
/*!***********************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/clone.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clone = void 0;
const types_1 = __webpack_require__(/*! ./types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function clone(obj) {
    if (null == obj || "object" != typeof obj) {
        return obj;
    }
    if (obj instanceof types_1.ABAPObject) {
        const n = new types_1.ABAPObject();
        n.set(obj.get());
        // @ts-ignore
        return n;
    }
    else if (obj instanceof types_1.DataReference) {
        const n = new types_1.DataReference(obj.getType());
        n.assign(obj.getPointer());
        // @ts-ignore
        return n;
    }
    else if (obj instanceof types_1.HexUInt8) {
        const n = new types_1.HexUInt8({ length: obj.getLength(), qualifiedName: obj.getQualifiedName() });
        n.set(obj.get());
        // @ts-ignore
        return n;
    }
    // @ts-ignore
    const copy = new obj.constructor();
    for (const attr in obj) {
        // @ts-ignore
        // eslint-disable-next-line no-prototype-builtins
        if (obj.hasOwnProperty(attr)) {
            /*
            if (null === obj[attr]) {
              console.dir("null");
              copy[attr] = null;
            } else
            */
            if ("object" !== typeof obj[attr]) {
                copy[attr] = obj[attr];
            }
            else {
                copy[attr] = clone(obj[attr]);
            }
        }
    }
    return copy;
}
exports.clone = clone;
//# sourceMappingURL=clone.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/assigned.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/assigned.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assigned = void 0;
function assigned(val) {
    return val.isAssigned();
}
exports.assigned = assigned;
//# sourceMappingURL=assigned.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/between.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/between.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.between = void 0;
const ge_1 = __webpack_require__(/*! ./ge */ "./node_modules/@abaplint/runtime/build/src/compare/ge.js");
const le_1 = __webpack_require__(/*! ./le */ "./node_modules/@abaplint/runtime/build/src/compare/le.js");
function between(left, and1, and2) {
    return (0, ge_1.ge)(left, and1) && (0, le_1.le)(left, and2);
}
exports.between = between;
//# sourceMappingURL=between.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/ca.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/ca.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ca = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function ca(left, right) {
    if (left instanceof types_1.FieldSymbol) {
        return ca(left.getPointer(), right);
    }
    else if (right instanceof types_1.FieldSymbol) {
        return ca(left, right.getPointer());
    }
    let l = "";
    if (typeof left === "number" || typeof left === "string") {
        l = left.toString();
    }
    else if (left instanceof types_1.Structure) {
        l = left.getCharacter();
    }
    else {
        l = left.get().toString();
    }
    if (l === "") {
        l = " ";
    }
    let r = "";
    if (typeof right === "string") {
        r = right.toString();
    }
    else {
        r = right.get().toString();
    }
    let fdpos = 0;
    for (const c of l) {
        if (r.includes(c) === true) {
            // @ts-ignore
            abap.builtin.sy.get().fdpos.set(fdpos);
            return true;
        }
        fdpos++;
    }
    // @ts-ignore
    abap.builtin.sy.get().fdpos.set(fdpos);
    return false;
}
exports.ca = ca;
//# sourceMappingURL=ca.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/cn.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/cn.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cn = void 0;
const co_1 = __webpack_require__(/*! ./co */ "./node_modules/@abaplint/runtime/build/src/compare/co.js");
function cn(left, right) {
    return (0, co_1.co)(left, right) === false;
}
exports.cn = cn;
//# sourceMappingURL=cn.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/co.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/co.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.co = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function co(left, right) {
    let l = "";
    if (typeof left === "number" || typeof left === "string") {
        l = left.toString();
    }
    else {
        l = left.get().toString();
    }
    let r = "";
    if (typeof right === "string") {
        r = right.toString();
    }
    else if (right instanceof types_1.Structure) {
        r = right.getCharacter();
    }
    else {
        r = right.get().toString();
    }
    let fdpos = 0;
    for (const c of l) {
        if (r.includes(c) === false) {
            // @ts-ignore
            abap.builtin.sy.get().fdpos.set(fdpos);
            return false;
        }
        fdpos++;
    }
    // @ts-ignore
    abap.builtin.sy.get().fdpos.set(fdpos);
    return true;
}
exports.co = co;
//# sourceMappingURL=co.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/cp.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/cp.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cp = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function cp(left, right) {
    let l = "";
    if (typeof left === "number" || typeof left === "string") {
        l = left.toString();
    }
    else if (left instanceof types_1.Structure) {
        l = left.getCharacter();
    }
    else if (left instanceof types_1.FieldSymbol) {
        if (left.getPointer() === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        return cp(left.getPointer(), right);
    }
    else if (left instanceof types_1.Character) {
        l = left.getTrimEnd();
    }
    else {
        l = left.get().toString();
    }
    let r = "";
    if (typeof right === "string") {
        r = right.toString();
    }
    else if (right instanceof types_1.Character) {
        r = right.getTrimEnd();
    }
    else {
        r = right.get().toString().trimEnd();
    }
    r = r.replace(/\\/g, "\\\\");
    r = r.replace(/\[/g, "\\[");
    r = r.replace(/\]/g, "\\]");
    r = r.replace(/\}/g, "\\}");
    r = r.replace(/\{/g, "\\{");
    r = r.replace(/\?/g, "\\?");
    r = r.replace(/\(/g, "\\(");
    r = r.replace(/\)/g, "\\)");
    r = r.replace(/\./g, "\\.");
    r = r.replace(/\|/g, "\\|");
    r = r.replace(/\$/g, "\\$");
    r = r.replace(/\^/g, "\\^");
    r = r.replace(/#\*/g, "\\u{002A}");
    r = r.replace(/#\+/g, "\\u{002B}");
    r = r.replace(/\*/g, "[\\s\\S]*");
    r = r.replace(/\+/g, "[\\s\\S]");
    const reg = new RegExp("^" + r + "$", "iu");
    return l.match(reg) !== null;
}
exports.cp = cp;
//# sourceMappingURL=cp.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/cs.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/cs.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cs = void 0;
function cs(left, right) {
    let l = "";
    if (typeof left === "number" || typeof left === "string") {
        l = left.toString();
    }
    else {
        l = left.get().toString();
    }
    l = l.toUpperCase();
    let r = "";
    if (typeof right === "string") {
        r = right.toString();
    }
    else {
        r = right.get().toString();
    }
    r = r.toUpperCase();
    const index = l.indexOf(r);
    if (index < 0) {
        // @ts-ignore
        abap.builtin.sy.get().fdpos.set(l.length);
        return false;
    }
    else {
        // @ts-ignore
        abap.builtin.sy.get().fdpos.set(index);
        return true;
    }
}
exports.cs = cs;
//# sourceMappingURL=cs.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/eq.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/eq.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.eq = void 0;
/* eslint-disable max-len */
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const _parse_1 = __webpack_require__(/*! ../operators/_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
const initial_1 = __webpack_require__(/*! ./initial */ "./node_modules/@abaplint/runtime/build/src/compare/initial.js");
function compareTables(left, right) {
    const leftArray = left.array();
    const rightArray = right.array();
    if (leftArray.length !== rightArray.length) {
        return false;
    }
    for (let i = 0; i < leftArray.length; i++) {
        const rowCompare = eq(leftArray[i], rightArray[i]);
        if (rowCompare === false) {
            return false;
        }
    }
    return true;
}
function eq(left, right) {
    /*
      console.dir(left);
      console.dir(right);
    */
    if (right instanceof types_1.FieldSymbol) {
        return eq(left, right.getPointer());
    }
    else if (left instanceof types_1.FieldSymbol) {
        return eq(left.getPointer(), right);
    }
    if (left instanceof types_1.Integer8 || right instanceof types_1.Integer8) {
        if (left instanceof types_1.Table || left instanceof types_1.HashedTable || right instanceof types_1.Table || right instanceof types_1.HashedTable) {
            // exception?
            return false;
        }
        const l = left instanceof types_1.Integer8 ? left.get() : BigInt((0, _parse_1.parse)(left));
        const r = right instanceof types_1.Integer8 ? right.get() : BigInt((0, _parse_1.parse)(right));
        return l === r;
    }
    // for performance, do the typicaly/easy cases first
    if (right instanceof types_1.Character) {
        if (left instanceof types_1.Character) {
            if (right.getLength() === left.getLength()) {
                return right.get() === left.get();
            }
            else {
                return right.getTrimEnd() === left.getTrimEnd();
            }
        }
        else if (left instanceof types_1.Integer) {
            return (0, types_1.toInteger)(right.get(), false) === left.get();
        }
        else if (left instanceof types_1.String
            || left instanceof types_1.XString
            || left instanceof types_1.Numc
            || left instanceof types_1.HexUInt8
            || left instanceof types_1.Hex) {
            return right.getTrimEnd() === left.get();
        }
    }
    else if (right instanceof types_1.String) {
        if (left instanceof types_1.Character) {
            return right.get() === left.getTrimEnd();
        }
        else if (left instanceof types_1.String) {
            return right.get() === left.get();
        }
    }
    else if (right instanceof types_1.Numc) {
        if (left instanceof types_1.Numc && right.getLength() === left.getLength()) {
            return right.get() === left.get();
        }
        else if (left instanceof types_1.Integer) {
            return left.get() === parseInt(right.get(), 10);
        }
    }
    else if (right instanceof types_1.Integer) {
        if (left instanceof types_1.Integer || left instanceof types_1.Integer8) {
            return right.get() === left.get();
        }
        else if (left instanceof types_1.Character) {
            return (parseInt(left.get(), 10) || 0) === right.get();
        }
        else if (left instanceof types_1.Float) {
            return right.get() === left.getRaw();
        }
        else if (left instanceof types_1.Numc) {
            return right.get() === parseInt(left.get(), 10);
        }
        else if (left instanceof types_1.Packed) {
            return right.get() === left.get();
        }
    }
    else if (right instanceof types_1.DataReference && left instanceof types_1.DataReference) {
        return right.getPointer() === left.getPointer();
    }
    else if (right instanceof types_1.Table
        || right instanceof types_1.HashedTable) {
        if (left instanceof types_1.Table
            || left instanceof types_1.HashedTable) {
            return compareTables(left, right);
        }
        else {
            // this happens in dynamic/ANY typed scenarios?
            return false;
        }
    }
    else if (right instanceof types_1.Hex || right instanceof types_1.XString || right instanceof types_1.HexUInt8) {
        if (left instanceof types_1.Hex || left instanceof types_1.HexUInt8) {
            // @ts-ignore
            if (right.getLength && right.getLength() !== left.getLength()) {
                return (0, initial_1.initial)(left) && (0, initial_1.initial)(right);
            }
            return right.get() === left.get();
        }
        else if (left instanceof types_1.XString) {
            return right.get() === left.get();
        }
        /*
      } else if (right instanceof HexUInt8) {
        if (left instanceof XString) {
          return right.get() === left.get();
        } else if (left instanceof HexUInt8) {
    // https://stackoverflow.com/questions/21553528/how-to-test-for-equality-in-arraybuffer-dataview-and-typedarray
          const llen = left.getLength();
          if (llen === right.getLength()) {
    // todo: this can be optimized by creating multi byte views?
    //       new DataView(this.value.buffer).setInt32(0, 0, true);
            for (let i = 0; i < llen; i++) {
              if (right.getOffsetRaw(i) !== left.getOffsetRaw(i)) {
                return false;
              }
            }
          } else {
            return initial(left) && initial(right);
          }
        }
        */
    }
    else if (right instanceof types_1.ABAPObject) {
        if (left instanceof types_1.ABAPObject) {
            return right.get() === left.get();
        }
    }
    else if (right instanceof types_1.Date) {
        if (left instanceof types_1.Date) {
            return right.get() === left.get();
        }
    }
    else if (right instanceof types_1.Packed) {
        if (left instanceof types_1.Packed) {
            return right.get() === left.get();
        }
        else if (left instanceof types_1.Integer) {
            return right.get() === left.get();
        }
    }
    else if (right instanceof types_1.Integer8) {
        if (left instanceof types_1.Integer
            || left instanceof types_1.Integer8
            || left instanceof types_1.Packed) {
            return right.get() === left.get();
        }
        else if (left instanceof types_1.Float) {
            return right.get() === left.getRaw();
        }
    }
    else if (right instanceof types_1.Float) {
        if (left instanceof types_1.Float) {
            return right.getRaw() === left.getRaw();
        }
        else if (left instanceof types_1.Integer
            || left instanceof types_1.Integer8) {
            return right.getRaw() === left.get();
        }
    }
    if (left instanceof types_1.Structure || right instanceof types_1.Structure) {
        if (!(right instanceof types_1.Structure)) {
            return eq(left.getCharacter(), right);
        }
        else if (!(left instanceof types_1.Structure)) {
            return eq(left, right.getCharacter());
        }
        const l = left.get();
        const r = right.get();
        const leftKeys = Object.keys(l);
        const rightKeys = Object.keys(r);
        if (leftKeys.length !== rightKeys.length) {
            return false;
        }
        for (const k of leftKeys) {
            const e = eq(l[k], r[k]);
            if (e === false) {
                return false;
            }
        }
        return true;
    }
    let l = undefined;
    if (left instanceof types_1.Character) {
        l = left.getTrimEnd();
    }
    else if (left instanceof types_1.Date) {
        l = left.get().trimEnd();
    }
    else if (left instanceof types_1.Table || left instanceof types_1.HashedTable) {
        return false;
    }
    else if (typeof left === "object") {
        l = left.get();
    }
    else {
        l = left;
    }
    let r = undefined;
    if (right instanceof types_1.Character) {
        r = right.getTrimEnd();
    }
    else if (right instanceof types_1.Date) {
        r = right.get().trimEnd();
    }
    else if (typeof right === "object") {
        r = right.get();
    }
    else {
        r = right;
    }
    if ((right instanceof types_1.Hex || right instanceof types_1.HexUInt8) && typeof l === "number") {
        // todo, handle this case earlier
        r = parseInt(right.get(), 16);
    }
    else if ((left instanceof types_1.Hex || left instanceof types_1.HexUInt8) && typeof r === "number") {
        // todo, handle this case earlier
        l = parseInt(left.get(), 16);
    }
    if (right instanceof types_1.Float && left instanceof types_1.Float) {
        r = right.getRaw();
        l = left.getRaw();
    }
    else if (right instanceof types_1.Float && typeof l === "number") {
        r = right.getRaw();
    }
    else if (left instanceof types_1.Float) {
        if (typeof r === "number") {
            l = left.getRaw();
        }
        else if (typeof r === "string") {
            l = left.getRaw();
            r = Number(r);
        }
    }
    if (right instanceof types_1.Numc && left instanceof types_1.Integer) {
        l = left.get();
        r = parseInt(right.get(), 10);
    }
    else if (right instanceof types_1.Integer && left instanceof types_1.Numc) {
        r = right.get();
        l = parseInt(left.get(), 10);
    }
    // assumption: typically no casts are required, so start checking if the types doesnt match
    if (typeof l !== typeof r) {
        if (typeof l === "string" && typeof r === "number") {
            r = r.toString();
        }
        else if (typeof l === "number" && typeof r === "string") {
            if (r === "") {
                r = 0;
            }
            else if (r.includes(".")) {
                r = parseFloat(r);
            }
            else {
                r = parseInt(r, 10);
            }
        }
    }
    /*
      console.dir(l);
      console.dir(r);
    */
    return l === r;
}
exports.eq = eq;
//# sourceMappingURL=eq.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/ge.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/ge.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ge = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/runtime/build/src/compare/index.js");
function ge(left, right) {
    return (0, _1.gt)(left, right) || (0, _1.eq)(left, right);
}
exports.ge = ge;
//# sourceMappingURL=ge.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/gt.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/gt.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.gt = void 0;
const _parse_1 = __webpack_require__(/*! ../operators/_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const integer_1 = __webpack_require__(/*! ../types/integer */ "./node_modules/@abaplint/runtime/build/src/types/integer.js");
function gt(left, right) {
    if (left instanceof types_1.FieldSymbol) {
        if (left.getPointer() === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        return gt(left.getPointer(), right);
    }
    else if (right instanceof types_1.FieldSymbol) {
        if (right.getPointer() === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        return gt(left, right.getPointer());
    }
    if (left instanceof types_1.Table || right instanceof types_1.Table || left instanceof types_1.HashedTable || right instanceof types_1.HashedTable) {
        throw new Error("runtime_todo, gt TABLE");
    }
    if (left instanceof types_1.Hex || right instanceof types_1.Hex || left instanceof types_1.HexUInt8 || right instanceof types_1.HexUInt8) {
        return gt_with_hex(left, right);
    }
    if (left instanceof types_1.Integer8 || right instanceof types_1.Integer8) {
        const l = left instanceof types_1.Integer8 ? left.get() : BigInt((0, _parse_1.parse)(left));
        const r = right instanceof types_1.Integer8 ? right.get() : BigInt((0, _parse_1.parse)(right));
        return l > r;
    }
    let l = undefined;
    if (typeof left === "number" || typeof left === "string") {
        l = left;
    }
    else if (left instanceof types_1.Float || left instanceof types_1.DecFloat34) {
        l = left.getRaw();
    }
    else {
        l = left.get();
    }
    let r = undefined;
    if (typeof right === "number" || typeof right === "string") {
        r = right;
    }
    else if (right instanceof types_1.Float || right instanceof types_1.DecFloat34) {
        r = right.getRaw();
    }
    else {
        r = right.get();
    }
    if (typeof l === "string" && typeof r === "number") {
        if (l === "") {
            l = 0;
        }
        else {
            l = parseInt(l, 10);
        }
    }
    else if (typeof l === "number" && typeof r === "string") {
        if (r === "") {
            r = 0;
        }
        else {
            r = parseInt(r, 10);
        }
    }
    if (l === undefined) {
        return true; // todo, not sure this is correct
    }
    if (r === undefined) {
        return true; // todo, not sure this is correct
    }
    return l > r;
}
exports.gt = gt;
function gt_with_hex(left, right) {
    const left_hex = get_hex_from_parameter(left);
    const right_hex = get_hex_from_parameter(right);
    return left_hex > right_hex;
}
function get_hex_from_parameter(comparison_part) {
    // todo: optimize?
    let hex_from_parameter = "";
    switch (typeof comparison_part) {
        case "number":
            hex_from_parameter = comparison_part.toString(16);
            break;
        case "string":
            hex_from_parameter = comparison_part.split("")
                .map(c => c.charCodeAt(0).toString(16).padStart(2, "0"))
                .join("");
            break;
        case "object":
            if (comparison_part instanceof types_1.Hex
                || comparison_part instanceof types_1.XString
                || comparison_part instanceof types_1.HexUInt8
                || comparison_part instanceof types_1.Character) {
                hex_from_parameter = comparison_part.get();
            }
            else if (comparison_part instanceof integer_1.Integer) {
                hex_from_parameter = comparison_part.get().toString(16).toUpperCase();
                if (hex_from_parameter.length % 2 === 1) {
                    hex_from_parameter = "0" + hex_from_parameter;
                }
            }
            else {
                throw new Error("runtime_todo, gt hex1");
            }
            break;
        default:
            throw new Error("runtime_todo, gt hex2");
    }
    return hex_from_parameter;
}
//# sourceMappingURL=gt.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/in.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/in.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compareIn = void 0;
const cp_1 = __webpack_require__(/*! ./cp */ "./node_modules/@abaplint/runtime/build/src/compare/cp.js");
const eq_1 = __webpack_require__(/*! ./eq */ "./node_modules/@abaplint/runtime/build/src/compare/eq.js");
const ne_1 = __webpack_require__(/*! ./ne */ "./node_modules/@abaplint/runtime/build/src/compare/ne.js");
function compareIn(left, right) {
    if (right.array().length === 0) {
        return true;
    }
    for (const row of right.array()) {
        if ((0, eq_1.eq)(row.get()["sign"], "I") && (0, eq_1.eq)(row.get()["option"], "EQ")) {
            if ((0, eq_1.eq)(row.get()["low"], left)) {
                return true;
            }
        }
        else if ((0, eq_1.eq)(row.get()["sign"], "E") && (0, eq_1.eq)(row.get()["option"], "EQ")) {
            if ((0, ne_1.ne)(row.get()["low"], left)) {
                return true;
            }
        }
        else if ((0, eq_1.eq)(row.get()["sign"], "I") && (0, eq_1.eq)(row.get()["option"], "CP")) {
            if ((0, cp_1.cp)(left, row.get()["low"])) {
                return true;
            }
        }
        else {
            console.dir(row);
            throw new Error("compareIn todo");
        }
    }
    return false;
}
exports.compareIn = compareIn;
//# sourceMappingURL=in.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["in"] = void 0;
__exportStar(__webpack_require__(/*! ./assigned */ "./node_modules/@abaplint/runtime/build/src/compare/assigned.js"), exports);
__exportStar(__webpack_require__(/*! ./between */ "./node_modules/@abaplint/runtime/build/src/compare/between.js"), exports);
__exportStar(__webpack_require__(/*! ./ca */ "./node_modules/@abaplint/runtime/build/src/compare/ca.js"), exports);
__exportStar(__webpack_require__(/*! ./cn */ "./node_modules/@abaplint/runtime/build/src/compare/cn.js"), exports);
__exportStar(__webpack_require__(/*! ./co */ "./node_modules/@abaplint/runtime/build/src/compare/co.js"), exports);
__exportStar(__webpack_require__(/*! ./cp */ "./node_modules/@abaplint/runtime/build/src/compare/cp.js"), exports);
__exportStar(__webpack_require__(/*! ./cs */ "./node_modules/@abaplint/runtime/build/src/compare/cs.js"), exports);
__exportStar(__webpack_require__(/*! ./eq */ "./node_modules/@abaplint/runtime/build/src/compare/eq.js"), exports);
__exportStar(__webpack_require__(/*! ./ge */ "./node_modules/@abaplint/runtime/build/src/compare/ge.js"), exports);
__exportStar(__webpack_require__(/*! ./gt */ "./node_modules/@abaplint/runtime/build/src/compare/gt.js"), exports);
__exportStar(__webpack_require__(/*! ./initial */ "./node_modules/@abaplint/runtime/build/src/compare/initial.js"), exports);
__exportStar(__webpack_require__(/*! ./instance_of */ "./node_modules/@abaplint/runtime/build/src/compare/instance_of.js"), exports);
__exportStar(__webpack_require__(/*! ./le */ "./node_modules/@abaplint/runtime/build/src/compare/le.js"), exports);
__exportStar(__webpack_require__(/*! ./lt */ "./node_modules/@abaplint/runtime/build/src/compare/lt.js"), exports);
__exportStar(__webpack_require__(/*! ./m */ "./node_modules/@abaplint/runtime/build/src/compare/m.js"), exports);
__exportStar(__webpack_require__(/*! ./na */ "./node_modules/@abaplint/runtime/build/src/compare/na.js"), exports);
__exportStar(__webpack_require__(/*! ./ne */ "./node_modules/@abaplint/runtime/build/src/compare/ne.js"), exports);
__exportStar(__webpack_require__(/*! ./np */ "./node_modules/@abaplint/runtime/build/src/compare/np.js"), exports);
__exportStar(__webpack_require__(/*! ./ns */ "./node_modules/@abaplint/runtime/build/src/compare/ns.js"), exports);
__exportStar(__webpack_require__(/*! ./o */ "./node_modules/@abaplint/runtime/build/src/compare/o.js"), exports);
__exportStar(__webpack_require__(/*! ./z */ "./node_modules/@abaplint/runtime/build/src/compare/z.js"), exports);
var in_1 = __webpack_require__(/*! ./in */ "./node_modules/@abaplint/runtime/build/src/compare/in.js");
Object.defineProperty(exports, "in", ({ enumerable: true, get: function () { return in_1.compareIn; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/initial.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/initial.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.initial = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const REGEX_ZEROS = /^0+$/;
const REGEX_SPACES = /^ *$/;
function initial(val) {
    // todo, refactor? add as method in each type instead?
    if (val instanceof types_1.Table || val instanceof types_1.HashedTable) {
        return val.array().length === 0;
    }
    else if (val instanceof types_1.Integer8) {
        return val.get() === 0n;
    }
    else if (val instanceof types_1.DataReference) {
        return val.getPointer() === undefined;
    }
    else if (val instanceof types_1.Date) {
        return val.get() === "00000000";
    }
    else if (val instanceof types_1.Numc) {
        return val.get().match(REGEX_ZEROS) !== null;
    }
    else if (val instanceof types_1.Hex || val instanceof types_1.HexUInt8) {
        return val.get().match(REGEX_ZEROS) !== null;
    }
    else if (val instanceof types_1.Time) {
        return val.get() === "000000";
    }
    else if (val instanceof types_1.Float) {
        return val.getRaw() === 0;
    }
    else if (val instanceof types_1.Character) {
        return val.get().match(REGEX_SPACES) !== null;
    }
    else if (val instanceof types_1.FieldSymbol && val.getPointer() === undefined) {
        throw new Error("FS not assigned");
    }
    else if (val instanceof types_1.FieldSymbol) {
        const res = initial(val.getPointer());
        return res;
    }
    if (typeof val === "string") {
        return val === "";
    }
    else if (typeof val === "number") {
        return val === 0;
    }
    const value = val.get();
    if (typeof value === "string") {
        return value === "";
    }
    else if (typeof value === "number") {
        return value === 0;
    }
    else if (val instanceof types_1.ABAPObject) {
        return value === undefined;
    }
    else if (typeof value === "object") {
        for (const f of Object.keys(value)) {
            if (initial(value[f]) === false) {
                return false;
            }
        }
        return true;
    }
    else {
        throw new Error("runtime, initial, missing implementation");
    }
}
exports.initial = initial;
//# sourceMappingURL=initial.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/instance_of.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/instance_of.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.instance_of = void 0;
function instance_of(val, cname) {
    return val.get() instanceof cname;
}
exports.instance_of = instance_of;
//# sourceMappingURL=instance_of.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/le.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/le.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.le = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/runtime/build/src/compare/index.js");
function le(left, right) {
    return (0, _1.lt)(left, right) || (0, _1.eq)(left, right);
}
exports.le = le;
//# sourceMappingURL=le.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/lt.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/lt.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lt = void 0;
const gt_1 = __webpack_require__(/*! ./gt */ "./node_modules/@abaplint/runtime/build/src/compare/gt.js");
function lt(left, right) {
    return (0, gt_1.gt)(right, left);
}
exports.lt = lt;
//# sourceMappingURL=lt.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/m.js":
/*!***************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/m.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.m = exports.hexToBinary = void 0;
function hexToBinary(input) {
    let ret = "";
    const hex = input.get();
    for (let index = 0; index < hex.length / 2; index++) {
        const byte = hex.substring(index * 2, index * 2 + 2);
        ret += parseInt(byte, 16).toString(2).padStart(8, "0");
    }
    return ret;
}
exports.hexToBinary = hexToBinary;
// bitwise compare
function m(operand1, operand2) {
    let operand1Bits = hexToBinary(operand1);
    const operand2Bits = hexToBinary(operand2);
    if (operand1Bits.length < operand2Bits.length) {
        operand1Bits = operand1Bits.padEnd(operand2Bits.length, "0");
    }
    let oneFound = false;
    let zeroFound = false;
    for (let index = 0; index < operand2Bits.length; index++) {
        const o1bit = operand1Bits.substring(index, index + 1);
        const o2bit = operand2Bits.substring(index, index + 1);
        if (o2bit === "1") {
            if (o1bit === "1") {
                oneFound = true;
            }
            else {
                zeroFound = true;
            }
        }
    }
    return oneFound && zeroFound;
}
exports.m = m;
//# sourceMappingURL=m.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/na.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/na.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.na = void 0;
const ca_1 = __webpack_require__(/*! ./ca */ "./node_modules/@abaplint/runtime/build/src/compare/ca.js");
function na(left, right) {
    return !(0, ca_1.ca)(left, right);
}
exports.na = na;
//# sourceMappingURL=na.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/ne.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/ne.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ne = void 0;
const eq_1 = __webpack_require__(/*! ./eq */ "./node_modules/@abaplint/runtime/build/src/compare/eq.js");
function ne(left, right) {
    return !(0, eq_1.eq)(left, right);
}
exports.ne = ne;
//# sourceMappingURL=ne.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/np.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/np.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.np = void 0;
const cp_1 = __webpack_require__(/*! ./cp */ "./node_modules/@abaplint/runtime/build/src/compare/cp.js");
function np(left, right) {
    return !(0, cp_1.cp)(left, right);
}
exports.np = np;
//# sourceMappingURL=np.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/ns.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/ns.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ns = void 0;
const cs_1 = __webpack_require__(/*! ./cs */ "./node_modules/@abaplint/runtime/build/src/compare/cs.js");
function ns(left, right) {
    return !(0, cs_1.cs)(left, right);
}
exports.ns = ns;
//# sourceMappingURL=ns.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/o.js":
/*!***************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/o.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.o = void 0;
const m_1 = __webpack_require__(/*! ./m */ "./node_modules/@abaplint/runtime/build/src/compare/m.js");
// bitwise compare
function o(operand1, operand2) {
    let operand1Bits = (0, m_1.hexToBinary)(operand1);
    const operand2Bits = (0, m_1.hexToBinary)(operand2);
    if (operand1Bits.length < operand2Bits.length) {
        operand1Bits = operand1Bits.padEnd(operand2Bits.length, "0");
    }
    //  let oneFound = false;
    let zeroFound = false;
    for (let index = 0; index < operand2Bits.length; index++) {
        const o1bit = operand1Bits.substring(index, index + 1);
        const o2bit = operand2Bits.substring(index, index + 1);
        if (o2bit === "1") {
            if (o1bit === "1") {
                //        oneFound = true;
            }
            else {
                zeroFound = true;
            }
        }
    }
    return zeroFound === false;
}
exports.o = o;
//# sourceMappingURL=o.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/compare/z.js":
/*!***************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/compare/z.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.z = void 0;
const m_1 = __webpack_require__(/*! ./m */ "./node_modules/@abaplint/runtime/build/src/compare/m.js");
// bitwise compare
function z(operand1, operand2) {
    let operand1Bits = (0, m_1.hexToBinary)(operand1);
    const operand2Bits = (0, m_1.hexToBinary)(operand2);
    if (operand1Bits.length < operand2Bits.length) {
        operand1Bits = operand1Bits.padEnd(operand2Bits.length, "0");
    }
    let oneFound = false;
    //  let zeroFound = false;
    for (let index = 0; index < operand2Bits.length; index++) {
        const o1bit = operand1Bits.substring(index, index + 1);
        const o2bit = operand2Bits.substring(index, index + 1);
        if (o2bit === "1") {
            if (o1bit === "1") {
                oneFound = true;
            }
            else {
                //        zeroFound = true;
            }
        }
    }
    return oneFound === false;
}
exports.z = z;
//# sourceMappingURL=z.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/console/memory_console.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/console/memory_console.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemoryConsole = void 0;
class MemoryConsole {
    constructor() {
        this.data = "";
    }
    clear() {
        this.data = "";
    }
    add(data) {
        this.data = this.data + data;
    }
    get() {
        return this.data;
    }
    isEmpty() {
        return this.data === "";
    }
    getTrimmed() {
        return this.data.split("\n").map(a => a.trimEnd()).join("\n");
    }
}
exports.MemoryConsole = MemoryConsole;
//# sourceMappingURL=memory_console.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/console/standard_out_console.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/console/standard_out_console.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "?c7fc");

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StandardOutConsole = void 0;
class StandardOutConsole {
    constructor() {
        this.empty = true;
    }
    clear() {
        throw new Error("transpiler runtime: not supported for stdio console");
    }
    add(data) {
        process.stdout.write(data);
        this.empty = false;
    }
    get() {
        return "";
    }
    isEmpty() {
        return this.empty;
    }
    getTrimmed() {
        throw new Error("transpiler runtime: not supported for stdio console");
    }
}
exports.StandardOutConsole = StandardOutConsole;
//# sourceMappingURL=standard_out_console.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/context.js":
/*!*************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/context.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Context = void 0;
class Context {
    constructor() {
        this.cursorCounter = 0;
        this.cursors = {};
        // DEFAULT and secondary database connections
        this.databaseConnections = {};
        this.RFCDestinations = {};
    }
    defaultDB() {
        if (this.databaseConnections["DEFAULT"] === undefined) {
            throw new Error("Runtime, database not initialized");
        }
        return this.databaseConnections["DEFAULT"];
    }
}
exports.Context = Context;
//# sourceMappingURL=context.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/db/db.js":
/*!***********************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/db/db.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=db.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/expand_dynamic.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/expand_dynamic.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.expandDynamic = void 0;
const types_1 = __webpack_require__(/*! ./types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function expandDynamic(code, ev) {
    if (code === "") {
        return "1 = 1";
    }
    else {
        // todo more here, this is just one simple case,
        const match = code.match(/ <(\w+)>/);
        if (match && match[1]) {
            const name = "fs_" + match[1] + "_";
            const found = ev(name);
            if (found instanceof types_1.FieldSymbol) {
                code = code.replace(/ <(\w+)>/, "'" + found.get() + "'");
            }
        }
        return code;
    }
}
exports.expandDynamic = expandDynamic;
//# sourceMappingURL=expand_dynamic.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/expand_in.js":
/*!***************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/expand_in.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.expandIN = void 0;
// note: must always return an expression, never return empty string
// https://www.sqlite.org/lang_select.html
function expandIN(fieldName, table) {
    let ret = "";
    if (table.array().length === 0) {
        // " NOT IN ()" does not work on postgres
        // LIKE '%' does not work in snowflake with RTRIM collation
        ret = `true`;
    }
    else {
        ret = `(`;
        const values = [];
        for (const row of table.array()) {
            if (row.get().sign?.get() === "I" && row.get().option?.get() === "EQ") {
                values.push(`"${fieldName}" = '` + row.get().low?.get().replace(/'/g, "''") + "'");
            }
            else if (row.get().sign?.get() === "I" && row.get().option?.get() === "CP") {
                values.push(`"${fieldName}" LIKE '` + row.get().low?.get().trimEnd().replace(/'/g, "''").replace(/\*/g, "%") + "'");
            }
            else {
                throw new Error(`IN, ${row.get().sign?.get()} ${row.get().option?.get()} not supported`);
            }
        }
        ret += values.join(" OR ") + ")";
    }
    return ret;
}
exports.expandIN = expandIN;
//# sourceMappingURL=expand_in.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ABAP = exports.MemoryConsole = exports.DB = exports.types = exports.RFC = exports.UnitTestResult = void 0;
const context_1 = __webpack_require__(/*! ./context */ "./node_modules/@abaplint/runtime/build/src/context.js");
const offset_length_1 = __webpack_require__(/*! ./offset_length */ "./node_modules/@abaplint/runtime/build/src/offset_length.js");
const statements_1 = __webpack_require__(/*! ./statements */ "./node_modules/@abaplint/runtime/build/src/statements/index.js");
const template_formatting_1 = __webpack_require__(/*! ./template_formatting */ "./node_modules/@abaplint/runtime/build/src/template_formatting.js");
const unit_test_1 = __webpack_require__(/*! ./unit_test */ "./node_modules/@abaplint/runtime/build/src/unit_test.js");
Object.defineProperty(exports, "UnitTestResult", ({ enumerable: true, get: function () { return unit_test_1.UnitTestResult; } }));
const builtin = __webpack_require__(/*! ./builtin */ "./node_modules/@abaplint/runtime/build/src/builtin/index.js");
const compare = __webpack_require__(/*! ./compare */ "./node_modules/@abaplint/runtime/build/src/compare/index.js");
const DB = __webpack_require__(/*! ./db/db */ "./node_modules/@abaplint/runtime/build/src/db/db.js");
exports.DB = DB;
const operators = __webpack_require__(/*! ./operators */ "./node_modules/@abaplint/runtime/build/src/operators/index.js");
const RFC = __webpack_require__(/*! ./rfc */ "./node_modules/@abaplint/runtime/build/src/rfc.js");
exports.RFC = RFC;
const types = __webpack_require__(/*! ./types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
exports.types = types;
const expand_in_1 = __webpack_require__(/*! ./expand_in */ "./node_modules/@abaplint/runtime/build/src/expand_in.js");
const expand_dynamic_1 = __webpack_require__(/*! ./expand_dynamic */ "./node_modules/@abaplint/runtime/build/src/expand_dynamic.js");
const classic_error_1 = __webpack_require__(/*! ./classic_error */ "./node_modules/@abaplint/runtime/build/src/classic_error.js");
const standard_out_console_1 = __webpack_require__(/*! ./console/standard_out_console */ "./node_modules/@abaplint/runtime/build/src/console/standard_out_console.js");
const memory_console_1 = __webpack_require__(/*! ./console/memory_console */ "./node_modules/@abaplint/runtime/build/src/console/memory_console.js");
Object.defineProperty(exports, "MemoryConsole", ({ enumerable: true, get: function () { return memory_console_1.MemoryConsole; } }));
const prefix_1 = __webpack_require__(/*! ./prefix */ "./node_modules/@abaplint/runtime/build/src/prefix.js");
const integer_factory_1 = __webpack_require__(/*! ./integer_factory */ "./node_modules/@abaplint/runtime/build/src/integer_factory.js");
class ABAP {
    constructor(input) {
        // global objects
        this.Classes = {};
        this.DDIC = {};
        this.FunctionModules = {};
        this.Interfaces = {};
        this.MSAG = {};
        this.SMIM = {};
        this.TypePools = {};
        this.W3MI = {};
        this.types = types;
        this.builtin = builtin;
        this.operators = operators;
        this.compare = compare;
        this.OffsetLength = offset_length_1.OffsetLength;
        this.templateFormatting = template_formatting_1.templateFormatting;
        this.expandIN = expand_in_1.expandIN;
        this.expandDynamic = expand_dynamic_1.expandDynamic;
        this.buildDbTableName = prefix_1.buildDbTableName;
        this.ClassicError = classic_error_1.ClassicError;
        this.IntegerFactory = integer_factory_1.IntegerFactory;
        this.context = new context_1.Context();
        this.console = input?.console ? input?.console : new standard_out_console_1.StandardOutConsole();
        this.context.console = this.console;
        this.dbo = input?.database || { schemaPrefix: "", tablePrefix: "" };
        if (this.dbo.schemaPrefix === undefined) {
            this.dbo.schemaPrefix = "";
        }
        if (this.dbo.tablePrefix === undefined) {
            this.dbo.tablePrefix = "";
        }
        this.statements = new statements_1.Statements(this.context);
        // todo, this should not be a singleton, it should be part of this instance
        // todo, move to context
        builtin.sy.get().subrc.set(0);
        builtin.sy.get().tabix.set(0);
        builtin.sy.get().index.set(0);
        this.statements.getTime({ sy: builtin.sy });
    }
}
exports.ABAP = ABAP;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/integer_factory.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/integer_factory.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IntegerFactory = void 0;
const types_1 = __webpack_require__(/*! ./types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
class IntegerFactory {
    static get(num) {
        if (IntegerFactory.map[num] === undefined) {
            IntegerFactory.map[num] = new types_1.Integer().set(num).setConstant();
        }
        return IntegerFactory.map[num];
    }
}
exports.IntegerFactory = IntegerFactory;
IntegerFactory.map = {};
//# sourceMappingURL=integer_factory.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/offset_length.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/offset_length.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OffsetLength = void 0;
const types_1 = __webpack_require__(/*! ./types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
class OffsetLength {
    constructor(obj, options) {
        this.obj = obj;
        if (this.obj instanceof types_1.FieldSymbol) {
            this.obj = this.obj.getPointer();
            if (this.obj === undefined) {
                throw new Error("GETWA_NOT_ASSIGNED");
            }
        }
        this.isHex = this.obj instanceof types_1.Hex || this.obj instanceof types_1.XString || this.obj instanceof types_1.HexUInt8;
        if (options.offset) {
            if (typeof options.offset === "number") {
                this.offset = options.offset;
            }
            else {
                this.offset = options.offset.get();
            }
            if (this.isHex) {
                this.offset *= 2;
            }
        }
        if (options.length) {
            if (typeof options.length === "number") {
                this.length = options.length;
            }
            else {
                this.length = options.length.get();
            }
            if (this.isHex) {
                this.length *= 2;
            }
        }
    }
    get() {
        if (this.isHex) {
            let offset = this.offset;
            if (offset) {
                offset = offset / 2;
            }
            let length = this.length;
            if (length) {
                length = length / 2;
            }
            return this.obj.getOffset({ offset: offset, length: length }).get();
        }
        else {
            return this.obj.getOffset({ offset: this.offset, length: this.length }).get();
        }
    }
    set(value) {
        let val = "";
        if (typeof value === "string") {
            val = value;
        }
        else if (typeof value === "number") {
            val = value + "";
        }
        else if (value instanceof types_1.Integer) {
            val = value.get() + "";
            if (this.isHex) {
                val = Number(val).toString(16).toUpperCase();
            }
        }
        else {
            val = value.get() + "";
        }
        if (this.length) {
            val = val.substr(0, this.length);
            if (this.isHex || this.obj instanceof types_1.Time) {
                val = val.padStart(this.length, "0");
            }
            else if (val.length < this.length) {
                val = val.padEnd(this.length, " ");
            }
        }
        if (this.isHex === true && this.obj instanceof types_1.HexUInt8) {
            let base = this.offset ? this.offset / 2 : 0;
            for (let current = 0; current < val.length; current += 2) {
                const v = Number.parseInt(val.substr(current, 2), 16);
                this.obj.setOffset(base, v);
                base++;
            }
        }
        else {
            let old = this.obj instanceof types_1.Structure ? this.obj.getCharacter() : this.obj.get();
            if (this.length && this.offset) {
                old = old.substr(0, this.offset) + val + old.substr(this.offset + this.length);
            }
            else if (this.length) {
                old = val + old.substr(this.length);
            }
            else if (this.offset) {
                old = old.substr(0, this.offset) + val;
            }
            this.obj.set(old);
        }
    }
}
exports.OffsetLength = OffsetLength;
//# sourceMappingURL=offset_length.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/operators/_bit_operations.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/operators/_bit_operations.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.get_bit_operation_chunks = void 0;
function get_bit_operation_chunks(left, right) {
    const ret = [];
    let leftFull = left.get();
    const leftLen = leftFull.length;
    leftFull = leftFull.padEnd(Math.ceil(leftLen / 2) * 2, "0");
    let rightFull = right.get();
    const rightLen = rightFull.length;
    rightFull = rightFull.padEnd(Math.ceil(rightLen / 2) * 2, "0");
    const maxLen = leftFull.length > rightFull.length ? leftFull.length : rightFull.length;
    // Using 3-byte chunkgs (6 hex positions) to avoid JavaScript negative values for extreme cases
    const chunks = maxLen / 6;
    for (let pass = chunks; pass > 0; pass--) {
        const chunkStart = maxLen - pass * 6;
        const chunkEnd = maxLen - (pass - 1) * 6;
        let leftSlice = leftFull.slice(chunkStart, chunkEnd);
        let rightSlice = rightFull.slice(chunkStart, chunkEnd);
        const chunkLen = leftSlice.length > rightSlice.length ? leftSlice.length : rightSlice.length;
        leftSlice = leftSlice.padEnd(chunkLen, "0");
        rightSlice = rightSlice.padEnd(chunkLen, "0");
        const leftChunk = parseInt(leftSlice, 16);
        const rightChunk = parseInt(rightSlice, 16);
        ret.push({ leftChunk: leftChunk, rightChunk: rightChunk, chunkLen: chunkLen });
    }
    return ret;
}
exports.get_bit_operation_chunks = get_bit_operation_chunks;
//# sourceMappingURL=_bit_operations.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/operators/_parse.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parse = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const xstring_1 = __webpack_require__(/*! ../types/xstring */ "./node_modules/@abaplint/runtime/build/src/types/xstring.js");
function parse(val) {
    if (typeof val === "number") {
        return val;
    }
    else if (typeof val === "string") {
        if (val.includes(".")) {
            return parseFloat(val);
        }
        else {
            return parseInt(val, 10);
        }
    }
    else if (val instanceof types_1.Integer) {
        // optimize, as this is the most common case
        return val.get();
    }
    else if (val instanceof types_1.Float) {
        return val.getRaw();
    }
    else if (val instanceof xstring_1.XString) {
        if (val.get() === "") {
            return 0;
        }
        return parseInt(val.get(), 16);
    }
    else if (val instanceof types_1.Hex || val instanceof types_1.HexUInt8) {
        let num = parseInt(val.get(), 16);
        // handle two complement,
        if (val.getLength() >= 4) {
            const maxVal = Math.pow(2, val.get().length / 2 * 8);
            if (num > maxVal / 2 - 1) {
                num = num - maxVal;
            }
        }
        return num;
    }
    else if (val instanceof types_1.Time || val instanceof types_1.Date) {
        return val.getNumeric();
    }
    else if (val instanceof types_1.DecFloat34) {
        return val.getRaw();
    }
    else {
        return parse(val.get());
    }
}
exports.parse = parse;
//# sourceMappingURL=_parse.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/operators/add.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/operators/add.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.add = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const string_1 = __webpack_require__(/*! ../types/string */ "./node_modules/@abaplint/runtime/build/src/types/string.js");
const _parse_1 = __webpack_require__(/*! ./_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
function add(left, right) {
    if (left instanceof types_1.Integer && right instanceof types_1.Integer) {
        return new types_1.Integer().set(left.get() + right.get());
    }
    else if (typeof left === "number" && typeof right === "number"
        && Number.isInteger(left) && Number.isInteger(right)) {
        return new types_1.Integer().set(left + right);
    }
    else if (typeof left === "number" && Number.isInteger(left) && right instanceof types_1.Integer) {
        return new types_1.Integer().set(left + right.get());
    }
    else if (typeof right === "number" && Number.isInteger(right) && left instanceof types_1.Integer) {
        return new types_1.Integer().set(left.get() + right);
    }
    else if ((left instanceof string_1.String || left instanceof types_1.Character) && Number.isInteger(Number(left.get())) && right instanceof types_1.Integer) {
        return new types_1.Integer().set(Number.parseInt(left.get(), 10) + right.get());
    }
    else if ((right instanceof string_1.String || right instanceof types_1.Character) && Number.isInteger(Number(right)) && left instanceof types_1.Integer) {
        return new types_1.Integer().set(left.get() + Number.parseInt(right.get(), 10));
    }
    else if (left instanceof types_1.Integer8) {
        if (right instanceof types_1.Integer8) {
            return new types_1.Integer8().set(left.get() + right.get());
        }
        else {
            return new types_1.Integer8().set(left.get() + BigInt((0, _parse_1.parse)(right)));
        }
    }
    else if (right instanceof types_1.Integer8) {
        return new types_1.Integer8().set(BigInt((0, _parse_1.parse)(left)) + right.get());
    }
    if (left instanceof types_1.FieldSymbol) {
        if (left.getPointer() === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        return add(left.getPointer(), right);
    }
    if (right instanceof types_1.FieldSymbol) {
        if (right.getPointer() === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        return add(left, right.getPointer());
    }
    const ret = new types_1.Float().set((0, _parse_1.parse)(left) + (0, _parse_1.parse)(right));
    return ret;
}
exports.add = add;
//# sourceMappingURL=add.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/operators/bit-and.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/operators/bit-and.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bitand = void 0;
/*eslint no-bitwise: ["error", { "allow": ["&"] }] */
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const _bit_operations_1 = __webpack_require__(/*! ./_bit_operations */ "./node_modules/@abaplint/runtime/build/src/operators/_bit_operations.js");
function bitand(left, right) {
    let and = "";
    const chunks = (0, _bit_operations_1.get_bit_operation_chunks)(left, right);
    // eslint-disable-next-line no-cond-assign
    for (let i = 0, chunk; chunk = chunks[i]; i++) {
        and = and + (chunk.leftChunk & chunk.rightChunk).toString(16).toUpperCase().padStart(chunk.chunkLen, "0");
    }
    const ret = new types_1.XString();
    ret.set(and);
    return ret;
}
exports.bitand = bitand;
//# sourceMappingURL=bit-and.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/operators/bit-not.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/operators/bit-not.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bitnot = void 0;
const builtin_1 = __webpack_require__(/*! ../builtin */ "./node_modules/@abaplint/runtime/build/src/builtin/index.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
// note: javascript bitwise negate doesnt work well for long hex values
function bitnot(right) {
    const len = (0, builtin_1.xstrlen)({ val: right }).get();
    let not = "";
    for (let i = 0; i < len; i++) {
        const byte = right.getOffset({ offset: i, length: 1 });
        let binary = parseInt(byte.get(), 16).toString(2).padStart(8, "0");
        binary = binary.replace(/0/g, "2");
        binary = binary.replace(/1/g, "0");
        binary = binary.replace(/2/g, "1");
        const hex = parseInt(binary, 2).toString(16).padStart(2, "0");
        not += hex;
    }
    const ret = new types_1.Hex({ length: right.get().length / 2 });
    ret.set(not.toUpperCase());
    return ret;
}
exports.bitnot = bitnot;
//# sourceMappingURL=bit-not.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/operators/bit-or.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/operators/bit-or.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bitor = void 0;
/*eslint no-bitwise: ["error", { "allow": ["|"] }] */
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const _bit_operations_1 = __webpack_require__(/*! ./_bit_operations */ "./node_modules/@abaplint/runtime/build/src/operators/_bit_operations.js");
function bitor(left, right) {
    let or = "";
    const chunks = (0, _bit_operations_1.get_bit_operation_chunks)(left, right);
    // eslint-disable-next-line no-cond-assign
    for (let i = 0, chunk; chunk = chunks[i]; i++) {
        or = or + (chunk.leftChunk | chunk.rightChunk).toString(16).toUpperCase().padStart(chunk.chunkLen, "0");
    }
    const ret = new types_1.XString();
    ret.set(or);
    return ret;
}
exports.bitor = bitor;
//# sourceMappingURL=bit-or.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/operators/bit-xor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/operators/bit-xor.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bitxor = void 0;
/*eslint no-bitwise: ["error", { "allow": ["^"] }] */
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const _bit_operations_1 = __webpack_require__(/*! ./_bit_operations */ "./node_modules/@abaplint/runtime/build/src/operators/_bit_operations.js");
function bitxor(left, right) {
    let xor = "";
    const chunks = (0, _bit_operations_1.get_bit_operation_chunks)(left, right);
    // eslint-disable-next-line no-cond-assign
    for (let i = 0, chunk; chunk = chunks[i]; i++) {
        xor = xor + (chunk.leftChunk ^ chunk.rightChunk).toString(16).toUpperCase().padStart(chunk.chunkLen, "0");
    }
    const ret = new types_1.XString();
    ret.set(xor);
    return ret;
}
exports.bitxor = bitxor;
//# sourceMappingURL=bit-xor.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/operators/concat.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/operators/concat.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.concat = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function concat(left, right) {
    if (Array.isArray(left)) {
        // used in ampersand concatenation
        let res = concat(left[0], left[1]);
        for (let i = 2; i < left.length; i++) {
            res = concat(res, left[i]);
        }
        return res;
    }
    let val = "";
    if (typeof left === "string" || typeof left === "number") {
        val += left;
    }
    else if (left instanceof types_1.Character) {
        val += left.getTrimEnd();
    }
    else {
        val += left.get();
    }
    if (typeof right === "string" || typeof right === "number") {
        val += right;
    }
    else if (right instanceof types_1.Character) {
        val += right.getTrimEnd();
    }
    else {
        val += right.get();
    }
    return new types_1.String().set(val);
}
exports.concat = concat;
//# sourceMappingURL=concat.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/operators/div.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/operators/div.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.div = void 0;
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const _parse_1 = __webpack_require__(/*! ./_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
function div(left, right) {
    if (left instanceof types_1.Integer8 || right instanceof types_1.Integer8) {
        const l = left instanceof types_1.Integer8 ? left.get() : BigInt((0, _parse_1.parse)(left));
        const r = right instanceof types_1.Integer8 ? right.get() : BigInt((0, _parse_1.parse)(right));
        if (r === 0n) {
            if (l === 0n) {
                return new types_1.Integer8().set(0n);
            }
            else {
                (0, throw_error_1.throwError)("CX_SY_ZERODIVIDE");
            }
        }
        const remainder = l % r;
        let div = l / r;
        if (remainder !== 0n) {
            const sign1 = l < 0n;
            const sign2 = r < 0n;
            if (sign1 !== sign2) {
                div = div - 1n;
            }
        }
        return new types_1.Integer8().set(div);
    }
    const l = (0, _parse_1.parse)(left);
    const r = (0, _parse_1.parse)(right);
    if (r === 0) {
        if (l === 0) {
            return new types_1.Integer().set(0);
        }
        else {
            (0, throw_error_1.throwError)("CX_SY_ZERODIVIDE");
        }
    }
    else {
        return new types_1.Integer().set(Math.floor(l / r));
    }
}
exports.div = div;
//# sourceMappingURL=div.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/operators/divide.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/operators/divide.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.divide = void 0;
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const _parse_1 = __webpack_require__(/*! ./_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
// todo, this will only work when the target value is an integer?
function divide(left, right) {
    if (left instanceof types_1.Integer8 || right instanceof types_1.Integer8) {
        const l = left instanceof types_1.Integer8 ? left.get() : BigInt((0, _parse_1.parse)(left));
        const r = right instanceof types_1.Integer8 ? right.get() : BigInt((0, _parse_1.parse)(right));
        if (r === 0n) {
            if (l === 0n) {
                return new types_1.Integer8().set(0n);
            }
            else {
                (0, throw_error_1.throwError)("CX_SY_ZERODIVIDE");
            }
        }
        return new types_1.Integer8().set(l / r);
    }
    const r = (0, _parse_1.parse)(right);
    const l = (0, _parse_1.parse)(left);
    if (r === 0) {
        if (l === 0) {
            return new types_1.Integer().set(0);
        }
        else {
            (0, throw_error_1.throwError)("CX_SY_ZERODIVIDE");
        }
    }
    const val = l / r;
    return new types_1.Float().set(val);
}
exports.divide = divide;
//# sourceMappingURL=divide.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/operators/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/operators/index.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./add */ "./node_modules/@abaplint/runtime/build/src/operators/add.js"), exports);
__exportStar(__webpack_require__(/*! ./div */ "./node_modules/@abaplint/runtime/build/src/operators/div.js"), exports);
__exportStar(__webpack_require__(/*! ./divide */ "./node_modules/@abaplint/runtime/build/src/operators/divide.js"), exports);
__exportStar(__webpack_require__(/*! ./minus */ "./node_modules/@abaplint/runtime/build/src/operators/minus.js"), exports);
__exportStar(__webpack_require__(/*! ./mod */ "./node_modules/@abaplint/runtime/build/src/operators/mod.js"), exports);
__exportStar(__webpack_require__(/*! ./multiply */ "./node_modules/@abaplint/runtime/build/src/operators/multiply.js"), exports);
__exportStar(__webpack_require__(/*! ./power */ "./node_modules/@abaplint/runtime/build/src/operators/power.js"), exports);
__exportStar(__webpack_require__(/*! ./bit-and */ "./node_modules/@abaplint/runtime/build/src/operators/bit-and.js"), exports);
__exportStar(__webpack_require__(/*! ./bit-not */ "./node_modules/@abaplint/runtime/build/src/operators/bit-not.js"), exports);
__exportStar(__webpack_require__(/*! ./bit-or */ "./node_modules/@abaplint/runtime/build/src/operators/bit-or.js"), exports);
__exportStar(__webpack_require__(/*! ./bit-xor */ "./node_modules/@abaplint/runtime/build/src/operators/bit-xor.js"), exports);
__exportStar(__webpack_require__(/*! ./concat */ "./node_modules/@abaplint/runtime/build/src/operators/concat.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/operators/minus.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/operators/minus.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.minus = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const _parse_1 = __webpack_require__(/*! ./_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
const string_1 = __webpack_require__(/*! ../types/string */ "./node_modules/@abaplint/runtime/build/src/types/string.js");
function minus(left, right) {
    if (left instanceof types_1.FieldSymbol) {
        if (left.getPointer() === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        return minus(left.getPointer(), right);
    }
    if (right instanceof types_1.FieldSymbol) {
        if (right.getPointer() === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        return minus(left, right.getPointer());
    }
    if (left instanceof types_1.Integer8 || right instanceof types_1.Integer8) {
        const l = left instanceof types_1.Integer8 ? left.get() : BigInt((0, _parse_1.parse)(left));
        const r = right instanceof types_1.Integer8 ? right.get() : BigInt((0, _parse_1.parse)(right));
        return new types_1.Integer8().set(l - r);
    }
    else if (left instanceof types_1.Integer && right instanceof types_1.Integer) {
        return new types_1.Integer().set(left.get() - right.get());
    }
    else if (typeof left === "number" && typeof right === "number"
        && Number.isInteger(left) && Number.isInteger(right)) {
        return new types_1.Integer().set(left - right);
    }
    else if (typeof left === "number" && Number.isInteger(left) && right instanceof types_1.Integer) {
        return new types_1.Integer().set(left - right.get());
    }
    else if (typeof right === "number" && Number.isInteger(right) && left instanceof types_1.Integer) {
        return new types_1.Integer().set(left.get() - right);
    }
    else if ((left instanceof string_1.String || left instanceof types_1.Character) && Number.isInteger(Number(left.get())) && right instanceof types_1.Integer) {
        return new types_1.Integer().set(Number.parseInt(left.get(), 10) - right.get());
    }
    else if ((right instanceof string_1.String || right instanceof types_1.Character) && Number.isInteger(Number(right)) && left instanceof types_1.Integer) {
        return new types_1.Integer().set(left.get() - Number.parseInt(right.get(), 10));
    }
    return new types_1.Float().set((0, _parse_1.parse)(left) - (0, _parse_1.parse)(right));
}
exports.minus = minus;
//# sourceMappingURL=minus.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/operators/mod.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/operators/mod.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mod = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const _parse_1 = __webpack_require__(/*! ./_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
function mod(left, right) {
    if (left instanceof types_1.Integer8 || right instanceof types_1.Integer8) {
        const l = left instanceof types_1.Integer8 ? left.get() : BigInt((0, _parse_1.parse)(left));
        const r = right instanceof types_1.Integer8 ? right.get() : BigInt((0, _parse_1.parse)(right));
        let val = ((l % r) + r) % r;
        if (val < 0) {
            val = val * -1n;
        }
        return new types_1.Integer8().set(val);
    }
    const l = (0, _parse_1.parse)(left);
    const r = (0, _parse_1.parse)(right);
    let val = ((l % r) + r) % r;
    if (val < 0) {
        val = val * -1;
    }
    if (left instanceof types_1.Integer8 || right instanceof types_1.Integer8) {
        return new types_1.Integer8().set(val);
    }
    else {
        return new types_1.Integer().set(val);
    }
}
exports.mod = mod;
//# sourceMappingURL=mod.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/operators/multiply.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/operators/multiply.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.multiply = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const _parse_1 = __webpack_require__(/*! ./_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
const string_1 = __webpack_require__(/*! ../types/string */ "./node_modules/@abaplint/runtime/build/src/types/string.js");
function multiply(left, right) {
    if (left instanceof types_1.Integer8 || right instanceof types_1.Integer8) {
        const l = left instanceof types_1.Integer8 ? left.get() : BigInt((0, _parse_1.parse)(left));
        const r = right instanceof types_1.Integer8 ? right.get() : BigInt((0, _parse_1.parse)(right));
        return new types_1.Integer8().set(l * r);
    }
    else if (left instanceof types_1.Integer && right instanceof types_1.Integer) {
        const val = left.get() * right.get();
        return new types_1.Integer().set(val);
    }
    else if (typeof left === "number" && typeof right === "number"
        && Number.isInteger(left) && Number.isInteger(right)) {
        const val = left * right;
        return new types_1.Integer().set(val);
    }
    else if (typeof left === "number" && Number.isInteger(left) && right instanceof types_1.Integer) {
        const val = left * right.get();
        return new types_1.Integer().set(val);
    }
    else if (typeof right === "number" && Number.isInteger(right) && left instanceof types_1.Integer) {
        const val = left.get() * right;
        return new types_1.Integer().set(val);
    }
    else if ((left instanceof string_1.String || left instanceof types_1.Character) && Number.isInteger(Number(left.get())) && right instanceof types_1.Integer) {
        const val = Number.parseInt(left.get(), 10) * right.get();
        return new types_1.Integer().set(val);
    }
    else if ((right instanceof string_1.String || right instanceof types_1.Character) && Number.isInteger(Number(right)) && left instanceof types_1.Integer) {
        const val = left.get() * Number.parseInt(right.get(), 10);
        return new types_1.Integer().set(val);
    }
    return new types_1.Float().set((0, _parse_1.parse)(left) * (0, _parse_1.parse)(right));
}
exports.multiply = multiply;
//# sourceMappingURL=multiply.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/operators/power.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/operators/power.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.power = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const _parse_1 = __webpack_require__(/*! ./_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
function power(left, right) {
    if (left instanceof types_1.Integer8 || right instanceof types_1.Integer8) {
        const l = left instanceof types_1.Integer8 ? left.get() : BigInt((0, _parse_1.parse)(left));
        const r = right instanceof types_1.Integer8 ? right.get() : BigInt((0, _parse_1.parse)(right));
        return new types_1.Integer8().set(l ** r);
    }
    return new types_1.Float().set(Math.pow((0, _parse_1.parse)(left), (0, _parse_1.parse)(right)));
}
exports.power = power;
//# sourceMappingURL=power.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/prefix.js":
/*!************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/prefix.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildDbTableName = void 0;
function buildDbTableName(table) {
    // @ts-ignore
    let ret = `"${abap.dbo.tablePrefix + table.trimEnd().toLowerCase()}"`;
    // @ts-ignore
    if (abap.dbo.schemaPrefix !== "") {
        // @ts-ignore
        ret = `"${abap.dbo.schemaPrefix}".` + ret;
    }
    return ret;
}
exports.buildDbTableName = buildDbTableName;
//# sourceMappingURL=prefix.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/rfc.js":
/*!*********************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/rfc.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=rfc.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/append.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/append.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.append = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function append(input) {
    if (input.target instanceof types_1.FieldSymbol) {
        input.target = input.target.getPointer();
        if (input.target === undefined) {
            throw "Field symbol not assigned";
        }
    }
    if (input.source instanceof types_1.FieldSymbol) {
        input.source = input.source.getPointer();
    }
    if (input.target === undefined) {
        // short APPEND, use header field
        if (!(input.source instanceof types_1.Table)) {
            throw "APPEND, header, table";
        }
        input.source.append(input.source.getHeader());
        // @ts-ignore
        abap.builtin.sy.get().tabix.set(input.source.array().length);
        return;
    }
    else if (input.lines === true && input.source instanceof types_1.Table) {
        let from = 1;
        if (input.from) {
            from = parseInt(input.from.get() + "", 10);
        }
        let to = input.source.array().length;
        if (input.to) {
            to = parseInt(input.to.get() + "", 10);
        }
        let index = 1;
        for (const a of input.source.array()) {
            if (index < from || index > to) {
                index++;
                continue;
            }
            input.target.append(a);
            index++;
        }
    }
    else {
        const val = input.target.append(input.source);
        if (input.assigning) {
            if (val instanceof types_1.FieldSymbol) {
                input.assigning.assign(val.getPointer());
            }
            else {
                input.assigning.assign(val);
            }
        }
        else if (input.referenceInto) {
            if (val instanceof types_1.FieldSymbol) {
                input.referenceInto.assign(val.getPointer());
            }
            else {
                input.referenceInto.assign(val);
            }
        }
    }
    // @ts-ignore
    abap.builtin.sy.get().tabix.set(input.target.array().length);
}
exports.append = append;
//# sourceMappingURL=append.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/assert.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/assert.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assert = void 0;
function assert(input) {
    if (input === false) {
        throw new Error("ASSERTION_FAILED");
    }
}
exports.assert = assert;
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/assign.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/assign.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assign = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function assign(input) {
    //  console.dir(input);
    if (input.dynamicName) {
        if (input.dynamicSource instanceof types_1.FieldSymbol) {
            input.dynamicSource = input.dynamicSource.getPointer();
        }
        input.dynamicName = input.dynamicName.trimEnd();
        if (input.dynamicName.includes("->")) {
            if (input.dynamicSource instanceof types_1.ABAPObject || input.dynamicSource instanceof types_1.DataReference) {
                const split = input.dynamicName.split(/->|-/);
                split.shift();
                for (const s of split) {
                    if (s === "*") {
                        // @ts-ignore
                        input.dynamicSource = input.dynamicSource.dereference();
                    }
                    else {
                        // @ts-ignore
                        input.dynamicSource = input.dynamicSource.get()[s.toLowerCase().replace(/[~\\/]/g, "$")];
                    }
                }
            }
            else {
                // @ts-ignore
                abap.builtin.sy.get().subrc.set(4);
                return;
            }
        }
        else if (input.dynamicName.includes("=>")) {
            const split = input.dynamicName.split("=>");
            // @ts-ignore
            const clas = abap.Classes[split[0].toUpperCase()];
            if (clas === undefined) {
                // @ts-ignore
                abap.builtin.sy.get().subrc.set(4);
                return;
            }
            if (clas[split[1].toLowerCase()] !== undefined) {
                input.target.assign(clas[split[1].toLowerCase()]);
                // @ts-ignore
                abap.builtin.sy.get().subrc.set(0);
                return;
            }
            else if (clas[split[0].toLowerCase() + "$" + split[1].toLowerCase()] !== undefined) {
                input.target.assign(clas[split[0].toLowerCase() + "$" + split[1].toLowerCase()]);
                // @ts-ignore
                abap.builtin.sy.get().subrc.set(0);
                return;
            }
        }
        if (input.dynamicSource) {
            input.target.assign(input.dynamicSource);
            // @ts-ignore
            abap.builtin.sy.get().subrc.set(0);
        }
        else {
            // @ts-ignore
            abap.builtin.sy.get().subrc.set(4);
        }
    }
    else if (input.component) {
        if (input.source instanceof types_1.FieldSymbol || input.source instanceof types_1.DataReference) {
            input.source = input.source.getPointer();
            assign(input);
            return;
        }
        else if (!(input.source instanceof types_1.Structure)
            && !(input.source instanceof types_1.Table)) {
            // @ts-ignore
            abap.builtin.sy.get().subrc.set(4);
            return;
        }
        let component = input.component;
        if (typeof component !== "string") {
            component = component.get();
        }
        if (input.source instanceof types_1.Table) {
            if (input.source.getOptions()?.withHeader === true) {
                input.source = input.source.getHeader();
            }
            else {
                // result is the table itself, no change of input.source
            }
        }
        let result = undefined;
        if (typeof component === "number") {
            if (component === 0) {
                result = input.source;
            }
            else if (input.source instanceof types_1.Structure) {
                const structure_as_object = input.source.get();
                const keys = Object.keys(structure_as_object);
                const component_name = keys[component - 1];
                result = structure_as_object[component_name];
            }
        }
        else if (!(input.source instanceof types_1.Table)) {
            const split = component.toLowerCase().trimEnd().split("-");
            result = input.source;
            for (const s of split) {
                result = result.get()[s];
            }
        }
        if (result === undefined) {
            // not a field in the structure
            // @ts-ignore
            abap.builtin.sy.get().subrc.set(4);
        }
        else {
            input.target.assign(result);
            // @ts-ignore
            abap.builtin.sy.get().subrc.set(0);
        }
    }
    else {
        //    console.dir(input);
        if (input.source instanceof types_1.FieldSymbol) {
            const pnt = input.source.getPointer();
            if (pnt === undefined) {
                throw new Error("GETWA_NOT_ASSIGNED");
            }
            input.target.assign(pnt);
            // @ts-ignore
            abap.builtin.sy.get().subrc.set(0);
        }
        else if (input.source === undefined) {
            // @ts-ignore
            abap.builtin.sy.get().subrc.set(4);
        }
        else {
            if (input.casting) {
                input.target.setCasting();
            }
            input.target.assign(input.source);
            // @ts-ignore
            abap.builtin.sy.get().subrc.set(0);
        }
    }
}
exports.assign = assign;
//# sourceMappingURL=assign.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/call_function.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/call_function.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallFunction = void 0;
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const receive_1 = __webpack_require__(/*! ./receive */ "./node_modules/@abaplint/runtime/build/src/statements/receive.js");
class CallFunction {
    constructor(context) {
        this.context = context;
    }
    // note: this is only called if DESTINIATION is supplied
    async callFunction(options) {
        const param = {
            exporting: options.exporting,
            importing: options.importing,
            tables: options.tables,
            changing: options.changing,
            exceptions: options.exceptions,
        };
        options.name = options.name.trimEnd();
        // @ts-ignore
        const fm = abap.FunctionModules[options.name];
        if (options.destination) {
            if (options.destination.trim() === "") {
                if (fm === undefined) {
                    (0, throw_error_1.throwError)("CX_SY_DYN_CALL_ILLEGAL_FUNC");
                }
                await fm(param);
                return;
            }
            const dest = this.context.RFCDestinations[options.destination];
            if (dest === undefined) {
                throw new Error(`RFC destination ${options.destination} does not exist`);
            }
            await dest.call(options.name, {
                exporting: options.exporting,
                importing: options.importing,
                tables: options.tables,
                changing: options.changing,
                exceptions: options.exceptions,
            });
        }
        else if (options.calling) {
            if (fm === undefined) {
                (0, throw_error_1.throwError)("CX_SY_DYN_CALL_ILLEGAL_FUNC");
            }
            await fm(param);
            // save importing + tables + changing + exception for RECEIVE RESULTS
            (0, receive_1._receiveSetResult)(param);
            // call the callback, async
            options.calling({ p_task: new types_1.Character(8).set("OPENABAP") });
        }
        else {
            throw new Error("runtime: callFunction, unexpected input");
        }
    }
}
exports.CallFunction = CallFunction;
//# sourceMappingURL=call_function.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/call_transaction.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/call_transaction.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.callTransaction = void 0;
function callTransaction() {
    // @ts-ignore
    abap.builtin.sy.get().subrc.set(4);
    // @ts-ignore
    abap.builtin.sy.get().msgid.set("00");
    // @ts-ignore
    abap.builtin.sy.get().msgty.set("E");
    // @ts-ignore
    abap.builtin.sy.get().msgno.set("000");
    // @ts-ignore
    abap.builtin.sy.get().msgv1.set("CALL TRANSACTION");
    // @ts-ignore
    abap.builtin.sy.get().msgv2.set("not supported in open-abap");
}
exports.callTransaction = callTransaction;
//# sourceMappingURL=call_transaction.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/cast.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/cast.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cast = void 0;
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
// todo, field symbols as input?
// todo, local classes?
// check with javascript instanceof?
// handling interfaces?
async function cast(target, source) {
    if (source instanceof types_1.ABAPObject && source.get() === undefined) {
        target.clear();
        return;
    }
    // eslint-disable-next-line prefer-const
    let checkIntf = true;
    if (source instanceof types_1.FieldSymbol) {
        if (source.getPointer() === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        await cast(target, source.getPointer());
        return;
    }
    else if (target instanceof types_1.FieldSymbol && target.getPointer() === undefined) {
        throw new Error("GETWA_NOT_ASSIGNED");
    }
    let targetName = undefined;
    if (target.getQualifiedName) {
        targetName = target.getQualifiedName()?.toUpperCase();
    }
    // @ts-ignore
    let targetClass = abap.Classes[targetName];
    if (targetClass === undefined) {
        // todo, for unit testing,
        // @ts-ignore
        targetClass = abap.Classes["PROG-ZFOOBAR-" + targetName];
    }
    if (targetClass?.INTERNAL_TYPE === "CLAS") {
        // using "instanceof" is probably wrong in some cases,
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof
        if (source.get() instanceof targetClass === false) {
            (0, throw_error_1.throwError)("CX_SY_MOVE_CAST_ERROR");
        }
    }
    else if (checkIntf === true && targetClass?.INTERNAL_TYPE === "INTF") {
        const list = source.get().constructor.IMPLEMENTED_INTERFACES;
        const isImplemented = list.some(i => i === targetName);
        if (isImplemented === false) {
            (0, throw_error_1.throwError)("CX_SY_MOVE_CAST_ERROR");
        }
    }
    target.set(source);
}
exports.cast = cast;
//# sourceMappingURL=cast.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/clear.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/clear.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clear = void 0;
function clear(value) {
    value.clear();
}
exports.clear = clear;
//# sourceMappingURL=clear.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/close_cursor.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/close_cursor.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.closeCursor = void 0;
async function closeCursor(context, cursor) {
    await context.cursors[cursor].closeCursor();
    delete context.cursors[cursor];
}
exports.closeCursor = closeCursor;
//# sourceMappingURL=close_cursor.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/collect.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/collect.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.collect = void 0;
const compare_1 = __webpack_require__(/*! ../compare */ "./node_modules/@abaplint/runtime/build/src/compare/index.js");
const insert_internal_1 = __webpack_require__(/*! ./insert_internal */ "./node_modules/@abaplint/runtime/build/src/statements/insert_internal.js");
const read_table_1 = __webpack_require__(/*! ./read_table */ "./node_modules/@abaplint/runtime/build/src/statements/read_table.js");
function collect(source, target) {
    const read = (0, read_table_1.readTable)(target, { withKey: (i) => { return (0, compare_1.eq)(i.table_line, source); } });
    if (read.subrc === 4) {
        (0, insert_internal_1.insertInternal)({ table: target, data: source });
    }
}
exports.collect = collect;
//# sourceMappingURL=collect.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/commit.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/commit.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.commit = void 0;
function commit() {
    // todo
}
exports.commit = commit;
//# sourceMappingURL=commit.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/concatenate.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/concatenate.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.concatenate = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function concatenate(input) {
    let sep = "";
    if (input.separatedBy) {
        if (typeof input.separatedBy === "string" || typeof input.separatedBy === "number") {
            sep = input.separatedBy.toString();
        }
        else {
            sep = input.separatedBy.get().toString();
        }
    }
    if (input.lines === true) {
        const list = [];
        const tab = input.source[0];
        if (tab instanceof types_1.Table) {
            for (const l of tab.array()) {
                if (input.respectingBlanks !== true) {
                    list.push(l.get().trimEnd());
                }
                else {
                    list.push(l.get());
                }
            }
        }
        input.target.set(list.join(sep));
    }
    else {
        let result = "";
        for (const source of input.source) {
            let val = "";
            if (source instanceof types_1.Table) {
                throw new Error("concatenate, error: input is table");
            }
            else if (typeof source === "string" || typeof source === "number") {
                val = source.toString();
            }
            else if (source instanceof types_1.Character) {
                if (input.respectingBlanks !== true) {
                    val = source.getTrimEnd();
                }
                else {
                    val = source.get();
                }
            }
            else {
                val = source.get().toString();
            }
            result += val + sep;
        }
        if (sep.length > 0 && result.length > 0) {
            result = result.slice(0, result.length - sep.length);
        }
        input.target.set(result);
    }
}
exports.concatenate = concatenate;
//# sourceMappingURL=concatenate.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/condense.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/condense.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.condense = void 0;
function condense(input, options) {
    let trimmed = input.get().replace(/ +$/, "");
    trimmed = trimmed.replace(/^ +/, "");
    if (options.nogaps) {
        trimmed = trimmed.replace(/ */g, "");
    }
    else {
        trimmed = trimmed.replace(/ {2,}/g, " ");
    }
    input.set(trimmed);
}
exports.condense = condense;
//# sourceMappingURL=condense.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/convert.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/convert.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convert = void 0;
const temporal_polyfill_1 = __webpack_require__(/*! temporal-polyfill */ "./node_modules/temporal-polyfill/index.cjs");
function convert(source, target) {
    /*
    console.dir(source);
    console.dir(target);
    */
    let date = "";
    if (source.date) {
        if (typeof source.date === "string") {
            date = source.date;
        }
        else {
            date = source.date.get();
        }
        if (date.trimEnd() === "") {
            date = "00000000";
        }
    }
    let time = "";
    if (source.time) {
        if (typeof source.time === "string") {
            time = source.time;
        }
        else {
            time = source.time.get();
        }
        if (time.trimEnd() === "") {
            time = "000000";
        }
    }
    let stamp = "";
    if (source.stamp) {
        if (typeof source.stamp === "string") {
            stamp = source.stamp;
        }
        else {
            stamp = source.stamp.get() + "";
        }
    }
    let zone = "";
    if (source.zone) {
        if (typeof source.zone === "string") {
            zone = source.zone;
        }
        else {
            zone = source.zone.get() + "";
        }
        zone = zone.trimEnd();
    }
    if (zone.trim() === "") {
        zone = "UTC";
    }
    ////////////////////////
    let zoned = undefined;
    if (date !== "" && time !== "") {
        if (date === "00000000" && time === "000000") {
            target.stamp?.clear();
            return;
        }
        const pt = temporal_polyfill_1.Temporal.PlainTime.from(time.substring(0, 2) + ":" + time.substring(2, 4) + ":" + time.substring(4, 6));
        zoned = temporal_polyfill_1.Temporal.PlainDate.from(date).toZonedDateTime({ timeZone: zone, plainTime: pt });
        zoned = zoned.withTimeZone("UTC");
    }
    else {
        if (stamp === "0") {
            target.date?.clear();
            target.time?.clear();
            return;
        }
        const pt = temporal_polyfill_1.Temporal.PlainTime.from(stamp.substring(8, 10) + ":" + stamp.substring(10, 12) + ":" + stamp.substring(12, 14));
        zoned = temporal_polyfill_1.Temporal.PlainDate.from(stamp.substring(0, 8)).toZonedDateTime({ timeZone: "UTC", plainTime: pt });
        zoned = zoned.withTimeZone(zone);
    }
    const d = zoned.toPlainDate().toString().replace(/-/g, "");
    const t = zoned.toPlainTime().toString().replace(/:/g, "");
    if (target.stamp) {
        target.stamp.set(d + t);
    }
    if (target.date) {
        target.date.set(d);
    }
    if (target.time) {
        target.time.set(t);
    }
}
exports.convert = convert;
//# sourceMappingURL=convert.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/create_data.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/create_data.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createData = void 0;
const clone_1 = __webpack_require__(/*! ../clone */ "./node_modules/@abaplint/runtime/build/src/clone.js");
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function createData(target, options) {
    if (target instanceof types_1.FieldSymbol) {
        createData(target.getPointer(), options);
        return;
    }
    else if (!(target instanceof types_1.DataReference)) {
        throw new Error("CREATE_DATA_REFERENCE_EXPECTED");
    }
    if (options?.name && options?.table) {
        // @ts-ignore
        if (abap.DDIC[options.name.trimEnd()] === undefined) {
            (0, throw_error_1.throwError)("CX_SY_CREATE_DATA_ERROR");
        }
        // @ts-ignore
        target.assign(new abap.types.Table(abap.DDIC[options.name.trimEnd()].type));
    }
    else if (options?.name) {
        // @ts-ignore
        if (abap.DDIC[options.name.trimEnd()]) {
            // @ts-ignore
            target.assign((0, clone_1.clone)(abap.DDIC[options.name.trimEnd()].type));
        }
        else if (options.name.includes("=>")) {
            const [className, typeName] = options.name.trimEnd().toUpperCase().split("=>");
            // @ts-ignore
            if (abap.Classes[className] === undefined) {
                (0, throw_error_1.throwError)("CX_SY_CREATE_DATA_ERROR");
            }
            // @ts-ignore
            if (abap.Classes[className][typeName.toLowerCase()] === undefined) {
                (0, throw_error_1.throwError)("CX_SY_CREATE_DATA_ERROR");
            }
            // @ts-ignore
            target.assign((0, clone_1.clone)(abap.Classes[className][typeName.toLowerCase()]));
        }
        else if (options.name.startsWith("\\TYPE=%")) {
            // currently, only the runtime knows the references to the anonymous types
            // @ts-ignore
            const clas = abap.Classes["KERNEL_CREATE_DATA_HANDLE"];
            if (clas === undefined) {
                throw new Error("CreateData, kernel class missing");
            }
            clas.anonymous({ name: options.name.trimEnd(), dref: target });
        }
        else if (options.name.trimEnd() === "ABAP_BOOL") {
            // ABAP_BOOL is special, its not part of the type pool, its built-into abaplint
            target.assign(new types_1.Character(1, { qualifiedName: "ABAP_BOOL", ddicName: "ABAP_BOOL" }));
        }
        else if (options.name.trimEnd() === "STRING") {
            target.assign(new types_1.String());
        }
        else if (options.name.trimEnd() === "XSTRING") {
            target.assign(new types_1.XString());
        }
        else if (options.name.trimEnd() === "I") {
            target.assign(new types_1.Integer());
        }
        else if (options.name.trimEnd() === "T") {
            target.assign(new types_1.Time());
        }
        else if (options.name.trimEnd() === "D") {
            target.assign(new types_1.Date());
        }
        else if (options.name.trimEnd() === "F") {
            target.assign(new types_1.Float());
        }
        else if (options.name.trimEnd() === "INT8") {
            target.assign(new types_1.Integer8());
        }
        else if (options.refTo === true) {
            // @ts-ignore
            if (abap.Classes[options.name.toUpperCase()] === undefined) {
                (0, throw_error_1.throwError)("CX_SY_CREATE_DATA_ERROR");
            }
            // @ts-ignore
            target.assign(new abap.types.ABAPObject({ qualifiedName: options.name, RTTIName: options.name }));
        }
        else {
            (0, throw_error_1.throwError)("CX_SY_CREATE_DATA_ERROR");
        }
        if (options.typeLineOf === true) {
            // @ts-ignore
            target.assign((0, clone_1.clone)(target.getPointer().getRowType()));
        }
    }
    else if (options?.typeName) {
        switch (options.typeName) {
            case "C":
                {
                    let length = 1;
                    if (options.length) {
                        length = options.length.get();
                    }
                    target.assign(new types_1.Character(length));
                }
                break;
            case "N":
                {
                    let length = 1;
                    if (options.length) {
                        length = options.length.get();
                    }
                    target.assign(new types_1.Numc({ length: length }));
                }
                break;
            case "X":
                {
                    let length = 1;
                    if (options.length) {
                        length = options.length.get();
                    }
                    target.assign(new types_1.Hex({ length: length }));
                }
                break;
            case "P":
                {
                    let length = 1;
                    if (options.length) {
                        length = options.length.get();
                    }
                    let decimals = 0;
                    if (options.decimals) {
                        decimals = options.decimals.get();
                    }
                    target.assign(new types_1.Packed({ length: length, decimals: decimals }));
                }
                break;
            case "F":
                target.assign(new types_1.Float());
                break;
            case "D":
                target.assign(new types_1.Date());
                break;
            case "T":
                target.assign(new types_1.Time());
                break;
            case "I":
                target.assign(new types_1.Integer());
                break;
            case "STRING":
                target.assign(new types_1.String());
                break;
            case "INT8":
                target.assign(new types_1.Integer8());
                break;
            case "XSTRING":
                target.assign(new types_1.XString());
                break;
            default:
                // @ts-ignore
                if (abap.DDIC[options.typeName.trimEnd()]) {
                    // @ts-ignore
                    target.assign((0, clone_1.clone)(abap.DDIC[options.typeName.trimEnd()].type));
                }
                else if (options.typeName.includes("=>")) {
                    const [className, typeName] = options.typeName.toUpperCase().split("=>");
                    // @ts-ignore
                    if (abap.Classes[className] === undefined) {
                        (0, throw_error_1.throwError)("CX_SY_CREATE_DATA_ERROR");
                    }
                    // @ts-ignore
                    if (abap.Classes[className][typeName.toLowerCase().trimEnd()] === undefined) {
                        (0, throw_error_1.throwError)("CX_SY_CREATE_DATA_ERROR");
                    }
                    // @ts-ignore
                    target.assign((0, clone_1.clone)(abap.Classes[className][typeName.toLowerCase().trimEnd()]));
                }
                else {
                    throw "CREATE DATA, unknown type " + options.typeName;
                }
        }
    }
    else if (options?.type) {
        target.assign((0, clone_1.clone)(options.type));
    }
    else if (options?.likeLineOf) {
        if (options.likeLineOf instanceof types_1.FieldSymbol) {
            options.likeLineOf = options.likeLineOf.getPointer();
        }
        target.assign((0, clone_1.clone)(options.likeLineOf.getRowType()));
    }
    else if (options?.like) {
        if (options.like instanceof types_1.FieldSymbol) {
            options.like = options.like.getPointer();
        }
        target.assign((0, clone_1.clone)(options.like));
    }
    else {
        target.assign((0, clone_1.clone)(target.getType()));
    }
}
exports.createData = createData;
//# sourceMappingURL=create_data.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/delete_database.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/delete_database.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteDatabase = void 0;
const prefix_1 = __webpack_require__(/*! ../prefix */ "./node_modules/@abaplint/runtime/build/src/prefix.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const insert_database_1 = __webpack_require__(/*! ./insert_database */ "./node_modules/@abaplint/runtime/build/src/statements/insert_database.js");
async function deleteDatabase(table, options, context) {
    if (options.table instanceof types_1.FieldSymbol) {
        options.table = options.table.getPointer();
    }
    if (options.from instanceof types_1.FieldSymbol) {
        options.from = options.from.getPointer();
    }
    if (typeof table !== "string") {
        table = table.get().trimEnd();
    }
    if (options.table) {
        for (const row of options.table.array()) {
            await deleteDatabase(table, { from: row }, context);
        }
    }
    else if (options.from) {
        let where = [];
        const structure = options.from.get();
        for (const k of Object.keys(structure)) {
            const str = `"${k.toLowerCase()}"` + " = " + (0, insert_database_1.toValue)(structure[k].get());
            where.push(str);
        }
        where = where.join(" AND ");
        const { subrc, dbcnt } = await context.defaultDB().delete({
            table: (0, prefix_1.buildDbTableName)(table),
            where,
        });
        // @ts-ignore
        abap.builtin.sy.get().subrc.set(subrc);
        // @ts-ignore
        abap.builtin.sy.get().dbcnt.set(dbcnt);
    }
    else if (options.where) {
        const { subrc, dbcnt } = await context.defaultDB().delete({
            table: (0, prefix_1.buildDbTableName)(table),
            where: options.where,
        });
        // @ts-ignore
        abap.builtin.sy.get().subrc.set(subrc);
        // @ts-ignore
        abap.builtin.sy.get().dbcnt.set(dbcnt);
    }
    else {
        throw "deleteDatabase todo";
    }
}
exports.deleteDatabase = deleteDatabase;
//# sourceMappingURL=delete_database.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/delete_internal.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/delete_internal.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.deleteInternal = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const compare_1 = __webpack_require__(/*! ../compare */ "./node_modules/@abaplint/runtime/build/src/compare/index.js");
const loop_1 = __webpack_require__(/*! ./loop */ "./node_modules/@abaplint/runtime/build/src/statements/loop.js");
async function deleteInternal(target, options) {
    let index = 0;
    if (target instanceof types_1.FieldSymbol) {
        target = target.getPointer();
        if (target === undefined) {
            throw new Error("deleteInternal, FS not assigned");
        }
    }
    if (options?.index
        && options?.where === undefined
        && options?.adjacent === undefined
        && options?.fromValue === undefined
        && options?.from === undefined
        && options?.to === undefined) {
        if (target.array()[options.index.get() - 1] === undefined) {
            // @ts-ignore
            abap.builtin.sy.get().subrc.set(4);
            return;
        }
        else {
            target.deleteIndex(options.index.get() - 1);
            // @ts-ignore
            abap.builtin.sy.get().subrc.set(0);
            return;
        }
    }
    if (options?.to) {
        if (options?.from !== undefined || options?.where !== undefined) {
            throw "DeleteInternalTodo";
        }
        for (let i = 0; i < options.to.get(); i++) {
            target.deleteIndex(0);
        }
        return;
    }
    if (options?.adjacent === true) {
        if (target instanceof types_1.HashedTable) {
            throw new Error("delete adjacent, hashed table");
        }
        const array = target.array();
        for (let index = array.length - 1; index > 0; index--) {
            const prev = array[index - 1];
            const i = array[index];
            if (options?.comparing) {
                let match = false;
                for (const compareField of options.comparing) {
                    match = (0, compare_1.eq)(prev.get()[compareField], i.get()[compareField]);
                    if (!match) {
                        break;
                    }
                }
                if (match) {
                    target.deleteIndex(index);
                }
            }
            else if ((0, compare_1.eq)(prev, i) === true) {
                target.deleteIndex(index);
            }
        }
        return;
    }
    if (target instanceof types_1.HashedTable && options?.fromValue) {
        target.deleteFrom(options.fromValue);
        return;
    }
    // @ts-ignore
    const originalTabix = abap.builtin.sy.get().tabix.get();
    for await (const i of (0, loop_1.loop)(target)) {
        // @ts-ignore
        index = abap.builtin.sy.get().tabix.get() - 1;
        if (options?.where) {
            const row = i instanceof types_1.Structure ? i.get() : { table_line: i };
            if (options.where(row) === true) {
                if (target instanceof types_1.HashedTable) {
                    target.deleteFrom(i);
                }
                else {
                    target.deleteIndex(index);
                }
            }
        }
        else if (options?.index && options.index.get() === index) {
            target.deleteIndex(options.index.get() - 1);
            break;
        }
        else if (options?.fromValue && (0, compare_1.eq)(options.fromValue, i)) {
            target.deleteIndex(index);
        }
        else if (options?.from && options.from.get() <= index + 1) {
            target.deleteIndex(index);
        }
        else if (options === undefined && originalTabix === index + 1) {
            // short form, "DELETE tab"
            target.deleteIndex(index);
            break;
        }
    }
}
exports.deleteInternal = deleteInternal;
//# sourceMappingURL=delete_internal.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/describe.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/describe.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.describe = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function describe(input) {
    //  console.dir(input);
    if (input.type) {
        if (input.field instanceof types_1.FieldSymbol) {
            describe({ field: input.field.getPointer(), type: input.type, length: input.length, mode: input.mode });
            return;
        }
        if (input.field instanceof types_1.Table || input.field instanceof types_1.HashedTable) {
            input.type.set("h");
        }
        else if (input.field instanceof types_1.Character || typeof input.field === "string") {
            input.type.set("C");
        }
        else if (input.field instanceof types_1.Integer) {
            input.type.set("I");
        }
        else if (input.field instanceof types_1.Integer8) {
            input.type.set("8");
        }
        else if (input.field instanceof types_1.Date) {
            input.type.set("D");
        }
        else if (input.field instanceof types_1.Time) {
            input.type.set("T");
        }
        else if (input.field instanceof types_1.Float) {
            input.type.set("F");
        }
        else if (input.field instanceof types_1.Numc) {
            input.type.set("N");
        }
        else if (input.field instanceof types_1.Hex || input.field instanceof types_1.HexUInt8) {
            input.type.set("X");
        }
        else if (input.field instanceof types_1.Packed) {
            input.type.set("P");
        }
        else if (input.field instanceof types_1.String) {
            input.type.set("g");
        }
        else if (input.field instanceof types_1.XString) {
            input.type.set("y");
        }
        else if (input.field instanceof types_1.DecFloat34) {
            input.type.set("e");
        }
        else if (input.field instanceof types_1.Structure) {
            input.type.set("u");
        }
        else if (input.field instanceof types_1.ABAPObject) {
            input.type.set("r");
        }
        else if (input.field instanceof types_1.DataReference) {
            input.type.set("l");
        }
        else {
            throw new Error("DESCRIBE, todo, transpiler, " + input.field.constructor.name);
        }
    }
    if (input.field instanceof types_1.FieldSymbol) {
        input.field = input.field.getPointer();
    }
    if (input.length) {
        if (input.field instanceof types_1.Character
            || input.field instanceof types_1.Packed
            || input.field instanceof types_1.Numc
            || input.field instanceof types_1.HexUInt8
            || input.field instanceof types_1.Hex) {
            input.length.set(input.field.getLength());
        }
        else {
            throw new Error("DESCRIBE length, unsupported or todo, " + input.field.constructor.name);
        }
    }
    if (input.decimals) {
        if (input.field instanceof types_1.Packed) {
            input.decimals.set(input.field.getDecimals());
        }
        else {
            throw new Error("DESCRIBE decimals, unsupported or todo, " + input.field.constructor.name);
        }
    }
    if (input.table) {
        // @ts-ignore
        abap.builtin.sy.get().tfill.set(input.table.getArrayLength());
        input.lines?.set(input.table.getArrayLength());
    }
}
exports.describe = describe;
//# sourceMappingURL=describe.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/fetch_next_cursor.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/fetch_next_cursor.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fetchNextCursor = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const select_1 = __webpack_require__(/*! ./select */ "./node_modules/@abaplint/runtime/build/src/statements/select.js");
async function fetchNextCursor(context, cursor, target, packageSize) {
    if (target instanceof types_1.FieldSymbol) {
        if (target.isAssigned() === false) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        // @ts-ignore
        target = target.getPointer();
    }
    if (target instanceof types_1.Structure) {
        packageSize = 1;
    }
    const result = await context.cursors[cursor].fetchNextCursor(packageSize);
    if (result.rows.length === 0) {
        // @ts-ignore
        abap.builtin.sy.get().subrc.set(4);
        return;
    }
    // @ts-ignore
    abap.builtin.sy.get().subrc.set(0);
    (0, select_1.rowsToTarget)(target, result.rows);
}
exports.fetchNextCursor = fetchNextCursor;
//# sourceMappingURL=fetch_next_cursor.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/find.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/find.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.find = void 0;
const abap_regex_1 = __webpack_require__(/*! ../abap_regex */ "./node_modules/@abaplint/runtime/build/src/abap_regex.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function find(input, options) {
    let sectionOffset = options.sectionOffset?.get();
    if (sectionOffset && options.byteMode) {
        sectionOffset = sectionOffset * 2;
    }
    let s = "";
    if (options.find) {
        s = options.find;
        if (typeof s !== "string") {
            s = s.get();
        }
        if (s === "") {
            // @ts-ignore
            abap.builtin.sy.get().subrc.set(0);
            return;
        }
        s = s.replace(/\[/g, "\\[");
        s = s.replace(/\]/g, "\\]");
        s = s.replace(/\?/g, "\\?");
        s = s.replace(/\(/g, "\\(");
        s = s.replace(/\)/g, "\\)");
        s = s.replace(/\./g, "\\.");
        s = s.replace(/\|/g, "\\|");
        s = s.replace(/\*/g, "\\*");
        s = s.replace(/\+/g, "\\+");
        s = new RegExp(s, "g");
    }
    else if (options.regex || options.pcre) {
        if (options.regex) {
            if (typeof options.regex === "string") {
                if (options.regex === "") {
                    throw new Error("FIND, runtime, no input, regex empty");
                }
            }
            else if (options.regex.get() === "") {
                throw new Error("FIND, runtime, no input, regex empty");
            }
        }
        let r = options.regex;
        if (r === undefined) {
            r = options.pcre;
        }
        if (typeof r !== "string") {
            r = r.get();
        }
        if (typeof r === "string") {
            r = abap_regex_1.ABAPRegExp.convert(r);
        }
        else if (r.constructor.name === "cl_abap_regex") {
            const obj = r;
            // @ts-ignore
            r = obj.mv_pattern.get();
            // @ts-ignore
            if (obj.mv_ignore_case.get() === "X") {
                options.ignoringCase = true;
            }
        }
        else {
            throw "find(), unexpected input";
        }
        s = new RegExp(r, "gm" + (options.ignoringCase === true ? "i" : ""));
    }
    else {
        throw "FIND, runtime, no input";
    }
    const matches = [];
    if (input instanceof types_1.Table) {
        let line = 1;
        for (const blah of input.array()) {
            let temp;
            // eslint-disable-next-line no-cond-assign
            while (temp = s.exec(blah.get())) {
                matches.push({ ...temp, line });
                if (options.first === true) {
                    break;
                }
            }
            line++;
        }
    }
    else {
        let blah = input.get();
        if (sectionOffset) {
            blah = blah.substr(sectionOffset);
        }
        let temp;
        // eslint-disable-next-line no-cond-assign
        while (temp = s.exec(blah)) {
            matches.push(temp);
            if (options.first === true) {
                break;
            }
        }
    }
    if (options.submatches) {
        for (let index = 0; index < options.submatches.length; index++) {
            // @ts-ignore
            if (matches[0] && matches[0][index + 1]) {
                // @ts-ignore
                options.submatches[index].set(matches[0][index + 1]);
            }
            else if (matches.length > 0) {
                options.submatches[index].clear();
            }
        }
    }
    if (options.results) {
        // assumption, results is a table with the correct type
        options.results.clear();
        for (const m of matches) {
            const match = new types_1.Structure({
                line: new types_1.Integer(),
                offset: new types_1.Integer(),
                length: new types_1.Integer(),
                submatches: types_1.TableFactory.construct(new types_1.Structure({ offset: new types_1.Integer(), length: new types_1.Integer() })),
            });
            match.get().line.set(m.line || 0);
            match.get().offset.set(m.index);
            match.get().length.set(m[0].length);
            const submatch = new types_1.Structure({ offset: new types_1.Integer(), length: new types_1.Integer() });
            for (let i = 1; i < m.length; i++) {
                // @ts-ignore
                if (m[i] === undefined) {
                    submatch.get().offset.set(-1);
                    submatch.get().length.set(0);
                }
                else {
                    // @ts-ignore
                    submatch.get().offset.set(m.index + m[0].indexOf(m[i]));
                    // @ts-ignore
                    submatch.get().length.set(m[i].length);
                }
                match.get().submatches.append(submatch);
            }
            if (options.results instanceof types_1.Table) {
                options.results.append(match);
            }
            else {
                options.results.set(match);
            }
            if (options.first === undefined || options.first === true) {
                break;
            }
        }
    }
    if (matches.length === 0) {
        // @ts-ignore
        abap.builtin.sy.get().subrc.set(4);
    }
    else {
        // @ts-ignore
        abap.builtin.sy.get().subrc.set(0);
    }
    if (matches[0]?.index !== undefined) {
        let val = matches[0].index;
        if (sectionOffset) {
            val += sectionOffset;
        }
        if (options.byteMode) {
            val = val / 2;
        }
        options.offset?.set(val);
    }
    if (options?.count) {
        options.count?.set(matches.length);
    }
    else {
        options.count?.clear();
    }
    if (options?.length && matches && matches[0]) {
        options.length?.set(matches[0][0].length);
    }
    else {
        options.length?.clear();
    }
}
exports.find = find;
//# sourceMappingURL=find.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/get_bit.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/get_bit.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getBit = void 0;
/* eslint-disable no-bitwise */
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function getBit(number, hex, output) {
    const byteIndex = Math.floor((number.get() - 1) / 8);
    const bitIndex = (number.get() - 1) % 8;
    if (hex instanceof types_1.HexUInt8) {
        let int = hex.getOffsetRaw(byteIndex);
        int >>= (8 - bitIndex - 1);
        int &= 1;
        // @ts-ignore
        output.set(int);
    }
    else {
        if (bitIndex < 0) {
            throw new Error("BIT_OFFSET_NOT_POSITIVE");
        }
        const h = hex.get().substr(byteIndex * 2, 2);
        const parsed = parseInt(h, 16).toString(2);
        const bits = parsed.padStart(8, "0");
        output.set(bits.substr(bitIndex, 1));
    }
}
exports.getBit = getBit;
//# sourceMappingURL=get_bit.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/get_locale.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/get_locale.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getLocale = void 0;
function getLocale(target) {
    // todo
    target.set("E");
}
exports.getLocale = getLocale;
//# sourceMappingURL=get_locale.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/get_parameter.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/get_parameter.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getParameter = void 0;
function getParameter(_source, _target) {
    // todo, additional logic? call ABAP kernel class?
    // @ts-ignore
    abap.builtin.sy.get().subrc.set(4);
}
exports.getParameter = getParameter;
//# sourceMappingURL=get_parameter.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/get_run_time.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/get_run_time.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getRunTime = void 0;
let prev = undefined;
function getRunTime(value) {
    if (prev === undefined) {
        value.set(0);
        prev = new Date().getTime();
    }
    else {
        const now = new Date().getTime();
        value.set(now - prev);
        prev = now;
    }
}
exports.getRunTime = getRunTime;
//# sourceMappingURL=get_run_time.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/get_time.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/get_time.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getTime = void 0;
function getTime(options) {
    const d = new Date();
    const date = d.getUTCFullYear() +
        (d.getUTCMonth() + 1 + "").padStart(2, "0") +
        (d.getUTCDate() + "").padStart(2, "0");
    const time = (d.getUTCHours() + "").padStart(2, "0") +
        (d.getUTCMinutes() + "").padStart(2, "0") +
        (d.getUTCSeconds() + "").padStart(2, "0");
    if (options === undefined) {
        options = {};
    }
    if (options?.sy === undefined) {
        // @ts-ignore
        options.sy = abap.builtin.sy;
    }
    options.sy.get().datlo.set(date);
    options.sy.get().datum.set(date);
    options.sy.get().timlo.set(time);
    options.sy.get().uzeit.set(time);
    if (options?.field) {
        options.field.set(time);
    }
    if (options?.stamp) {
        options.stamp.set(date + time);
    }
}
exports.getTime = getTime;
//# sourceMappingURL=get_time.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Statements = void 0;
const append_1 = __webpack_require__(/*! ./append */ "./node_modules/@abaplint/runtime/build/src/statements/append.js");
const assert_1 = __webpack_require__(/*! ./assert */ "./node_modules/@abaplint/runtime/build/src/statements/assert.js");
const assign_1 = __webpack_require__(/*! ./assign */ "./node_modules/@abaplint/runtime/build/src/statements/assign.js");
const clear_1 = __webpack_require__(/*! ./clear */ "./node_modules/@abaplint/runtime/build/src/statements/clear.js");
const commit_1 = __webpack_require__(/*! ./commit */ "./node_modules/@abaplint/runtime/build/src/statements/commit.js");
const concatenate_1 = __webpack_require__(/*! ./concatenate */ "./node_modules/@abaplint/runtime/build/src/statements/concatenate.js");
const condense_1 = __webpack_require__(/*! ./condense */ "./node_modules/@abaplint/runtime/build/src/statements/condense.js");
const convert_1 = __webpack_require__(/*! ./convert */ "./node_modules/@abaplint/runtime/build/src/statements/convert.js");
const create_data_1 = __webpack_require__(/*! ./create_data */ "./node_modules/@abaplint/runtime/build/src/statements/create_data.js");
const delete_internal_1 = __webpack_require__(/*! ./delete_internal */ "./node_modules/@abaplint/runtime/build/src/statements/delete_internal.js");
const describe_1 = __webpack_require__(/*! ./describe */ "./node_modules/@abaplint/runtime/build/src/statements/describe.js");
const find_1 = __webpack_require__(/*! ./find */ "./node_modules/@abaplint/runtime/build/src/statements/find.js");
const collect_1 = __webpack_require__(/*! ./collect */ "./node_modules/@abaplint/runtime/build/src/statements/collect.js");
const overlay_1 = __webpack_require__(/*! ./overlay */ "./node_modules/@abaplint/runtime/build/src/statements/overlay.js");
const cast_1 = __webpack_require__(/*! ./cast */ "./node_modules/@abaplint/runtime/build/src/statements/cast.js");
const get_bit_1 = __webpack_require__(/*! ./get_bit */ "./node_modules/@abaplint/runtime/build/src/statements/get_bit.js");
const read_report_1 = __webpack_require__(/*! ./read_report */ "./node_modules/@abaplint/runtime/build/src/statements/read_report.js");
const raise_event_1 = __webpack_require__(/*! ./raise_event */ "./node_modules/@abaplint/runtime/build/src/statements/raise_event.js");
const receive_1 = __webpack_require__(/*! ./receive */ "./node_modules/@abaplint/runtime/build/src/statements/receive.js");
const get_locale_1 = __webpack_require__(/*! ./get_locale */ "./node_modules/@abaplint/runtime/build/src/statements/get_locale.js");
const unpack_1 = __webpack_require__(/*! ./unpack */ "./node_modules/@abaplint/runtime/build/src/statements/unpack.js");
const get_parameter_1 = __webpack_require__(/*! ./get_parameter */ "./node_modules/@abaplint/runtime/build/src/statements/get_parameter.js");
const set_locale_1 = __webpack_require__(/*! ./set_locale */ "./node_modules/@abaplint/runtime/build/src/statements/set_locale.js");
const get_run_time_1 = __webpack_require__(/*! ./get_run_time */ "./node_modules/@abaplint/runtime/build/src/statements/get_run_time.js");
const get_time_1 = __webpack_require__(/*! ./get_time */ "./node_modules/@abaplint/runtime/build/src/statements/get_time.js");
const insert_database_1 = __webpack_require__(/*! ./insert_database */ "./node_modules/@abaplint/runtime/build/src/statements/insert_database.js");
const insert_internal_1 = __webpack_require__(/*! ./insert_internal */ "./node_modules/@abaplint/runtime/build/src/statements/insert_internal.js");
const delete_database_1 = __webpack_require__(/*! ./delete_database */ "./node_modules/@abaplint/runtime/build/src/statements/delete_database.js");
const loop_1 = __webpack_require__(/*! ./loop */ "./node_modules/@abaplint/runtime/build/src/statements/loop.js");
const message_1 = __webpack_require__(/*! ./message */ "./node_modules/@abaplint/runtime/build/src/statements/message.js");
const modify_database_1 = __webpack_require__(/*! ./modify_database */ "./node_modules/@abaplint/runtime/build/src/statements/modify_database.js");
const modify_internal_1 = __webpack_require__(/*! ./modify_internal */ "./node_modules/@abaplint/runtime/build/src/statements/modify_internal.js");
const move_corresponding_1 = __webpack_require__(/*! ./move_corresponding */ "./node_modules/@abaplint/runtime/build/src/statements/move_corresponding.js");
const read_table_1 = __webpack_require__(/*! ./read_table */ "./node_modules/@abaplint/runtime/build/src/statements/read_table.js");
const replace_1 = __webpack_require__(/*! ./replace */ "./node_modules/@abaplint/runtime/build/src/statements/replace.js");
const rollback_1 = __webpack_require__(/*! ./rollback */ "./node_modules/@abaplint/runtime/build/src/statements/rollback.js");
const select_1 = __webpack_require__(/*! ./select */ "./node_modules/@abaplint/runtime/build/src/statements/select.js");
const set_bit_1 = __webpack_require__(/*! ./set_bit */ "./node_modules/@abaplint/runtime/build/src/statements/set_bit.js");
const shift_1 = __webpack_require__(/*! ./shift */ "./node_modules/@abaplint/runtime/build/src/statements/shift.js");
const sort_1 = __webpack_require__(/*! ./sort */ "./node_modules/@abaplint/runtime/build/src/statements/sort.js");
const wait_1 = __webpack_require__(/*! ./wait */ "./node_modules/@abaplint/runtime/build/src/statements/wait.js");
const fetch_next_cursor_1 = __webpack_require__(/*! ./fetch_next_cursor */ "./node_modules/@abaplint/runtime/build/src/statements/fetch_next_cursor.js");
const open_cursor_1 = __webpack_require__(/*! ./open_cursor */ "./node_modules/@abaplint/runtime/build/src/statements/open_cursor.js");
const close_cursor_1 = __webpack_require__(/*! ./close_cursor */ "./node_modules/@abaplint/runtime/build/src/statements/close_cursor.js");
const set_handler_1 = __webpack_require__(/*! ./set_handler */ "./node_modules/@abaplint/runtime/build/src/statements/set_handler.js");
const split_1 = __webpack_require__(/*! ./split */ "./node_modules/@abaplint/runtime/build/src/statements/split.js");
const translate_1 = __webpack_require__(/*! ./translate */ "./node_modules/@abaplint/runtime/build/src/statements/translate.js");
const call_transaction_1 = __webpack_require__(/*! ./call_transaction */ "./node_modules/@abaplint/runtime/build/src/statements/call_transaction.js");
const update_database_1 = __webpack_require__(/*! ./update_database */ "./node_modules/@abaplint/runtime/build/src/statements/update_database.js");
const write_1 = __webpack_require__(/*! ./write */ "./node_modules/@abaplint/runtime/build/src/statements/write.js");
const call_function_1 = __webpack_require__(/*! ./call_function */ "./node_modules/@abaplint/runtime/build/src/statements/call_function.js");
const types_1 = __webpack_require__(/*! util/types */ "?2460");
// this is a class, as statements like SELECT needs access to the database object instance
// and WRITE will access the Console
class Statements {
    constructor(context) {
        this.append = append_1.append;
        this.assert = assert_1.assert;
        this.assign = assign_1.assign;
        this.cast = cast_1.cast;
        this.clear = clear_1.clear;
        this.collect = collect_1.collect;
        this.commit = commit_1.commit;
        this.concatenate = concatenate_1.concatenate;
        this.condense = condense_1.condense;
        this.convert = convert_1.convert;
        this.createData = create_data_1.createData;
        this.deleteInternal = delete_internal_1.deleteInternal;
        this.describe = describe_1.describe;
        this.find = find_1.find;
        this.unpack = unpack_1.unpack;
        this.getBit = get_bit_1.getBit;
        this.readReport = read_report_1.readReport;
        this.getLocale = get_locale_1.getLocale;
        this.getParameter = get_parameter_1.getParameter;
        this.getRunTime = get_run_time_1.getRunTime;
        this.getTime = get_time_1.getTime;
        this.insertInternal = insert_internal_1.insertInternal;
        this.loop = loop_1.loop;
        this.modifyInternal = modify_internal_1.modifyInternal;
        this.moveCorresponding = move_corresponding_1.moveCorresponding;
        this.overlay = overlay_1.overlay;
        this.raiseEvent = raise_event_1.raiseEvent;
        this.readTable = read_table_1.readTable;
        this.replace = replace_1.replace;
        this.rollback = rollback_1.rollback;
        this.setBit = set_bit_1.setBit;
        this.setHandler = set_handler_1.setHandler;
        this.setLocale = set_locale_1.setLocale;
        this.shift = shift_1.shift;
        this.sort = sort_1.sort;
        this.split = split_1.split;
        this.translate = translate_1.translate;
        this.wait = wait_1.wait;
        this.receive = receive_1.receive;
        this.callTransaction = call_transaction_1.callTransaction;
        this.context = context;
        this.traceTotals = {};
    }
    _trace(func, name, min, totals) {
        const tt = this.traceTotals;
        const exec = (...options) => {
            const start = Date.now();
            const result = func.bind(this)(...options);
            const runtime = Date.now() - start;
            if (totals === true) {
                if (tt[name] === undefined) {
                    tt[name] = 0;
                }
                tt[name] += runtime;
            }
            if (runtime >= min) {
                console.log(`STATEMENT: ${name}, ${runtime} ms`);
                if (totals === true) {
                    console.log(JSON.stringify(tt));
                }
            }
            return result;
        };
        return exec;
    }
    _traceAsync(func, name, min, totals) {
        const tt = this.traceTotals;
        const exec = async (...options) => {
            const start = Date.now();
            const result = await func.bind(this)(...options);
            const runtime = Date.now() - start;
            if (totals === true) {
                if (tt[name] === undefined) {
                    tt[name] = 0;
                }
                tt[name] += runtime;
            }
            if (runtime >= min) {
                console.log(`STATEMENT: ${name}, ${runtime} ms`);
                if (totals === true) {
                    console.log(JSON.stringify(tt));
                }
            }
            return result;
        };
        return exec;
    }
    _setTrace(min = 10, totals = false) {
        const candidates = [...Object.keys(this), ...Object.getOwnPropertyNames(Statements.prototype)];
        for (const c of candidates) {
            if (c === "context" || c === "constructor" || c.startsWith("_") || c === "loop") {
                continue;
            }
            const func = this[c];
            if ((0, types_1.isAsyncFunction)(func)) {
                this[c] = this._traceAsync(func, c, min, totals);
            }
            else {
                this[c] = this._trace(func, c, min, totals);
            }
        }
    }
    async openCursor(target, select, options) {
        const num = await (0, open_cursor_1.openCursor)(this.context, select, options);
        target.set(num);
    }
    async fetchNextCursor(cursor, target, packageSize) {
        await (0, fetch_next_cursor_1.fetchNextCursor)(this.context, cursor.get(), target, packageSize?.get() || 0);
    }
    async closeCursor(cursor) {
        await (0, close_cursor_1.closeCursor)(this.context, cursor.get());
    }
    async deleteDatabase(table, options) {
        await (0, delete_database_1.deleteDatabase)(table, options, this.context);
    }
    async insertDatabase(table, options) {
        return (0, insert_database_1.insertDatabase)(table, options, this.context);
    }
    async modifyDatabase(table, options) {
        return (0, modify_database_1.modifyDatabase)(table, options, this.context);
    }
    async select(target, select, runtimeOptions) {
        return (0, select_1.select)(target, select, runtimeOptions || {}, this.context);
    }
    async updateDatabase(table, options) {
        return (0, update_database_1.updateDatabase)(table, options, this.context);
    }
    async callFunction(options) {
        return new call_function_1.CallFunction(this.context).callFunction(options);
    }
    async message(options) {
        return new message_1.MessageStatement(this.context).message(options);
    }
    write(source, options) {
        return new write_1.WriteStatement(this.context).write(source, options);
    }
}
exports.Statements = Statements;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/insert_database.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/insert_database.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.insertDatabase = exports.toValue = void 0;
const prefix_1 = __webpack_require__(/*! ../prefix */ "./node_modules/@abaplint/runtime/build/src/prefix.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function toValue(value) {
    if (typeof value === "string") {
        // postgres requires ' for values
        return "'" + value.replace(/'/g, "''") + "'";
        //    return '"' + value.replace(/"/g, "\"\"") + '"';
    }
    else {
        return value;
    }
}
exports.toValue = toValue;
async function insertDatabase(table, options, context) {
    const columns = [];
    const values = [];
    if (options.values === undefined && options.table === undefined) {
        throw "insertDatabase, wrong input";
    }
    if (options.table !== undefined) {
        let subrc = 0;
        let dbcnt = 0;
        for (const row of options.table.array()) {
            await insertDatabase(table, { values: row, connection: options.connection }, context);
            // @ts-ignore
            subrc = Math.max(subrc, abap.builtin.sy.get().subrc.get());
            // @ts-ignore
            dbcnt += abap.builtin.sy.get().dbcnt.get();
        }
        // @ts-ignore
        abap.builtin.sy.get().subrc.set(subrc);
        // @ts-ignore
        abap.builtin.sy.get().dbcnt.set(dbcnt);
        return;
    }
    const structure = options.values.get();
    for (const k of Object.keys(structure)) {
        const field = structure[k];
        if (field instanceof types_1.Structure) {
            // then its a group, ignore
            continue;
        }
        columns.push(k);
        values.push(toValue(field.get()));
    }
    if (typeof table !== "string") {
        table = table.get().trimEnd().toLowerCase();
    }
    let db = context.defaultDB();
    if (options.connection) {
        db = context.databaseConnections[options.connection];
    }
    const { subrc, dbcnt } = await db.insert({
        table: (0, prefix_1.buildDbTableName)(table),
        columns,
        values,
    });
    // @ts-ignore
    abap.builtin.sy.get().subrc.set(subrc);
    // @ts-ignore
    abap.builtin.sy.get().dbcnt.set(dbcnt);
    return subrc;
}
exports.insertDatabase = insertDatabase;
//# sourceMappingURL=insert_database.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/insert_internal.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/insert_internal.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.insertInternal = void 0;
const clone_1 = __webpack_require__(/*! ../clone */ "./node_modules/@abaplint/runtime/build/src/clone.js");
const compare_1 = __webpack_require__(/*! ../compare */ "./node_modules/@abaplint/runtime/build/src/compare/index.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const read_table_1 = __webpack_require__(/*! ./read_table */ "./node_modules/@abaplint/runtime/build/src/statements/read_table.js");
const sort_1 = __webpack_require__(/*! ./sort */ "./node_modules/@abaplint/runtime/build/src/statements/sort.js");
function insertInternal(options) {
    if (options.table instanceof types_1.FieldSymbol) {
        if (options.table.getPointer() === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        options.table = options.table.getPointer();
    }
    else if (options.data instanceof types_1.FieldSymbol) {
        if (options.data.getPointer() === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        options.data = options.data.getPointer();
    }
    const tableOptions = options.table.getOptions();
    let isSorted = tableOptions?.primaryKey?.type === types_1.TableAccessType.sorted
        || tableOptions?.primaryKey?.type === types_1.TableAccessType.hashed;
    if (options.table instanceof types_1.HashedTable) {
        isSorted = false;
    }
    else if (isSorted) {
        const insert = options.data instanceof types_1.Structure ? options.data.get() : { table_line: options.data };
        let compare = (row) => {
            for (const key of tableOptions?.primaryKey?.keyFields || []) {
                if (key.includes("-")) {
                    const [first, second] = key.split("-");
                    if ((0, compare_1.ne)(row[first.toLowerCase()].get()[second.toLowerCase()], insert[first.toLowerCase()].get()[second.toLowerCase()])) {
                        return false;
                    }
                }
                else {
                    if ((0, compare_1.ne)(row[key.toLowerCase()], insert[key.toLowerCase()])) {
                        return false;
                    }
                }
            }
            return true;
        };
        if (tableOptions.primaryKey?.isUnique === true) {
            const withKeyValue = [];
            let binary = false;
            const data = options?.data;
            if (data instanceof types_1.Structure) {
                const fieldName = tableOptions.primaryKey.keyFields[0].toLowerCase();
                if (fieldName !== "table_line" && fieldName.includes("-") === false) {
                    withKeyValue.push({ key: (i) => { return i[fieldName]; }, value: data.get()[fieldName] });
                    binary = true;
                }
            }
            else {
                compare = (row) => {
                    // @ts-ignore
                    return (0, compare_1.eq)(row.table_line, options.data);
                };
            }
            (0, read_table_1.readTable)(options.table, { withKey: compare, withKeyValue: withKeyValue, binarySearch: binary });
            // @ts-ignore
            if (abap.builtin.sy.get().subrc.get() === 0) {
                // @ts-ignore
                abap.builtin.sy.get().subrc.set(4);
                return;
            }
        }
    }
    let data = options.data;
    if (typeof data === "string") {
        const tmp = (0, clone_1.clone)(options.table.getRowType());
        tmp.set(data);
        data = tmp;
    }
    if (data && options.index) {
        const index = options.index.get() - 1;
        const val = options.table.insertIndex(data, index);
        if (options.assigning) {
            options.assigning.assign(val);
        }
    }
    else if (options.lines
        && (options.data instanceof types_1.Table
            || options.data instanceof types_1.HashedTable)) {
        if (options.table instanceof types_1.HashedTable) {
            for (const source of options.data.array()) {
                const result = options.table.insert(source);
                if (result.subrc !== 0) {
                    throw new Error("ITAB_DUPLICATE_KEY");
                }
            }
        }
        else {
            for (const i of options.data.array()) {
                options.table.append(i);
            }
        }
    }
    else if (options.initial === true) {
        let index = options.table.getArrayLength();
        if (options.index) {
            index = options.index.get() - 1;
        }
        const val = options.table.insertIndex(options.table.getRowType(), index);
        if (options.assigning) {
            options.assigning.assign(val);
        }
        if (options.referenceInto) {
            options.referenceInto.assign(val);
        }
    }
    else if (options.table instanceof types_1.HashedTable && data) {
        const { value: val, subrc: subrc } = options.table.insert(data);
        if (options.assigning) {
            options.assigning.assign(val);
        }
        if (options.referenceInto) {
            options.referenceInto.assign(val);
        }
        // @ts-ignore
        abap.builtin.sy.get().subrc.set(subrc);
        return;
    }
    else if (data) {
        // todo, for now it just appends, this is not correct, but currently the table type is not known
        const val = options.table.insertIndex(data, options.table.getArrayLength(), options.noClone);
        if (options.assigning) {
            options.assigning.assign(val);
        }
        if (options.referenceInto) {
            options.referenceInto.assign(val);
        }
    }
    // @ts-ignore
    abap.builtin.sy.get().subrc.set(0);
    if (isSorted && !(options.table instanceof types_1.HashedTable)) {
        // slow, but works for now
        let by = tableOptions?.primaryKey?.keyFields?.map(f => {
            return { component: f.toLowerCase() };
        });
        if (by?.length === 1 && by[0].component === "table_line") {
            by = [];
        }
        if (by && by.length > 0) {
            (0, sort_1.sort)(options.table, { by: by, skipSortedCheck: true });
        }
        else {
            (0, sort_1.sort)(options.table, { skipSortedCheck: true });
        }
    }
}
exports.insertInternal = insertInternal;
//# sourceMappingURL=insert_internal.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/loop.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/loop.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loop = void 0;
const binary_search_1 = __webpack_require__(/*! ../binary_search */ "./node_modules/@abaplint/runtime/build/src/binary_search.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function determineFromTo(array, topEquals, key) {
    if (topEquals === undefined) {
        // if there is no WHERE supplied, its using the sorting of the secondary key
        return { from: 1, to: array.length };
    }
    let from = 0;
    let to = array.length;
    // todo: multi field
    const keyField = key.keyFields[0].toLowerCase();
    const keyValue = topEquals[keyField];
    if (keyField && keyValue) {
        from = (0, binary_search_1.binarySearchFrom)(array, from, to, keyField, keyValue);
        to = (0, binary_search_1.binarySearchTo)(array, from, to, keyField, keyValue);
        //    console.dir("from: " + from + ", to: " + to);
    }
    return {
        from: from,
        to: to,
    };
}
async function* loop(table, options) {
    if (table === undefined) {
        throw new Error("LOOP at undefined");
    }
    else if (table instanceof types_1.FieldSymbol) {
        const pnt = table.getPointer();
        if (pnt === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        yield* loop(pnt, options);
        return;
    }
    const length = table.getArrayLength();
    if (length === 0) {
        // @ts-ignore
        abap.builtin.sy.get().subrc.set(4);
        return;
    }
    let loopFrom = options?.from && options?.from.get() > 0 ? options.from.get() - 1 : 0;
    let loopTo = options?.to && options.to.get() < length ? options.to.get() : length;
    let array = [];
    if (options?.usingKey && options.usingKey !== undefined && options.usingKey !== "primary_key") {
        array = table.getSecondaryIndex(options.usingKey);
        const { from, to } = determineFromTo(array, options.topEquals, table.getKeyByName(options.usingKey));
        loopFrom = Math.max(loopFrom, from) - 1;
        loopTo = Math.min(loopTo, to);
    }
    else {
        array = table.array();
    }
    const loopController = table.startLoop(loopFrom, loopTo, array);
    let entered = false;
    try {
        const isStructured = array[0] instanceof types_1.Structure;
        while (loopController.index < loopController.loopTo) {
            if (loopController.index > array.length) {
                break;
            }
            const current = array[loopController.index];
            if (options?.where) {
                const row = isStructured ? current.get() : { table_line: current };
                if (await options.where(row) === false) {
                    loopController.index++;
                    continue;
                }
            }
            // @ts-ignore
            abap.builtin.sy.get().tabix.set(loopController.index + 1);
            entered = true;
            yield current;
            loopController.index++;
            if (options?.to === undefined && options?.usingKey === undefined) {
                // extra rows might have been inserted inside the loop
                loopController.loopTo = array.length;
            }
        }
    }
    finally {
        table.unregisterLoop(loopController);
        // @ts-ignore
        abap.builtin.sy.get().subrc.set(entered ? 0 : 4);
    }
}
exports.loop = loop;
//# sourceMappingURL=loop.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/message.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/message.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageStatement = void 0;
function replace(text, w) {
    for (let i = 0; i < 6; i++) {
        const search = "&" + (i + 1);
        let replace = "";
        if (w && w[i]) {
            const j = w[i];
            if (typeof j === "string") {
                replace = j;
            }
            else {
                // todo: some formatting missing here,
                replace = (j.get() + "").trimEnd();
            }
        }
        const field = "msgv" + (i + 1);
        if (i <= 3) {
            // @ts-ignore
            abap.builtin.sy.get()[field].set(replace);
        }
        text = text.replace(search, replace);
    }
    return text.trim();
}
async function findText(context, arbgb, msgnr, msgty) {
    let text = undefined;
    if (arbgb && msgnr) {
        try {
            // todo, sql injection?
            const select = `SELECT * FROM t100 WHERE sprsl='E' AND arbgb='${arbgb}' AND msgnr='${msgnr}' LIMIT 1`;
            const { rows: result } = await context.defaultDB().select({ select });
            if (result[0]) {
                text = result[0]["text"];
            }
        }
        catch {
            // use fallback text
        }
    }
    if (text === undefined) {
        // @ts-ignore
        text = abap.MSAG[arbgb?.trimEnd().toUpperCase()]?.[msgnr];
    }
    if (text === undefined) {
        // fallback
        text = msgty + ":" + arbgb?.trim() + ":" + msgnr + " &1 &2 &3 &4";
    }
    return text;
}
class MessageStatement {
    constructor(context) {
        this.context = context;
    }
    async message(options) {
        let arbgb = options.id;
        if (arbgb !== undefined && typeof arbgb !== "string") {
            arbgb = arbgb.get();
        }
        arbgb = arbgb?.toUpperCase();
        let msgty = options.type;
        if (msgty !== undefined && typeof msgty !== "string") {
            msgty = msgty.get();
        }
        msgty = msgty?.toUpperCase();
        // @ts-ignore
        abap.builtin.sy.get().msgid.set(arbgb || "");
        let msgnr = options.number;
        if (msgnr !== undefined && typeof msgnr !== "string") {
            msgnr = msgnr.get();
        }
        // @ts-ignore
        abap.builtin.sy.get().msgno.set(msgnr || "");
        // @ts-ignore
        abap.builtin.sy.get().msgty.set(msgty);
        let replaced = "";
        if (options.exception) {
            replaced = await options.exception.get().if_message$get_text();
        }
        else {
            const text = await findText(this.context, arbgb, msgnr, msgty);
            replaced = replace(text, options.with);
        }
        if (options.into) {
            options.into.set(replaced);
        }
        else {
            // hmm, add option on how/if to write messages to console? or it should be the abap.console() ?
            console.log(replaced);
        }
    }
}
exports.MessageStatement = MessageStatement;
//# sourceMappingURL=message.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/modify_database.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/modify_database.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.modifyDatabase = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const insert_database_1 = __webpack_require__(/*! ./insert_database */ "./node_modules/@abaplint/runtime/build/src/statements/insert_database.js");
const update_database_1 = __webpack_require__(/*! ./update_database */ "./node_modules/@abaplint/runtime/build/src/statements/update_database.js");
async function modifyDatabase(table, options, context) {
    if (options.table instanceof types_1.FieldSymbol) {
        options.table = options.table.getPointer();
    }
    if (options.values instanceof types_1.FieldSymbol) {
        options.values = options.values.getPointer();
    }
    if (options.table) {
        for (const row of options.table.array()) {
            const subrc = await (0, insert_database_1.insertDatabase)(table, { values: row }, context);
            if (subrc !== 0) {
                await (0, update_database_1.updateDatabase)(table, { from: row }, context);
            }
        }
    }
    else if (options.values) {
        const subrc = await (0, insert_database_1.insertDatabase)(table, { values: options.values }, context);
        if (subrc !== 0) {
            await (0, update_database_1.updateDatabase)(table, { from: options.values }, context);
        }
    }
    else {
        throw "modifyDatabase todo";
    }
}
exports.modifyDatabase = modifyDatabase;
//# sourceMappingURL=modify_database.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/modify_internal.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/modify_internal.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.modifyInternal = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const delete_internal_1 = __webpack_require__(/*! ./delete_internal */ "./node_modules/@abaplint/runtime/build/src/statements/delete_internal.js");
const insert_internal_1 = __webpack_require__(/*! ./insert_internal */ "./node_modules/@abaplint/runtime/build/src/statements/insert_internal.js");
const read_table_1 = __webpack_require__(/*! ./read_table */ "./node_modules/@abaplint/runtime/build/src/statements/read_table.js");
function modifyInternal(table, options) {
    let found = false;
    //  console.dir(options);
    if (options.index) {
        const index = options.index.get() - 1;
        const element = table.array()[index];
        found = element !== undefined;
        if (found) {
            element.set(options.from);
            /*
            table.deleteIndex(index);
            table.insertIndex(options.from, index);
            */
        }
    }
    else if (options.where && options.transporting && options.from) {
        let index = 1;
        const fs = new types_1.FieldSymbol();
        while (index <= table.array().length) {
            const currentIndex = new types_1.Integer().set(index);
            const readResult = (0, read_table_1.readTable)(table, {
                withKey: options.where,
                assigning: fs,
                index: currentIndex
            });
            if (readResult.subrc === 0) {
                found = true;
                for (const t of options.transporting) {
                    fs.get()[t].set(options.from.get()[t]);
                }
            }
            index++;
        }
    }
    else if (options.from) {
        const readResult = (0, read_table_1.readTable)(table, { from: options.from });
        if (readResult.subrc === 0) {
            (0, delete_internal_1.deleteInternal)(table, { index: new types_1.Integer().set(readResult.foundIndex) });
        }
        (0, insert_internal_1.insertInternal)({ table, data: options.from });
    }
    const subrc = found ? 0 : 4;
    // @ts-ignore
    abap.builtin.sy.get().subrc.set(subrc);
}
exports.modifyInternal = modifyInternal;
//# sourceMappingURL=modify_internal.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/move_corresponding.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/move_corresponding.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.moveCorresponding = void 0;
function moveCorresponding(source, target) {
    for (const n in source.get()) {
        target.get()[n]?.set(source.get()[n]);
    }
}
exports.moveCorresponding = moveCorresponding;
//# sourceMappingURL=move_corresponding.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/open_cursor.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/open_cursor.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.openCursor = void 0;
async function openCursor(context, select, options) {
    let db = context.defaultDB();
    if (options?.connection) {
        db = context.databaseConnections[options.connection];
    }
    const callbacks = await db.openCursor({ select: select });
    const num = context.cursorCounter++;
    context.cursors[num] = callbacks;
    return num;
}
exports.openCursor = openCursor;
//# sourceMappingURL=open_cursor.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/overlay.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/overlay.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.overlay = void 0;
const offset_length_1 = __webpack_require__(/*! ../offset_length */ "./node_modules/@abaplint/runtime/build/src/offset_length.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function overlay(value, withh, _only) {
    const set = value instanceof types_1.Structure ? value.getCharacter() : value.get();
    const w = withh.get();
    const len = set.length;
    for (let i = 0; i < len; i++) {
        if (set.substring(i, i + 1) === " ") {
            new offset_length_1.OffsetLength(value, { offset: i, length: 1 }).set(w.substring(i, i + 1));
        }
    }
}
exports.overlay = overlay;
//# sourceMappingURL=overlay.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/raise_event.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/raise_event.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.raiseEvent = void 0;
function raiseEvent() {
    // todo
    return;
}
exports.raiseEvent = raiseEvent;
//# sourceMappingURL=raise_event.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/read_report.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/read_report.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readReport = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function readReport(name, options) {
    if (options.into) {
        options.into.clear();
        options.into.append(new types_1.String().set("ReadReportTodo-" + name));
    }
    // TODO
    // @ts-ignore
    abap.builtin.sy.get().subrc.set(0);
}
exports.readReport = readReport;
//# sourceMappingURL=read_report.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/read_table.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/read_table.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readTable = void 0;
const binary_search_1 = __webpack_require__(/*! ../binary_search */ "./node_modules/@abaplint/runtime/build/src/binary_search.js");
const compare_1 = __webpack_require__(/*! ../compare */ "./node_modules/@abaplint/runtime/build/src/compare/index.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
/** startIndex = javascript index, return ABAP index */
function searchWithKeyEarlyExit(arr, withKey, startIndex = 0, usesTableLine, firstKeyName, firstValue) {
    const isStructured = arr[0] instanceof types_1.Structure;
    for (let index = startIndex; index < arr.length; index++) {
        const a = arr[index];
        let row = undefined;
        if (usesTableLine === false && isStructured === true) {
            row = a.get();
        }
        else {
            row = isStructured ? { table_line: a, ...a.get() } : { table_line: a };
        }
        if (withKey(row) === true) {
            return {
                found: a,
                foundIndex: index + 1,
            };
        }
        /*
        console.dir(row);
        console.dir(row[firstKeyName.toLowerCase()]);
        console.dir(firstValue);
        */
        if ((0, compare_1.gt)(row[firstKeyName.toLowerCase()], firstValue)) {
            return {
                found: undefined,
                foundIndex: 0,
            };
        }
    }
    return {
        found: undefined,
        foundIndex: 0,
    };
}
/** startIndex = javascript index, return ABAP index */
function searchWithKey(arr, withKey, startIndex = 0, usesTableLine) {
    const isStructured = arr[0] instanceof types_1.Structure;
    for (let index = startIndex; index < arr.length; index++) {
        const a = arr[index];
        let row = undefined;
        if (usesTableLine === false && isStructured === true) {
            row = a.get();
        }
        else {
            row = isStructured ? { table_line: a, ...a.get() } : { table_line: a };
        }
        if (withKey(row) === true) {
            return {
                found: a,
                foundIndex: index + 1,
            };
        }
    }
    return {
        found: undefined,
        foundIndex: 0,
    };
}
/////////////////
function readTable(table, options) {
    let found = undefined;
    let foundIndex = 0;
    let binarySubrc = undefined;
    //  console.dir(options);
    if (table instanceof types_1.FieldSymbol) {
        if (table.getPointer() === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        return readTable(table.getPointer(), options);
    }
    // check if it is a primary index read specified with WITH KEY instead of WITH TABLE KEY
    if (options?.withTableKey === undefined
        && options?.withKeySimple
        && (table.getOptions().primaryKey?.keyFields || []).length > 0) {
        if (table instanceof types_1.HashedTable) {
            // hashed tables requires all fields for fast lookup
            const fields = new Set(table.getOptions().primaryKey.keyFields);
            for (const name in options.withKeySimple) {
                fields.delete(name.toUpperCase());
            }
            if (fields.size === 0) {
                options.withTableKey = true;
            }
        }
        else {
            // while sorted just needs the first key field
            const firstKeyField = table.getOptions().primaryKey.keyFields[0];
            let useKey = false;
            for (const name in options.withKeySimple) {
                if (firstKeyField === name.toUpperCase()) {
                    useKey = true;
                }
            }
            if (useKey === true) {
                options.withTableKey = true;
            }
        }
    }
    if (options?.index) {
        if (table instanceof types_1.HashedTable) {
            throw new Error("Hashed table, READ INDEX not possible");
        }
        const arr = table.array();
        let index = options.index;
        if (typeof index !== "number") {
            if (index instanceof types_1.FieldSymbol) {
                if (index.getPointer() === undefined) {
                    throw new Error("GETWA_NOT_ASSIGNED");
                }
                index = index.getPointer();
            }
            if (index instanceof types_1.Float || index instanceof types_1.DecFloat34) {
                index = index.getRaw();
            }
            else if (index instanceof types_1.Integer8) {
                index = Number(index.get());
            }
            else {
                index = index.get();
            }
        }
        found = arr[index - 1];
        if (found) {
            foundIndex = index;
        }
    }
    else if (table instanceof types_1.HashedTable && options?.withTableKey === true && options.withKeySimple) {
        const hash = table.buildHashFromSimple(options.withKeySimple);
        found = table.read(hash);
        foundIndex = 0;
    }
    else if (table instanceof types_1.HashedTable && options?.withKey) {
        // this is slow..
        const searchResult = searchWithKey(table.array(), options.withKey, 0, options?.usesTableLine);
        found = searchResult.found;
        foundIndex = 0;
    }
    else if (options?.keyName && options.withKey && options.withKeySimple) {
        const arr = table.getSecondaryIndex(options.keyName);
        const keyInformation = table.getKeyByName(options.keyName);
        const firstKeyName = keyInformation?.keyFields[0];
        if (firstKeyName === undefined) {
            throw new Error("readTable, first key name not found");
        }
        //    console.dir("SEC:");
        const firstValue = options.withKeySimple[firstKeyName.toLowerCase()];
        if (firstValue === undefined) {
            // fallback
            return readTable(table, { ...options, withKeySimple: undefined });
        }
        const startIndex = (0, binary_search_1.binarySearchFrom)(arr, 0, arr.length, firstKeyName.toLowerCase(), firstValue) - 1;
        //    console.dir("startindex: " + startIndex);
        if (startIndex >= 0) {
            const searchResult = searchWithKeyEarlyExit(arr, options.withKey, startIndex, options.usesTableLine, firstKeyName, firstValue);
            //      console.dir(searchResult);
            found = searchResult.found;
            foundIndex = searchResult.foundIndex;
        }
    }
    else if ((options?.binarySearch === true || options?.withTableKey === true)
        && options.withKeyValue
        && (options?.binarySearch === true || table.getOptions().primaryKey?.type !== types_1.TableAccessType.standard)
        && options.withKey) {
        // note: it currently only uses the first key field for binary search, todo
        const first = options.withKeyValue[0];
        const arr = table.array();
        const startIndex = (0, binary_search_1.binarySearchFromRow)(arr, 0, arr.length - 1, first.key, first.value, options.usesTableLine);
        // todo: early exit if not found
        const searchResult = searchWithKey(arr, options.withKey, startIndex, options.usesTableLine);
        found = searchResult.found;
        foundIndex = searchResult.foundIndex;
        if (found === undefined) {
            if (arr.length === 0) {
                binarySubrc = 8;
                foundIndex = 1;
            }
            else {
                binarySubrc = 4;
                foundIndex = startIndex + 1;
                // check if going beyond the last row, todo: only checks one field
                const last = arr[arr.length - 1];
                const isStructured = last instanceof types_1.Structure;
                let row = undefined;
                if (options.usesTableLine === false && isStructured === true) {
                    row = last.get();
                }
                else {
                    row = isStructured ? { table_line: last, ...last.get() } : { table_line: last };
                }
                if ((0, compare_1.ge)(first.value, first.key(row))) {
                    binarySubrc = 8;
                }
            }
        }
    }
    else if (options?.withKey) {
        const arr = table.array();
        const searchResult = searchWithKey(arr, options.withKey, 0, options.usesTableLine);
        found = searchResult.found;
        foundIndex = searchResult.foundIndex;
    }
    else if (options?.from) {
        if (options.from instanceof types_1.FieldSymbol) {
            options.from = options.from.getPointer();
        }
        if (table instanceof types_1.Table && options.from instanceof types_1.Structure) {
            // todo: optimize if the primary key is sorted
            const arr = table.array();
            const keys = table.getOptions()?.primaryKey?.keyFields;
            const isStructured = arr[0] instanceof types_1.Structure;
            if (keys !== undefined && isStructured === true) {
                //        console.dir(keys);
                //        console.dir(options.from.get()[keys[0].toLowerCase()]);
                for (const a of arr) {
                    foundIndex++;
                    let matches = true;
                    for (const k of keys) {
                        if ((0, compare_1.eq)(a.get()[k.toLowerCase()], options.from.get()[k.toLowerCase()]) === false) {
                            matches = false;
                            break;
                        }
                    }
                    if (matches === true) {
                        found = a;
                        break;
                    }
                }
            }
        }
        else if (table instanceof types_1.HashedTable && options.from instanceof types_1.Structure) {
            const key = table.buildHashFromData(options.from);
            found = table.read(key);
        }
        if (found === undefined) {
            foundIndex = 0;
        }
        if (found === undefined && table.getOptions().primaryKey?.type === types_1.TableAccessType.sorted) {
            binarySubrc = 8;
        }
    }
    else {
        throw new Error("runtime, readTable, unexpected input");
    }
    let subrc = found ? 0 : 4;
    if (binarySubrc) {
        subrc = binarySubrc;
    }
    else if ((options?.binarySearch === true || options?.keyName !== undefined)
        && subrc === 4) {
        subrc = 8;
    }
    // @ts-ignore
    abap.builtin.sy.get().subrc.set(subrc);
    // @ts-ignore
    abap.builtin.sy.get().tabix.set(foundIndex);
    if (found) {
        if (options.into) {
            if (options.into instanceof types_1.DataReference) {
                if (found instanceof types_1.DataReference) {
                    options.into.assign(found.getPointer());
                }
                else {
                    options.into.assign(found);
                }
            }
            else {
                options.into.set(found);
            }
        }
        else if (options.referenceInto) {
            options.referenceInto.assign(found);
        }
        else if (options.assigning) {
            options.assigning.assign(found);
        }
    }
    return { subrc, foundIndex };
}
exports.readTable = readTable;
//# sourceMappingURL=read_table.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/receive.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/receive.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.receive = exports._receiveSetResult = void 0;
let cache = undefined;
function _receiveSetResult(options) {
    cache = options;
}
exports._receiveSetResult = _receiveSetResult;
function receive(options) {
    if (cache === undefined) {
        throw new Error("runtime receive(), no results");
    }
    for (const a in cache.importing || []) {
        const aval = cache.importing[a];
        const bval = options.importing[a];
        if (bval === undefined) {
            continue;
        }
        bval.set(aval);
    }
    for (const a in cache.tables || []) {
        const aval = cache.tables[a];
        const bval = options.tables[a];
        if (bval === undefined) {
            continue;
        }
        bval.set(aval);
    }
    for (const a in cache.changing || []) {
        const aval = cache.changing[a];
        const bval = options.changing[a];
        if (bval === undefined) {
            continue;
        }
        bval.set(aval);
    }
    cache = undefined;
}
exports.receive = receive;
//# sourceMappingURL=receive.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/replace.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/replace.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.replace = void 0;
const abap_regex_1 = __webpack_require__(/*! ../abap_regex */ "./node_modules/@abaplint/runtime/build/src/abap_regex.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const concatenate_1 = __webpack_require__(/*! ./concatenate */ "./node_modules/@abaplint/runtime/build/src/statements/concatenate.js");
function replace(input) {
    if (input.target instanceof types_1.Table) {
        for (const row of input.target.array()) {
            replace({ ...input, target: row });
        }
        return;
    }
    let temp = input.target.get();
    const ignoreCase = input.ignoringCase === true ? "i" : "";
    const allOccurrences = input.all === true ? "g" : "";
    let search = undefined;
    let found = false;
    if (input.of) {
        let inp = input.of.get();
        if (input.of instanceof types_1.Character) {
            inp = input.of.getTrimEnd();
        }
        if (inp.length === 0 && input.all === true) {
            throw "REPLACE, zero length input";
        }
        found = temp.indexOf(inp) >= 0;
        inp = abap_regex_1.ABAPRegExp.escapeRegExp(inp);
        search = new RegExp(inp, ignoreCase + allOccurrences);
    }
    else if (input.regex) {
        // TODO: this is a bit wrong, ABAP regex is not like JS regex
        const regex = abap_regex_1.ABAPRegExp.convert(input.regex.get());
        if (regex.length === 0 && input.all === true) {
            throw "REPLACE, zero length input";
        }
        search = new RegExp(regex, ignoreCase + allOccurrences);
        found = temp.match(search) !== null;
    }
    else if (input.pcre) {
        const regex = abap_regex_1.ABAPRegExp.convert(input.pcre.get());
        if (regex.length === 0 && input.all === true) {
            throw "REPLACE, zero length input";
        }
        search = new RegExp(regex, ignoreCase + allOccurrences);
        found = temp.match(search) !== null;
    }
    else if (input.sectionLength && input.sectionOffset) {
        const before = input.target.getOffset({ length: input.sectionOffset });
        const after = input.target.getOffset({ offset: input.sectionLength.get() + input.sectionOffset.get() });
        (0, concatenate_1.concatenate)({ source: [before, input.with, after], target: input.target });
        // @ts-ignore
        abap.builtin.sy.get().subrc.set(0);
        return;
    }
    else {
        throw "REPLACE, unexpected input";
    }
    let rr = "";
    if (typeof input.with === "string") {
        rr = input.with;
    }
    else {
        if (input.with instanceof types_1.Character) {
            rr = input.with.getTrimEnd();
        }
        else {
            rr = input.with.get();
        }
        rr = rr.replace(/\\\$/g, "$");
        rr = rr.replace(/\\\{/g, "{");
        rr = rr.replace(/\\\}/g, "}");
    }
    if (input.replacementLength) {
        const match = temp.match(search);
        let replacement = rr;
        for (let counter = 1; counter < 10; counter++) {
            const dollar = "$" + counter;
            if (replacement.includes(dollar) && match && match[counter] !== undefined) {
                replacement = replacement.replace(dollar, match[counter]);
            }
        }
        input.replacementLength.set(replacement.length);
    }
    temp = temp.replace(search, rr);
    const subrc = found ? 0 : 4;
    // @ts-ignore
    abap.builtin.sy.get().subrc.set(subrc);
    input.target.set(temp);
}
exports.replace = replace;
//# sourceMappingURL=replace.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/rollback.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/rollback.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rollback = void 0;
function rollback() {
    // todo
}
exports.rollback = rollback;
//# sourceMappingURL=rollback.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/select.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/select.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rowsToTarget = exports.select = void 0;
const clone_1 = __webpack_require__(/*! ../clone */ "./node_modules/@abaplint/runtime/build/src/clone.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
async function select(target, input, runtimeOptions, context) {
    const { rows: rows } = await context.defaultDB().select(input);
    if (target instanceof types_1.FieldSymbol) {
        if (target.isAssigned() === false) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        // @ts-ignore
        target = target.getPointer();
    }
    if (runtimeOptions?.appending !== true) {
        if (Array.isArray(target)) {
            target.forEach(f => f.clear());
        }
        else {
            target?.clear();
        }
    }
    if (rows.length === 0) {
        // @ts-ignore
        abap.builtin.sy.get().dbcnt.set(0);
        // @ts-ignore
        abap.builtin.sy.get().subrc.set(4);
        return;
    }
    rowsToTarget(target, rows);
    if (target === undefined && rows.length === 1) {
        // @ts-ignore
        abap.builtin.sy.get().dbcnt.set(Object.values(rows[0])[0]);
    }
    else {
        // @ts-ignore
        abap.builtin.sy.get().dbcnt.set(rows.length);
    }
    // @ts-ignore
    abap.builtin.sy.get().subrc.set(0);
}
exports.select = select;
function rowsToTarget(target, rows) {
    if (target instanceof types_1.Structure) {
        const result = {};
        for (const column in rows[0]) {
            if (rows[0][column] === null || target.get()[column] === undefined) {
                continue;
            }
            result[column] = (0, clone_1.clone)(target.get()[column]).set(rows[0][column]);
        }
        // @ts-ignore
        abap.statements.moveCorresponding(new types_1.Structure(result), target);
    }
    else if (target instanceof types_1.Table || target instanceof types_1.HashedTable) {
        for (const row of rows) {
            const targetRow = (0, clone_1.clone)(target.getRowType());
            if (targetRow instanceof types_1.Structure) {
                for (let columnName in row) {
                    columnName = columnName.toLowerCase();
                    if (row[columnName] === null) {
                        targetRow.get()[columnName]?.clear();
                        continue;
                    }
                    // @ts-ignore
                    targetRow.get()[columnName]?.set(row[columnName]);
                }
            }
            else {
                const columnName = Object.keys(row)[0];
                targetRow.set(row[columnName]);
            }
            // @ts-ignore
            abap.statements.insertInternal({ table: target, data: targetRow, noClone: true });
        }
    }
    else if (Array.isArray(target)) {
        for (let index = 0; index < target.length; index++) {
            const element = target[index];
            element.set(rows[0][Object.keys(rows[0])[index]]);
        }
    }
    else if (target !== undefined) {
        // its a simple type
        target.set(rows[0][Object.keys(rows[0])[0]]);
    }
}
exports.rowsToTarget = rowsToTarget;
//# sourceMappingURL=select.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/set_bit.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/set_bit.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setBit = void 0;
/* eslint-disable no-bitwise */
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function setBit(number, hex, val) {
    if (number.get() <= 0) {
        throw new Error("BIT_OFFSET_NOT_POSITIVE");
    }
    else if (hex instanceof types_1.HexUInt8) {
        const byteIndex = Math.floor((number.get() - 1) / 8);
        const bitIndex = (number.get() - 1) % 8;
        let bits = hex.getOffsetRaw(byteIndex);
        const bitMask = 1 << (8 - bitIndex - 1);
        if (val?.get() === 0 || val?.get() === "0") {
            bits &= ~bitMask;
        }
        else {
            bits |= bitMask;
        }
        hex.setOffset(byteIndex, bits);
    }
    else {
        const hexFull = hex.get();
        const fullByteLength = Math.ceil(hexFull.length / 2);
        const byteNum = Math.ceil(number.get() / 8);
        if (byteNum > fullByteLength) {
            return;
        }
        let pre = "";
        let byte = "";
        let post = "";
        if (hexFull.length > 2) {
            if (byteNum > 1) {
                pre = hexFull.substr(0, (byteNum - 1) * 2);
            }
            byte = hexFull.substr((byteNum - 1) * 2, 2);
            if (fullByteLength > byteNum) {
                post = hexFull.substr(byteNum * 2, (fullByteLength - byteNum) * 2);
            }
        }
        else {
            byte = hexFull;
        }
        let bits = parseInt(byte, 16);
        const bitMask = 1 << 8 - (number.get() - (byteNum - 1) * 8);
        if (val?.get() === 0 || val?.get() === "0") {
            bits &= ~bitMask;
        }
        else {
            bits |= bitMask;
        }
        const reconstructed = pre + bits.toString(16).toUpperCase().padStart(2, "0") + post;
        hex.set(reconstructed);
    }
}
exports.setBit = setBit;
//# sourceMappingURL=set_bit.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/set_handler.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/set_handler.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setHandler = void 0;
function setHandler(_methods, _f, _activation) {
    // todo
    return;
}
exports.setHandler = setHandler;
//# sourceMappingURL=set_handler.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/set_locale.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/set_locale.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setLocale = void 0;
function setLocale(_source) {
    // todo
}
exports.setLocale = setLocale;
//# sourceMappingURL=set_locale.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/shift.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/shift.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shift = void 0;
const compare_1 = __webpack_require__(/*! ../compare */ "./node_modules/@abaplint/runtime/build/src/compare/index.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function shift(target, options) {
    if (options?.mode === "BYTE") {
        shift_byte_mode(target, options);
    }
    else {
        shift_character_mode(target, options);
    }
}
exports.shift = shift;
function shift_character_mode(target, options) {
    let value = target.get();
    if (options?.deletingLeading) {
        let leading = options.deletingLeading;
        if (typeof leading !== "string") {
            leading = leading.get();
        }
        const split = leading.split("");
        while (split.some(s => value.substr(0, 1) === s)) {
            value = value.substr(1);
        }
    }
    else if (options?.deletingTrailing) {
        let trailing = options.deletingTrailing;
        if (typeof trailing !== "string") {
            trailing = trailing.get();
        }
        if ((0, compare_1.co)(value, " ") === false) {
            while (value.endsWith(trailing)) {
                value = " ".repeat(trailing.length) + value.substring(0, value.length - trailing.length);
            }
        }
    }
    else if (options?.places) {
        const p = options.places.get();
        if (options.circular) {
            value = value.substr(p) + value.substr(0, p);
        }
        else {
            if (options.direction === "RIGHT") {
                value = " ".repeat(options.places.get()) + value.substring(0, options.places.get());
            }
            else {
                value = value.substr(p);
            }
        }
    }
    else if (options?.to) {
        let to = "";
        if (typeof options.to === "string") {
            to = options.to;
        }
        else {
            to = options.to.get();
        }
        const index = value.search(to);
        if (index > 0) {
            value = value.substr(index);
        }
    }
    else if (options?.circular) {
        if (options.direction === "RIGHT") {
            value = value.substring(value.length - 1, value.length) + value.substring(0, value.length - 1);
        }
        else {
            value = value.substr(1) + value.substr(0, 1);
        }
    }
    else {
        value = value.substr(1);
    }
    if (target instanceof types_1.Numc) {
        target.set(value, true);
    }
    else {
        target.set(value);
    }
}
function shift_byte_mode(target, options) {
    let value = target.get();
    if (options?.deletingLeading) {
        let leading = options.deletingLeading;
        if (typeof leading !== "string") {
            leading = leading.get();
        }
        const split = leading.split("");
        while (split.some(s => value.substr(0, 2) === s)) {
            value = value.substr(2);
        }
    }
    else if (options?.places) {
        if (options.circular) {
            if (options.direction === "RIGHT") {
                for (let i = 0; i < options.places.get(); i++) {
                    value = value.substr(value.length - 2) + value.substr(0, value.length - 2);
                }
            }
            else {
                for (let i = 0; i < options.places.get(); i++) {
                    value = value.substr(2) + value.substr(0, 2);
                }
            }
        }
        else {
            const p = options.places.get() * 2;
            if (options.direction === "RIGHT") {
                value = "0".repeat(p) + value.substring(0, p);
            }
            else {
                value = value.substr(p);
            }
        }
    }
    else if (options?.to) {
        let to = "";
        if (typeof options.to === "string") {
            to = options.to;
        }
        else {
            to = options.to.get();
        }
        const index = value.search(to);
        if (index > 0) {
            value = value.substr(index);
        }
    }
    else if (options?.circular) {
        value = value.substr(2) + value.substr(0, 2);
    }
    else {
        value = value.substr(2);
    }
    target.set(value);
}
//# sourceMappingURL=shift.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/sort.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/sort.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sort = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const compare_1 = __webpack_require__(/*! ../compare */ "./node_modules/@abaplint/runtime/build/src/compare/index.js");
function compare(a, b, input) {
    const componentName = input.component;
    const descending = input.descending;
    let vala = undefined;
    let valb = undefined;
    if (componentName === "table_line") {
        vala = a.get();
        valb = b.get();
    }
    else if (componentName.includes("-")) {
        const sub = componentName.split("-");
        vala = a;
        valb = b;
        for (const s of sub) {
            vala = vala.get()[s];
            valb = valb.get()[s];
        }
    }
    else {
        vala = a.get()[componentName];
        valb = b.get()[componentName];
    }
    if (vala === undefined || valb === undefined) {
        throw new Error("sort compare, wrong component name, " + componentName);
    }
    if (descending && (0, compare_1.gt)(vala, valb)) {
        return -1;
    }
    else if (!descending && (0, compare_1.lt)(vala, valb)) {
        return -1;
    }
    else if ((0, compare_1.eq)(vala, valb)) {
        return 0;
    }
    else {
        return 1;
    }
}
function sort(input, options) {
    //  console.dir(input);
    if (input instanceof types_1.FieldSymbol) {
        const pnt = input.getPointer();
        if (pnt === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        sort(pnt, options);
        return;
    }
    else if (options?.skipSortedCheck !== true
        && input instanceof types_1.Table
        && input.getOptions()?.primaryKey?.type === types_1.TableAccessType.sorted) {
        throw new Error("SORT called on sorted table");
    }
    if (input instanceof types_1.HashedTable) {
        throw new Error("Sort hashed table, ugh?");
    }
    if (options?.by) {
        if (options.by.length === 0) {
            throw "SortByLengthZero";
        }
        input.sort((a, b) => {
            for (const c of options.by || []) {
                const res = compare(a, b, c);
                if (res !== 0) {
                    return res;
                }
            }
            return 0;
        });
    }
    else {
        const descending = options?.descending === true;
        input.sort((a, b) => {
            if ((0, compare_1.eq)(a, b)) {
                return 0;
            }
            else if (descending && (0, compare_1.gt)(a, b)) {
                return -1;
            }
            else if (!descending && (0, compare_1.lt)(a, b)) {
                return -1;
            }
            else {
                return 1;
            }
        });
    }
}
exports.sort = sort;
//# sourceMappingURL=sort.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/split.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/split.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.split = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function split(param) {
    let source = "";
    if (typeof param.source === "string") {
        source = param.source;
    }
    else if (param.source instanceof types_1.Character) {
        source = param.source.getTrimEnd();
    }
    else {
        source = param.source.get();
    }
    const at = typeof param.at === "string" ? param.at : param.at.get();
    const split = source.includes(at) ? source.split(at) : [];
    if (param.table) {
        if (source.endsWith(at)) {
            split.pop();
        }
        param.table.clear();
        for (const s of split) {
            param.table.append(new types_1.String().set(s));
        }
        if (source !== "" && split.length === 0) {
            param.table.append(new types_1.String().set(source));
        }
    }
    if (param.targets) {
        if (split.length === 0) {
            split.push(source);
        }
        for (const t of param.targets) {
            t.clear();
            if (split.length > 0) {
                t.set(split.shift().replace(/ +$/, ""));
            }
        }
        if (split.length > 0) {
            const concat = split.join(at);
            const last = param.targets[param.targets.length - 1];
            last.set(last.get() + at + concat);
        }
    }
}
exports.split = split;
//# sourceMappingURL=split.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/translate.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/translate.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.translate = void 0;
function translate(input, i) {
    let c = i;
    if (typeof c !== "string") {
        c = c.get();
    }
    if (c === "LOWER") {
        input.set(input.get().toLowerCase());
    }
    else if (c === "UPPER") {
        input.set(input.get().toUpperCase());
    }
    else {
        const chunks = c.match(/.{1,2}/g);
        const characters = input.get().split("");
        let result = "";
        for (let char of characters) {
            for (const chunk of chunks || []) {
                const search = chunk.substr(0, 1);
                const replace = chunk.substr(1, 1);
                if (char === search) {
                    char = replace;
                    break;
                }
            }
            result += char;
        }
        input.set(result);
    }
}
exports.translate = translate;
//# sourceMappingURL=translate.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/unpack.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/unpack.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unpack = void 0;
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
async function unpack(source, target) {
    if (source instanceof types_1.FieldSymbol) {
        const pointer = source.getPointer();
        if (pointer === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        return unpack(pointer, target);
    }
    if (target instanceof types_1.FieldSymbol) {
        const pointer = target.getPointer();
        if (pointer === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        return unpack(source, pointer);
    }
    if (source instanceof types_1.Character && target instanceof types_1.Character) {
        const sourceValue = source.getTrimEnd().trimStart();
        if (sourceValue.length > 0 && /^\d+$/.test(sourceValue) === false) {
            (0, throw_error_1.throwError)("CX_SY_CONVERSION_NO_NUMBER");
        }
        target.set(sourceValue.padStart(target.getLength(), "0"));
    }
    else {
        throw new Error("unpack, transpiler runtime todo, types");
    }
}
exports.unpack = unpack;
//# sourceMappingURL=unpack.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/update_database.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/update_database.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.updateDatabase = void 0;
const prefix_1 = __webpack_require__(/*! ../prefix */ "./node_modules/@abaplint/runtime/build/src/prefix.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const insert_database_1 = __webpack_require__(/*! ./insert_database */ "./node_modules/@abaplint/runtime/build/src/statements/insert_database.js");
async function updateDatabase(table, options, context) {
    if (options.table instanceof types_1.FieldSymbol) {
        options.table = options.table.getPointer();
    }
    if (options.from instanceof types_1.FieldSymbol) {
        options.from = options.from.getPointer();
    }
    if (typeof table !== "string") {
        table = table.get();
    }
    // @ts-ignore
    const keys = abap.DDIC[table.toUpperCase()].keyFields;
    const where = [];
    const set = [];
    if (options.from) {
        const structure = options.from.get();
        for (const k of Object.keys(structure)) {
            const str = k + " = " + (0, insert_database_1.toValue)(structure[k].get());
            if (keys.includes(k.toUpperCase())) {
                where.push(str);
            }
            else {
                set.push(str);
            }
        }
    }
    else if (options.set) {
        if (options.where) {
            where.push(options.where);
        }
        set.push(...options.set);
    }
    else {
        throw "updateDatabase, todo";
    }
    const { subrc, dbcnt } = await context.defaultDB().update({
        table: (0, prefix_1.buildDbTableName)(table),
        where: where.join(" AND "),
        set,
    });
    // @ts-ignore
    abap.builtin.sy.get().subrc.set(subrc);
    // @ts-ignore
    abap.builtin.sy.get().dbcnt.set(dbcnt);
    return subrc;
}
exports.updateDatabase = updateDatabase;
//# sourceMappingURL=update_database.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/wait.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/wait.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wait = void 0;
async function wait(options) {
    await new Promise(r => setTimeout(r, 50));
    while (true) {
        if (options.cond() === true) {
            break;
        }
        await new Promise(r => setTimeout(r, 500));
        console.log("WAIT waiting another round");
    }
}
exports.wait = wait;
//# sourceMappingURL=wait.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/statements/write.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/statements/write.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WriteStatement = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const NO_DEICMAL_CURRENCIES = ["HUF", "KRW", "JPY"];
class WriteStatement {
    constructor(context) {
        this.context = context;
    }
    write(source, options) {
        let right = false;
        if (options?.skipLine === true) {
            this.context.console.add("\n");
        }
        else {
            if (options?.newLine === true && this.context.console.isEmpty() === false) {
                this.context.console.add("\n");
            }
            let result = "";
            if (typeof source === "string" || typeof source === "number") {
                result = source.toString();
            }
            else if (source instanceof types_1.Structure) {
                const obj = source.getCharacter();
                this.write(obj, { ...options });
            }
            else if (source instanceof types_1.Float) {
                if (options?.exponent?.get() === 0) {
                    const tens = source.getRaw().toFixed(0).length - 1;
                    if (options.noSign === true && source.getRaw() < 0) {
                        result = source.getRaw().toFixed(17 - tens).replace(".", ",");
                        result = result.replace("-", "");
                    }
                    else {
                        result = source.getRaw().toFixed(16 - tens).replace(".", ",");
                    }
                }
                else {
                    result = source.get().toString();
                }
            }
            else if (source instanceof types_1.Packed) {
                let num = source.get();
                let decimals = source.getDecimals();
                if (NO_DEICMAL_CURRENCIES.includes(options?.currency?.get().trimEnd() || "")) {
                    // todo, more work needed here,
                    num = num * 100;
                    decimals = 0;
                }
                result = num.toFixed(decimals).replace(".", ",");
                right = true;
            }
            else {
                result = source.get().toString();
            }
            if (options?.noSign === true) {
                result = result.replace("-", "");
            }
            if (options?.target) {
                if (right === true) {
                    const len = options.target.get().length;
                    options.target.set(" ".repeat(len - result.length) + result);
                }
                else {
                    options.target.set(result);
                }
            }
            else {
                this.context.console.add(result);
            }
        }
    }
}
exports.WriteStatement = WriteStatement;
//# sourceMappingURL=write.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/template_formatting.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/template_formatting.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.templateFormatting = void 0;
const types_1 = __webpack_require__(/*! ./types */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
function templateFormatting(source, options) {
    let text = "";
    if (source instanceof types_1.FieldSymbol) {
        if (source.getPointer() === undefined) {
            throw new Error("GETWA_NOT_ASSIGNED");
        }
        return templateFormatting(source.getPointer(), options);
    }
    else if (source instanceof types_1.Table
        || source instanceof types_1.HashedTable
        || source instanceof types_1.ABAPObject
        || source instanceof types_1.Structure) {
        throw new Error("STRG_ILLEGAL_DATA_TYPE");
    }
    else if (source instanceof types_1.Character) {
        text = source.getTrimEnd();
    }
    else if (source instanceof types_1.DecFloat34) {
        const raw = source.getRaw();
        if (Number.isInteger(raw)) {
            text = raw.toFixed(0);
        }
        else {
            text = raw + "";
        }
    }
    else if (source instanceof types_1.Float) {
        const raw = source.getRaw();
        if (options?.style === "scientific") {
            text = raw.toExponential().toUpperCase();
            text = text.replace(/([+-])(\d)$/, "$10$2");
        }
        else if (Number.isInteger(raw)) {
            text = raw.toFixed(0);
        }
        else {
            text = raw.toFixed(16);
        }
    }
    else if (source instanceof types_1.Packed) {
        if (options?.decimals) {
            text = source.get().toFixed(options.decimals);
        }
        else {
            text = source.get().toFixed(source.getDecimals());
        }
    }
    else {
        text = source.get() + "";
    }
    if (options) {
        if (options.currency !== undefined) {
            throw "template formatting with currency not supported";
        }
        if (options.date === "iso") {
            text = text.substr(0, 4) + "-" + text.substr(4, 2) + "-" + text.substr(6, 2);
        }
        if (options.time === "iso") {
            text = text.substr(0, 2) + ":" + text.substr(2, 2) + ":" + text.substr(4, 2);
        }
        if (options.timestamp === "iso") {
            // make sure to get decimals from packed number,
            text = templateFormatting(source).replace(".", ",");
            text = text.substr(0, 4) + "-" + text.substr(4, 2) + "-" + text.substr(6, 2) + "T" + text.substr(8, 2) + ":" + text.substr(10, 2) + ":" + text.substr(12, 2) + text.substr(14);
            if (text === "0--T::") {
                text = "0000-00-00T00:00:00";
            }
        }
        else if (options.width && options.pad) {
            if (options.align === "right") {
                text = text.trimEnd().padStart(options.width, options.pad);
            }
            else {
                text = text.trimEnd().padEnd(options.width, options.pad);
            }
        }
        else if (options.width) {
            text = text.trimEnd().padEnd(options.width, " ");
        }
        else if (options.decimals && source instanceof types_1.Integer) {
            text = source.get().toFixed(options.decimals);
        }
        else if (options.decimals && source instanceof types_1.Float) {
            text = source.getRaw().toFixed(options.decimals);
        }
    }
    return text;
}
exports.templateFormatting = templateFormatting;
//# sourceMappingURL=template_formatting.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/throw_error.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/throw_error.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.throwError = void 0;
function throwError(name) {
    // @ts-ignore
    if (abap.Classes[name] !== undefined) {
        // @ts-ignore
        throw new abap.Classes[name]();
    }
    else {
        throw new Error(`Global class ${name} not found`);
    }
}
exports.throwError = throwError;
//# sourceMappingURL=throw_error.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/_date_helper.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/_date_helper.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getNumberFromDate = exports.getDateFromNumber = void 0;
function getDateFromNumber(value) {
    const msInOneDay = 24 * 60 * 60 * 1000;
    const date = new Date(-62135596800000 + value * msInOneDay);
    let removeJulianLeaps = 2;
    if (value <= 577736) {
        let beforeGregorian = date.getFullYear() <= 1582 ? date.getFullYear() : 1582;
        if (date.getMonth() < 1 || (date.getMonth() === 1 && date.getDay() < 29)) {
            beforeGregorian -= 1;
        }
        removeJulianLeaps = Math.floor(beforeGregorian / 100) - Math.floor(beforeGregorian / 400);
    }
    date.setTime(date.getTime() - removeJulianLeaps * msInOneDay);
    let ret = date.getFullYear().toString().padStart(4, "0");
    ret += (date.getMonth() + 1).toString().padStart(2, "0");
    ret += date.getDate().toString().padStart(2, "0");
    return ret;
}
exports.getDateFromNumber = getDateFromNumber;
function getNumberFromDate(value) {
    const msInOneDay = 24 * 60 * 60 * 1000;
    const date = new Date(-62135596800000);
    date.setUTCFullYear(parseInt(value.substr(0, 4), 10));
    date.setUTCMonth(parseInt(value.substr(4, 2), 10) - 1);
    date.setUTCDate(parseInt(value.substr(6, 2), 10));
    let days = Math.floor((date.getTime() + 62135596800000) / msInOneDay);
    let addJulianLeaps = 2;
    if (days <= 577736) {
        let beforeGregorian = date.getFullYear() <= 1582 ? date.getFullYear() : 1582;
        if (date.getMonth() < 1 || (date.getMonth() === 1 && date.getDay() < 29)) {
            beforeGregorian -= 1;
        }
        addJulianLeaps = Math.floor(beforeGregorian / 100) - Math.floor(beforeGregorian / 400);
    }
    days = days + addJulianLeaps;
    return days;
}
exports.getNumberFromDate = getNumberFromDate;
//# sourceMappingURL=_date_helper.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/abap_object.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/abap_object.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ABAPObject = void 0;
const field_symbol_1 = __webpack_require__(/*! ./field_symbol */ "./node_modules/@abaplint/runtime/build/src/types/field_symbol.js");
class ABAPObject {
    constructor(input) {
        this.qualifiedName = input?.qualifiedName;
        this.RTTIName = input?.RTTIName;
        this.clear();
    }
    get() {
        return this.value;
    }
    clear() {
        this.value = undefined;
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    getRTTIName() {
        return this.RTTIName;
    }
    set(value) {
        if (value instanceof ABAPObject) {
            this.value = value.get();
        }
        else if (value instanceof field_symbol_1.FieldSymbol) {
            this.value = value.getPointer().get();
        }
        else {
            this.value = value;
        }
        return this;
    }
}
exports.ABAPObject = ABAPObject;
//# sourceMappingURL=abap_object.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/character.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/character.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Character = void 0;
const _parse_1 = __webpack_require__(/*! ../operators/_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
const field_symbol_1 = __webpack_require__(/*! ./field_symbol */ "./node_modules/@abaplint/runtime/build/src/types/field_symbol.js");
const structure_1 = __webpack_require__(/*! ./structure */ "./node_modules/@abaplint/runtime/build/src/types/structure.js");
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/@abaplint/runtime/build/src/types/integer.js");
const TRIMREGEX = / *$/;
class Character {
    constructor(length, extra) {
        this.constant = false;
        this.length = length || 1;
        if (typeof this.length === "object") {
            throw "Character, invalid length, object: " + JSON.stringify(this.length);
        }
        else if (this.length <= 0) {
            throw "Character, invalid length, less than zero";
        }
        this.extra = extra;
        this.clear();
    }
    setConstant() {
        this.constant = true;
        return this;
    }
    set(value) {
        if (this.constant === true) {
            throw new Error("Changing constant");
        }
        if (typeof value === "string") {
            this.value = value;
        }
        else if (typeof value === "number") {
            this.value = value + "";
        }
        else if (value instanceof field_symbol_1.FieldSymbol) {
            if (value.getPointer() === undefined) {
                throw new Error("GETWA_NOT_ASSIGNED");
            }
            this.set(value.getPointer());
            return this;
        }
        else if (value instanceof structure_1.Structure) {
            this.set(value.getCharacter());
            return this;
        }
        else if (value instanceof integer_1.Integer) {
            this.value = Math.abs(value.get()) + (value.get() < 0 ? "-" : " ");
            this.value = this.value.padStart(this.length, " ");
        }
        else {
            this.value = value.get() + "";
        }
        if (this.value.length > this.length) {
            this.value = this.value.substr(0, this.length);
        }
        else if (this.value.length < this.length) {
            this.value = this.value.padEnd(this.length, " ");
        }
        return this;
    }
    getQualifiedName() {
        return this.extra?.qualifiedName;
    }
    getConversionExit() {
        return this.extra?.conversionExit;
    }
    getDDICName() {
        return this.extra?.ddicName;
    }
    getLength() {
        return this.length;
    }
    clear() {
        this.value = " ".repeat(this.length);
    }
    get() {
        return this.value;
    }
    getTrimEnd() {
        if (this.value.endsWith(" ") === true) {
            return this.value.replace(TRIMREGEX, "");
        }
        else {
            return this.value;
        }
    }
    getOffset(input) {
        let offset = input?.offset;
        if (offset) {
            offset = (0, _parse_1.parse)(offset);
        }
        let length = input?.length;
        if (length) {
            length = (0, _parse_1.parse)(length);
        }
        if ((offset && offset >= this.length)
            || (length && length > this.length)
            || (offset && length && offset + length > this.length)
            || (offset && offset < 0)
            || (length && length < 0)) {
            (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
        }
        let ret = this.value;
        if (offset) {
            ret = ret.substr(offset);
        }
        if (length !== undefined) {
            ret = ret.substr(0, length);
        }
        const r = new Character(ret.length);
        r.set(ret);
        return r;
    }
}
exports.Character = Character;
//# sourceMappingURL=character.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/data_reference.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/data_reference.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataReference = void 0;
const string_1 = __webpack_require__(/*! ./string */ "./node_modules/@abaplint/runtime/build/src/types/string.js");
const _parse_1 = __webpack_require__(/*! ../operators/_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
const field_symbol_1 = __webpack_require__(/*! ./field_symbol */ "./node_modules/@abaplint/runtime/build/src/types/field_symbol.js");
class DataReference {
    constructor(type) {
        this.pointer = undefined;
        this.type = type;
    }
    getType() {
        return this.type;
    }
    assign(pointer) {
        this.pointer = pointer;
    }
    unassign() {
        this.pointer = undefined;
    }
    getPointer() {
        return this.pointer;
    }
    dereference() {
        return this.pointer;
    }
    ///////////////
    clear() {
        this.unassign();
        //    return this.pointer?.clear();
    }
    get() {
        if (this.pointer === this) {
            throw "Cyclic data reference";
        }
        // @ts-ignore
        return this.pointer?.get();
    }
    array() {
        // @ts-ignore
        return this.pointer?.array();
    }
    getArrayLength() {
        // @ts-ignore
        return this.pointer?.getArrayLength();
    }
    set(value) {
        if (value instanceof DataReference) {
            this.pointer = value.getPointer();
            return this;
        }
        else if (value instanceof field_symbol_1.FieldSymbol) {
            if (value.getPointer() === undefined) {
                throw new Error("GETWA_NOT_ASSIGNED");
            }
            else if (value.getPointer() instanceof DataReference) {
                this.pointer = value.getPointer().getPointer();
                return this;
            }
            else {
                throw new Error("OBJECTS_MOVE_NOT_SUPPORTED");
            }
        }
        else {
            return this.pointer?.set(value);
        }
        return this;
    }
    getOffset(input) {
        if (input?.offset) {
            input.offset = (0, _parse_1.parse)(input.offset);
        }
        if (input?.length) {
            input.length = (0, _parse_1.parse)(input.length);
        }
        // Assuming we're interested in Strings here, for now...
        let ret = this.get();
        if (input?.offset) {
            ret = ret.substr(input.offset);
        }
        if (input?.length !== undefined) {
            ret = ret.substr(0, input.length);
        }
        const r = new string_1.String();
        r.set(ret);
        return r;
    }
}
exports.DataReference = DataReference;
//# sourceMappingURL=data_reference.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/date.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/date.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Date = void 0;
const string_1 = __webpack_require__(/*! ./string */ "./node_modules/@abaplint/runtime/build/src/types/string.js");
const _date_helper_1 = __webpack_require__(/*! ./_date_helper */ "./node_modules/@abaplint/runtime/build/src/types/_date_helper.js");
const float_1 = __webpack_require__(/*! ./float */ "./node_modules/@abaplint/runtime/build/src/types/float.js");
const _parse_1 = __webpack_require__(/*! ../operators/_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
class Date {
    constructor(input) {
        this.clear();
        this.qualifiedName = input?.qualifiedName;
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    set(value) {
        if (typeof value === "number") {
            if (value <= 0 || value > 3652060) {
                this.value = "00000000";
            }
            else {
                this.value = (0, _date_helper_1.getDateFromNumber)(value);
            }
        }
        else if (value instanceof float_1.Float) {
            this.set(Math.round(value.getRaw()));
        }
        else if (typeof value === "string") {
            this.value = value;
        }
        else {
            this.set(value.get());
        }
        if (this.value.length > 8) {
            this.value = this.value.substr(0, 8);
        }
        else if (this.value.length < 8) {
            this.value = this.value.padEnd(8, " ");
        }
        return this;
    }
    clear() {
        this.value = "00000000";
    }
    get() {
        return this.value;
    }
    getNumeric() {
        return (0, _date_helper_1.getNumberFromDate)(this.value);
    }
    getOffset(input) {
        if (input?.offset) {
            input.offset = (0, _parse_1.parse)(input.offset);
        }
        if (input?.length) {
            input.length = (0, _parse_1.parse)(input.length);
        }
        let ret = this.value;
        if (input?.offset) {
            // @ts-ignore
            ret = ret.substr(input.offset);
        }
        if (input?.length !== undefined) {
            // @ts-ignore
            ret = ret.substr(0, input.length);
        }
        const r = new string_1.String();
        r.set(ret);
        return r;
    }
}
exports.Date = Date;
//# sourceMappingURL=date.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/decfloat34.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/decfloat34.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DecFloat34 = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const hex_1 = __webpack_require__(/*! ./hex */ "./node_modules/@abaplint/runtime/build/src/types/hex.js");
const xstring_1 = __webpack_require__(/*! ./xstring */ "./node_modules/@abaplint/runtime/build/src/types/xstring.js");
class DecFloat34 {
    constructor() {
        this.value = 0;
    }
    set(value) {
        if (typeof value === "number") {
            this.value = value;
        }
        else if (typeof value === "string" && value.trim().length === 0) {
            this.value = 0;
        }
        else if (typeof value === "string") {
            this.value = parseFloat(value);
        }
        else if (value instanceof _1.Float) {
            this.value = value.getRaw();
        }
        else if (value instanceof hex_1.Hex || value instanceof xstring_1.XString) {
            // todo, how/if should this work?
            this.set(parseInt(value.get(), 16));
        }
        else {
            this.set(value.get());
        }
        return this;
    }
    clear() {
        this.value = 0;
    }
    getRaw() {
        return this.value;
    }
    get() {
        let text = new Number(this.value).toString();
        text = text.replace(".", ",");
        return text;
    }
}
exports.DecFloat34 = DecFloat34;
//# sourceMappingURL=decfloat34.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/field_symbol.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/field_symbol.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldSymbol = void 0;
const table_1 = __webpack_require__(/*! ./table */ "./node_modules/@abaplint/runtime/build/src/types/table.js");
const string_1 = __webpack_require__(/*! ./string */ "./node_modules/@abaplint/runtime/build/src/types/string.js");
const hex_1 = __webpack_require__(/*! ./hex */ "./node_modules/@abaplint/runtime/build/src/types/hex.js");
const float_1 = __webpack_require__(/*! ./float */ "./node_modules/@abaplint/runtime/build/src/types/float.js");
const data_reference_1 = __webpack_require__(/*! ./data_reference */ "./node_modules/@abaplint/runtime/build/src/types/data_reference.js");
const hex_uint8_1 = __webpack_require__(/*! ./hex_uint8 */ "./node_modules/@abaplint/runtime/build/src/types/hex_uint8.js");
class FieldSymbol {
    constructor(type) {
        this.pointer = undefined;
        this.casting = false;
        this.type = type;
    }
    getQualifiedName() {
        // @ts-ignore
        return this.type.getQualifiedName();
    }
    assign(pointer) {
        this.pointer = pointer;
    }
    setCasting() {
        this.casting = true;
    }
    unassign() {
        this.pointer = undefined;
    }
    isAssigned() {
        return this.pointer !== undefined;
    }
    getPointer() {
        if (this.casting) {
            // todo, this wont work for everything, eg changing CASTING'ed values
            return this.get();
        }
        return this.pointer;
    }
    dereference() {
        if (this.pointer instanceof data_reference_1.DataReference) {
            return this.pointer.getPointer();
        }
        else {
            return this.pointer;
        }
    }
    ///////////////
    clear() {
        return this.pointer?.clear();
    }
    get() {
        if (this.casting) {
            if (this.type instanceof hex_1.Hex || this.type instanceof hex_uint8_1.HexUInt8) {
                const pt = this.pointer;
                if (pt instanceof float_1.Float) {
                    const buf = Buffer.allocUnsafe(8);
                    // CASTING is platform specific, so perhaps add a setting? But anyhow its not something developers should use
                    buf.writeDoubleLE(pt.getRaw());
                    return buf.toString("hex").toUpperCase();
                }
                else {
                    // @ts-ignore
                    const ret = new string_1.String().set(Buffer.from(this.pointer?.get(), "utf16le").toString("hex"));
                    return ret.get();
                }
            }
            else {
                // @ts-ignore
                const ret = new string_1.String().set(Buffer.from(this.pointer?.get(), "hex").toString("utf16le"));
                return ret.get();
            }
        }
        else {
            // @ts-ignore
            return this.pointer?.get();
        }
    }
    appendInitial() {
        if (this.pointer instanceof table_1.Table) {
            return this.pointer.appendInitial();
        }
        return undefined;
    }
    array() {
        // @ts-ignore
        return this.pointer?.array();
    }
    getArrayLength() {
        // @ts-ignore
        return this.pointer?.getArrayLength();
    }
    set(value) {
        if (this.casting) {
            if (this.type instanceof hex_1.Hex || this.type instanceof hex_uint8_1.HexUInt8) {
                const pt = this.pointer;
                if (pt instanceof float_1.Float) {
                    const buf = Buffer.from(value.get(), "hex");
                    pt.set(buf.readDoubleLE());
                    return;
                }
            }
        }
        this.pointer?.set(value);
        return this;
    }
    getOffset(input) {
        return this.getPointer().getOffset(input);
    }
}
exports.FieldSymbol = FieldSymbol;
//# sourceMappingURL=field_symbol.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/float.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/float.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Float = void 0;
const hex_1 = __webpack_require__(/*! ./hex */ "./node_modules/@abaplint/runtime/build/src/types/hex.js");
const xstring_1 = __webpack_require__(/*! ./xstring */ "./node_modules/@abaplint/runtime/build/src/types/xstring.js");
const integer8_1 = __webpack_require__(/*! ./integer8 */ "./node_modules/@abaplint/runtime/build/src/types/integer8.js");
/*
function getNumberParts(x: number) {
  if(isNaN(x)) {
    throw "Float NaN";
  }
  const sig = x > 0 ? 1 : -1;
  if (!isFinite(x)) {
    throw "Float not finite";
  }
  x = Math.abs(x);
  const exp = Math.floor(Math.log(x) * Math.LOG2E) - 52;
  const man = x / Math.pow(2, exp);
  return {mantissa: sig * man, exponent: exp};
}
*/
class Float {
    constructor(input) {
        this.value = 0;
        this.qualifiedName = input?.qualifiedName;
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    set(value) {
        if (typeof value === "number") {
            this.value = value;
        }
        else if (typeof value === "string" && value.trim().length === 0) {
            this.value = 0;
        }
        else if (typeof value === "string") {
            this.value = parseFloat(value);
        }
        else if (value instanceof integer8_1.Integer8) {
            this.value = Number(value.get());
        }
        else if (value instanceof Float) {
            this.value = value.getRaw();
        }
        else if (value instanceof hex_1.Hex || value instanceof xstring_1.XString) {
            // todo, how/if should this work?
            this.set(parseInt(value.get(), 16));
        }
        else {
            this.set(value.get());
        }
        return this;
    }
    clear() {
        this.value = 0;
    }
    getRaw() {
        return this.value;
    }
    get() {
        let text = new Number(this.value).toExponential(16);
        text = text.replace(".", ",");
        if (text.includes("e+")) {
            const split = text.split("e+");
            const mantissa = split[0];
            const exponent = split[1].padStart(2, "0");
            return mantissa + "E+" + exponent;
        }
        else {
            const split = text.split("e-");
            const mantissa = split[0];
            const exponent = split[1].padStart(2, "0");
            return mantissa + "E-" + exponent;
        }
    }
}
exports.Float = Float;
//# sourceMappingURL=float.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/hex.js":
/*!***************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/hex.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hex = void 0;
const _parse_1 = __webpack_require__(/*! ../operators/_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
const float_1 = __webpack_require__(/*! ./float */ "./node_modules/@abaplint/runtime/build/src/types/float.js");
const xstring_1 = __webpack_require__(/*! ./xstring */ "./node_modules/@abaplint/runtime/build/src/types/xstring.js");
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
const integer8_1 = __webpack_require__(/*! ./integer8 */ "./node_modules/@abaplint/runtime/build/src/types/integer8.js");
const REGEXP = /^(?![A-F0-9])/;
class Hex {
    constructor(input) {
        this.length = input?.length ? input?.length : 1;
        this.qualifiedName = input?.qualifiedName;
        this.clear();
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    set(value) {
        const doubleLength = this.length * 2;
        if (typeof value === "string") {
            this.value = value;
        }
        else if (typeof value === "number") {
            const maxVal = Math.pow(2, this.length * 8);
            if (value < 0) {
                let hex = Math.round(value + 0x100000000).toString(16).toUpperCase();
                if (hex.length > doubleLength) {
                    hex = hex.substring(hex.length - doubleLength);
                }
                this.value = hex;
            }
            else if (value >= maxVal) {
                const sub = value % maxVal;
                this.value = Math.round(sub).toString(16).toUpperCase();
            }
            else {
                this.value = Math.round(value).toString(16).toUpperCase();
            }
            this.value = this.value.padStart(doubleLength, "0");
        }
        else if (value instanceof integer8_1.Integer8) {
            let hex = "";
            if (value.get() < 0) {
                hex = (value.get() + 0x10000000000000000n).toString(16).toUpperCase();
                if (hex.length > doubleLength) {
                    hex = hex.substring(hex.length - doubleLength);
                }
            }
            else {
                hex = value.get().toString(16).toUpperCase();
                hex = hex.padStart(doubleLength, "0");
            }
            return this.set(hex);
        }
        else if (value instanceof Hex || value instanceof xstring_1.XString) {
            this.value = value.get();
        }
        else {
            const v = value.get();
            if (value instanceof float_1.Float) {
                return this.set(value.getRaw());
            }
            else if (typeof v === "number") {
                return this.set(v);
            }
            else {
                this.value = v;
                if (this.value.match(REGEXP)) {
                    this.value = "";
                }
            }
        }
        if (this.value.length > doubleLength) {
            this.value = this.value.substr(0, doubleLength);
        }
        else if (this.value.length < doubleLength) {
            this.value = this.value.padEnd(doubleLength, "0");
        }
        //    this.value = this.value.toUpperCase(); // todo, for some reason abapNTLM needs this? investigate
        return this;
    }
    getLength() {
        return this.length;
    }
    clear() {
        this.value = "0".repeat(this.length * 2);
    }
    get() {
        return this.value;
    }
    getOffset(input) {
        let offset = input?.offset;
        if (offset) {
            if (offset instanceof integer8_1.Integer8) {
                offset = Number(offset.get());
            }
            else {
                offset = (0, _parse_1.parse)(offset);
            }
            if (offset * 2 > this.value.length
                || offset < 0) {
                (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
            }
        }
        let length = input?.length;
        if (length) {
            if (length instanceof integer8_1.Integer8) {
                length = Number(length.get());
            }
            else {
                length = (0, _parse_1.parse)(length);
            }
            if (length * 2 > this.value.length
                || length < 0) {
                (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
            }
        }
        // NOTE: this only copies the minimal length of the string,
        if (offset !== undefined && length !== undefined) {
            if (offset * 2 + length * 2 > this.value.length) {
                (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
            }
            return new xstring_1.XString().set(this.value.substr(offset * 2, length * 2));
        }
        else if (offset !== undefined) {
            return new xstring_1.XString().set(this.value.substr(offset * 2));
        }
        else if (length !== undefined) {
            return new xstring_1.XString().set(this.value.substr(0, length * 2));
        }
        else {
            throw new Error("hex: getOffset, unexpected");
        }
    }
}
exports.Hex = Hex;
//# sourceMappingURL=hex.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/hex_uint8.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/hex_uint8.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HexUInt8 = void 0;
/* eslint-disable no-bitwise */
const _parse_1 = __webpack_require__(/*! ../operators/_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
const float_1 = __webpack_require__(/*! ./float */ "./node_modules/@abaplint/runtime/build/src/types/float.js");
const xstring_1 = __webpack_require__(/*! ./xstring */ "./node_modules/@abaplint/runtime/build/src/types/xstring.js");
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
const integer8_1 = __webpack_require__(/*! ./integer8 */ "./node_modules/@abaplint/runtime/build/src/types/integer8.js");
const REGEXP = /^(?![A-F0-9])/;
const LUT_HEX_4b = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"];
const LUT_HEX_8b = new Array(0x100);
for (let n = 0; n < 0x100; n++) {
    LUT_HEX_8b[n] = `${LUT_HEX_4b[(n >>> 4) & 0xF]}${LUT_HEX_4b[n & 0xF]}`;
}
class HexUInt8 {
    constructor(input) {
        this.length = input?.length ? input?.length : 1;
        this.qualifiedName = input?.qualifiedName;
        this.value = new Uint8Array(this.length);
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    setOffset(offset, value) {
        // caller must validate offset
        this.value[offset] = value;
    }
    getOffsetRaw(offset) {
        // caller must validate offset
        return this.value[offset];
    }
    set(value) {
        let hexString = "";
        if (typeof value === "string") {
            hexString = value;
            if (hexString.length < this.length * 2) {
                hexString = hexString.padEnd(this.length * 2, "0");
            }
        }
        else if (typeof value === "number") {
            const maxVal = Math.pow(2, this.length * 8);
            if (value < 0) {
                hexString = Math.round(value + 0x100000000).toString(16).toUpperCase();
            }
            else if (value >= maxVal) {
                const sub = value % maxVal;
                hexString = Math.round(sub).toString(16).toUpperCase();
            }
            else {
                hexString = Math.round(value).toString(16).toUpperCase();
            }
            if (hexString.length > this.length * 2) {
                hexString = hexString.substring(hexString.length - this.length * 2);
            }
            else if (hexString.length < this.length * 2) {
                hexString = hexString.padStart(this.length * 2, "0");
            }
        }
        else if (value instanceof integer8_1.Integer8) {
            if (value.get() < 0) {
                hexString = (value.get() + 0x10000000000000000n).toString(16).toUpperCase();
            }
            else {
                hexString = value.get().toString(16).toUpperCase();
            }
            if (hexString.length > this.length * 2) {
                hexString = hexString.substring(hexString.length - this.length * 2);
            }
            else if (hexString.length < this.length * 2) {
                hexString = hexString.padStart(this.length * 2, "0");
            }
        }
        else if (value instanceof HexUInt8 || value instanceof xstring_1.XString) {
            hexString = value.get();
            if (hexString.length < this.length * 2) {
                hexString = hexString.padEnd(this.length * 2, "0");
            }
        }
        else {
            const v = value.get();
            if (value instanceof float_1.Float) {
                return this.set(value.getRaw());
            }
            else if (typeof v === "number") {
                return this.set(v);
            }
            else {
                hexString = v;
                if (hexString.match(REGEXP)) {
                    hexString = "";
                }
                if (hexString.length < this.length * 2) {
                    hexString = hexString.padEnd(this.length * 2, "0");
                }
            }
        }
        if (hexString.length > this.length * 2) {
            hexString = hexString.substring(0, this.length * 2);
        }
        this.value = Uint8Array.from(Buffer.from(hexString, "hex"));
        return this;
    }
    getLength() {
        return this.length;
    }
    clear() {
        // optimize? https://gist.github.com/chrisj/872283d15e1bb460a4766a52f50ebcf6
        for (let i = 0; i < this.value.length; i++) {
            this.value[i] = 0;
        }
    }
    get() {
        //    return Buffer.from(this.value).toString("hex").toUpperCase();
        let out = "";
        // eslint-disable-next-line @typescript-eslint/prefer-for-of
        for (let idx = 0; idx < this.value.length; idx++) {
            out += LUT_HEX_8b[this.value[idx]];
        }
        return out;
    }
    getOffset(input) {
        let offset = input?.offset;
        if (offset) {
            if (offset instanceof integer8_1.Integer8) {
                offset = Number(offset.get());
            }
            else {
                offset = (0, _parse_1.parse)(offset);
            }
            if (offset > this.length
                || offset < 0) {
                (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
            }
        }
        else {
            offset = 0;
        }
        let length = input?.length;
        if (length) {
            if (length instanceof integer8_1.Integer8) {
                length = Number(length.get());
            }
            else {
                length = (0, _parse_1.parse)(length);
            }
            if (length > this.length
                || length < 0) {
                (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
            }
        }
        if (offset !== undefined && length !== undefined) {
            if (offset + length > this.length) {
                (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
            }
        }
        // not sure how this works: without copying, https://nodejs.org/api/buffer.html#static-method-bufferfromarraybuffer-byteoffset-length
        /*
            console.dir(offset);
            console.dir(length);
            console.dir(this.value.subarray(offset, length ? offset + length : undefined));
            console.dir(Buffer.from(this.value.subarray(offset, length ? offset + length : undefined)));
        */
        //    const str = Buffer.from(this.value.subarray(offset, length ? offset + length : undefined)).toString("hex").toUpperCase();
        let str = "";
        const until = length ? offset + length : this.value.length;
        // eslint-disable-next-line @typescript-eslint/prefer-for-of
        for (let idx = offset; idx < until; idx++) {
            str += LUT_HEX_8b[this.value[idx]];
        }
        return new xstring_1.XString().set(str);
    }
}
exports.HexUInt8 = HexUInt8;
//# sourceMappingURL=hex_uint8.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./abap_object */ "./node_modules/@abaplint/runtime/build/src/types/abap_object.js"), exports);
__exportStar(__webpack_require__(/*! ./character */ "./node_modules/@abaplint/runtime/build/src/types/character.js"), exports);
__exportStar(__webpack_require__(/*! ./data_reference */ "./node_modules/@abaplint/runtime/build/src/types/data_reference.js"), exports);
__exportStar(__webpack_require__(/*! ./date */ "./node_modules/@abaplint/runtime/build/src/types/date.js"), exports);
__exportStar(__webpack_require__(/*! ./decfloat34 */ "./node_modules/@abaplint/runtime/build/src/types/decfloat34.js"), exports);
__exportStar(__webpack_require__(/*! ./field_symbol */ "./node_modules/@abaplint/runtime/build/src/types/field_symbol.js"), exports);
__exportStar(__webpack_require__(/*! ./float */ "./node_modules/@abaplint/runtime/build/src/types/float.js"), exports);
__exportStar(__webpack_require__(/*! ./hex */ "./node_modules/@abaplint/runtime/build/src/types/hex.js"), exports);
__exportStar(__webpack_require__(/*! ./hex_uint8 */ "./node_modules/@abaplint/runtime/build/src/types/hex_uint8.js"), exports);
__exportStar(__webpack_require__(/*! ./integer */ "./node_modules/@abaplint/runtime/build/src/types/integer.js"), exports);
__exportStar(__webpack_require__(/*! ./integer8 */ "./node_modules/@abaplint/runtime/build/src/types/integer8.js"), exports);
__exportStar(__webpack_require__(/*! ./numc */ "./node_modules/@abaplint/runtime/build/src/types/numc.js"), exports);
__exportStar(__webpack_require__(/*! ./packed */ "./node_modules/@abaplint/runtime/build/src/types/packed.js"), exports);
__exportStar(__webpack_require__(/*! ./string */ "./node_modules/@abaplint/runtime/build/src/types/string.js"), exports);
__exportStar(__webpack_require__(/*! ./structure */ "./node_modules/@abaplint/runtime/build/src/types/structure.js"), exports);
__exportStar(__webpack_require__(/*! ./table */ "./node_modules/@abaplint/runtime/build/src/types/table.js"), exports);
__exportStar(__webpack_require__(/*! ./time */ "./node_modules/@abaplint/runtime/build/src/types/time.js"), exports);
__exportStar(__webpack_require__(/*! ./utc_long */ "./node_modules/@abaplint/runtime/build/src/types/utc_long.js"), exports);
__exportStar(__webpack_require__(/*! ./xstring */ "./node_modules/@abaplint/runtime/build/src/types/xstring.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/integer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/integer.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Integer = exports.toInteger = exports.MIN_INTEGER = exports.MAX_INTEGER = exports.DIGITS = void 0;
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
const float_1 = __webpack_require__(/*! ./float */ "./node_modules/@abaplint/runtime/build/src/types/float.js");
const hex_1 = __webpack_require__(/*! ./hex */ "./node_modules/@abaplint/runtime/build/src/types/hex.js");
const xstring_1 = __webpack_require__(/*! ./xstring */ "./node_modules/@abaplint/runtime/build/src/types/xstring.js");
const integer8_1 = __webpack_require__(/*! ./integer8 */ "./node_modules/@abaplint/runtime/build/src/types/integer8.js");
const hex_uint8_1 = __webpack_require__(/*! ./hex_uint8 */ "./node_modules/@abaplint/runtime/build/src/types/hex_uint8.js");
exports.DIGITS = new RegExp(/^\s*-?\+?\d+\.?\d* *$/i);
exports.MAX_INTEGER = 2147483647;
exports.MIN_INTEGER = -2147483648;
function toInteger(value, exception = true) {
    if (value.endsWith("-")) {
        value = "-" + value.substring(0, value.length - 1);
    }
    if (value.trim().length === 0) {
        value = "0";
    }
    else if (exports.DIGITS.test(value) === false) {
        if (exception === true) {
            (0, throw_error_1.throwError)("CX_SY_CONVERSION_NO_NUMBER");
        }
        else {
            throw new Error("CONVT_NO_NUMBER");
        }
    }
    return parseInt(value, 10);
}
exports.toInteger = toInteger;
class Integer {
    constructor(input) {
        this.constant = false;
        this.value = 0;
        this.qualifiedName = input?.qualifiedName;
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    setConstant() {
        this.constant = true;
        return this;
    }
    set(value) {
        if (this.constant === true) {
            throw new Error("Changing constant");
        }
        if (typeof value === "number") {
            this.value = Math.round(value);
        }
        else if (typeof value === "string") {
            this.value = toInteger(value);
        }
        else if (value instanceof integer8_1.Integer8) {
            this.set(Number(value.get()));
        }
        else if (value instanceof float_1.Float) {
            this.set(Math.round(value.getRaw()));
        }
        else if (value instanceof hex_1.Hex || value instanceof xstring_1.XString || value instanceof hex_uint8_1.HexUInt8) {
            let num = parseInt(value.get(), 16);
            // handle two complement,
            if ((value instanceof hex_1.Hex || value instanceof hex_uint8_1.HexUInt8)
                && value.getLength() >= 4) {
                const maxVal = Math.pow(2, value.get().length / 2 * 8);
                if (num > maxVal / 2 - 1) {
                    num = num - maxVal;
                }
            }
            this.set(num);
        }
        else {
            this.set(value.get());
        }
        /*
            if (this.value > 2147483647 || this.value < -2147483648) {
              throwError("CX_SY_ARITHMETIC_OVERFLOW");
            }
        */
        return this;
    }
    clear() {
        this.value = 0;
    }
    get() {
        return this.value;
    }
}
exports.Integer = Integer;
//# sourceMappingURL=integer.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/integer8.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/integer8.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Integer8 = void 0;
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
const float_1 = __webpack_require__(/*! ./float */ "./node_modules/@abaplint/runtime/build/src/types/float.js");
const hex_1 = __webpack_require__(/*! ./hex */ "./node_modules/@abaplint/runtime/build/src/types/hex.js");
const xstring_1 = __webpack_require__(/*! ./xstring */ "./node_modules/@abaplint/runtime/build/src/types/xstring.js");
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/@abaplint/runtime/build/src/types/integer.js");
const get_bit_1 = __webpack_require__(/*! ../statements/get_bit */ "./node_modules/@abaplint/runtime/build/src/statements/get_bit.js");
const character_1 = __webpack_require__(/*! ./character */ "./node_modules/@abaplint/runtime/build/src/types/character.js");
const hex_uint8_1 = __webpack_require__(/*! ./hex_uint8 */ "./node_modules/@abaplint/runtime/build/src/types/hex_uint8.js");
const digits = new RegExp(/^\s*-?\+?\d+\.?\d* *$/i);
class Integer8 {
    constructor(input) {
        this.value = 0n;
        this.qualifiedName = input?.qualifiedName;
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    set(value) {
        if (typeof value === "number") {
            this.value = BigInt(value);
        }
        else if (typeof value === "bigint") {
            this.value = value;
        }
        else if (typeof value === "string") {
            if (value.endsWith("-")) {
                value = "-" + value.substring(0, value.length - 1);
            }
            if (value.trim().length === 0) {
                value = "0";
            }
            else if (digits.test(value) === false) {
                (0, throw_error_1.throwError)("CX_SY_CONVERSION_NO_NUMBER");
            }
            this.value = BigInt(value);
        }
        else if (value instanceof float_1.Float) {
            this.set(Math.round(value.getRaw()));
        }
        else if (value instanceof hex_1.Hex || value instanceof xstring_1.XString || value instanceof hex_uint8_1.HexUInt8) {
            if (value.get().length === 16) {
                const lv_bit = new character_1.Character();
                (0, get_bit_1.getBit)(new integer_1.Integer().set(1), value, lv_bit);
                if (lv_bit.get() === "1") {
                    const val = BigInt("0x" + value.get());
                    this.value = val - BigInt("0x10000000000000000");
                }
                else {
                    this.value = BigInt("0x" + value.get());
                }
            }
            else {
                // todo, what if the input is longer than 16 bytes?
                this.value = BigInt("0x" + value.get());
            }
        }
        else {
            this.set(value.get());
        }
        return this;
    }
    clear() {
        this.value = 0n;
    }
    get() {
        return this.value;
    }
}
exports.Integer8 = Integer8;
//# sourceMappingURL=integer8.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/numc.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/numc.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Numc = void 0;
const _parse_1 = __webpack_require__(/*! ../operators/_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
const float_1 = __webpack_require__(/*! ./float */ "./node_modules/@abaplint/runtime/build/src/types/float.js");
class Numc {
    constructor(input) {
        this.length = input?.length ? input?.length : 1;
        this.qualifiedName = input?.qualifiedName;
        this.clear();
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    set(value, raw = false) {
        if (typeof value === "number") {
            this.value = Math.trunc(value) + "";
        }
        else if (typeof value === "string") {
            this.value = parseInt(value, 10) + "";
        }
        else if (value instanceof float_1.Float) {
            this.value = Math.trunc(value.getRaw()) + "";
        }
        else {
            this.set(value.get());
            return this;
        }
        if (this.value.length > this.length) {
            this.value = this.value.substr(this.value.length - this.length, this.length);
        }
        else {
            const pad = this.length - this.value.length;
            if (pad > 0 && raw === false) {
                this.value = "0".repeat(pad) + this.value;
            }
        }
        return this;
    }
    getLength() {
        return this.length;
    }
    clear() {
        this.value = "0".repeat(this.length);
    }
    get() {
        return this.value;
    }
    getOffset(input) {
        let offset = input?.offset;
        if (offset) {
            offset = (0, _parse_1.parse)(offset);
        }
        let length = input?.length;
        if (length) {
            length = (0, _parse_1.parse)(length);
        }
        if ((offset && offset >= this.length)
            || (offset && offset < 0)
            || (length && length < 0)) {
            (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
        }
        let ret = this.value;
        if (offset) {
            ret = ret.substr(offset);
        }
        if (length !== undefined) {
            ret = ret.substr(0, length);
        }
        const r = new Numc({ length: ret.length });
        r.set(ret);
        return r;
    }
}
exports.Numc = Numc;
//# sourceMappingURL=numc.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/packed.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/packed.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Packed = void 0;
const float_1 = __webpack_require__(/*! ./float */ "./node_modules/@abaplint/runtime/build/src/types/float.js");
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
const integer8_1 = __webpack_require__(/*! ./integer8 */ "./node_modules/@abaplint/runtime/build/src/types/integer8.js");
const digits = new RegExp(/^\s*-?\+?\d*\.?\d* *$/i);
class Packed {
    constructor(input) {
        this.value = 0;
        this.length = 666;
        if (input?.length) {
            this.length = input.length;
        }
        this.decimals = 0;
        if (input?.decimals) {
            this.decimals = input.decimals;
        }
        this.qualifiedName = input?.qualifiedName;
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    round(value, places) {
        // @ts-ignore
        return +(Math.round(value + "e+" + places) + "e-" + places);
    }
    set(value) {
        if (typeof value === "number") {
            this.value = value;
        }
        else if (typeof value === "string") {
            if (value.trim().length === 0) {
                this.value = 0;
                return this;
            }
            else if (digits.test(value) === false) {
                (0, throw_error_1.throwError)("CX_SY_CONVERSION_NO_NUMBER");
            }
            this.value = this.round(parseFloat(value), this.decimals);
        }
        else if (value instanceof integer8_1.Integer8) {
            this.value = Number(value.get());
        }
        else if (value instanceof float_1.Float) {
            this.value = this.round(value.getRaw(), this.decimals);
        }
        else {
            this.set(value.get());
        }
        return this;
    }
    getLength() {
        return this.length;
    }
    getDecimals() {
        return this.decimals;
    }
    clear() {
        this.value = 0;
    }
    get() {
        return this.value;
    }
}
exports.Packed = Packed;
//# sourceMappingURL=packed.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/string.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/string.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.String = void 0;
const _parse_1 = __webpack_require__(/*! ../operators/_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
const character_1 = __webpack_require__(/*! ./character */ "./node_modules/@abaplint/runtime/build/src/types/character.js");
const field_symbol_1 = __webpack_require__(/*! ./field_symbol */ "./node_modules/@abaplint/runtime/build/src/types/field_symbol.js");
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/@abaplint/runtime/build/src/types/integer.js");
const packed_1 = __webpack_require__(/*! ./packed */ "./node_modules/@abaplint/runtime/build/src/types/packed.js");
const structure_1 = __webpack_require__(/*! ./structure */ "./node_modules/@abaplint/runtime/build/src/types/structure.js");
const float_1 = __webpack_require__(/*! ./float */ "./node_modules/@abaplint/runtime/build/src/types/float.js");
class String {
    constructor(input) {
        this.value = "";
        this.qualifiedName = input?.qualifiedName;
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    set(value) {
        if (value instanceof field_symbol_1.FieldSymbol) {
            if (value.getPointer() === undefined) {
                throw new Error("GETWA_NOT_ASSIGNED");
            }
            return this.set(value.getPointer());
        }
        else if (typeof value === "string") {
            this.value = value;
        }
        else if (typeof value === "number") {
            this.value = value.toString();
        }
        else if (value instanceof character_1.Character) {
            // replace trailing blanks if the source is a Character string
            this.value = value.getTrimEnd();
        }
        else if (value instanceof structure_1.Structure) {
            this.value = value.getCharacter().trimEnd();
        }
        else if (value instanceof packed_1.Packed) {
            const lv_sign = value.get() >= 0 ? " " : "-";
            this.value = Math.abs(value.get()).toFixed(value.getDecimals());
            this.value += lv_sign;
        }
        else if (value instanceof integer_1.Integer) {
            const lv_sign = value.get() >= 0 ? " " : "-";
            this.value = Math.abs(value.get()) + "";
            this.value += lv_sign;
        }
        else if (value instanceof float_1.Float) {
            this.value = value.get() + "";
            this.value = this.value.replace(",", ".");
        }
        else {
            this.value = value.get() + "";
        }
        return this;
    }
    clear() {
        this.value = "";
    }
    get() {
        return this.value;
    }
    getOffset(input) {
        let offset = input?.offset;
        if (offset) {
            offset = (0, _parse_1.parse)(offset);
        }
        let length = input?.length;
        if (length) {
            length = (0, _parse_1.parse)(length);
        }
        if ((offset && offset > this.value.length)
            || (length && length > this.value.length)
            || (offset && length && offset + length > this.value.length)
            || (offset && offset < 0)
            || (length && length < 0)) {
            (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
        }
        let ret = this.value;
        if (offset) {
            ret = ret.substr(offset);
        }
        if (length !== undefined) {
            ret = ret.substr(0, length);
        }
        const r = new String();
        r.set(ret);
        return r;
    }
}
exports.String = String;
//# sourceMappingURL=string.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/structure.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/structure.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Structure = void 0;
const clone_1 = __webpack_require__(/*! ../clone */ "./node_modules/@abaplint/runtime/build/src/clone.js");
const field_symbol_1 = __webpack_require__(/*! ./field_symbol */ "./node_modules/@abaplint/runtime/build/src/types/field_symbol.js");
const table_1 = __webpack_require__(/*! ./table */ "./node_modules/@abaplint/runtime/build/src/types/table.js");
const _parse_1 = __webpack_require__(/*! ../operators/_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
const character_1 = __webpack_require__(/*! ./character */ "./node_modules/@abaplint/runtime/build/src/types/character.js");
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
class Structure {
    constructor(fields, qualifiedName, ddicName, suffix, asInclude) {
        this.value = fields;
        this.qualifiedName = qualifiedName?.toUpperCase();
        this.ddicName = ddicName?.toUpperCase();
        this.suffix = suffix;
        this.asInclude = asInclude;
    }
    clear() {
        for (const f in this.value) {
            // @ts-ignore
            this.value[f].clear();
        }
        return this;
    }
    getDDICName() {
        return this.ddicName;
    }
    getRenamingSuffix() {
        return this.suffix;
    }
    getAsInclude() {
        return this.asInclude;
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    set(input) {
        if (input === undefined) {
            return;
        }
        if (input instanceof field_symbol_1.FieldSymbol) {
            this.set(input.getPointer());
        }
        else if (input instanceof table_1.Table) {
            throw new Error("Structure, input is a table");
        }
        else if (input instanceof Structure) {
            const obj = input.get();
            const keys1 = Object.keys(obj);
            const keys2 = Object.keys(this.value);
            /*
            console.dir(keys1);
            console.dir(keys2);
      */
            for (let i = 0; i < keys1.length; i++) {
                const key1 = keys1[i];
                const key2 = keys2[i];
                this.value[key2].set((0, clone_1.clone)(obj[key1]));
            }
            /*
                  for (const f in obj) {
                    // @ts-ignore
                    this.value[f].set(clone(obj[f]));
                  }
                  */
        }
        else {
            this.setCharacter(input);
        }
        return this;
    }
    setCharacter(input) {
        this.clear();
        let val = input;
        if (typeof val !== "string") {
            val = val.get() + "";
        }
        for (const key of Object.keys(this.value)) {
            const targetLength = this.value[key].getLength();
            this.value[key].set(val.substr(0, targetLength));
            val = val.substr(targetLength);
        }
    }
    get() {
        return this.value;
    }
    getCharacter() {
        let val = "";
        for (const v in this.value) {
            if (this.value[v] instanceof Structure) {
                val += this.value[v].getCharacter();
            }
            else {
                val += this.value[v].get();
            }
        }
        return val;
    }
    getOffset(input) {
        let offset = input?.offset;
        if (offset) {
            offset = (0, _parse_1.parse)(offset);
        }
        let length = input?.length;
        if (length) {
            length = (0, _parse_1.parse)(length);
        }
        const val = this.getCharacter();
        if ((offset && offset >= val.length)
            || (offset && offset < 0)
            || (length && length < 0)) {
            (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
        }
        let ret = val;
        if (offset) {
            ret = ret.substr(offset);
        }
        if (length !== undefined) {
            ret = ret.substr(0, length);
        }
        const r = new character_1.Character(ret.length);
        r.set(ret);
        return r;
    }
}
exports.Structure = Structure;
//# sourceMappingURL=structure.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/table.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/table.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Table = exports.HashedTable = exports.TableFactory = exports.LoopController = exports.TableKeyType = exports.TableAccessType = void 0;
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/@abaplint/runtime/build/src/types/integer.js");
const string_1 = __webpack_require__(/*! ./string */ "./node_modules/@abaplint/runtime/build/src/types/string.js");
const clone_1 = __webpack_require__(/*! ../clone */ "./node_modules/@abaplint/runtime/build/src/clone.js");
const structure_1 = __webpack_require__(/*! ./structure */ "./node_modules/@abaplint/runtime/build/src/types/structure.js");
const field_symbol_1 = __webpack_require__(/*! ./field_symbol */ "./node_modules/@abaplint/runtime/build/src/types/field_symbol.js");
const data_reference_1 = __webpack_require__(/*! ./data_reference */ "./node_modules/@abaplint/runtime/build/src/types/data_reference.js");
const insert_internal_1 = __webpack_require__(/*! ../statements/insert_internal */ "./node_modules/@abaplint/runtime/build/src/statements/insert_internal.js");
const sort_1 = __webpack_require__(/*! ../statements/sort */ "./node_modules/@abaplint/runtime/build/src/statements/sort.js");
const character_1 = __webpack_require__(/*! ./character */ "./node_modules/@abaplint/runtime/build/src/types/character.js");
const hex_1 = __webpack_require__(/*! ./hex */ "./node_modules/@abaplint/runtime/build/src/types/hex.js");
const hex_uint8_1 = __webpack_require__(/*! ./hex_uint8 */ "./node_modules/@abaplint/runtime/build/src/types/hex_uint8.js");
// const FEATURE_SHARED_TABLES = true;
var TableAccessType;
(function (TableAccessType) {
    TableAccessType["standard"] = "STANDARD";
    TableAccessType["sorted"] = "SORTED";
    TableAccessType["hashed"] = "HASHED";
    TableAccessType["index"] = "INDEX";
    TableAccessType["any"] = "ANY";
})(TableAccessType || (exports.TableAccessType = TableAccessType = {}));
var TableKeyType;
(function (TableKeyType) {
    TableKeyType["default"] = "DEFAULT";
    TableKeyType["user"] = "USER";
    TableKeyType["empty"] = "EMPTY";
})(TableKeyType || (exports.TableKeyType = TableKeyType = {}));
class LoopController {
    constructor(from, loopTo, array) {
        this.index = from;
        this.loopTo = loopTo;
        this.array = array;
    }
}
exports.LoopController = LoopController;
class TableFactory {
    static construct(rowType, options, qualifiedName) {
        if (options === undefined) {
            options = {
                primaryKey: {
                    name: "primary_key",
                    type: TableAccessType.standard,
                    keyFields: [],
                    isUnique: false,
                },
                keyType: TableKeyType.default,
                withHeader: false,
            };
        }
        if (options.primaryKey?.type === TableAccessType.hashed) {
            return new HashedTable(rowType, options, qualifiedName);
        }
        else {
            return new Table(rowType, options, qualifiedName);
        }
    }
}
exports.TableFactory = TableFactory;
/*
export class SortedTable {
  // todo
}
*/
class HashedTable {
    constructor(rowType, options, qualifiedName) {
        this.value = {};
        this.secondaryIndexes = {};
        this.loops = new Set();
        this.rowType = rowType;
        this.options = options;
        this.options = options;
        if (options?.withHeader === true) {
            this.header = (0, clone_1.clone)(this.rowType);
        }
        this.qualifiedName = qualifiedName?.toUpperCase();
    }
    getArrayLength() {
        return Object.keys(this.value).length;
    }
    getKeyByName(name) {
        return this.getOptions()?.secondary?.find(s => s.name.toUpperCase() === name.toUpperCase());
    }
    getSecondaryIndex(name) {
        if (this.secondaryIndexes[name.toUpperCase()]) {
            return this.secondaryIndexes[name.toUpperCase()];
        }
        const secondary = this.getKeyByName(name);
        if (secondary === undefined) {
            throw `Table, secondary key "${name}" not found`;
        }
        // note, array() already is a copy, so it can be used,
        const copy = this.array();
        (0, sort_1.sort)(copy, { by: secondary.keyFields.map(k => { return { component: k.toLowerCase() }; }) });
        this.secondaryIndexes[name.toUpperCase()] = copy;
        return copy;
    }
    buildHashFromData(data) {
        let hash = "";
        for (const k of this.options.primaryKey.keyFields) {
            if (k === "TABLE_LINE") {
                if (data instanceof structure_1.Structure) {
                    hash += k + ":" + data.getCharacter() + "|";
                }
                else {
                    // @ts-ignore
                    hash += k + ":" + data.get() + "|";
                }
            }
            else {
                // @ts-ignore
                let val = data.get()[k.toLowerCase()];
                if (val instanceof structure_1.Structure) {
                    val = val.getCharacter();
                }
                else {
                    val = val.get();
                }
                hash += k + ":" + val + "|";
            }
        }
        return hash;
    }
    deleteIndex(_index) {
        throw new Error("HashedTable, deleteIndex");
    }
    deleteFrom(row) {
        const hash = this.buildHashFromData(row);
        delete this.value[hash];
    }
    buildHashFromSimple(data) {
        let hash = "";
        const ttyp = this.getRowType();
        for (const k of this.options.primaryKey.keyFields) {
            let val = data[k.toLowerCase()];
            if (val instanceof structure_1.Structure) {
                val = val.getCharacter();
            }
            else {
                // convert to correct type, eg Chars have specific length, or rounding,
                if (k === "TABLE_LINE") {
                    const rowType = (0, clone_1.clone)(ttyp);
                    rowType.set(val.get());
                    val = rowType.get();
                }
                else if (ttyp instanceof structure_1.Structure) {
                    const field = ttyp.get()[k.toLowerCase()];
                    // if types match, there is no need to clone
                    if (field instanceof string_1.String && val instanceof string_1.String) {
                        val = val.get();
                    }
                    else if (field instanceof character_1.Character && val instanceof character_1.Character && field.getLength() === val.getLength()) {
                        val = val.get();
                    }
                    else if (field instanceof hex_1.Hex && val instanceof hex_1.Hex && field.getLength() === val.getLength()) {
                        val = val.get();
                    }
                    else if (field instanceof hex_uint8_1.HexUInt8 && val instanceof hex_uint8_1.HexUInt8 && field.getLength() === val.getLength()) {
                        val = val.get();
                    }
                    else {
                        // convert
                        const rowType = (0, clone_1.clone)(field);
                        rowType.set(val.get());
                        val = rowType.get();
                    }
                }
                else {
                    throw new Error("HashedTable, buildHashFromSimple, unexpected type");
                }
            }
            hash += k + ":" + val + "|";
        }
        return hash;
    }
    read(hash) {
        return this.value[hash];
    }
    insert(data) {
        const hash = this.buildHashFromData(data);
        if (this.value[hash] !== undefined) {
            return { value: undefined, subrc: 4 };
        }
        else {
            const val = this.cloneRow(data);
            for (const loopController of this.loops.values()) {
                loopController.array.push(val);
            }
            this.value[hash] = val;
            return { value: val, subrc: 0 };
        }
    }
    array() {
        // used for LOOP
        const ret = [];
        for (const hash in this.value) {
            ret.push(this.value[hash]);
        }
        return ret;
    }
    startLoop(from, to, array) {
        const l = new LoopController(from, to, array);
        this.loops.add(l);
        return l;
    }
    unregisterLoop(loop) {
        this.loops.delete(loop);
    }
    insertIndex(_item, _index) {
        throw new Error("Hash table insert index");
    }
    append(_item) {
        throw new Error("Hash table append");
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    getOptions() {
        return this.options;
    }
    getRowType() {
        return this.rowType;
    }
    clear() {
        this.value = {};
        this.secondaryIndexes = {};
    }
    set(tab) {
        if (tab instanceof field_symbol_1.FieldSymbol) {
            if (tab.getPointer() === undefined) {
                throw new Error("GETWA_NOT_ASSIGNED");
            }
            return this.set(tab.getPointer());
        }
        if (tab === this) {
            return this;
        }
        this.clear();
        if (tab instanceof Table || tab instanceof HashedTable) {
            for (const a of tab.array()) {
                this.insert(a);
            }
            return this;
        }
        else {
            throw new Error("Method not implemented, set hashed table");
        }
    }
    getHeader() {
        if (this.header === undefined) {
            throw "table, getHeader";
        }
        return this.header;
    }
    ///////////////////////////
    cloneRow(item) {
        // make sure to do conversion if needed
        if (typeof item === "number") {
            const tmp = (0, clone_1.clone)(this.getRowType());
            tmp.set(new integer_1.Integer().set(item));
            return tmp;
        }
        else if (typeof item === "string") {
            const tmp = (0, clone_1.clone)(this.getRowType());
            tmp.set(new string_1.String().set(item));
            return tmp;
            // @ts-ignore
            // eslint-disable-next-line max-len
        }
        else if (this.isStructured === true && item.getQualifiedName && this.rowType.getQualifiedName && item.getQualifiedName() !== "" && item.getQualifiedName() === this.rowType.getQualifiedName()) {
            // types match, so no need to do conversions, just clone the item
            const val = (0, clone_1.clone)(item);
            return val;
        }
        else {
            const tmp = (0, clone_1.clone)(this.getRowType());
            tmp.set(item);
            return tmp;
        }
    }
}
exports.HashedTable = HashedTable;
class Table {
    constructor(rowType, options, qualifiedName) {
        this.value = [];
        this.secondaryIndexes = {};
        this.loops = new Set();
        this.rowType = rowType;
        this.options = options;
        this.isStructured = rowType instanceof structure_1.Structure;
        if (options?.withHeader === true) {
            this.header = (0, clone_1.clone)(this.rowType);
        }
        this.qualifiedName = qualifiedName?.toUpperCase();
    }
    getArrayLength() {
        return this.value.length;
    }
    getKeyByName(name) {
        return this.getOptions()?.secondary?.find(s => s.name.toUpperCase() === name.toUpperCase());
    }
    getSecondaryIndex(name) {
        if (this.secondaryIndexes[name.toUpperCase()]) {
            return this.secondaryIndexes[name.toUpperCase()];
        }
        const secondary = this.getKeyByName(name);
        if (secondary === undefined) {
            throw `Table, secondary key "${name}" not found`;
        }
        const copy = [...this.value];
        (0, sort_1.sort)(copy, { by: secondary.keyFields.map(k => { return { component: k.toLowerCase() }; }), skipSortedCheck: true });
        this.secondaryIndexes[name.toUpperCase()] = copy;
        return copy;
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    getOptions() {
        return this.options;
    }
    startLoop(from, to, array) {
        const l = new LoopController(from, to, array);
        this.loops.add(l);
        return l;
    }
    unregisterLoop(loop) {
        this.loops.delete(loop);
    }
    getRowType() {
        return this.rowType;
    }
    // Modifications to the array must be done inside this class, in order to keep track of LOOP indexes
    array() {
        return this.value;
    }
    clear() {
        this.value = [];
        this.secondaryIndexes = {};
    }
    set(tab) {
        this.secondaryIndexes = {};
        if (this.options?.withHeader === true) {
            this.header?.set(tab);
        }
        else {
            if (!(tab instanceof Table) && !(tab instanceof field_symbol_1.FieldSymbol)) {
                throw "Table, set error";
            }
            if (tab instanceof field_symbol_1.FieldSymbol) {
                tab = tab.getPointer();
            }
            if (tab === this) {
                return this;
            }
            this.clear();
            // this clones the values, and add sorting if required
            (0, insert_internal_1.insertInternal)({ table: this, data: tab, lines: true });
        }
        return this;
    }
    getHeader() {
        if (this.header === undefined) {
            throw "table, getHeader";
        }
        return this.header;
    }
    insertIndex(item, index, noClone = false) {
        this.secondaryIndexes = {};
        if (item instanceof field_symbol_1.FieldSymbol) {
            const p = item.getPointer();
            if (p === undefined) {
                throw new Error("insertIndex, fs not assigned");
            }
            this.insertIndex(p, index);
            return p;
        }
        let val;
        if (noClone === false) {
            val = this.cloneRow(item);
        }
        else {
            val = item;
        }
        if (index === 0) {
            this.value.unshift(val);
        }
        else if (index === this.value.length) {
            this.value.push(val);
        }
        else {
            this.value.splice(index, 0, val);
        }
        for (const loopController of this.loops.values()) {
            if (index <= loopController.index) {
                loopController.index++;
            }
        }
        return val;
    }
    /** index = javascript indexed */
    deleteIndex(index) {
        this.secondaryIndexes = {};
        if (index > this.value.length) {
            return;
        }
        if (index === this.value.length - 1) {
            this.value.pop(); // pop'ing is faster than splice
        }
        else if (index === 0) {
            this.value.shift();
        }
        else {
            this.value.splice(index, 1);
        }
        for (const l of this.loops.values()) {
            if (l.index >= index) {
                l.index--;
            }
        }
    }
    append(item) {
        this.secondaryIndexes = {};
        if (item instanceof field_symbol_1.FieldSymbol) {
            const p = item.getPointer();
            if (p === undefined) {
                throw new Error("APPEND, fs not assigned");
            }
            this.append(p);
            return p;
        }
        else if (item instanceof data_reference_1.DataReference) {
            const ref = new data_reference_1.DataReference(item.getType());
            ref.assign(item.getPointer());
            this.value.push(ref);
            return ref;
        }
        else {
            const val = this.cloneRow(item);
            this.value.push(val);
            return val;
        }
    }
    appendInitial() {
        this.secondaryIndexes = {};
        // note that this will clone the object
        this.append(this.rowType);
        // @ts-ignore
        abap.builtin.sy.get().tabix.set(this.value.length);
        return this.value[this.value.length - 1];
    }
    sort(compareFn) {
        this.value.sort(compareFn);
    }
    ///////////////////////////
    cloneRow(item) {
        // make sure to do conversion if needed
        if (typeof item === "number") {
            const tmp = (0, clone_1.clone)(this.getRowType());
            tmp.set(new integer_1.Integer().set(item));
            return tmp;
        }
        else if (typeof item === "string") {
            const tmp = (0, clone_1.clone)(this.getRowType());
            tmp.set(new string_1.String().set(item));
            return tmp;
            // @ts-ignore
            // eslint-disable-next-line max-len
        }
        else if (this.isStructured === true && item.getQualifiedName && this.rowType.getQualifiedName && item.getQualifiedName() !== "" && item.getQualifiedName() === this.rowType.getQualifiedName()) {
            // types match, so no need to do conversions, just clone the item
            const val = (0, clone_1.clone)(item);
            return val;
        }
        else {
            const tmp = (0, clone_1.clone)(this.getRowType());
            tmp.set(item);
            return tmp;
        }
    }
}
exports.Table = Table;
//# sourceMappingURL=table.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/time.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/time.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Time = void 0;
const string_1 = __webpack_require__(/*! ./string */ "./node_modules/@abaplint/runtime/build/src/types/string.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/runtime/build/src/types/index.js");
const _parse_1 = __webpack_require__(/*! ../operators/_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
class Time {
    constructor(input) {
        this.clear();
        this.qualifiedName = input?.qualifiedName;
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    set(value) {
        if (typeof value === "number") {
            const date = new Date();
            date.setTime(value * 1000);
            this.value = date.getUTCHours().toString().padStart(2, "0") +
                date.getUTCMinutes().toString().padStart(2, "0") +
                date.getUTCSeconds().toString().padStart(2, "0");
        }
        else if (typeof value === "string") {
            this.value = value;
            if (this.value.length > 6) {
                this.value = this.value.substring(0, 6);
            }
        }
        else if (value instanceof string_1.String) {
            this.set(value.get().padEnd(6, "0"));
        }
        else if (value instanceof _1.Float) {
            this.set(Math.round(value.getRaw()));
        }
        else {
            this.set(value.get());
        }
        return this;
    }
    clear() {
        this.value = "000000";
    }
    get() {
        return this.value;
    }
    getNumeric() {
        const hours = parseInt(this.value.substr(0, 2), 10);
        const minutes = parseInt(this.value.substr(2, 2), 10);
        const seconds = parseInt(this.value.substr(4, 2), 10);
        return hours * 3600 + minutes * 60 + seconds;
    }
    getOffset(input) {
        if (input?.offset) {
            input.offset = (0, _parse_1.parse)(input.offset);
        }
        if (input?.length) {
            input.length = (0, _parse_1.parse)(input.length);
        }
        let ret = this.value;
        if (input?.offset) {
            // @ts-ignore
            ret = ret.substr(input.offset);
        }
        if (input?.length !== undefined) {
            // @ts-ignore
            ret = ret.substr(0, input.length);
        }
        const r = new string_1.String();
        r.set(ret);
        return r;
    }
}
exports.Time = Time;
//# sourceMappingURL=time.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/utc_long.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/utc_long.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UTCLong = void 0;
class UTCLong {
    constructor(input) {
        this.clear();
        this.qualifiedName = input?.qualifiedName;
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    getOffset(_input) {
        throw new Error("Method not implemented, getOffset(), utcLong");
    }
    set(_value) {
        // todo
        return this;
    }
    clear() {
        this.value = "";
    }
    get() {
        return this.value;
    }
}
exports.UTCLong = UTCLong;
//# sourceMappingURL=utc_long.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/types/xstring.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/types/xstring.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XString = void 0;
const _parse_1 = __webpack_require__(/*! ../operators/_parse */ "./node_modules/@abaplint/runtime/build/src/operators/_parse.js");
const float_1 = __webpack_require__(/*! ./float */ "./node_modules/@abaplint/runtime/build/src/types/float.js");
const character_1 = __webpack_require__(/*! ./character */ "./node_modules/@abaplint/runtime/build/src/types/character.js");
const throw_error_1 = __webpack_require__(/*! ../throw_error */ "./node_modules/@abaplint/runtime/build/src/throw_error.js");
const integer8_1 = __webpack_require__(/*! ./integer8 */ "./node_modules/@abaplint/runtime/build/src/types/integer8.js");
class XString {
    constructor(input) {
        this.value = "";
        this.qualifiedName = input?.qualifiedName;
    }
    getQualifiedName() {
        return this.qualifiedName;
    }
    set(value) {
        if (typeof value === "string") {
            this.value = value;
            if (this.value.length % 2 === 1) {
                this.value = this.value + "0";
            }
        }
        else if (typeof value === "number") {
            this.value = Math.round(value).toString(16).toUpperCase();
            if (this.value.length % 2 === 1) {
                this.value = "0" + this.value;
            }
        }
        else {
            let v = value.get();
            if (value instanceof float_1.Float) {
                v = value.getRaw();
                this.set(v);
            }
            else if (value instanceof character_1.Character) {
                this.set(value.getTrimEnd());
            }
            else if (typeof v === "number") {
                this.value = v.toString(16).toUpperCase();
                if (this.value.length % 2 === 1) {
                    this.value = "0" + this.value;
                }
            }
            else {
                this.set(v);
            }
        }
        return this;
    }
    clear() {
        this.value = "";
    }
    get() {
        return this.value;
    }
    getOffset(input) {
        let offset = input?.offset;
        if (offset) {
            if (offset instanceof integer8_1.Integer8) {
                offset = Number(offset.get());
            }
            else {
                offset = (0, _parse_1.parse)(offset);
            }
            if (offset * 2 > this.value.length
                || offset < 0) {
                (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
            }
        }
        let length = input?.length;
        if (length) {
            if (length instanceof integer8_1.Integer8) {
                length = Number(length.get());
            }
            else {
                length = (0, _parse_1.parse)(length);
            }
            if (length * 2 > this.value.length
                || length < 0) {
                (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
            }
        }
        // NOTE: this only copies the minimal length of the string,
        if (offset !== undefined && length !== undefined) {
            if (offset * 2 + length * 2 > this.value.length) {
                (0, throw_error_1.throwError)("CX_SY_RANGE_OUT_OF_BOUNDS");
            }
            return new XString().set(this.value.substr(offset * 2, length * 2));
        }
        else if (offset !== undefined) {
            return new XString().set(this.value.substr(offset * 2));
        }
        else if (length !== undefined) {
            return new XString().set(this.value.substr(0, length * 2));
        }
        else {
            throw new Error("xstring: getOffset, unexpected");
        }
    }
}
exports.XString = XString;
//# sourceMappingURL=xstring.js.map

/***/ }),

/***/ "./node_modules/@abaplint/runtime/build/src/unit_test.js":
/*!***************************************************************!*\
  !*** ./node_modules/@abaplint/runtime/build/src/unit_test.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnitTestResult = void 0;
/* eslint-disable max-len */
class UnitTestMethodResult {
    constructor(name) {
        this.name = name;
        this.result = undefined;
        this.result = undefined;
    }
    pass() {
        this.result = "Pass";
    }
    fail() {
        this.result = "Fail";
    }
    skip() {
        this.result = "Skip";
    }
}
class UnitTestClassResult {
    constructor(name) {
        this.name = name;
        this.methods = [];
    }
    addMethod(name) {
        const ret = new UnitTestMethodResult(name);
        this.methods.push(ret);
        return ret;
    }
}
class UnitTestObjectResult {
    constructor(name) {
        this.name = name;
        this.classes = [];
    }
    addTestClass(name) {
        const ret = new UnitTestClassResult(name);
        this.classes.push(ret);
        return ret;
    }
}
class UnitTestResult {
    constructor() {
        this.objects = [];
    }
    addObject(name) {
        const ret = new UnitTestObjectResult(name);
        this.objects.push(ret);
        return ret;
    }
    xUnitXML() {
        // https://xunit.net/docs/format-xml-v2
        // <assemblies> = project
        // <assembly> = global object/global class
        // <collection> = local class
        // <test> = method
        let ret = `<?xml version="1.0" encoding="utf-8"?>\n<assemblies>\n`;
        for (const obj of this.objects) {
            ret += `  <assembly name="${obj.name}" test-framework="abap-framework" environment="abap-environment">\n`;
            for (const clas of obj.classes) {
                ret += `    <collection name="${clas.name}">\n`;
                for (const meth of clas.methods) {
                    ret += `      ` +
                        `<test name="${obj.name}.${clas.name}.${meth.name}" type="${obj.name}.${clas.name}" method="${obj.name}.${clas.name}.${meth.name}" time="0" result="${meth.result}"></test>\n`;
                }
                ret += `    </collection>\n`;
            }
            ret += `  </assembly>\n`;
        }
        ret += `</assemblies>`;
        return ret;
    }
}
exports.UnitTestResult = UnitTestResult;
//# sourceMappingURL=unit_test.js.map

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



const base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
const ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
const customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

const K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    const arr = new Uint8Array(1)
    const proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  const buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  const valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  const b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  const length = byteLength(string, encoding) | 0
  let buf = createBuffer(length)

  const actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  const length = array.length < 0 ? 0 : checked(array.length) | 0
  const buf = createBuffer(length)
  for (let i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayView (arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    const copy = new Uint8Array(arrayView)
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
  }
  return fromArrayLike(arrayView)
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  let buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    const len = checked(obj.length) | 0
    const buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  let x = a.length
  let y = b.length

  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  let i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  const buffer = Buffer.allocUnsafe(length)
  let pos = 0
  for (i = 0; i < list.length; ++i) {
    let buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)
        buf.copy(buffer, pos)
      } else {
        Uint8Array.prototype.set.call(
          buffer,
          buf,
          pos
        )
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    } else {
      buf.copy(buffer, pos)
    }
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  const len = string.length
  const mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  let loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  const i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  const len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (let i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  const len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (let i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  const len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (let i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  const length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  let str = ''
  const max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  let x = thisEnd - thisStart
  let y = end - start
  const len = Math.min(x, y)

  const thisCopy = this.slice(thisStart, thisEnd)
  const targetCopy = target.slice(start, end)

  for (let i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  let indexSize = 1
  let arrLength = arr.length
  let valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  let i
  if (dir) {
    let foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      let found = true
      for (let j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  const remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  const strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  let i
  for (i = 0; i < length; ++i) {
    const parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  const remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  let loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  const res = []

  let i = start
  while (i < end) {
    const firstByte = buf[i]
    let codePoint = null
    let bytesPerSequence = (firstByte > 0xEF)
      ? 4
      : (firstByte > 0xDF)
          ? 3
          : (firstByte > 0xBF)
              ? 2
              : 1

    if (i + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  const len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  let res = ''
  let i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  let ret = ''
  end = Math.min(buf.length, end)

  for (let i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  const len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  let out = ''
  for (let i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  const bytes = buf.slice(start, end)
  let res = ''
  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
  for (let i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  const len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  const newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUintLE =
Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUintBE =
Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  let val = this[offset + --byteLength]
  let mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUint8 =
Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUint16LE =
Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUint16BE =
Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUint32LE =
Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUint32BE =
Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const lo = first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24

  const hi = this[++offset] +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    last * 2 ** 24

  return BigInt(lo) + (BigInt(hi) << BigInt(32))
})

Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const hi = first * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  const lo = this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last

  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
})

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let val = this[offset]
  let mul = 1
  let i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  let i = byteLength
  let mul = 1
  let val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  const val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = this[offset + 4] +
    this[offset + 5] * 2 ** 8 +
    this[offset + 6] * 2 ** 16 +
    (last << 24) // Overflow

  return (BigInt(val) << BigInt(32)) +
    BigInt(first +
    this[++offset] * 2 ** 8 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 24)
})

Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
  offset = offset >>> 0
  validateNumber(offset, 'offset')
  const first = this[offset]
  const last = this[offset + 7]
  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8)
  }

  const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    this[++offset]

  return (BigInt(val) << BigInt(32)) +
    BigInt(this[++offset] * 2 ** 24 +
    this[++offset] * 2 ** 16 +
    this[++offset] * 2 ** 8 +
    last)
})

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUintLE =
Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let mul = 1
  let i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUintBE =
Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    const maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  let i = byteLength - 1
  let mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUint8 =
Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUint16LE =
Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUint16BE =
Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUint32LE =
Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUint32BE =
Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function wrtBigUInt64LE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  lo = lo >> 8
  buf[offset++] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  hi = hi >> 8
  buf[offset++] = hi
  return offset
}

function wrtBigUInt64BE (buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7)

  let lo = Number(value & BigInt(0xffffffff))
  buf[offset + 7] = lo
  lo = lo >> 8
  buf[offset + 6] = lo
  lo = lo >> 8
  buf[offset + 5] = lo
  lo = lo >> 8
  buf[offset + 4] = lo
  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))
  buf[offset + 3] = hi
  hi = hi >> 8
  buf[offset + 2] = hi
  hi = hi >> 8
  buf[offset + 1] = hi
  hi = hi >> 8
  buf[offset] = hi
  return offset + 8
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
})

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = 0
  let mul = 1
  let sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    const limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  let i = byteLength - 1
  let mul = 1
  let sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
})

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  const len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      const code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  let i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    const bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    const len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// CUSTOM ERRORS
// =============

// Simplified versions from Node, changed for Buffer-only usage
const errors = {}
function E (sym, getMessage, Base) {
  errors[sym] = class NodeError extends Base {
    constructor () {
      super()

      Object.defineProperty(this, 'message', {
        value: getMessage.apply(this, arguments),
        writable: true,
        configurable: true
      })

      // Add the error code to the name to include it in the stack trace.
      this.name = `${this.name} [${sym}]`
      // Access the stack to generate the error message including the error code
      // from the name.
      this.stack // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.
      delete this.name
    }

    get code () {
      return sym
    }

    set code (value) {
      Object.defineProperty(this, 'code', {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      })
    }

    toString () {
      return `${this.name} [${sym}]: ${this.message}`
    }
  }
}

E('ERR_BUFFER_OUT_OF_BOUNDS',
  function (name) {
    if (name) {
      return `${name} is outside of buffer bounds`
    }

    return 'Attempt to access memory outside buffer bounds'
  }, RangeError)
E('ERR_INVALID_ARG_TYPE',
  function (name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
  }, TypeError)
E('ERR_OUT_OF_RANGE',
  function (str, range, input) {
    let msg = `The value of "${str}" is out of range.`
    let received = input
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input))
    } else if (typeof input === 'bigint') {
      received = String(input)
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received)
      }
      received += 'n'
    }
    msg += ` It must be ${range}. Received ${received}`
    return msg
  }, RangeError)

function addNumericalSeparator (val) {
  let res = ''
  let i = val.length
  const start = val[0] === '-' ? 1 : 0
  for (; i >= start + 4; i -= 3) {
    res = `_${val.slice(i - 3, i)}${res}`
  }
  return `${val.slice(0, i)}${res}`
}

// CHECK FUNCTIONS
// ===============

function checkBounds (buf, offset, byteLength) {
  validateNumber(offset, 'offset')
  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1))
  }
}

function checkIntBI (value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    const n = typeof min === 'bigint' ? 'n' : ''
    let range
    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`
      } else {
        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
                `${(byteLength + 1) * 8 - 1}${n}`
      }
    } else {
      range = `>= ${min}${n} and <= ${max}${n}`
    }
    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
  }
  checkBounds(buf, offset, byteLength)
}

function validateNumber (value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
  }
}

function boundsError (value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type)
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',
                                    `>= ${type ? 1 : 0} and <= ${length}`,
                                    value)
}

// HELPER FUNCTIONS
// ================

const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  let codePoint
  const length = string.length
  let leadSurrogate = null
  const bytes = []

  for (let i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  let c, hi, lo
  const byteArray = []
  for (let i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  let i
  for (i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = (function () {
  const alphabet = '0123456789abcdef'
  const table = new Array(256)
  for (let i = 0; i < 16; ++i) {
    const i16 = i * 16
    for (let j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

// Return not function with Error if BigInt not supported
function defineBigIntMethod (fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
}

function BufferBigIntNotDefined () {
  throw new Error('BigInt not supported')
}


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "?c7fc":
/*!*********************************!*\
  !*** process/browser (ignored) ***!
  \*********************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?2460":
/*!****************************!*\
  !*** util/types (ignored) ***!
  \****************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?d19c":
/*!*********************************************!*\
  !*** ./%23ui2%23cl_json.clas.mjs (ignored) ***!
  \*********************************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./node_modules/temporal-polyfill/chunks/EHDzkv8k.cjs":
/*!************************************************************!*\
  !*** ./node_modules/temporal-polyfill/chunks/EHDzkv8k.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


function createSlotClass(branding, construct, getters, methods, staticMethods) {
  function Class(...args) {
    if (!(this instanceof Class)) {
      throw new TypeError(internal.invalidCallingContext);
    }
    setSlots(this, construct(...args));
  }
  function bindMethod(method, methodName) {
    return Object.defineProperties((function(...args) {
      return method.call(this, getSpecificSlots(this), ...args);
    }), internal.createNameDescriptors(methodName));
  }
  function getSpecificSlots(obj) {
    const slots = getSlots(obj);
    if (!slots || slots.branding !== branding) {
      throw new TypeError(internal.invalidCallingContext);
    }
    return slots;
  }
  return Object.defineProperties(Class.prototype, {
    ...internal.createGetterDescriptors(internal.mapProps(bindMethod, getters)),
    ...internal.createPropDescriptors(internal.mapProps(bindMethod, methods)),
    ...internal.createStringTagDescriptors("Temporal." + branding)
  }), Object.defineProperties(Class, {
    ...internal.createPropDescriptors(staticMethods),
    ...internal.createNameDescriptors(branding)
  }), [ Class, slots => {
    const instance = Object.create(Class.prototype);
    return setSlots(instance, slots), instance;
  }, getSpecificSlots ];
}

function createProtocolValidator(propNames) {
  return propNames = propNames.concat("id").sort(), obj => {
    if (!internal.hasAllPropsByName(obj, propNames)) {
      throw new TypeError(internal.invalidProtocol);
    }
    return obj;
  };
}

function rejectInvalidBag(bag) {
  if (getSlots(bag) || void 0 !== bag.calendar || void 0 !== bag.timeZone) {
    throw new TypeError(internal.invalidBag);
  }
  return bag;
}

function createFormatMethod(methodName) {
  return function(...formattables) {
    const prepFormat = internalsMap.get(this), [format, ...rawFormattables] = prepFormat(...formattables);
    return format[methodName](...rawFormattables);
  };
}

function createProxiedMethod(methodName) {
  return function(...args) {
    return internalsMap.get(this).rawFormat[methodName](...args);
  };
}

function createFormatPrepperForBranding(branding) {
  const config = classFormatConfigs[branding];
  if (!config) {
    throw new TypeError(internal.invalidFormatType(branding));
  }
  return internal.createFormatPrepper(config, internal.memoize(internal.createFormatForPrep));
}

function createCalendarFieldMethods(methodNameMap, alsoAccept) {
  const methods = {};
  for (const methodName in methodNameMap) {
    methods[methodName] = ({native: native}, dateArg) => {
      const argSlots = getSlots(dateArg) || {}, {branding: branding} = argSlots, refinedSlots = branding === internal.PlainDateBranding || alsoAccept.includes(branding) ? argSlots : toPlainDateSlots(dateArg);
      return native[methodName](refinedSlots);
    };
  }
  return methods;
}

function createCalendarGetters(methodNameMap) {
  const methods = {};
  for (const methodName in methodNameMap) {
    methods[methodName] = slots => {
      const {calendar: calendar} = slots;
      return (calendarSlot = calendar, "string" == typeof calendarSlot ? internal.createNativeStandardOps(calendarSlot) : (calendarProtocol = calendarSlot, 
      Object.assign(Object.create(adapterSimpleOps), {
        calendarProtocol: calendarProtocol
      })))[methodName](slots);
      var calendarSlot, calendarProtocol;
    };
  }
  return methods;
}

function neverValueOf() {
  throw new TypeError(internal.forbiddenValueOf);
}

function createCalendarFromSlots({calendar: calendar}) {
  return "string" == typeof calendar ? new Calendar(calendar) : calendar;
}

function toPlainMonthDaySlots(arg, options) {
  if (options = internal.copyOptions(options), internal.isObjectLike(arg)) {
    const slots = getSlots(arg);
    if (slots && slots.branding === internal.PlainMonthDayBranding) {
      return internal.refineOverflowOptions(options), slots;
    }
    const calendarMaybe = extractCalendarSlotFromBag(arg), calendar = calendarMaybe || internal.isoCalendarId;
    return internal.refinePlainMonthDayBag(createMonthDayRefineOps(calendar), !calendarMaybe, arg, options);
  }
  const res = internal.parsePlainMonthDay(internal.createNativeStandardOps, arg);
  return internal.refineOverflowOptions(options), res;
}

function getOffsetNanosecondsForAdapter(timeZoneProtocol, getOffsetNanosecondsFor, epochNano) {
  return offsetNano = getOffsetNanosecondsFor.call(timeZoneProtocol, createInstant(internal.createInstantSlots(epochNano))), 
  internal.validateTimeZoneOffset(internal.requireInteger(offsetNano));
  var offsetNano;
}

function createAdapterOps(timeZoneProtocol, adapterFuncs = timeZoneAdapters) {
  const keys = Object.keys(adapterFuncs).sort(), boundFuncs = {};
  for (const key of keys) {
    boundFuncs[key] = internal.bindArgs(adapterFuncs[key], timeZoneProtocol, internal.requireFunction(timeZoneProtocol[key]));
  }
  return boundFuncs;
}

function createTimeZoneOps(timeZoneSlot, adapterFuncs) {
  return "string" == typeof timeZoneSlot ? internal.queryNativeTimeZone(timeZoneSlot) : createAdapterOps(timeZoneSlot, adapterFuncs);
}

function createTimeZoneOffsetOps(timeZoneSlot) {
  return createTimeZoneOps(timeZoneSlot, simpleTimeZoneAdapters);
}

function toInstantSlots(arg) {
  if (internal.isObjectLike(arg)) {
    const slots = getSlots(arg);
    if (slots) {
      switch (slots.branding) {
       case internal.InstantBranding:
        return slots;

       case internal.ZonedDateTimeBranding:
        return internal.createInstantSlots(slots.epochNanoseconds);
      }
    }
  }
  return internal.parseInstant(arg);
}

function getImplTransition(direction, impl, instantArg) {
  const epochNano = impl.getTransition(toInstantSlots(instantArg).epochNanoseconds, direction);
  return epochNano ? createInstant(internal.createInstantSlots(epochNano)) : null;
}

function refineTimeZoneSlot(arg) {
  return internal.isObjectLike(arg) ? (getSlots(arg) || {}).timeZone || validateTimeZoneProtocol(arg) : (arg => internal.resolveTimeZoneId(internal.parseTimeZoneId(internal.requireString(arg))))(arg);
}

function toPlainTimeSlots(arg, options) {
  if (internal.isObjectLike(arg)) {
    const slots = getSlots(arg) || {};
    switch (slots.branding) {
     case internal.PlainTimeBranding:
      return internal.refineOverflowOptions(options), slots;

     case internal.PlainDateTimeBranding:
      return internal.refineOverflowOptions(options), internal.createPlainTimeSlots(slots);

     case internal.ZonedDateTimeBranding:
      return internal.refineOverflowOptions(options), internal.zonedDateTimeToPlainTime(createTimeZoneOffsetOps, slots);
    }
    return internal.refinePlainTimeBag(arg, options);
  }
  return internal.refineOverflowOptions(options), internal.parsePlainTime(arg);
}

function optionalToPlainTimeFields(timeArg) {
  return void 0 === timeArg ? void 0 : toPlainTimeSlots(timeArg);
}

function toPlainYearMonthSlots(arg, options) {
  if (options = internal.copyOptions(options), internal.isObjectLike(arg)) {
    const slots = getSlots(arg);
    return slots && slots.branding === internal.PlainYearMonthBranding ? (internal.refineOverflowOptions(options), 
    slots) : internal.refinePlainYearMonthBag(createYearMonthRefineOps(getCalendarSlotFromBag(arg)), arg, options);
  }
  const res = internal.parsePlainYearMonth(internal.createNativeStandardOps, arg);
  return internal.refineOverflowOptions(options), res;
}

function toPlainDateTimeSlots(arg, options) {
  if (options = internal.copyOptions(options), internal.isObjectLike(arg)) {
    const slots = getSlots(arg) || {};
    switch (slots.branding) {
     case internal.PlainDateTimeBranding:
      return internal.refineOverflowOptions(options), slots;

     case internal.PlainDateBranding:
      return internal.refineOverflowOptions(options), internal.createPlainDateTimeSlots({
        ...slots,
        ...internal.isoTimeFieldDefaults
      });

     case internal.ZonedDateTimeBranding:
      return internal.refineOverflowOptions(options), internal.zonedDateTimeToPlainDateTime(createTimeZoneOffsetOps, slots);
    }
    return internal.refinePlainDateTimeBag(createDateRefineOps(getCalendarSlotFromBag(arg)), arg, options);
  }
  const res = internal.parsePlainDateTime(arg);
  return internal.refineOverflowOptions(options), res;
}

function toPlainDateSlots(arg, options) {
  if (options = internal.copyOptions(options), internal.isObjectLike(arg)) {
    const slots = getSlots(arg) || {};
    switch (slots.branding) {
     case internal.PlainDateBranding:
      return internal.refineOverflowOptions(options), slots;

     case internal.PlainDateTimeBranding:
      return internal.refineOverflowOptions(options), internal.createPlainDateSlots(slots);

     case internal.ZonedDateTimeBranding:
      return internal.refineOverflowOptions(options), internal.zonedDateTimeToPlainDate(createTimeZoneOffsetOps, slots);
    }
    return internal.refinePlainDateBag(createDateRefineOps(getCalendarSlotFromBag(arg)), arg, options);
  }
  const res = internal.parsePlainDate(arg);
  return internal.refineOverflowOptions(options), res;
}

function dayAdapter(calendarProtocol, dayMethod, isoFields) {
  return internal.requirePositiveInteger(dayMethod.call(calendarProtocol, createPlainDate(internal.createPlainDateSlots(isoFields, calendarProtocol))));
}

function createCompoundOpsCreator(adapterFuncs) {
  return calendarSlot => "string" == typeof calendarSlot ? internal.createNativeStandardOps(calendarSlot) : ((calendarProtocol, adapterFuncs) => {
    const keys = Object.keys(adapterFuncs).sort(), boundFuncs = {};
    for (const key of keys) {
      boundFuncs[key] = internal.bindArgs(adapterFuncs[key], calendarProtocol, calendarProtocol[key]);
    }
    return boundFuncs;
  })(calendarSlot, adapterFuncs);
}

function toDurationSlots(arg) {
  if (internal.isObjectLike(arg)) {
    const slots = getSlots(arg);
    return slots && slots.branding === internal.DurationBranding ? slots : internal.refineDurationBag(arg);
  }
  return internal.parseDuration(arg);
}

function refinePublicRelativeTo(relativeTo) {
  if (void 0 !== relativeTo) {
    if (internal.isObjectLike(relativeTo)) {
      const slots = getSlots(relativeTo) || {};
      switch (slots.branding) {
       case internal.ZonedDateTimeBranding:
       case internal.PlainDateBranding:
        return slots;

       case internal.PlainDateTimeBranding:
        return internal.createPlainDateSlots(slots);
      }
      const calendar = getCalendarSlotFromBag(relativeTo);
      return {
        ...internal.refineMaybeZonedDateTimeBag(refineTimeZoneSlot, createTimeZoneOps, createDateRefineOps(calendar), relativeTo),
        calendar: calendar
      };
    }
    return internal.parseRelativeToSlots(relativeTo);
  }
}

function getCalendarSlotFromBag(bag) {
  return extractCalendarSlotFromBag(bag) || internal.isoCalendarId;
}

function extractCalendarSlotFromBag(bag) {
  const {calendar: calendar} = bag;
  if (void 0 !== calendar) {
    return refineCalendarSlot(calendar);
  }
}

function refineCalendarSlot(arg) {
  return internal.isObjectLike(arg) ? (getSlots(arg) || {}).calendar || validateCalendarProtocol(arg) : (arg => internal.resolveCalendarId(internal.parseCalendarId(internal.requireString(arg))))(arg);
}

function toZonedDateTimeSlots(arg, options) {
  if (options = internal.copyOptions(options), internal.isObjectLike(arg)) {
    const slots = getSlots(arg);
    if (slots && slots.branding === internal.ZonedDateTimeBranding) {
      return internal.refineZonedFieldOptions(options), slots;
    }
    const calendarSlot = getCalendarSlotFromBag(arg);
    return internal.refineZonedDateTimeBag(refineTimeZoneSlot, createTimeZoneOps, createDateRefineOps(calendarSlot), calendarSlot, arg, options);
  }
  return internal.parseZonedDateTime(arg, options);
}

function slotsToIso(slots) {
  return internal.zonedEpochSlotsToIso(slots, createTimeZoneOffsetOps);
}

function adaptDateMethods(methods) {
  return internal.mapProps((method => slots => method(slotsToIso(slots))), methods);
}

var internal = __webpack_require__(/*! ./tM8Arf6G.cjs */ "./node_modules/temporal-polyfill/chunks/tM8Arf6G.cjs");

const slotsMap = new WeakMap, getSlots = slotsMap.get.bind(slotsMap), setSlots = slotsMap.set.bind(slotsMap), DateTimeFormat = function() {
  const members = internal.RawDateTimeFormat.prototype, memberDescriptors = Object.getOwnPropertyDescriptors(members), classDescriptors = Object.getOwnPropertyDescriptors(internal.RawDateTimeFormat), DateTimeFormat = function(locales, options = {}) {
    if (!(this instanceof DateTimeFormat)) {
      return new DateTimeFormat(locales, options);
    }
    internalsMap.set(this, ((locales, options = {}) => {
      const rawFormat = new internal.RawDateTimeFormat(locales, options), resolveOptions = rawFormat.resolvedOptions(), resolvedLocale = resolveOptions.locale, copiedOptions = internal.pluckProps(Object.keys(options), resolveOptions), queryFormatPrepperForBranding = internal.memoize(createFormatPrepperForBranding), prepFormat = (...formattables) => {
        let branding;
        const slotsList = formattables.map(((formattable, i) => {
          const slots = getSlots(formattable), slotsBranding = (slots || {}).branding;
          if (i && branding && branding !== slotsBranding) {
            throw new TypeError(internal.mismatchingFormatTypes);
          }
          return branding = slotsBranding, slots;
        }));
        return branding ? queryFormatPrepperForBranding(branding)(resolvedLocale, copiedOptions, ...slotsList) : [ rawFormat, ...formattables ];
      };
      return prepFormat.rawFormat = rawFormat, prepFormat;
    })(locales, options));
  };
  for (const memberName in memberDescriptors) {
    const memberDescriptor = memberDescriptors[memberName], formatLikeMethod = memberName.startsWith("format") && createFormatMethod(memberName);
    "function" == typeof memberDescriptor.value ? memberDescriptor.value = "constructor" === memberName ? DateTimeFormat : formatLikeMethod || createProxiedMethod(memberName) : formatLikeMethod && (memberDescriptor.get = function() {
      return formatLikeMethod.bind(this);
    });
  }
  return classDescriptors.prototype.value = Object.create(members, memberDescriptors), 
  Object.defineProperties(DateTimeFormat, classDescriptors), DateTimeFormat;
}(), internalsMap = new WeakMap, classFormatConfigs = {
  PlainYearMonth: internal.plainYearMonthConfig,
  PlainMonthDay: internal.plainMonthDayConfig,
  PlainDate: internal.plainDateConfig,
  PlainDateTime: internal.plainDateTimeConfig,
  PlainTime: internal.plainTimeConfig,
  Instant: internal.instantConfig
}, prepPlainYearMonthFormat = internal.createFormatPrepper(internal.plainYearMonthConfig), prepPlainMonthDayFormat = internal.createFormatPrepper(internal.plainMonthDayConfig), prepPlainDateFormat = internal.createFormatPrepper(internal.plainDateConfig), prepPlainDateTimeFormat = internal.createFormatPrepper(internal.plainDateTimeConfig), prepPlainTimeFormat = internal.createFormatPrepper(internal.plainTimeConfig), prepInstantFormat = internal.createFormatPrepper(internal.instantConfig), prepZonedDateTimeFormat = internal.createFormatPrepper(internal.zonedDateTimeConfig), yearMonthOnlyRefiners = {
  era: internal.requireStringOrUndefined,
  eraYear: internal.requireIntegerOrUndefined,
  year: internal.requireInteger,
  month: internal.requirePositiveInteger,
  daysInMonth: internal.requirePositiveInteger,
  daysInYear: internal.requirePositiveInteger,
  inLeapYear: internal.requireBoolean,
  monthsInYear: internal.requirePositiveInteger
}, monthOnlyRefiners = {
  monthCode: internal.requireString
}, dayOnlyRefiners = {
  day: internal.requirePositiveInteger
}, dateOnlyRefiners = {
  dayOfWeek: internal.requirePositiveInteger,
  dayOfYear: internal.requirePositiveInteger,
  weekOfYear: internal.requirePositiveIntegerOrUndefined,
  yearOfWeek: internal.requireIntegerOrUndefined,
  daysInWeek: internal.requirePositiveInteger
}, dateRefiners = {
  ...yearMonthOnlyRefiners,
  ...monthOnlyRefiners,
  ...dayOnlyRefiners,
  ...dateOnlyRefiners
}, calendarFieldMethods = {
  ...createCalendarFieldMethods(yearMonthOnlyRefiners, [ internal.PlainYearMonthBranding ]),
  ...createCalendarFieldMethods(dateOnlyRefiners, []),
  ...createCalendarFieldMethods(monthOnlyRefiners, [ internal.PlainYearMonthBranding, internal.PlainMonthDayBranding ]),
  ...createCalendarFieldMethods(dayOnlyRefiners, [ internal.PlainMonthDayBranding ])
}, dateGetters = createCalendarGetters(dateRefiners), yearMonthGetters = createCalendarGetters({
  ...yearMonthOnlyRefiners,
  ...monthOnlyRefiners
}), monthDayGetters = createCalendarGetters({
  ...monthOnlyRefiners,
  ...dayOnlyRefiners
}), calendarIdGetters = {
  calendarId: slots => internal.getId(slots.calendar)
}, adapterSimpleOps = internal.mapProps(((refiner, methodName) => function(isoFields) {
  const {calendarProtocol: calendarProtocol} = this;
  return refiner(calendarProtocol[methodName](createPlainDate(internal.createPlainDateSlots(isoFields, calendarProtocol))));
}), dateRefiners), durationGetters = internal.mapPropNames((propName => slots => slots[propName]), internal.durationFieldNamesAsc.concat("sign")), timeGetters = internal.mapPropNames(((_name, i) => slots => slots[internal.isoTimeFieldNamesAsc[i]]), internal.timeFieldNamesAsc), epochGetters = {
  epochSeconds: internal.getEpochSeconds,
  epochMilliseconds: internal.getEpochMilliseconds,
  epochMicroseconds: internal.getEpochMicroseconds,
  epochNanoseconds: internal.getEpochNanoseconds
}, removeBranding = internal.bindArgs(internal.excludePropsByName, new Set([ "branding" ])), [PlainMonthDay, createPlainMonthDay, getPlainMonthDaySlots] = createSlotClass(internal.PlainMonthDayBranding, internal.bindArgs(internal.constructPlainMonthDaySlots, refineCalendarSlot), {
  ...calendarIdGetters,
  ...monthDayGetters
}, {
  with(slots, mod, options) {
    return createPlainMonthDay(internal.plainMonthDayWithFields(createMonthDayModOps, slots, this, rejectInvalidBag(mod), options));
  },
  equals: (slots, otherArg) => internal.plainMonthDaysEqual(slots, toPlainMonthDaySlots(otherArg)),
  toString: internal.formatPlainMonthDayIso,
  toJSON: slots => internal.formatPlainMonthDayIso(slots),
  toLocaleString(slots, locales, options) {
    const [format, epochMilli] = prepPlainMonthDayFormat(locales, options, slots);
    return format.format(epochMilli);
  },
  toPlainDate(slots, bag) {
    return createPlainDate(internal.plainMonthDayToPlainDate(createDateModOps, slots, this, bag));
  },
  getISOFields: removeBranding,
  getCalendar: createCalendarFromSlots,
  valueOf: neverValueOf
}, {
  from: (arg, options) => createPlainMonthDay(toPlainMonthDaySlots(arg, options))
}), timeZoneAdapters = {
  getOffsetNanosecondsFor: getOffsetNanosecondsForAdapter,
  getPossibleInstantsFor(timeZoneProtocol, getPossibleInstantsFor, isoFields) {
    const epochNanos = [ ...getPossibleInstantsFor.call(timeZoneProtocol, createPlainDateTime(internal.createPlainDateTimeSlots(isoFields, internal.isoCalendarId))) ].map((instant => getInstantSlots(instant).epochNanoseconds)), epochNanoLen = epochNanos.length;
    return epochNanoLen > 1 && (epochNanos.sort(internal.compareBigNanos), internal.validateTimeZoneGap(internal.bigNanoToNumber(internal.diffBigNanos(epochNanos[0], epochNanos[epochNanoLen - 1])))), 
    epochNanos;
  }
}, simpleTimeZoneAdapters = {
  getOffsetNanosecondsFor: getOffsetNanosecondsForAdapter
}, [Instant, createInstant, getInstantSlots] = createSlotClass(internal.InstantBranding, internal.constructInstantSlots, epochGetters, {
  add: (slots, durationArg) => createInstant(internal.moveInstant(0, slots, toDurationSlots(durationArg))),
  subtract: (slots, durationArg) => createInstant(internal.moveInstant(1, slots, toDurationSlots(durationArg))),
  until: (slots, otherArg, options) => createDuration(internal.diffInstants(0, slots, toInstantSlots(otherArg), options)),
  since: (slots, otherArg, options) => createDuration(internal.diffInstants(1, slots, toInstantSlots(otherArg), options)),
  round: (slots, options) => createInstant(internal.roundInstant(slots, options)),
  equals: (slots, otherArg) => internal.instantsEqual(slots, toInstantSlots(otherArg)),
  toString: (slots, options) => internal.formatInstantIso(refineTimeZoneSlot, createTimeZoneOffsetOps, slots, options),
  toJSON: slots => internal.formatInstantIso(refineTimeZoneSlot, createTimeZoneOffsetOps, slots),
  toLocaleString(slots, locales, options) {
    const [format, epochMilli] = prepInstantFormat(locales, options, slots);
    return format.format(epochMilli);
  },
  toZonedDateTimeISO: (slots, timeZoneArg) => createZonedDateTime(internal.instantToZonedDateTime(slots, refineTimeZoneSlot(timeZoneArg))),
  toZonedDateTime(slots, options) {
    const refinedObj = internal.requireObjectLike(options);
    return createZonedDateTime(internal.instantToZonedDateTime(slots, refineTimeZoneSlot(refinedObj.timeZone), refineCalendarSlot(refinedObj.calendar)));
  },
  valueOf: neverValueOf
}, {
  from: arg => createInstant(toInstantSlots(arg)),
  fromEpochSeconds: epochSec => createInstant(internal.epochSecToInstant(epochSec)),
  fromEpochMilliseconds: epochMilli => createInstant(internal.epochMilliToInstant(epochMilli)),
  fromEpochMicroseconds: epochMicro => createInstant(internal.epochMicroToInstant(epochMicro)),
  fromEpochNanoseconds: epochNano => createInstant(internal.epochNanoToInstant(epochNano)),
  compare: (a, b) => internal.compareInstants(toInstantSlots(a), toInstantSlots(b))
}), [TimeZone, createTimeZone] = createSlotClass("TimeZone", (id => {
  const slotId = internal.resolveTimeZoneId(id);
  return {
    branding: "TimeZone",
    id: slotId,
    native: internal.queryNativeTimeZone(slotId)
  };
}), {
  id: slots => slots.id
}, {
  toString: slots => slots.id,
  toJSON: slots => slots.id,
  getPossibleInstantsFor: ({native: native}, plainDateTimeArg) => native.getPossibleInstantsFor(toPlainDateTimeSlots(plainDateTimeArg)).map((epochNano => createInstant(internal.createInstantSlots(epochNano)))),
  getOffsetNanosecondsFor: ({native: native}, instantArg) => native.getOffsetNanosecondsFor(toInstantSlots(instantArg).epochNanoseconds),
  getOffsetStringFor(_slots, instantArg) {
    const epochNano = toInstantSlots(instantArg).epochNanoseconds, offsetNano = createAdapterOps(this, simpleTimeZoneAdapters).getOffsetNanosecondsFor(epochNano);
    return internal.formatOffsetNano(offsetNano);
  },
  getPlainDateTimeFor(_slots, instantArg, calendarArg = internal.isoCalendarId) {
    const epochNano = toInstantSlots(instantArg).epochNanoseconds, offsetNano = createAdapterOps(this, simpleTimeZoneAdapters).getOffsetNanosecondsFor(epochNano);
    return createPlainDateTime(internal.createPlainDateTimeSlots(internal.epochNanoToIso(epochNano, offsetNano), refineCalendarSlot(calendarArg)));
  },
  getInstantFor(_slots, plainDateTimeArg, options) {
    const isoFields = toPlainDateTimeSlots(plainDateTimeArg), epochDisambig = internal.refineEpochDisambigOptions(options), calendarOps = createAdapterOps(this);
    return createInstant(internal.createInstantSlots(internal.getSingleInstantFor(calendarOps, isoFields, epochDisambig)));
  },
  getNextTransition: ({native: native}, instantArg) => getImplTransition(1, native, instantArg),
  getPreviousTransition: ({native: native}, instantArg) => getImplTransition(-1, native, instantArg),
  equals(_slots, otherArg) {
    return !!internal.isTimeZoneSlotsEqual(this, refineTimeZoneSlot(otherArg));
  }
}, {
  from(arg) {
    const timeZoneSlot = refineTimeZoneSlot(arg);
    return "string" == typeof timeZoneSlot ? new TimeZone(timeZoneSlot) : timeZoneSlot;
  }
}), validateTimeZoneProtocol = createProtocolValidator(Object.keys(timeZoneAdapters)), [PlainTime, createPlainTime] = createSlotClass(internal.PlainTimeBranding, internal.constructPlainTimeSlots, timeGetters, {
  with(_slots, mod, options) {
    return createPlainTime(internal.plainTimeWithFields(this, rejectInvalidBag(mod), options));
  },
  add: (slots, durationArg) => createPlainTime(internal.movePlainTime(0, slots, toDurationSlots(durationArg))),
  subtract: (slots, durationArg) => createPlainTime(internal.movePlainTime(1, slots, toDurationSlots(durationArg))),
  until: (slots, otherArg, options) => createDuration(internal.diffPlainTimes(0, slots, toPlainTimeSlots(otherArg), options)),
  since: (slots, otherArg, options) => createDuration(internal.diffPlainTimes(1, slots, toPlainTimeSlots(otherArg), options)),
  round: (slots, options) => createPlainTime(internal.roundPlainTime(slots, options)),
  equals: (slots, other) => internal.plainTimesEqual(slots, toPlainTimeSlots(other)),
  toString: internal.formatPlainTimeIso,
  toJSON: slots => internal.formatPlainTimeIso(slots),
  toLocaleString(slots, locales, options) {
    const [format, epochMilli] = prepPlainTimeFormat(locales, options, slots);
    return format.format(epochMilli);
  },
  toZonedDateTime: (slots, options) => createZonedDateTime(internal.plainTimeToZonedDateTime(refineTimeZoneSlot, toPlainDateSlots, createTimeZoneOps, slots, options)),
  toPlainDateTime: (slots, plainDateArg) => createPlainDateTime(internal.plainTimeToPlainDateTime(slots, toPlainDateSlots(plainDateArg))),
  getISOFields: removeBranding,
  valueOf: neverValueOf
}, {
  from: (arg, options) => createPlainTime(toPlainTimeSlots(arg, options)),
  compare: (arg0, arg1) => internal.compareIsoTimeFields(toPlainTimeSlots(arg0), toPlainTimeSlots(arg1))
}), [PlainYearMonth, createPlainYearMonth, getPlainYearMonthSlots] = createSlotClass(internal.PlainYearMonthBranding, internal.bindArgs(internal.constructPlainYearMonthSlots, refineCalendarSlot), {
  ...calendarIdGetters,
  ...yearMonthGetters
}, {
  with(slots, mod, options) {
    return createPlainYearMonth(internal.plainYearMonthWithFields(createYearMonthModOps, slots, this, rejectInvalidBag(mod), options));
  },
  add: (slots, durationArg, options) => createPlainYearMonth(internal.movePlainYearMonth(createYearMonthMoveOps, 0, slots, toDurationSlots(durationArg), options)),
  subtract: (slots, durationArg, options) => createPlainYearMonth(internal.movePlainYearMonth(createYearMonthMoveOps, 1, slots, toDurationSlots(durationArg), options)),
  until: (slots, otherArg, options) => createDuration(internal.diffPlainYearMonth(createYearMonthDiffOps, 0, slots, toPlainYearMonthSlots(otherArg), options)),
  since: (slots, otherArg, options) => createDuration(internal.diffPlainYearMonth(createYearMonthDiffOps, 1, slots, toPlainYearMonthSlots(otherArg), options)),
  equals: (slots, otherArg) => internal.plainYearMonthsEqual(slots, toPlainYearMonthSlots(otherArg)),
  toString: internal.formatPlainYearMonthIso,
  toJSON: slots => internal.formatPlainYearMonthIso(slots),
  toLocaleString(slots, locales, options) {
    const [format, epochMilli] = prepPlainYearMonthFormat(locales, options, slots);
    return format.format(epochMilli);
  },
  toPlainDate(slots, bag) {
    return createPlainDate(internal.plainYearMonthToPlainDate(createDateModOps, slots, this, bag));
  },
  getISOFields: removeBranding,
  getCalendar: createCalendarFromSlots,
  valueOf: neverValueOf
}, {
  from: (arg, options) => createPlainYearMonth(toPlainYearMonthSlots(arg, options)),
  compare: (arg0, arg1) => internal.compareIsoDateFields(toPlainYearMonthSlots(arg0), toPlainYearMonthSlots(arg1))
}), [PlainDateTime, createPlainDateTime] = createSlotClass(internal.PlainDateTimeBranding, internal.bindArgs(internal.constructPlainDateTimeSlots, refineCalendarSlot), {
  ...calendarIdGetters,
  ...dateGetters,
  ...timeGetters
}, {
  with(slots, mod, options) {
    return createPlainDateTime(internal.plainDateTimeWithFields(createDateModOps, slots, this, rejectInvalidBag(mod), options));
  },
  withPlainTime: (slots, plainTimeArg) => createPlainDateTime(internal.plainDateTimeWithPlainTime(slots, optionalToPlainTimeFields(plainTimeArg))),
  withPlainDate: (slots, plainDateArg) => createPlainDateTime(internal.plainDateTimeWithPlainDate(slots, toPlainDateSlots(plainDateArg))),
  withCalendar: (slots, calendarArg) => createPlainDateTime(internal.slotsWithCalendar(slots, refineCalendarSlot(calendarArg))),
  add: (slots, durationArg, options) => createPlainDateTime(internal.movePlainDateTime(createMoveOps, 0, slots, toDurationSlots(durationArg), options)),
  subtract: (slots, durationArg, options) => createPlainDateTime(internal.movePlainDateTime(createMoveOps, 1, slots, toDurationSlots(durationArg), options)),
  until: (slots, otherArg, options) => createDuration(internal.diffPlainDateTimes(createDiffOps, 0, slots, toPlainDateTimeSlots(otherArg), options)),
  since: (slots, otherArg, options) => createDuration(internal.diffPlainDateTimes(createDiffOps, 1, slots, toPlainDateTimeSlots(otherArg), options)),
  round: (slots, options) => createPlainDateTime(internal.roundPlainDateTime(slots, options)),
  equals: (slots, otherArg) => internal.plainDateTimesEqual(slots, toPlainDateTimeSlots(otherArg)),
  toString: (slots, options) => internal.formatPlainDateTimeIso(slots, options),
  toJSON: slots => internal.formatPlainDateTimeIso(slots),
  toLocaleString(slots, locales, options) {
    const [format, epochMilli] = prepPlainDateTimeFormat(locales, options, slots);
    return format.format(epochMilli);
  },
  toZonedDateTime: (slots, timeZoneArg, options) => createZonedDateTime(internal.plainDateTimeToZonedDateTime(createTimeZoneOps, slots, refineTimeZoneSlot(timeZoneArg), options)),
  toPlainDate: slots => createPlainDate(internal.createPlainDateSlots(slots)),
  toPlainYearMonth(slots) {
    return createPlainYearMonth(internal.plainDateTimeToPlainYearMonth(createYearMonthRefineOps, slots, this));
  },
  toPlainMonthDay(slots) {
    return createPlainMonthDay(internal.plainDateTimeToPlainMonthDay(createMonthDayRefineOps, slots, this));
  },
  toPlainTime: slots => createPlainTime(internal.createPlainTimeSlots(slots)),
  getISOFields: removeBranding,
  getCalendar: createCalendarFromSlots,
  valueOf: neverValueOf
}, {
  from: (arg, options) => createPlainDateTime(toPlainDateTimeSlots(arg, options)),
  compare: (arg0, arg1) => internal.compareIsoDateTimeFields(toPlainDateTimeSlots(arg0), toPlainDateTimeSlots(arg1))
}), [PlainDate, createPlainDate, getPlainDateSlots] = createSlotClass(internal.PlainDateBranding, internal.bindArgs(internal.constructPlainDateSlots, refineCalendarSlot), {
  ...calendarIdGetters,
  ...dateGetters
}, {
  with(slots, mod, options) {
    return createPlainDate(internal.plainDateWithFields(createDateModOps, slots, this, rejectInvalidBag(mod), options));
  },
  withCalendar: (slots, calendarArg) => createPlainDate(internal.slotsWithCalendar(slots, refineCalendarSlot(calendarArg))),
  add: (slots, durationArg, options) => createPlainDate(internal.movePlainDate(createMoveOps, 0, slots, toDurationSlots(durationArg), options)),
  subtract: (slots, durationArg, options) => createPlainDate(internal.movePlainDate(createMoveOps, 1, slots, toDurationSlots(durationArg), options)),
  until: (slots, otherArg, options) => createDuration(internal.diffPlainDates(createDiffOps, 0, slots, toPlainDateSlots(otherArg), options)),
  since: (slots, otherArg, options) => createDuration(internal.diffPlainDates(createDiffOps, 1, slots, toPlainDateSlots(otherArg), options)),
  equals: (slots, otherArg) => internal.plainDatesEqual(slots, toPlainDateSlots(otherArg)),
  toString: internal.formatPlainDateIso,
  toJSON: slots => internal.formatPlainDateIso(slots),
  toLocaleString(slots, locales, options) {
    const [format, epochMilli] = prepPlainDateFormat(locales, options, slots);
    return format.format(epochMilli);
  },
  toZonedDateTime(slots, options) {
    const optionsObj = !internal.isObjectLike(options) || options instanceof TimeZone ? {
      timeZone: options
    } : options;
    return createZonedDateTime(internal.plainDateToZonedDateTime(refineTimeZoneSlot, toPlainTimeSlots, createTimeZoneOps, slots, optionsObj));
  },
  toPlainDateTime: (slots, plainTimeArg) => createPlainDateTime(internal.plainDateToPlainDateTime(slots, optionalToPlainTimeFields(plainTimeArg))),
  toPlainYearMonth(slots) {
    return createPlainYearMonth(internal.plainDateToPlainYearMonth(createYearMonthRefineOps, slots, this));
  },
  toPlainMonthDay(slots) {
    return createPlainMonthDay(internal.plainDateToPlainMonthDay(createMonthDayRefineOps, slots, this));
  },
  getISOFields: removeBranding,
  getCalendar: createCalendarFromSlots,
  valueOf: neverValueOf
}, {
  from: (arg, options) => createPlainDate(toPlainDateSlots(arg, options)),
  compare: (arg0, arg1) => internal.compareIsoDateFields(toPlainDateSlots(arg0), toPlainDateSlots(arg1))
}), refineAdapters = {
  fields(calendarProtocol, fieldsMethod, fieldNames) {
    return [ ...fieldsMethod.call(calendarProtocol, fieldNames) ];
  }
}, dateRefineAdapters = {
  dateFromFields(calendarProtocol, dateFromFields, fields, options) {
    return getPlainDateSlots(dateFromFields.call(calendarProtocol, Object.assign(Object.create(null), fields), options));
  },
  ...refineAdapters
}, yearMonthRefineAdapters = {
  yearMonthFromFields(calendarProtocol, yearMonthFromFields, fields, options) {
    return getPlainYearMonthSlots(yearMonthFromFields.call(calendarProtocol, Object.assign(Object.create(null), fields), options));
  },
  ...refineAdapters
}, monthDayRefineAdapters = {
  monthDayFromFields(calendarProtocol, monthDayFromFields, fields, options) {
    return getPlainMonthDaySlots(monthDayFromFields.call(calendarProtocol, Object.assign(Object.create(null), fields), options));
  },
  ...refineAdapters
}, modAdapters = {
  mergeFields(calendarProtocol, mergeFields, fields, additionalFields) {
    return internal.requireObjectLike(mergeFields.call(calendarProtocol, Object.assign(Object.create(null), fields), Object.assign(Object.create(null), additionalFields)));
  }
}, dateModAdapters = {
  ...dateRefineAdapters,
  ...modAdapters
}, yearMonthModAdapters = {
  ...yearMonthRefineAdapters,
  ...modAdapters
}, monthDayModAdapters = {
  ...monthDayRefineAdapters,
  ...modAdapters
}, moveAdapters = {
  dateAdd(calendarProtocol, dateAdd, isoFields, durationFields, options) {
    return getPlainDateSlots(dateAdd.call(calendarProtocol, createPlainDate(internal.createPlainDateSlots(isoFields, calendarProtocol)), createDuration(internal.createDurationSlots(durationFields)), options));
  }
}, diffAdapters = {
  ...moveAdapters,
  dateUntil(calendarProtocol, dateUntil, isoFields0, isoFields1, largestUnit, origOptions) {
    return getDurationSlots(dateUntil.call(calendarProtocol, createPlainDate(internal.createPlainDateSlots(isoFields0, calendarProtocol)), createPlainDate(internal.createPlainDateSlots(isoFields1, calendarProtocol)), Object.assign(Object.create(null), origOptions, {
      largestUnit: internal.unitNamesAsc[largestUnit]
    })));
  }
}, yearMonthMoveAdapters = {
  ...moveAdapters,
  day: dayAdapter
}, yearMonthDiffAdapters = {
  ...diffAdapters,
  day: dayAdapter
}, createYearMonthRefineOps = createCompoundOpsCreator(yearMonthRefineAdapters), createDateRefineOps = createCompoundOpsCreator(dateRefineAdapters), createMonthDayRefineOps = createCompoundOpsCreator(monthDayRefineAdapters), createYearMonthModOps = createCompoundOpsCreator(yearMonthModAdapters), createDateModOps = createCompoundOpsCreator(dateModAdapters), createMonthDayModOps = createCompoundOpsCreator(monthDayModAdapters), createMoveOps = createCompoundOpsCreator(moveAdapters), createDiffOps = createCompoundOpsCreator(diffAdapters), createYearMonthMoveOps = createCompoundOpsCreator(yearMonthMoveAdapters), createYearMonthDiffOps = createCompoundOpsCreator(yearMonthDiffAdapters), [Duration, createDuration, getDurationSlots] = createSlotClass(internal.DurationBranding, internal.constructDurationSlots, {
  ...durationGetters,
  blank: internal.getDurationBlank
}, {
  with: (slots, mod) => createDuration(internal.durationWithFields(slots, mod)),
  add: (slots, otherArg, options) => createDuration(internal.addDurations(refinePublicRelativeTo, createDiffOps, createTimeZoneOps, 0, slots, toDurationSlots(otherArg), options)),
  subtract: (slots, otherArg, options) => createDuration(internal.addDurations(refinePublicRelativeTo, createDiffOps, createTimeZoneOps, 1, slots, toDurationSlots(otherArg), options)),
  negated: slots => createDuration(internal.negateDuration(slots)),
  abs: slots => createDuration(internal.absDuration(slots)),
  round: (slots, options) => createDuration(internal.roundDuration(refinePublicRelativeTo, createDiffOps, createTimeZoneOps, slots, options)),
  total: (slots, options) => internal.totalDuration(refinePublicRelativeTo, createDiffOps, createTimeZoneOps, slots, options),
  toString: internal.formatDurationIso,
  toLocaleString(slots, locales, options) {
    return Intl.DurationFormat ? new Intl.DurationFormat(locales, options).format(this) : internal.formatDurationIso(slots);
  },
  toJSON: slots => internal.formatDurationIso(slots),
  valueOf: neverValueOf
}, {
  from: arg => createDuration(toDurationSlots(arg)),
  compare: (durationArg0, durationArg1, options) => internal.compareDurations(refinePublicRelativeTo, createMoveOps, createTimeZoneOps, toDurationSlots(durationArg0), toDurationSlots(durationArg1), options)
}), calendarMethods = {
  toString: slots => slots.id,
  toJSON: slots => slots.id,
  ...calendarFieldMethods,
  dateAdd: ({id: id, native: native}, plainDateArg, durationArg, options) => createPlainDate(internal.createPlainDateSlots(native.dateAdd(toPlainDateSlots(plainDateArg), toDurationSlots(durationArg), options), id)),
  dateUntil: ({native: native}, plainDateArg0, plainDateArg1, options) => createDuration(internal.createDurationSlots(native.dateUntil(toPlainDateSlots(plainDateArg0), toPlainDateSlots(plainDateArg1), internal.refineCalendarDiffOptions(options)))),
  dateFromFields: ({id: id, native: native}, fields, options) => createPlainDate(internal.refinePlainDateBag(native, fields, options, internal.getRequiredDateFields(id))),
  yearMonthFromFields: ({id: id, native: native}, fields, options) => createPlainYearMonth(internal.refinePlainYearMonthBag(native, fields, options, internal.getRequiredYearMonthFields(id))),
  monthDayFromFields: ({id: id, native: native}, fields, options) => createPlainMonthDay(internal.refinePlainMonthDayBag(native, 0, fields, options, internal.getRequiredMonthDayFields(id))),
  fields({native: native}, fieldNames) {
    const allowed = new Set(internal.dateFieldNamesAlpha), fieldNamesArray = [];
    for (const fieldName of fieldNames) {
      if (internal.requireString(fieldName), !allowed.has(fieldName)) {
        throw new RangeError(internal.forbiddenField(fieldName));
      }
      allowed.delete(fieldName), fieldNamesArray.push(fieldName);
    }
    return native.fields(fieldNamesArray);
  },
  mergeFields: ({native: native}, fields0, fields1) => native.mergeFields(internal.excludeUndefinedProps(internal.requireNonNullish(fields0)), internal.excludeUndefinedProps(internal.requireNonNullish(fields1)))
}, [Calendar] = createSlotClass("Calendar", (id => {
  const slotId = internal.resolveCalendarId(internal.requireString(id));
  return {
    branding: "Calendar",
    id: slotId,
    native: internal.createNativeStandardOps(slotId)
  };
}), {
  id: slots => slots.id
}, calendarMethods, {
  from(arg) {
    const calendarSlot = refineCalendarSlot(arg);
    return "string" == typeof calendarSlot ? new Calendar(calendarSlot) : calendarSlot;
  }
}), validateCalendarProtocol = createProtocolValidator(Object.keys(calendarMethods).slice(4)), [ZonedDateTime, createZonedDateTime] = createSlotClass(internal.ZonedDateTimeBranding, internal.bindArgs(internal.constructZonedDateTimeSlots, refineCalendarSlot, refineTimeZoneSlot), {
  ...epochGetters,
  ...calendarIdGetters,
  ...adaptDateMethods(dateGetters),
  ...adaptDateMethods(timeGetters),
  hoursInDay: slots => internal.computeHoursInDay(createTimeZoneOps, slots),
  offsetNanoseconds: slots => slotsToIso(slots).offsetNanoseconds,
  offset: slots => internal.formatOffsetNano(slotsToIso(slots).offsetNanoseconds),
  timeZoneId: slots => internal.getId(slots.timeZone)
}, {
  with(slots, mod, options) {
    return createZonedDateTime(internal.zonedDateTimeWithFields(createDateModOps, createTimeZoneOps, slots, this, rejectInvalidBag(mod), options));
  },
  withPlainTime: (slots, plainTimeArg) => createZonedDateTime(internal.zonedDateTimeWithPlainTime(createTimeZoneOps, slots, optionalToPlainTimeFields(plainTimeArg))),
  withPlainDate: (slots, plainDateArg) => createZonedDateTime(internal.zonedDateTimeWithPlainDate(createTimeZoneOps, slots, toPlainDateSlots(plainDateArg))),
  withTimeZone: (slots, timeZoneArg) => createZonedDateTime(internal.slotsWithTimeZone(slots, refineTimeZoneSlot(timeZoneArg))),
  withCalendar: (slots, calendarArg) => createZonedDateTime(internal.slotsWithCalendar(slots, refineCalendarSlot(calendarArg))),
  add: (slots, durationArg, options) => createZonedDateTime(internal.moveZonedDateTime(createMoveOps, createTimeZoneOps, 0, slots, toDurationSlots(durationArg), options)),
  subtract: (slots, durationArg, options) => createZonedDateTime(internal.moveZonedDateTime(createMoveOps, createTimeZoneOps, 1, slots, toDurationSlots(durationArg), options)),
  until: (slots, otherArg, options) => createDuration(internal.createDurationSlots(internal.diffZonedDateTimes(createDiffOps, createTimeZoneOps, 0, slots, toZonedDateTimeSlots(otherArg), options))),
  since: (slots, otherArg, options) => createDuration(internal.createDurationSlots(internal.diffZonedDateTimes(createDiffOps, createTimeZoneOps, 1, slots, toZonedDateTimeSlots(otherArg), options))),
  round: (slots, options) => createZonedDateTime(internal.roundZonedDateTime(createTimeZoneOps, slots, options)),
  startOfDay: slots => createZonedDateTime(internal.computeStartOfDay(createTimeZoneOps, slots)),
  equals: (slots, otherArg) => internal.zonedDateTimesEqual(slots, toZonedDateTimeSlots(otherArg)),
  toString: (slots, options) => internal.formatZonedDateTimeIso(createTimeZoneOffsetOps, slots, options),
  toJSON: slots => internal.formatZonedDateTimeIso(createTimeZoneOffsetOps, slots),
  toLocaleString(slots, locales, options = {}) {
    const [format, epochMilli] = prepZonedDateTimeFormat(locales, options, slots);
    return format.format(epochMilli);
  },
  toInstant: slots => createInstant(internal.zonedDateTimeToInstant(slots)),
  toPlainDate: slots => createPlainDate(internal.zonedDateTimeToPlainDate(createTimeZoneOffsetOps, slots)),
  toPlainTime: slots => createPlainTime(internal.zonedDateTimeToPlainTime(createTimeZoneOffsetOps, slots)),
  toPlainDateTime: slots => createPlainDateTime(internal.zonedDateTimeToPlainDateTime(createTimeZoneOffsetOps, slots)),
  toPlainYearMonth(slots) {
    return createPlainYearMonth(internal.zonedDateTimeToPlainYearMonth(createYearMonthRefineOps, slots, this));
  },
  toPlainMonthDay(slots) {
    return createPlainMonthDay(internal.zonedDateTimeToPlainMonthDay(createMonthDayRefineOps, slots, this));
  },
  getISOFields: slots => internal.buildZonedIsoFields(createTimeZoneOffsetOps, slots),
  getCalendar: createCalendarFromSlots,
  getTimeZone: ({timeZone: timeZone}) => "string" == typeof timeZone ? new TimeZone(timeZone) : timeZone,
  valueOf: neverValueOf
}, {
  from: (arg, options) => createZonedDateTime(toZonedDateTimeSlots(arg, options)),
  compare: (arg0, arg1) => internal.compareZonedDateTimes(toZonedDateTimeSlots(arg0), toZonedDateTimeSlots(arg1))
}), Now = Object.defineProperties({}, {
  ...internal.createStringTagDescriptors("Temporal.Now"),
  ...internal.createPropDescriptors({
    timeZoneId: () => internal.getCurrentTimeZoneId(),
    instant: () => createInstant(internal.createInstantSlots(internal.getCurrentEpochNano())),
    zonedDateTime: (calendar, timeZone = internal.getCurrentTimeZoneId()) => createZonedDateTime(internal.createZonedDateTimeSlots(internal.getCurrentEpochNano(), refineTimeZoneSlot(timeZone), refineCalendarSlot(calendar))),
    zonedDateTimeISO: (timeZone = internal.getCurrentTimeZoneId()) => createZonedDateTime(internal.createZonedDateTimeSlots(internal.getCurrentEpochNano(), refineTimeZoneSlot(timeZone), internal.isoCalendarId)),
    plainDateTime: (calendar, timeZone = internal.getCurrentTimeZoneId()) => createPlainDateTime(internal.createPlainDateTimeSlots(internal.getCurrentIsoDateTime(createTimeZoneOffsetOps(refineTimeZoneSlot(timeZone))), refineCalendarSlot(calendar))),
    plainDateTimeISO: (timeZone = internal.getCurrentTimeZoneId()) => createPlainDateTime(internal.createPlainDateTimeSlots(internal.getCurrentIsoDateTime(createTimeZoneOffsetOps(refineTimeZoneSlot(timeZone))), internal.isoCalendarId)),
    plainDate: (calendar, timeZone = internal.getCurrentTimeZoneId()) => createPlainDate(internal.createPlainDateSlots(internal.getCurrentIsoDateTime(createTimeZoneOffsetOps(refineTimeZoneSlot(timeZone))), refineCalendarSlot(calendar))),
    plainDateISO: (timeZone = internal.getCurrentTimeZoneId()) => createPlainDate(internal.createPlainDateSlots(internal.getCurrentIsoDateTime(createTimeZoneOffsetOps(refineTimeZoneSlot(timeZone))), internal.isoCalendarId)),
    plainTimeISO: (timeZone = internal.getCurrentTimeZoneId()) => createPlainTime(internal.createPlainTimeSlots(internal.getCurrentIsoDateTime(createTimeZoneOffsetOps(refineTimeZoneSlot(timeZone)))))
  })
}), Temporal = Object.defineProperties({}, {
  ...internal.createStringTagDescriptors("Temporal"),
  ...internal.createPropDescriptors({
    PlainYearMonth: PlainYearMonth,
    PlainMonthDay: PlainMonthDay,
    PlainDate: PlainDate,
    PlainTime: PlainTime,
    PlainDateTime: PlainDateTime,
    ZonedDateTime: ZonedDateTime,
    Instant: Instant,
    Calendar: Calendar,
    TimeZone: TimeZone,
    Duration: Duration,
    Now: Now
  })
});

exports.DateTimeFormat = DateTimeFormat, exports.Temporal = Temporal, exports.toTemporalInstant = function() {
  return createInstant(internal.createInstantSlots(internal.numberToBigNano(this.valueOf(), internal.nanoInMilli)));
};


/***/ }),

/***/ "./node_modules/temporal-polyfill/chunks/tM8Arf6G.cjs":
/*!************************************************************!*\
  !*** ./node_modules/temporal-polyfill/chunks/tM8Arf6G.cjs ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function clampProp(props, propName, min, max, overflow) {
  return clampEntity(propName, getDefinedProp(props, propName), min, max, overflow);
}

function clampEntity(entityName, num, min, max, overflow, choices) {
  const clamped = clampNumber(num, min, max);
  if (overflow && num !== clamped) {
    throw new RangeError(numberOutOfRange(entityName, num, min, max, choices));
  }
  return clamped;
}

function getDefinedProp(props, propName) {
  const propVal = props[propName];
  if (void 0 === propVal) {
    throw new TypeError(missingField(propName));
  }
  return propVal;
}

function isObjectLike(arg) {
  return null !== arg && /object|function/.test(typeof arg);
}

function memoize(generator, MapClass = Map) {
  const map = new MapClass;
  return (key, ...otherArgs) => {
    if (map.has(key)) {
      return map.get(key);
    }
    const val = generator(key, ...otherArgs);
    return map.set(key, val), val;
  };
}

function createPropDescriptors(propVals, readonly) {
  return mapProps((value => ({
    value: value,
    configurable: 1,
    writable: !readonly
  })), propVals);
}

function zipProps(propNamesRev, args) {
  const res = {};
  let i = propNamesRev.length;
  for (const arg of args) {
    res[propNamesRev[--i]] = arg;
  }
  return res;
}

function mapProps(transformer, props, extraArg) {
  const res = {};
  for (const propName in props) {
    res[propName] = transformer(props[propName], propName, extraArg);
  }
  return res;
}

function mapPropNames(generator, propNames, extraArg) {
  const props = {};
  for (let i = 0; i < propNames.length; i++) {
    const propName = propNames[i];
    props[propName] = generator(propName, i, extraArg);
  }
  return props;
}

function pluckProps(propNames, props) {
  const res = {};
  for (const propName of propNames) {
    res[propName] = props[propName];
  }
  return res;
}

function excludePropsByName(propNames, props) {
  const filteredProps = {};
  for (const propName in props) {
    propNames.has(propName) || (filteredProps[propName] = props[propName]);
  }
  return filteredProps;
}

function allPropsEqual(propNames, props0, props1) {
  for (const propName of propNames) {
    if (props0[propName] !== props1[propName]) {
      return 0;
    }
  }
  return 1;
}

function bindArgs(f, ...boundArgs) {
  return (...dynamicArgs) => f(...boundArgs, ...dynamicArgs);
}

function capitalize(s) {
  return s[0].toUpperCase() + s.substring(1);
}

function sortStrings(strs) {
  return strs.slice().sort();
}

function padNumber(digits, num) {
  return String(num).padStart(digits, "0");
}

function compareNumbers(a, b) {
  return Math.sign(a - b);
}

function clampNumber(num, min, max) {
  return Math.min(Math.max(num, min), max);
}

function divModFloor(num, divisor) {
  return [ Math.floor(num / divisor), modFloor(num, divisor) ];
}

function modFloor(num, divisor) {
  return (num % divisor + divisor) % divisor;
}

function divModTrunc(num, divisor) {
  return [ divTrunc(num, divisor), modTrunc(num, divisor) ];
}

function divTrunc(num, divisor) {
  return Math.trunc(num / divisor) || 0;
}

function modTrunc(num, divisor) {
  return num % divisor || 0;
}

function hasHalf(num) {
  return .5 === Math.abs(num % 1);
}

function givenFieldsToBigNano(fields, largestUnit, fieldNames) {
  let timeNano = 0, days = 0;
  for (let unit = 0; unit <= largestUnit; unit++) {
    const fieldVal = fields[fieldNames[unit]], unitNano = unitNanoMap[unit], unitInDay = nanoInUtcDay / unitNano, [unitDays, leftoverUnits] = divModTrunc(fieldVal, unitInDay);
    timeNano += leftoverUnits * unitNano, days += unitDays;
  }
  const [timeDays, leftoverNano] = divModTrunc(timeNano, nanoInUtcDay);
  return [ days + timeDays, leftoverNano ];
}

function nanoToGivenFields(nano, largestUnit, fieldNames) {
  const fields = {};
  for (let unit = largestUnit; unit >= 0; unit--) {
    const divisor = unitNanoMap[unit];
    fields[fieldNames[unit]] = divTrunc(nano, divisor), nano = modTrunc(nano, divisor);
  }
  return fields;
}

function createBigNano(days, timeNano) {
  let [extraDays, newTimeNano] = divModTrunc(timeNano, nanoInUtcDay), newDays = days + extraDays;
  const newDaysSign = Math.sign(newDays);
  return newDaysSign && newDaysSign === -Math.sign(newTimeNano) && (newDays -= newDaysSign, 
  newTimeNano += newDaysSign * nanoInUtcDay), [ newDays, newTimeNano ];
}

function addBigNanoAndNumber(a, b) {
  return createBigNano(a[0], a[1] + b);
}

function addBigNanos(a, b, sign = 1) {
  return createBigNano(a[0] + b[0] * sign, a[1] + b[1] * sign);
}

function diffBigNanos(a, b) {
  return addBigNanos(b, a, -1);
}

function compareBigNanos(a, b) {
  return compareNumbers(a[0], b[0]) || compareNumbers(a[1], b[1]);
}

function bigIntToBigNano(num, multiplierNano = 1) {
  const wholeInDay = BigInt(nanoInUtcDay / multiplierNano);
  return [ Number(num / wholeInDay), Number(num % wholeInDay) * multiplierNano ];
}

function numberToBigNano(num, multiplierNano = 1) {
  const wholeInDay = nanoInUtcDay / multiplierNano, [days, remainder] = divModTrunc(num, wholeInDay);
  return [ days, remainder * multiplierNano ];
}

function bigNanoToBigInt(bigNano, divisorNano = 1) {
  const [days, timeNano] = bigNano, whole = Math.floor(timeNano / divisorNano), wholeInDay = nanoInUtcDay / divisorNano;
  return BigInt(days) * BigInt(wholeInDay) + BigInt(whole);
}

function bigNanoToNumber(bigNano, divisorNano = 1, exact) {
  const [days, timeNano] = bigNano, [whole, remainderNano] = divModTrunc(timeNano, divisorNano);
  return days * (nanoInUtcDay / divisorNano) + (whole + (exact ? remainderNano / divisorNano : 0));
}

function divModBigNano(bigNano, divisorNano, divModFunc = divModFloor) {
  const [days, timeNano] = bigNano, [whole, remainderNano] = divModFunc(timeNano, divisorNano);
  return [ days * (nanoInUtcDay / divisorNano) + whole, remainderNano ];
}

function hashIntlFormatParts(intlFormat, epochMilliseconds) {
  const parts = intlFormat.formatToParts(epochMilliseconds), hash = {};
  for (const part of parts) {
    hash[part.type] = part.value;
  }
  return hash;
}

function checkIsoYearMonthInBounds(isoFields) {
  return clampProp(isoFields, "isoYear", isoYearMin, isoYearMax, 1), isoFields.isoYear === isoYearMin ? clampProp(isoFields, "isoMonth", 4, 12, 1) : isoFields.isoYear === isoYearMax && clampProp(isoFields, "isoMonth", 1, 9, 1), 
  isoFields;
}

function checkIsoDateInBounds(isoFields) {
  return checkIsoDateTimeInBounds({
    ...isoFields,
    ...isoTimeFieldDefaults,
    isoHour: 12
  }), isoFields;
}

function checkIsoDateTimeInBounds(isoFields) {
  const isoYear = clampProp(isoFields, "isoYear", isoYearMin, isoYearMax, 1), nudge = isoYear === isoYearMin ? 1 : isoYear === isoYearMax ? -1 : 0;
  return nudge && checkEpochNanoInBounds(isoToEpochNano({
    ...isoFields,
    isoDay: isoFields.isoDay + nudge,
    isoNanosecond: isoFields.isoNanosecond - nudge
  })), isoFields;
}

function checkEpochNanoInBounds(epochNano) {
  if (!epochNano || -1 === compareBigNanos(epochNano, epochNanoMin) || 1 === compareBigNanos(epochNano, epochNanoMax)) {
    throw new RangeError(outOfBoundsDate);
  }
  return epochNano;
}

function isoTimeFieldsToNano(isoTimeFields) {
  return givenFieldsToBigNano(isoTimeFields, 5, isoTimeFieldNamesAsc)[1];
}

function nanoToIsoTimeAndDay(nano) {
  const [dayDelta, timeNano] = divModFloor(nano, nanoInUtcDay);
  return [ nanoToGivenFields(timeNano, 5, isoTimeFieldNamesAsc), dayDelta ];
}

function epochNanoToSec(epochNano) {
  return epochNanoToSecMod(epochNano)[0];
}

function epochNanoToSecMod(epochNano) {
  return divModBigNano(epochNano, nanoInSec);
}

function epochNanoToMilli(epochNano) {
  return divModBigNano(epochNano, nanoInMilli)[0];
}

function isoToEpochMilli(isoDateTimeFields) {
  return isoArgsToEpochMilli(isoDateTimeFields.isoYear, isoDateTimeFields.isoMonth, isoDateTimeFields.isoDay, isoDateTimeFields.isoHour, isoDateTimeFields.isoMinute, isoDateTimeFields.isoSecond, isoDateTimeFields.isoMillisecond);
}

function isoToEpochNano(isoFields) {
  const epochMilli = isoToEpochMilli(isoFields);
  if (void 0 !== epochMilli) {
    const [days, milliRemainder] = divModTrunc(epochMilli, milliInDay);
    return [ days, milliRemainder * nanoInMilli + (isoFields.isoMicrosecond || 0) * nanoInMicro + (isoFields.isoNanosecond || 0) ];
  }
}

function isoToEpochNanoWithOffset(isoFields, offsetNano) {
  const [newIsoTimeFields, dayDelta] = nanoToIsoTimeAndDay(isoTimeFieldsToNano(isoFields) - offsetNano);
  return checkEpochNanoInBounds(isoToEpochNano({
    ...isoFields,
    isoDay: isoFields.isoDay + dayDelta,
    ...newIsoTimeFields
  }));
}

function isoArgsToEpochSec(...args) {
  return isoArgsToEpochMilli(...args) / milliInSec;
}

function isoArgsToEpochMilli(...args) {
  const [legacyDate, daysNudged] = isoToLegacyDate(...args), epochMilli = legacyDate.getTime();
  if (!isNaN(epochMilli)) {
    return epochMilli - daysNudged * milliInDay;
  }
}

function isoToLegacyDate(isoYear, isoMonth = 1, isoDay = 1, isoHour = 0, isoMinute = 0, isoSec = 0, isoMilli = 0) {
  const daysNudged = isoYear === isoYearMin ? 1 : isoYear === isoYearMax ? -1 : 0, legacyDate = new Date;
  return legacyDate.setUTCHours(isoHour, isoMinute, isoSec, isoMilli), legacyDate.setUTCFullYear(isoYear, isoMonth - 1, isoDay + daysNudged), 
  [ legacyDate, daysNudged ];
}

function epochNanoToIso(epochNano, offsetNano) {
  let [days, timeNano] = addBigNanoAndNumber(epochNano, offsetNano);
  timeNano < 0 && (timeNano += nanoInUtcDay, days -= 1);
  const [timeMilli, nanoRemainder] = divModFloor(timeNano, nanoInMilli), [isoMicrosecond, isoNanosecond] = divModFloor(nanoRemainder, nanoInMicro);
  return {
    ...epochMilliToIso(days * milliInDay + timeMilli),
    isoMicrosecond: isoMicrosecond,
    isoNanosecond: isoNanosecond
  };
}

function epochMilliToIso(epochMilli) {
  const daysOver = Math.ceil(Math.max(0, Math.abs(epochMilli) - maxMilli) / milliInDay) * Math.sign(epochMilli), legacyDate = new Date(epochMilli - daysOver * milliInDay);
  return zipProps(isoDateTimeFieldNamesAsc, [ legacyDate.getUTCFullYear(), legacyDate.getUTCMonth() + 1, legacyDate.getUTCDate() + daysOver, legacyDate.getUTCHours(), legacyDate.getUTCMinutes(), legacyDate.getUTCSeconds(), legacyDate.getUTCMilliseconds() ]);
}

function computeIsoMonthsInYear() {
  return isoMonthsInYear;
}

function computeIsoDaysInMonth(isoYear, isoMonth) {
  switch (isoMonth) {
   case 2:
    return computeIsoInLeapYear(isoYear) ? 29 : 28;

   case 4:
   case 6:
   case 9:
   case 11:
    return 30;
  }
  return 31;
}

function computeIsoDaysInYear(isoYear) {
  return computeIsoInLeapYear(isoYear) ? 366 : 365;
}

function computeIsoInLeapYear(isoYear) {
  return isoYear % 4 == 0 && (isoYear % 100 != 0 || isoYear % 400 == 0);
}

function computeIsoDayOfYear(isoDateFields) {
  return diffEpochMilliByDay(isoToEpochMilli((isoDateFields => ({
    ...isoDateFields,
    isoMonth: 1,
    isoDay: 1,
    ...isoTimeFieldDefaults
  }))(isoDateFields)), isoToEpochMilli({
    ...isoDateFields,
    ...isoTimeFieldDefaults
  })) + 1;
}

function computeIsoDayOfWeek(isoDateFields) {
  const [legacyDate, daysNudged] = isoToLegacyDate(isoDateFields.isoYear, isoDateFields.isoMonth, isoDateFields.isoDay);
  return modFloor(legacyDate.getUTCDay() - daysNudged, 7) || 7;
}

function computeGregoryEraParts({isoYear: isoYear}) {
  return isoYear < 1 ? [ "bce", 1 - isoYear ] : [ "ce", isoYear ];
}

function checkIsoDateTimeFields(isoDateTimeFields) {
  return checkIsoDateFields(isoDateTimeFields), constrainIsoTimeFields(isoDateTimeFields, 1), 
  isoDateTimeFields;
}

function checkIsoDateFields(isoInternals) {
  return constrainIsoDateFields(isoInternals, 1), isoInternals;
}

function isIsoDateFieldsValid(isoFields) {
  return allPropsEqual(isoDateFieldNamesAsc, isoFields, constrainIsoDateFields(isoFields));
}

function constrainIsoDateFields(isoFields, overflow) {
  const {isoYear: isoYear} = isoFields, isoMonth = clampProp(isoFields, "isoMonth", 1, computeIsoMonthsInYear(), overflow);
  return {
    isoYear: isoYear,
    isoMonth: isoMonth,
    isoDay: clampProp(isoFields, "isoDay", 1, computeIsoDaysInMonth(isoYear, isoMonth), overflow)
  };
}

function constrainIsoTimeFields(isoTimeFields, overflow) {
  return zipProps(isoTimeFieldNamesAsc, [ clampProp(isoTimeFields, "isoHour", 0, 23, overflow), clampProp(isoTimeFields, "isoMinute", 0, 59, overflow), clampProp(isoTimeFields, "isoSecond", 0, 59, overflow), clampProp(isoTimeFields, "isoMillisecond", 0, 999, overflow), clampProp(isoTimeFields, "isoMicrosecond", 0, 999, overflow), clampProp(isoTimeFields, "isoNanosecond", 0, 999, overflow) ]);
}

function requirePositiveInteger(arg) {
  return requireNumberIsPositive(requireInteger(arg));
}

function requireInteger(arg) {
  return requireNumberIsInteger(requireNumber(arg));
}

function requirePropDefined(optionName, optionVal) {
  if (null == optionVal) {
    throw new RangeError(missingField(optionName));
  }
  return optionVal;
}

function requireObjectLike(arg) {
  if (!isObjectLike(arg)) {
    throw new TypeError(invalidObject);
  }
  return arg;
}

function requireType(typeName, arg, entityName = typeName) {
  if (typeof arg !== typeName) {
    throw new TypeError(invalidEntity(entityName, arg));
  }
  return arg;
}

function requireNumberIsInteger(num, entityName = "number") {
  if (!Number.isInteger(num)) {
    throw new RangeError(expectedInteger(entityName, num));
  }
  return num || 0;
}

function requireNumberIsPositive(num, entityName = "number") {
  if (num <= 0) {
    throw new RangeError(expectedPositive(entityName, num));
  }
  return num;
}

function toString(arg) {
  if ("symbol" == typeof arg) {
    throw new TypeError(forbiddenSymbolToString);
  }
  return String(arg);
}

function toStringViaPrimitive(arg, entityName) {
  return isObjectLike(arg) ? String(arg) : requireString(arg, entityName);
}

function toBigInt(bi) {
  if ("string" == typeof bi) {
    return BigInt(bi);
  }
  if ("bigint" != typeof bi) {
    throw new TypeError(invalidBigInt(bi));
  }
  return bi;
}

function toNumber(arg, entityName = "number") {
  if ("bigint" == typeof arg) {
    throw new TypeError(forbiddenBigIntToNumber(entityName));
  }
  if (arg = Number(arg), !Number.isFinite(arg)) {
    throw new RangeError(expectedFinite(entityName, arg));
  }
  return arg;
}

function toInteger(arg, entityName) {
  return Math.trunc(toNumber(arg, entityName)) || 0;
}

function toStrictInteger(arg, entityName) {
  return requireNumberIsInteger(toNumber(arg, entityName), entityName);
}

function toPositiveInteger(arg, entityName) {
  return requireNumberIsPositive(toInteger(arg, entityName), entityName);
}

function refineOverflowOptions(options) {
  return void 0 === options ? 0 : refineOverflow(requireObjectLike(options));
}

function refineZonedFieldOptions(options, defaultOffsetDisambig = 0) {
  options = normalizeOptions(options);
  const epochDisambig = refineEpochDisambig(options), offsetDisambig = refineOffsetDisambig(options, defaultOffsetDisambig);
  return [ refineOverflow(options), offsetDisambig, epochDisambig ];
}

function refineEpochDisambigOptions(options) {
  return refineEpochDisambig(normalizeOptions(options));
}

function refineDiffOptions(roundingModeInvert, options, defaultLargestUnit, maxUnit = 9, minUnit = 0, defaultRoundingMode = 4) {
  options = normalizeOptions(options);
  let largestUnit = refineLargestUnit(options, maxUnit, minUnit), roundingInc = parseRoundingIncInteger(options), roundingMode = refineRoundingMode(options, defaultRoundingMode);
  const smallestUnit = refineSmallestUnit(options, maxUnit, minUnit, 1);
  return null == largestUnit ? largestUnit = Math.max(defaultLargestUnit, smallestUnit) : checkLargestSmallestUnit(largestUnit, smallestUnit), 
  roundingInc = refineRoundingInc(roundingInc, smallestUnit, 1), roundingModeInvert && (roundingMode = (roundingMode => roundingMode < 4 ? (roundingMode + 2) % 4 : roundingMode)(roundingMode)), 
  [ largestUnit, smallestUnit, roundingInc, roundingMode ];
}

function refineRoundOptions(options, maxUnit = 6, solarMode) {
  let roundingInc = parseRoundingIncInteger(options = normalizeUnitNameOptions(options, smallestUnitStr));
  const roundingMode = refineRoundingMode(options, 7);
  let smallestUnit = refineSmallestUnit(options, maxUnit);
  return smallestUnit = requirePropDefined(smallestUnitStr, smallestUnit), roundingInc = refineRoundingInc(roundingInc, smallestUnit, void 0, solarMode), 
  [ smallestUnit, roundingInc, roundingMode ];
}

function refineDateDisplayOptions(options) {
  return refineCalendarDisplay(normalizeOptions(options));
}

function refineTimeDisplayOptions(options, maxSmallestUnit) {
  return refineTimeDisplayTuple(normalizeOptions(options), maxSmallestUnit);
}

function refineTimeDisplayTuple(options, maxSmallestUnit = 4) {
  const subsecDigits = refineSubsecDigits(options);
  return [ refineRoundingMode(options, 4), ...refineSmallestUnitAndSubsecDigits(refineSmallestUnit(options, maxSmallestUnit), subsecDigits) ];
}

function refineSmallestUnitAndSubsecDigits(smallestUnit, subsecDigits) {
  return null != smallestUnit ? [ unitNanoMap[smallestUnit], smallestUnit < 4 ? 9 - 3 * smallestUnit : -1 ] : [ void 0 === subsecDigits ? 1 : 10 ** (9 - subsecDigits), subsecDigits ];
}

function parseRoundingIncInteger(options) {
  const roundingInc = options[roundingIncName];
  return void 0 === roundingInc ? 1 : toInteger(roundingInc, roundingIncName);
}

function refineRoundingInc(roundingInc, smallestUnit, allowManyLargeUnits, solarMode) {
  const upUnitNano = solarMode ? nanoInUtcDay : unitNanoMap[smallestUnit + 1];
  if (upUnitNano) {
    const unitNano = unitNanoMap[smallestUnit];
    if (upUnitNano % ((roundingInc = clampEntity(roundingIncName, roundingInc, 1, upUnitNano / unitNano - (solarMode ? 0 : 1), 1)) * unitNano)) {
      throw new RangeError(invalidEntity(roundingIncName, roundingInc));
    }
  } else {
    roundingInc = clampEntity(roundingIncName, roundingInc, 1, allowManyLargeUnits ? 10 ** 9 : 1, 1);
  }
  return roundingInc;
}

function refineSubsecDigits(options) {
  let subsecDigits = options[subsecDigitsName];
  if (void 0 !== subsecDigits) {
    if ("number" != typeof subsecDigits) {
      if ("auto" === toString(subsecDigits)) {
        return;
      }
      throw new RangeError(invalidEntity(subsecDigitsName, subsecDigits));
    }
    subsecDigits = clampEntity(subsecDigitsName, Math.floor(subsecDigits), 0, 9, 1);
  }
  return subsecDigits;
}

function normalizeOptions(options) {
  return void 0 === options ? {} : requireObjectLike(options);
}

function normalizeUnitNameOptions(options, optionName) {
  return "string" == typeof options ? {
    [optionName]: options
  } : requireObjectLike(options);
}

function copyOptions(options) {
  if (void 0 !== options) {
    if (isObjectLike(options)) {
      return Object.assign(Object.create(null), options);
    }
    throw new TypeError(invalidObject);
  }
}

function overrideOverflowOptions(options, overflow) {
  return options && Object.assign(Object.create(null), options, {
    overflow: overflowMapNames[overflow]
  });
}

function refineUnitOption(optionName, options, maxUnit = 9, minUnit = 0, ensureDefined) {
  let unitStr = options[optionName];
  if (void 0 === unitStr) {
    return ensureDefined ? minUnit : void 0;
  }
  if (unitStr = toString(unitStr), "auto" === unitStr) {
    return ensureDefined ? minUnit : null;
  }
  let unit = unitNameMap[unitStr];
  if (void 0 === unit && (unit = durationFieldIndexes[unitStr]), void 0 === unit) {
    throw new RangeError(invalidChoice(optionName, unitStr, unitNameMap));
  }
  return clampEntity(optionName, unit, minUnit, maxUnit, 1, unitNamesAsc), unit;
}

function refineChoiceOption(optionName, enumNameMap, options, defaultChoice = 0) {
  const enumArg = options[optionName];
  if (void 0 === enumArg) {
    return defaultChoice;
  }
  const enumStr = toString(enumArg), enumNum = enumNameMap[enumStr];
  if (void 0 === enumNum) {
    throw new RangeError(invalidChoice(optionName, enumStr, enumNameMap));
  }
  return enumNum;
}

function checkLargestSmallestUnit(largestUnit, smallestUnit) {
  if (smallestUnit > largestUnit) {
    throw new RangeError(flippedSmallestLargestUnit);
  }
}

function createInstantSlots(epochNano) {
  return {
    branding: InstantBranding,
    epochNanoseconds: epochNano
  };
}

function createZonedDateTimeSlots(epochNano, timeZone, calendar) {
  return {
    branding: ZonedDateTimeBranding,
    calendar: calendar,
    timeZone: timeZone,
    epochNanoseconds: epochNano
  };
}

function createPlainDateTimeSlots(isoFields, calendar = isoFields.calendar) {
  return {
    branding: PlainDateTimeBranding,
    calendar: calendar,
    ...pluckProps(isoDateTimeFieldNamesAlpha, isoFields)
  };
}

function createPlainDateSlots(isoFields, calendar = isoFields.calendar) {
  return {
    branding: PlainDateBranding,
    calendar: calendar,
    ...pluckProps(isoDateFieldNamesAlpha, isoFields)
  };
}

function createPlainYearMonthSlots(isoFields, calendar = isoFields.calendar) {
  return {
    branding: PlainYearMonthBranding,
    calendar: calendar,
    ...pluckProps(isoDateFieldNamesAlpha, isoFields)
  };
}

function createPlainMonthDaySlots(isoFields, calendar = isoFields.calendar) {
  return {
    branding: PlainMonthDayBranding,
    calendar: calendar,
    ...pluckProps(isoDateFieldNamesAlpha, isoFields)
  };
}

function createPlainTimeSlots(isoFields) {
  return {
    branding: PlainTimeBranding,
    ...pluckProps(isoTimeFieldNamesAlpha, isoFields)
  };
}

function createDurationSlots(durationFields) {
  return {
    branding: DurationBranding,
    sign: computeDurationSign(durationFields),
    ...pluckProps(durationFieldNamesAlpha, durationFields)
  };
}

function getId(idLike) {
  return "string" == typeof idLike ? idLike : requireString(idLike.id);
}

function isIdLikeEqual(idLike0, idLike1) {
  return idLike0 === idLike1 || getId(idLike0) === getId(idLike1);
}

function createRelativeSystem(getCalendarOps, getTimeZoneOps, slots) {
  const calendarOps = getCalendarOps(slots.calendar);
  return slots.epochNanoseconds ? [ slots, calendarOps, getTimeZoneOps(slots.timeZone) ] : [ {
    ...slots,
    ...isoTimeFieldDefaults
  }, calendarOps ];
}

function relativeMarkerToEpochNano(marker, timeZoneOps) {
  return timeZoneOps ? marker.epochNanoseconds : isoToEpochNano(marker);
}

function totalBigNano(bigNano, totalUnit) {
  return bigNanoToNumber(bigNano, unitNanoMap[totalUnit], 1);
}

function clampRelativeDuration(durationFields, clampUnit, clampDistance, marker, calendarOps, timeZoneOps) {
  const clampDurationFields = {
    ...durationFieldDefaults,
    [durationFieldNamesAsc[clampUnit]]: clampDistance
  }, marker0 = moveRelativeMarker(durationFields, marker, calendarOps, timeZoneOps), marker1 = moveRelativeMarker(clampDurationFields, marker0, calendarOps, timeZoneOps);
  return [ relativeMarkerToEpochNano(marker0, timeZoneOps), relativeMarkerToEpochNano(marker1, timeZoneOps) ];
}

function computeEpochNanoFrac(epochNano0, epochNano1, epochNanoProgress) {
  const denom = bigNanoToNumber(diffBigNanos(epochNano0, epochNano1));
  if (!denom) {
    throw new RangeError(invalidProtocolResults);
  }
  return bigNanoToNumber(diffBigNanos(epochNano0, epochNanoProgress)) / denom;
}

function roundDateTime(isoFields, smallestUnit, roundingInc, roundingMode, timeZoneOps) {
  return 6 === smallestUnit ? ((isoFields, timeZoneOps, roundingMode) => {
    if (timeZoneOps) {
      const nanoInDay = computeTimeInDay(timeZoneOps, isoFields);
      return checkIsoDateTimeInBounds({
        ...moveByIsoDays(isoFields, roundByInc(isoTimeFieldsToNano(isoFields), nanoInDay, roundingMode) / nanoInDay),
        ...isoTimeFieldDefaults
      });
    }
    return roundDateTimeToNano(isoFields, nanoInUtcDay, roundingMode);
  })(isoFields, timeZoneOps, roundingMode) : roundDateTimeToNano(isoFields, computeNanoInc(smallestUnit, roundingInc), roundingMode);
}

function roundDateTimeToNano(isoFields, nanoInc, roundingMode) {
  const [roundedIsoFields, dayDelta] = roundTimeToNano(isoFields, nanoInc, roundingMode);
  return checkIsoDateTimeInBounds({
    ...moveByIsoDays(isoFields, dayDelta),
    ...roundedIsoFields
  });
}

function roundTimeToNano(isoFields, nanoInc, roundingMode) {
  return nanoToIsoTimeAndDay(roundByInc(isoTimeFieldsToNano(isoFields), nanoInc, roundingMode));
}

function balanceDayTimeDuration(durationFields, largestUnit, smallestUnit, roundingInc, roundingMode) {
  return nanoToDurationDayTimeFields(roundBigNano(durationFieldsToBigNano(durationFields), smallestUnit, roundingInc, roundingMode), largestUnit);
}

function balanceDayTimeDurationByInc(durationFields, largestUnit, nanoInc, roundingMode) {
  return nanoToDurationDayTimeFields(roundBigNanoByInc(durationFieldsToBigNano(durationFields, largestUnit), nanoInc, roundingMode), largestUnit);
}

function roundRelativeDuration(durationFields, endEpochNano, largestUnit, smallestUnit, roundingInc, roundingMode, marker, calendarOps, timeZoneOps) {
  const nudgeFunc = smallestUnit > 6 ? nudgeRelativeDuration : timeZoneOps && smallestUnit < 6 ? nudgeRelativeDurationTime : nudgeDurationDayTime;
  let [roundedDurationFields, roundedEpochNano, grewBigUnit] = nudgeFunc(durationFields, endEpochNano, largestUnit, smallestUnit, roundingInc, roundingMode, marker, calendarOps, timeZoneOps);
  return grewBigUnit && (roundedDurationFields = ((durationFields, endEpochNano, largestUnit, smallestUnit, marker, calendarOps, timeZoneOps) => {
    const sign = computeDurationSign(durationFields);
    for (let currentUnit = smallestUnit + 1; currentUnit <= largestUnit; currentUnit++) {
      if (7 === currentUnit && 7 !== largestUnit) {
        continue;
      }
      const baseDurationFields = clearDurationFields(durationFields, currentUnit - 1);
      baseDurationFields[durationFieldNamesAsc[currentUnit]] += sign;
      const beyondThreshold = bigNanoToNumber(diffBigNanos(relativeMarkerToEpochNano(moveRelativeMarker(baseDurationFields, marker, calendarOps, timeZoneOps), timeZoneOps), endEpochNano));
      if (beyondThreshold && Math.sign(beyondThreshold) !== sign) {
        break;
      }
      durationFields = baseDurationFields;
    }
    return durationFields;
  })(roundedDurationFields, roundedEpochNano, largestUnit, Math.max(6, smallestUnit), marker, calendarOps, timeZoneOps)), 
  roundedDurationFields;
}

function computeNanoInc(smallestUnit, roundingInc) {
  return unitNanoMap[smallestUnit] * roundingInc;
}

function roundByInc(num, inc, roundingMode) {
  return ((num, roundingMode) => roundingModeFuncs[roundingMode](num))(num / inc, roundingMode) * inc;
}

function roundToMinute(offsetNano) {
  return roundByInc(offsetNano, nanoInMinute, 7);
}

function roundBigNano(bigNano, smallestUnit, roundingInc, roundingMode, useDayOrigin) {
  return 6 === smallestUnit ? [ roundByInc(totalBigNano(bigNano, 6), roundingInc, roundingMode), 0 ] : roundBigNanoByInc(bigNano, computeNanoInc(smallestUnit, roundingInc), roundingMode, useDayOrigin);
}

function roundBigNanoByInc(bigNano, nanoInc, roundingMode, useDayOrigin) {
  let [days, timeNano] = bigNano;
  useDayOrigin && timeNano < 0 && (timeNano += nanoInUtcDay, days -= 1);
  const [dayDelta, roundedTimeNano] = divModFloor(roundByInc(timeNano, nanoInc, roundingMode), nanoInUtcDay);
  return createBigNano(days + dayDelta, roundedTimeNano);
}

function nudgeDurationDayTime(durationFields, endEpochNano, largestUnit, smallestUnit, roundingInc, roundingMode) {
  const sign = computeDurationSign(durationFields), bigNano = durationFieldsToBigNano(durationFields), roundedBigNano = roundBigNano(bigNano, smallestUnit, roundingInc, roundingMode), nanoDiff = diffBigNanos(bigNano, roundedBigNano), expandedBigUnit = Math.sign(roundedBigNano[0] - bigNano[0]) === sign, roundedDayTimeFields = nanoToDurationDayTimeFields(roundedBigNano, Math.min(largestUnit, 6));
  return [ {
    ...durationFields,
    ...roundedDayTimeFields
  }, addBigNanos(endEpochNano, nanoDiff), expandedBigUnit ];
}

function nudgeRelativeDurationTime(durationFields, endEpochNano, _largestUnit, smallestUnit, roundingInc, roundingMode, marker, calendarOps, timeZoneOps) {
  const sign = computeDurationSign(durationFields);
  let [dayDelta, timeNano] = givenFieldsToBigNano(durationFields, 5, durationFieldNamesAsc);
  const nanoInc = computeNanoInc(smallestUnit, roundingInc);
  let roundedTimeNano = roundByInc(timeNano, nanoInc, roundingMode);
  const [dayEpochNano0, dayEpochNano1] = clampRelativeDuration({
    ...durationFields,
    ...durationTimeFieldDefaults
  }, 6, sign, marker, calendarOps, timeZoneOps), beyondDay = roundedTimeNano - bigNanoToNumber(diffBigNanos(dayEpochNano0, dayEpochNano1));
  beyondDay && Math.sign(beyondDay) !== sign ? endEpochNano = addBigNanoAndNumber(dayEpochNano0, roundedTimeNano) : (dayDelta += sign, 
  roundedTimeNano = roundByInc(beyondDay, nanoInc, roundingMode), endEpochNano = addBigNanoAndNumber(dayEpochNano1, roundedTimeNano));
  const durationTimeFields = nanoToDurationTimeFields(roundedTimeNano);
  return [ {
    ...durationFields,
    ...durationTimeFields,
    days: durationFields.days + dayDelta
  }, endEpochNano, Boolean(dayDelta) ];
}

function nudgeRelativeDuration(durationFields, endEpochNano, _largestUnit, smallestUnit, roundingInc, roundingMode, marker, calendarOps, timeZoneOps) {
  const sign = computeDurationSign(durationFields), smallestUnitFieldName = durationFieldNamesAsc[smallestUnit], baseDurationFields = clearDurationFields(durationFields, smallestUnit - 1), truncedVal = divTrunc(durationFields[smallestUnitFieldName], roundingInc) * roundingInc;
  baseDurationFields[smallestUnitFieldName] = truncedVal;
  const [epochNano0, epochNano1] = clampRelativeDuration(baseDurationFields, smallestUnit, roundingInc * sign, marker, calendarOps, timeZoneOps), exactVal = truncedVal + computeEpochNanoFrac(epochNano0, epochNano1, endEpochNano) * sign * roundingInc, roundedVal = roundByInc(exactVal, roundingInc, roundingMode), expanded = Math.sign(roundedVal - exactVal) === sign;
  return baseDurationFields[smallestUnitFieldName] = roundedVal, [ baseDurationFields, expanded ? epochNano1 : epochNano0, expanded ];
}

function formatDateLikeIso(calendarIdLike, formatSimple, isoFields, calendarDisplay) {
  const calendarId = getId(calendarIdLike), showCalendar = calendarDisplay > 1 || 0 === calendarDisplay && calendarId !== isoCalendarId;
  return 1 === calendarDisplay ? calendarId === isoCalendarId ? formatSimple(isoFields) : formatIsoDateFields(isoFields) : showCalendar ? formatIsoDateFields(isoFields) + formatCalendarId(calendarId, 2 === calendarDisplay) : formatSimple(isoFields);
}

function formatDurationFragments(fragObj) {
  const parts = [];
  for (const fragName in fragObj) {
    const fragVal = fragObj[fragName];
    fragVal && parts.push(fragVal, fragName);
  }
  return parts.join("");
}

function formatIsoDateTimeFields(isoDateTimeFields, subsecDigits) {
  return formatIsoDateFields(isoDateTimeFields) + "T" + formatIsoTimeFields(isoDateTimeFields, subsecDigits);
}

function formatIsoDateFields(isoDateFields) {
  return formatIsoYearMonthFields(isoDateFields) + "-" + padNumber2(isoDateFields.isoDay);
}

function formatIsoYearMonthFields(isoDateFields) {
  const {isoYear: isoYear} = isoDateFields;
  return (isoYear < 0 || isoYear > 9999 ? getSignStr(isoYear) + padNumber(6, Math.abs(isoYear)) : padNumber(4, isoYear)) + "-" + padNumber2(isoDateFields.isoMonth);
}

function formatIsoMonthDayFields(isoDateFields) {
  return padNumber2(isoDateFields.isoMonth) + "-" + padNumber2(isoDateFields.isoDay);
}

function formatIsoTimeFields(isoTimeFields, subsecDigits) {
  const parts = [ padNumber2(isoTimeFields.isoHour), padNumber2(isoTimeFields.isoMinute) ];
  return -1 !== subsecDigits && parts.push(padNumber2(isoTimeFields.isoSecond) + ((isoMillisecond, isoMicrosecond, isoNanosecond, subsecDigits) => formatSubsecNano(isoMillisecond * nanoInMilli + isoMicrosecond * nanoInMicro + isoNanosecond, subsecDigits))(isoTimeFields.isoMillisecond, isoTimeFields.isoMicrosecond, isoTimeFields.isoNanosecond, subsecDigits)), 
  parts.join(":");
}

function formatOffsetNano(offsetNano, offsetDisplay = 0) {
  if (1 === offsetDisplay) {
    return "";
  }
  const [hour, nanoRemainder0] = divModFloor(Math.abs(offsetNano), nanoInHour), [minute, nanoRemainder1] = divModFloor(nanoRemainder0, nanoInMinute), [second, nanoRemainder2] = divModFloor(nanoRemainder1, nanoInSec);
  return getSignStr(offsetNano) + padNumber2(hour) + ":" + padNumber2(minute) + (second || nanoRemainder2 ? ":" + padNumber2(second) + formatSubsecNano(nanoRemainder2) : "");
}

function formatCalendar(calendarIdLike, calendarDisplay) {
  if (1 !== calendarDisplay) {
    const calendarId = getId(calendarIdLike);
    if (calendarDisplay > 1 || 0 === calendarDisplay && calendarId !== isoCalendarId) {
      return formatCalendarId(calendarId, 2 === calendarDisplay);
    }
  }
  return "";
}

function formatCalendarId(calendarId, isCritical) {
  return "[" + (isCritical ? "!" : "") + "u-ca=" + calendarId + "]";
}

function formatSubsecNano(totalNano, subsecDigits) {
  let s = padNumber(9, totalNano);
  return s = void 0 === subsecDigits ? s.replace(trailingZerosRE, "") : s.slice(0, subsecDigits), 
  s ? "." + s : "";
}

function getSignStr(num) {
  return num < 0 ? "-" : "+";
}

function formatDurationNumber(n, force) {
  return n || force ? n.toLocaleString("fullwide", {
    useGrouping: 0
  }) : "";
}

function getMatchingInstantFor(timeZoneOps, isoFields, offsetNano, offsetDisambig = 0, epochDisambig = 0, epochFuzzy, hasZ) {
  if (void 0 !== offsetNano && 1 === offsetDisambig && (1 === offsetDisambig || hasZ)) {
    return isoToEpochNanoWithOffset(isoFields, offsetNano);
  }
  const possibleEpochNanos = timeZoneOps.getPossibleInstantsFor(isoFields);
  if (void 0 !== offsetNano && 3 !== offsetDisambig) {
    const matchingEpochNano = ((possibleEpochNanos, isoDateTimeFields, offsetNano, fuzzy) => {
      const zonedEpochNano = isoToEpochNano(isoDateTimeFields);
      fuzzy && (offsetNano = roundToMinute(offsetNano));
      for (const possibleEpochNano of possibleEpochNanos) {
        let possibleOffsetNano = bigNanoToNumber(diffBigNanos(possibleEpochNano, zonedEpochNano));
        if (fuzzy && (possibleOffsetNano = roundToMinute(possibleOffsetNano)), possibleOffsetNano === offsetNano) {
          return possibleEpochNano;
        }
      }
    })(possibleEpochNanos, isoFields, offsetNano, epochFuzzy);
    if (void 0 !== matchingEpochNano) {
      return matchingEpochNano;
    }
    if (0 === offsetDisambig) {
      throw new RangeError(invalidOffsetForTimeZone);
    }
  }
  return hasZ ? isoToEpochNano(isoFields) : getSingleInstantFor(timeZoneOps, isoFields, epochDisambig, possibleEpochNanos);
}

function getSingleInstantFor(timeZoneOps, isoFields, disambig = 0, possibleEpochNanos = timeZoneOps.getPossibleInstantsFor(isoFields)) {
  if (1 === possibleEpochNanos.length) {
    return possibleEpochNanos[0];
  }
  if (1 === disambig) {
    throw new RangeError(ambigOffset);
  }
  if (possibleEpochNanos.length) {
    return possibleEpochNanos[3 === disambig ? 1 : 0];
  }
  const zonedEpochNano = isoToEpochNano(isoFields), gapNano = ((timeZoneOps, zonedEpochNano) => {
    const startOffsetNano = timeZoneOps.getOffsetNanosecondsFor(addBigNanoAndNumber(zonedEpochNano, -nanoInUtcDay));
    return validateTimeZoneGap(timeZoneOps.getOffsetNanosecondsFor(addBigNanoAndNumber(zonedEpochNano, nanoInUtcDay)) - startOffsetNano);
  })(timeZoneOps, zonedEpochNano), shiftNano = gapNano * (2 === disambig ? -1 : 1);
  return (possibleEpochNanos = timeZoneOps.getPossibleInstantsFor(epochNanoToIso(zonedEpochNano, shiftNano)))[2 === disambig ? 0 : possibleEpochNanos.length - 1];
}

function computeTimeInDay(timeZoneOps, isoFields, divisorNano) {
  isoFields = {
    ...isoFields,
    ...isoTimeFieldDefaults
  };
  const res = bigNanoToNumber(diffBigNanos(getSingleInstantFor(timeZoneOps, {
    ...isoFields,
    ...isoTimeFieldDefaults
  }), getSingleInstantFor(timeZoneOps, {
    ...moveByIsoDays(isoFields, 1),
    ...isoTimeFieldDefaults
  })), divisorNano, 1);
  if (res <= 0) {
    throw new RangeError(invalidProtocolResults);
  }
  return res;
}

function validateTimeZoneOffset(offsetNano) {
  if (Math.abs(offsetNano) >= nanoInUtcDay) {
    throw new RangeError(outOfBoundsOffset);
  }
  return offsetNano;
}

function validateTimeZoneGap(gapNano) {
  if (gapNano > nanoInUtcDay) {
    throw new RangeError(outOfBoundsDstGap);
  }
  return gapNano;
}

function moveRelativeMarker(durationFields, slots, calendarOps, timeZoneOps) {
  return timeZoneOps ? {
    epochNanoseconds: moveZonedEpochSlots(calendarOps, timeZoneOps, slots, durationFields)
  } : moveDateTime(calendarOps, slots, durationFields);
}

function moveZonedEpochSlots(calendarOps, timeZoneOps, slots, durationFields, options) {
  const timeOnlyNano = durationFieldsToBigNano(durationFields, 5);
  let epochNano = slots.epochNanoseconds;
  if (durationHasDateParts(durationFields)) {
    const isoDateTimeFields = zonedEpochSlotsToIso(slots, timeZoneOps);
    epochNano = addBigNanos(getSingleInstantFor(timeZoneOps, {
      ...moveDateEfficient(calendarOps, isoDateTimeFields, {
        ...durationFields,
        ...durationTimeFieldDefaults
      }, options),
      ...pluckProps(isoTimeFieldNamesAsc, isoDateTimeFields),
      calendar: isoCalendarId
    }), timeOnlyNano);
  } else {
    epochNano = addBigNanos(epochNano, timeOnlyNano), refineOverflowOptions(options);
  }
  return checkEpochNanoInBounds(epochNano);
}

function moveDateTime(calendarOps, isoDateTimeFields, durationFields, options) {
  const [movedIsoTimeFields, dayDelta] = moveTime(isoDateTimeFields, durationFields);
  return checkIsoDateTimeInBounds({
    ...moveDateEfficient(calendarOps, isoDateTimeFields, {
      ...durationFields,
      ...durationTimeFieldDefaults,
      days: durationFields.days + dayDelta
    }, options),
    ...movedIsoTimeFields
  });
}

function moveDateEfficient(calendarOps, isoDateFields, durationFields, options) {
  if (durationFields.years || durationFields.months || durationFields.weeks) {
    return calendarOps.dateAdd(isoDateFields, durationFields, options);
  }
  refineOverflowOptions(options);
  const days = durationFields.days + givenFieldsToBigNano(durationFields, 5, durationFieldNamesAsc)[0];
  return days ? checkIsoDateInBounds(moveByIsoDays(isoDateFields, days)) : isoDateFields;
}

function moveToMonthStart(calendarOps, isoFields) {
  return moveByIsoDays(isoFields, 1 - calendarOps.day(isoFields));
}

function moveTime(isoFields, durationFields) {
  const [durDays, durTimeNano] = givenFieldsToBigNano(durationFields, 5, durationFieldNamesAsc), [newIsoFields, overflowDays] = nanoToIsoTimeAndDay(isoTimeFieldsToNano(isoFields) + durTimeNano);
  return [ newIsoFields, durDays + overflowDays ];
}

function moveByIsoDays(isoDateFields, days) {
  return days && (isoDateFields = epochMilliToIso(isoToEpochMilli(isoDateFields) + days * milliInDay)), 
  isoDateFields;
}

function spanDuration(durationFields0, durationFields1, largestUnit, marker, calendarOps, timeZoneOps) {
  let endMarker = moveRelativeMarker(durationFields0, marker, calendarOps, timeZoneOps);
  durationFields1 && (endMarker = moveRelativeMarker(durationFields1, endMarker, calendarOps, timeZoneOps));
  const balancedDuration = ((largestUnit, slots0, slots1, calendarOps, timeZoneOps) => timeZoneOps ? ((calendarOps, timeZoneOps, slots0, slots1, largestUnit) => {
    const sign = compareBigNanos(slots1.epochNanoseconds, slots0.epochNanoseconds);
    return sign ? largestUnit < 6 ? diffEpochNanoExact(slots0.epochNanoseconds, slots1.epochNanoseconds, largestUnit) : diffZonedEpochNanoViaCalendar(calendarOps, timeZoneOps, sign, slots0, slots1, largestUnit, void 0) : durationFieldDefaults;
  })(calendarOps, timeZoneOps, slots0, slots1, largestUnit) : ((calendarOps, startIsoFields, endIsoFields, largestUnit) => {
    const startEpochNano = isoToEpochNano(startIsoFields), endEpochNano = isoToEpochNano(endIsoFields), sign = compareBigNanos(endEpochNano, startEpochNano);
    return sign ? largestUnit <= 6 ? diffEpochNanoExact(startEpochNano, endEpochNano, largestUnit) : diffDateTimesViaCalendar(calendarOps, sign, startIsoFields, endIsoFields, largestUnit, void 0) : durationFieldDefaults;
  })(calendarOps, slots0, slots1, largestUnit))(largestUnit, marker, endMarker, calendarOps, timeZoneOps);
  return [ balancedDuration, relativeMarkerToEpochNano(endMarker, timeZoneOps) ];
}

function negateDuration(slots) {
  return createDurationSlots(negateDurationFields(slots));
}

function negateDurationFields(fields) {
  const res = {};
  for (const fieldName of durationFieldNamesAsc) {
    res[fieldName] = -1 * fields[fieldName] || 0;
  }
  return res;
}

function computeDurationSign(fields, fieldNames = durationFieldNamesAsc) {
  let sign = 0;
  for (const fieldName of fieldNames) {
    const fieldSign = Math.sign(fields[fieldName]);
    if (fieldSign) {
      if (sign && sign !== fieldSign) {
        throw new RangeError(forbiddenDurationSigns);
      }
      sign = fieldSign;
    }
  }
  return sign;
}

function checkDurationUnits(fields) {
  for (const calendarUnit of durationCalendarFieldNamesAsc) {
    clampEntity(calendarUnit, fields[calendarUnit], -maxCalendarUnit, maxCalendarUnit, 1);
  }
  return checkDurationTimeUnit(bigNanoToNumber(durationFieldsToBigNano(fields), nanoInSec)), 
  fields;
}

function checkDurationTimeUnit(n) {
  if (!Number.isSafeInteger(n)) {
    throw new RangeError(outOfBoundsDuration);
  }
}

function durationFieldsToBigNano(fields, largestUnit = 6) {
  return givenFieldsToBigNano(fields, largestUnit, durationFieldNamesAsc);
}

function nanoToDurationDayTimeFields(bigNano, largestUnit = 6) {
  const [days, timeNano] = bigNano, dayTimeFields = nanoToGivenFields(timeNano, largestUnit, durationFieldNamesAsc);
  if (dayTimeFields[durationFieldNamesAsc[largestUnit]] += days * (nanoInUtcDay / unitNanoMap[largestUnit]), 
  !Number.isFinite(dayTimeFields[durationFieldNamesAsc[largestUnit]])) {
    throw new RangeError(outOfBoundsDate);
  }
  return dayTimeFields;
}

function nanoToDurationTimeFields(nano, largestUnit = 5) {
  return nanoToGivenFields(nano, largestUnit, durationFieldNamesAsc);
}

function clearDurationFields(durationFields, largestUnitToClear) {
  const copy = {
    ...durationFields
  };
  for (let unit = 0; unit <= largestUnitToClear; unit++) {
    copy[durationFieldNamesAsc[unit]] = 0;
  }
  return copy;
}

function durationHasDateParts(fields) {
  return Boolean(computeDurationSign(fields, durationDateFieldNamesAsc));
}

function getLargestDurationUnit(fields) {
  let unit = 9;
  for (;unit > 0 && !fields[durationFieldNamesAsc[unit]]; unit--) {}
  return unit;
}

function createSplitTuple(startEpochSec, endEpochSec) {
  return [ startEpochSec, endEpochSec ];
}

function computePeriod(epochSec) {
  const startEpochSec = Math.floor(epochSec / periodDur) * periodDur;
  return [ startEpochSec, startEpochSec + periodDur ];
}

function parseOffsetNano(s) {
  const offsetNano = parseOffsetNanoMaybe(s);
  if (void 0 === offsetNano) {
    throw new RangeError(failedParse(s));
  }
  return offsetNano;
}

function parsePlainDate(s) {
  const organized = parseDateTimeLike(requireString(s));
  if (!organized || organized.hasZ) {
    throw new RangeError(failedParse(s));
  }
  return createPlainDateSlots(organized.hasTime ? finalizeDateTime(organized) : finalizeDate(organized));
}

function requireIsoCalendar(organized) {
  if (organized.calendar !== isoCalendarId) {
    throw new RangeError(invalidSubstring(organized.calendar));
  }
}

function finalizeZonedDateTime(organized, offsetNano, offsetDisambig = 0, epochDisambig = 0) {
  const slotId = resolveTimeZoneId(organized.timeZone), timeZoneImpl = queryNativeTimeZone(slotId);
  return createZonedDateTimeSlots(getMatchingInstantFor(timeZoneImpl, checkIsoDateTimeFields(organized), offsetNano, offsetDisambig, epochDisambig, !timeZoneImpl.offsetNano, organized.hasZ), slotId, resolveCalendarId(organized.calendar));
}

function finalizeDateTime(organized) {
  return resolveSlotsCalendar(checkIsoDateTimeInBounds(checkIsoDateTimeFields(organized)));
}

function finalizeDate(organized) {
  return resolveSlotsCalendar(checkIsoDateInBounds(checkIsoDateFields(organized)));
}

function resolveSlotsCalendar(organized) {
  return {
    ...organized,
    calendar: resolveCalendarId(organized.calendar)
  };
}

function parseDateTimeLike(s) {
  const parts = dateTimeRegExp.exec(s);
  return parts ? (parts => {
    const zOrOffset = parts[10], hasZ = "Z" === (zOrOffset || "").toUpperCase();
    return {
      isoYear: organizeIsoYearParts(parts),
      isoMonth: parseInt(parts[4]),
      isoDay: parseInt(parts[5]),
      ...organizeTimeParts(parts.slice(5)),
      ...organizeAnnotationParts(parts[16]),
      hasTime: Boolean(parts[6]),
      hasZ: hasZ,
      offset: hasZ ? void 0 : zOrOffset
    };
  })(parts) : void 0;
}

function parseYearMonthOnly(s) {
  const parts = yearMonthRegExp.exec(s);
  return parts ? (parts => ({
    isoYear: organizeIsoYearParts(parts),
    isoMonth: parseInt(parts[4]),
    isoDay: 1,
    ...organizeAnnotationParts(parts[5])
  }))(parts) : void 0;
}

function parseMonthDayOnly(s) {
  const parts = monthDayRegExp.exec(s);
  return parts ? (parts => ({
    isoYear: isoEpochFirstLeapYear,
    isoMonth: parseInt(parts[1]),
    isoDay: parseInt(parts[2]),
    ...organizeAnnotationParts(parts[3])
  }))(parts) : void 0;
}

function parseOffsetNanoMaybe(s, onlyHourMinute) {
  const parts = offsetRegExp.exec(s);
  return parts ? ((parts, onlyHourMinute) => {
    const firstSubMinutePart = parts[4] || parts[5];
    if (onlyHourMinute && firstSubMinutePart) {
      throw new RangeError(invalidSubstring(firstSubMinutePart));
    }
    return validateTimeZoneOffset((parseInt0(parts[2]) * nanoInHour + parseInt0(parts[3]) * nanoInMinute + parseInt0(parts[4]) * nanoInSec + parseSubsecNano(parts[5] || "")) * parseSign(parts[1]));
  })(parts, onlyHourMinute) : void 0;
}

function organizeIsoYearParts(parts) {
  const yearSign = parseSign(parts[1]), year = parseInt(parts[2] || parts[3]);
  if (yearSign < 0 && !year) {
    throw new RangeError(invalidSubstring(-0));
  }
  return yearSign * year;
}

function organizeTimeParts(parts) {
  const isoSecond = parseInt0(parts[3]);
  return {
    ...nanoToIsoTimeAndDay(parseSubsecNano(parts[4] || ""))[0],
    isoHour: parseInt0(parts[1]),
    isoMinute: parseInt0(parts[2]),
    isoSecond: 60 === isoSecond ? 59 : isoSecond
  };
}

function organizeAnnotationParts(s) {
  let calendarIsCritical, timeZoneId;
  const calendarIds = [];
  if (s.replace(annotationRegExp, ((whole, criticalStr, mainStr) => {
    const isCritical = Boolean(criticalStr), [val, name] = mainStr.split("=").reverse();
    if (name) {
      if ("u-ca" === name) {
        calendarIds.push(val), calendarIsCritical || (calendarIsCritical = isCritical);
      } else if (isCritical) {
        throw new RangeError(invalidSubstring(whole));
      }
    } else {
      if (timeZoneId) {
        throw new RangeError(invalidSubstring(whole));
      }
      timeZoneId = val;
    }
    return "";
  })), calendarIds.length > 1 && calendarIsCritical) {
    throw new RangeError(invalidSubstring(s));
  }
  return {
    timeZone: timeZoneId,
    calendar: calendarIds[0] || isoCalendarId
  };
}

function parseSubsecNano(fracStr) {
  return parseInt(fracStr.padEnd(9, "0"));
}

function createRegExp(meat) {
  return new RegExp(`^${meat}$`, "i");
}

function parseSign(s) {
  return s && "+" !== s ? -1 : 1;
}

function parseInt0(s) {
  return void 0 === s ? 0 : parseInt(s);
}

function resolveTimeZoneId(id) {
  const essence = getTimeZoneEssence(id);
  return "number" == typeof essence ? formatOffsetNano(essence) : essence ? (id => {
    if (icuRegExp.test(id)) {
      throw new RangeError(forbiddenIcuTimeZone);
    }
    return id.toLowerCase().split("/").map(((part, partI) => (part.length <= 3 || /\d/.test(part)) && !/etc|yap/.test(part) ? part.toUpperCase() : part.replace(/baja|dumont|[a-z]+/g, ((a, i) => a.length <= 2 && !partI || "in" === a || "chat" === a ? a.toUpperCase() : a.length > 2 || !i ? capitalize(a).replace(/island|noronha|murdo|rivadavia|urville/, capitalize) : a)))).join("/");
  })(id) : utcTimeZoneId;
}

function getTimeZoneAtomic(id) {
  const essence = getTimeZoneEssence(id);
  return "number" == typeof essence ? essence : essence ? essence.resolvedOptions().timeZone : utcTimeZoneId;
}

function getTimeZoneEssence(id) {
  const offsetNano = parseOffsetNanoMaybe(id = id.toUpperCase(), 1);
  return void 0 !== offsetNano ? offsetNano : id !== utcTimeZoneId ? queryTimeZoneIntlFormat(id) : void 0;
}

function compareInstants(instantSlots0, instantSlots1) {
  return compareBigNanos(instantSlots0.epochNanoseconds, instantSlots1.epochNanoseconds);
}

function compareZonedDateTimes(zonedDateTimeSlots0, zonedDateTimeSlots1) {
  return compareBigNanos(zonedDateTimeSlots0.epochNanoseconds, zonedDateTimeSlots1.epochNanoseconds);
}

function compareIsoDateTimeFields(isoFields0, isoFields1) {
  return compareIsoDateFields(isoFields0, isoFields1) || compareIsoTimeFields(isoFields0, isoFields1);
}

function compareIsoDateFields(isoFields0, isoFields1) {
  return compareNumbers(isoToEpochMilli(isoFields0), isoToEpochMilli(isoFields1));
}

function compareIsoTimeFields(isoFields0, isoFields1) {
  return compareNumbers(isoTimeFieldsToNano(isoFields0), isoTimeFieldsToNano(isoFields1));
}

function isTimeZoneSlotsEqual(a, b) {
  if (a === b) {
    return 1;
  }
  const aId = getId(a), bId = getId(b);
  if (aId === bId) {
    return 1;
  }
  try {
    return getTimeZoneAtomic(aId) === getTimeZoneAtomic(bId);
  } catch (_a) {}
}

function diffDateLike(invert, getCalendarOps, startIsoFields, endIsoFields, largestUnit, smallestUnit, roundingInc, roundingMode, origOptions) {
  const startEpochNano = isoToEpochNano(startIsoFields), endEpochNano = isoToEpochNano(endIsoFields);
  let durationFields;
  if (compareBigNanos(endEpochNano, startEpochNano)) {
    let calendarOps;
    6 === largestUnit ? durationFields = diffByDay(startIsoFields, endIsoFields) : (calendarOps = getCalendarOps(), 
    durationFields = calendarOps.dateUntil(startIsoFields, endIsoFields, largestUnit, origOptions)), 
    6 === smallestUnit && 1 === roundingInc || (calendarOps || (calendarOps = getCalendarOps()), 
    durationFields = roundRelativeDuration(durationFields, endEpochNano, largestUnit, smallestUnit, roundingInc, roundingMode, {
      ...startIsoFields,
      ...isoTimeFieldDefaults
    }, calendarOps));
  } else {
    durationFields = durationFieldDefaults;
  }
  return createDurationSlots(invert ? negateDurationFields(durationFields) : durationFields);
}

function diffZonedEpochNanoViaCalendar(calendarOps, timeZoneOps, sign, slots0, slots1, largestUnit, origOptions) {
  const startIsoFields = zonedEpochSlotsToIso(slots0, timeZoneOps), startIsoTimeFields = pluckProps(isoTimeFieldNamesAsc, startIsoFields), endIsoFields = zonedEpochSlotsToIso(slots1, timeZoneOps), endEpochNano = slots1.epochNanoseconds, isoToZonedEpochNano = bindArgs(getSingleInstantFor, timeZoneOps);
  let midIsoFields, midEpochNano, midSign, cnt = 0;
  do {
    if (cnt > 2) {
      throw new RangeError(invalidProtocolResults);
    }
    midIsoFields = {
      ...moveByIsoDays(endIsoFields, cnt++ * -sign),
      ...startIsoTimeFields
    }, midEpochNano = isoToZonedEpochNano(midIsoFields), midSign = compareBigNanos(endEpochNano, midEpochNano);
  } while (midSign === -sign);
  return {
    ...6 === largestUnit ? diffByDay(startIsoFields, midIsoFields) : calendarOps.dateUntil(startIsoFields, midIsoFields, largestUnit, origOptions),
    ...nanoToDurationTimeFields(bigNanoToNumber(diffBigNanos(midEpochNano, endEpochNano)))
  };
}

function diffDateTimesViaCalendar(calendarOps, sign, startIsoFields, endIsoFields, largestUnit, origOptions) {
  const startTimeNano = isoTimeFieldsToNano(startIsoFields);
  let timeNano = isoTimeFieldsToNano(endIsoFields) - startTimeNano, midIsoFields = startIsoFields;
  return Math.sign(timeNano) === -sign && (midIsoFields = moveByIsoDays(startIsoFields, sign), 
  timeNano += nanoInUtcDay * sign), {
    ...calendarOps.dateUntil({
      ...midIsoFields,
      ...isoTimeFieldDefaults
    }, {
      ...endIsoFields,
      ...isoTimeFieldDefaults
    }, largestUnit, origOptions),
    ...nanoToDurationTimeFields(timeNano)
  };
}

function diffEpochNano(startEpochNano, endEpochNano, largestUnit, smallestUnit, roundingInc, roundingMode) {
  return {
    ...durationFieldDefaults,
    ...nanoToDurationDayTimeFields(roundBigNano(diffBigNanos(startEpochNano, endEpochNano), smallestUnit, roundingInc, roundingMode), largestUnit)
  };
}

function diffEpochNanoExact(startEpochNano, endEpochNano, largestUnit) {
  return {
    ...durationFieldDefaults,
    ...nanoToDurationDayTimeFields(diffBigNanos(startEpochNano, endEpochNano), largestUnit)
  };
}

function diffByDay(startIsoFields, endIsoFields) {
  return {
    ...durationFieldDefaults,
    days: diffDays(startIsoFields, endIsoFields)
  };
}

function diffDays(startIsoFields, endIsoFields) {
  return diffEpochMilliByDay(isoToEpochMilli(startIsoFields), isoToEpochMilli(endIsoFields));
}

function diffEpochMilliByDay(epochMilli0, epochMilli1) {
  return Math.round((epochMilli1 - epochMilli0) / milliInDay);
}

function getCommonCalendarSlot(a, b) {
  if (!isIdLikeEqual(a, b)) {
    throw new RangeError(mismatchingCalendars);
  }
  return a;
}

function createIntlFieldCache(epochMilliToIntlFields) {
  return memoize((isoDateFields => {
    const epochMilli = isoToEpochMilli(isoDateFields);
    return epochMilliToIntlFields(epochMilli);
  }), WeakMap);
}

function createIntlYearMonthCache(epochMilliToIntlFields) {
  const yearCorrection = epochMilliToIntlFields(0).year - isoEpochOriginYear;
  return memoize((year => {
    let intlFields, epochMilli = isoArgsToEpochMilli(year - yearCorrection);
    const milliReversed = [], monthStrsReversed = [];
    do {
      epochMilli += 400 * milliInDay;
    } while ((intlFields = epochMilliToIntlFields(epochMilli)).year <= year);
    do {
      epochMilli += (1 - intlFields.day) * milliInDay, intlFields.year === year && (milliReversed.push(epochMilli), 
      monthStrsReversed.push(intlFields.month)), epochMilli -= milliInDay;
    } while ((intlFields = epochMilliToIntlFields(epochMilli)).year >= year);
    return {
      monthEpochMilli: milliReversed.reverse(),
      monthStrToIndex: mapPropNamesToIndex(monthStrsReversed.reverse())
    };
  }));
}

function parseIntlYear(intlParts, calendarIdBase) {
  let era, eraYear, year = parseIntlPartsYear(intlParts);
  if (intlParts.era) {
    const eraOrigins = eraOriginsByCalendarId[calendarIdBase];
    void 0 !== eraOrigins && (formattedEra = (formattedEra = intlParts.era).normalize("NFD").toLowerCase().replace(/[^a-z0-9]/g, ""), 
    era = eraRemaps[formattedEra] || formattedEra, eraYear = year, year = eraYearToYear(eraYear, eraOrigins[era] || 0));
  }
  var formattedEra;
  return {
    era: era,
    eraYear: eraYear,
    year: year
  };
}

function parseIntlPartsYear(intlParts) {
  return parseInt(intlParts.relatedYear || intlParts.year);
}

function computeIntlDateParts(isoFields) {
  const {year: year, month: month, day: day} = this.queryFields(isoFields), {monthStrToIndex: monthStrToIndex} = this.queryYearMonths(year);
  return [ year, monthStrToIndex[month] + 1, day ];
}

function computeIntlEpochMilli(year, month = 1, day = 1) {
  return this.queryYearMonths(year).monthEpochMilli[month - 1] + (day - 1) * milliInDay;
}

function computeIntlLeapMonth(year) {
  const currentMonthStrs = queryMonthStrs(this, year), prevMonthStrs = queryMonthStrs(this, year - 1), currentLength = currentMonthStrs.length;
  if (currentLength > prevMonthStrs.length) {
    const leapMonthMeta = getCalendarLeapMonthMeta(this);
    if (leapMonthMeta < 0) {
      return -leapMonthMeta;
    }
    for (let i = 0; i < currentLength; i++) {
      if (currentMonthStrs[i] !== prevMonthStrs[i]) {
        return i + 1;
      }
    }
  }
}

function computeIntlDaysInYear(year) {
  return diffEpochMilliByDay(computeIntlEpochMilli.call(this, year), computeIntlEpochMilli.call(this, year + 1));
}

function computeIntlDaysInMonth(year, month) {
  const {monthEpochMilli: monthEpochMilli} = this.queryYearMonths(year);
  let nextMonth = month + 1, nextMonthEpochMilli = monthEpochMilli;
  return nextMonth > monthEpochMilli.length && (nextMonth = 1, nextMonthEpochMilli = this.queryYearMonths(year + 1).monthEpochMilli), 
  diffEpochMilliByDay(monthEpochMilli[month - 1], nextMonthEpochMilli[nextMonth - 1]);
}

function computeIntlMonthsInYear(year) {
  return this.queryYearMonths(year).monthEpochMilli.length;
}

function queryMonthStrs(intlCalendar, year) {
  return Object.keys(intlCalendar.queryYearMonths(year).monthStrToIndex);
}

function resolveCalendarId(id) {
  if ((id = id.toLowerCase()) !== isoCalendarId && id !== gregoryCalendarId && computeCalendarIdBase(id) !== computeCalendarIdBase(queryCalendarIntlFormat(id).resolvedOptions().calendar)) {
    throw new RangeError(invalidCalendar(id));
  }
  return id;
}

function computeCalendarIdBase(id) {
  return "islamicc" === id && (id = "islamic"), id.split("-")[0];
}

function computeNativeWeekOfYear(isoFields) {
  return this.weekParts(isoFields)[0];
}

function computeNativeYearOfWeek(isoFields) {
  return this.weekParts(isoFields)[1];
}

function parseMonthCode(monthCode) {
  const m = monthCodeRegExp.exec(monthCode);
  if (!m) {
    throw new RangeError(invalidMonthCode(monthCode));
  }
  return [ parseInt(m[1]), Boolean(m[2]) ];
}

function monthCodeNumberToMonth(monthCodeNumber, isLeapMonth, leapMonth) {
  return monthCodeNumber + (isLeapMonth || leapMonth && monthCodeNumber >= leapMonth ? 1 : 0);
}

function monthToMonthCodeNumber(month, leapMonth) {
  return month - (leapMonth && month >= leapMonth ? 1 : 0);
}

function eraYearToYear(eraYear, eraOrigin) {
  return (eraOrigin + eraYear) * (Math.sign(eraOrigin) || 1) || 0;
}

function getCalendarEraOrigins(native) {
  return eraOriginsByCalendarId[getCalendarIdBase(native)];
}

function getCalendarLeapMonthMeta(native) {
  return leapMonthMetas[getCalendarIdBase(native)];
}

function getCalendarIdBase(native) {
  return computeCalendarIdBase(native.id || isoCalendarId);
}

function refineCalendarFields(calendarOps, bag, validFieldNames, requiredFieldNames = [], forcedValidFieldNames = []) {
  return refineFields(bag, [ ...calendarOps.fields(validFieldNames), ...forcedValidFieldNames ].sort(), requiredFieldNames);
}

function refineFields(bag, validFieldNames, requiredFieldNames, disallowEmpty = !requiredFieldNames) {
  const res = {};
  let prevFieldName, anyMatching = 0;
  for (const fieldName of validFieldNames) {
    if (fieldName === prevFieldName) {
      throw new RangeError(duplicateFields(fieldName));
    }
    if ("constructor" === fieldName || "__proto__" === fieldName) {
      throw new RangeError(forbiddenField(fieldName));
    }
    let fieldVal = bag[fieldName];
    if (void 0 !== fieldVal) {
      anyMatching = 1, builtinRefiners[fieldName] && (fieldVal = builtinRefiners[fieldName](fieldVal, fieldName)), 
      res[fieldName] = fieldVal;
    } else if (requiredFieldNames) {
      if (requiredFieldNames.includes(fieldName)) {
        throw new TypeError(missingField(fieldName));
      }
      res[fieldName] = timeFieldDefaults[fieldName];
    }
    prevFieldName = fieldName;
  }
  if (disallowEmpty && !anyMatching) {
    throw new TypeError(noValidFields(validFieldNames));
  }
  return res;
}

function refineTimeBag(fields, overflow) {
  return constrainIsoTimeFields(timeFieldsToIso({
    ...timeFieldDefaults,
    ...fields
  }), overflow);
}

function mergeCalendarFields(calendarOps, obj, bag, validFieldNames, forcedValidFieldNames = [], requiredObjFieldNames = []) {
  const fieldNames = [ ...calendarOps.fields(validFieldNames), ...forcedValidFieldNames ].sort();
  let fields = refineFields(obj, fieldNames, requiredObjFieldNames);
  const partialFields = refineFields(bag, fieldNames);
  return fields = calendarOps.mergeFields(fields, partialFields), refineFields(fields, fieldNames, []);
}

function convertToPlainMonthDay(calendarOps, input) {
  const fields = refineCalendarFields(calendarOps, input, monthCodeDayFieldNames);
  return calendarOps.monthDayFromFields(fields);
}

function convertToPlainYearMonth(calendarOps, input, options) {
  const fields = refineCalendarFields(calendarOps, input, yearMonthCodeFieldNames);
  return calendarOps.yearMonthFromFields(fields, options);
}

function convertToIso(calendarOps, input, inputFieldNames, extra, extraFieldNames) {
  input = pluckProps(inputFieldNames = calendarOps.fields(inputFieldNames), input), 
  extra = refineFields(extra, extraFieldNames = calendarOps.fields(extraFieldNames), []);
  let mergedFields = calendarOps.mergeFields(input, extra);
  return mergedFields = refineFields(mergedFields, [ ...inputFieldNames, ...extraFieldNames ].sort(), []), 
  calendarOps.dateFromFields(mergedFields);
}

function refineYear(calendarNative, fields) {
  let {era: era, eraYear: eraYear, year: year} = fields;
  const eraOrigins = getCalendarEraOrigins(calendarNative);
  if (void 0 !== era || void 0 !== eraYear) {
    if (void 0 === era || void 0 === eraYear) {
      throw new TypeError(mismatchingEraParts);
    }
    if (!eraOrigins) {
      throw new RangeError(forbiddenEraParts);
    }
    const eraOrigin = eraOrigins[era];
    if (void 0 === eraOrigin) {
      throw new RangeError(invalidEra(era));
    }
    const yearByEra = eraYearToYear(eraYear, eraOrigin);
    if (void 0 !== year && year !== yearByEra) {
      throw new RangeError(mismatchingYearAndEra);
    }
    year = yearByEra;
  } else if (void 0 === year) {
    throw new TypeError(missingYear(eraOrigins));
  }
  return year;
}

function refineMonth(calendarNative, fields, year, overflow) {
  let {month: month, monthCode: monthCode} = fields;
  if (void 0 !== monthCode) {
    const monthByCode = ((calendarNative, monthCode, year, overflow) => {
      const leapMonth = calendarNative.leapMonth(year), [monthCodeNumber, wantsLeapMonth] = parseMonthCode(monthCode);
      let month = monthCodeNumberToMonth(monthCodeNumber, wantsLeapMonth, leapMonth);
      if (wantsLeapMonth) {
        const leapMonthMeta = getCalendarLeapMonthMeta(calendarNative);
        if (void 0 === leapMonthMeta) {
          throw new RangeError(invalidLeapMonth);
        }
        if (leapMonthMeta > 0) {
          if (month > leapMonthMeta) {
            throw new RangeError(invalidLeapMonth);
          }
          if (void 0 === leapMonth) {
            if (1 === overflow) {
              throw new RangeError(invalidLeapMonth);
            }
            month--;
          }
        } else {
          if (month !== -leapMonthMeta) {
            throw new RangeError(invalidLeapMonth);
          }
          if (void 0 === leapMonth && 1 === overflow) {
            throw new RangeError(invalidLeapMonth);
          }
        }
      }
      return month;
    })(calendarNative, monthCode, year, overflow);
    if (void 0 !== month && month !== monthByCode) {
      throw new RangeError(mismatchingMonthAndCode);
    }
    month = monthByCode, overflow = 1;
  } else if (void 0 === month) {
    throw new TypeError(missingMonth);
  }
  return clampEntity("month", month, 1, calendarNative.monthsInYearPart(year), overflow);
}

function refineDay(calendarNative, fields, month, year, overflow) {
  return clampProp(fields, "day", 1, calendarNative.daysInMonthParts(year, month), overflow);
}

function spliceFields(dest, additional, allPropNames, deletablePropNames) {
  let anyMatching = 0;
  const nonMatchingPropNames = [];
  for (const propName of allPropNames) {
    void 0 !== additional[propName] ? anyMatching = 1 : nonMatchingPropNames.push(propName);
  }
  if (Object.assign(dest, additional), anyMatching) {
    for (const deletablePropName of deletablePropNames || nonMatchingPropNames) {
      delete dest[deletablePropName];
    }
  }
}

function getPreferredCalendarSlot(a, b) {
  if (a === b) {
    return a;
  }
  const aId = getId(a), bId = getId(b);
  if (aId === bId || aId === isoCalendarId) {
    return b;
  }
  if (bId === isoCalendarId) {
    return a;
  }
  throw new RangeError(mismatchingCalendars);
}

function createOptionsTransformer(validNames, fallbacks, excludedNames = []) {
  const excludedNameSet = new Set(excludedNames);
  return options => (((props, names) => {
    for (const name of names) {
      if (name in props) {
        return 1;
      }
    }
    return 0;
  })(options = excludePropsByName(excludedNameSet, options), validNames) || Object.assign(options, fallbacks), 
  options);
}

function isoDateFieldsToEpochNano(isoFields, resolvedOptions) {
  return getSingleInstantFor(queryNativeTimeZone(resolvedOptions.timeZone), {
    ...isoTimeFieldDefaults,
    isoHour: 12,
    ...isoFields
  });
}

function extractEpochNano(slots) {
  return slots.epochNanoseconds;
}

function createFormatForPrep(forcedTimeZoneId, locales, options, transformOptions) {
  if (options = transformOptions(options), forcedTimeZoneId) {
    if (void 0 !== options.timeZone) {
      throw new TypeError(forbiddenFormatTimeZone);
    }
    options.timeZone = forcedTimeZoneId;
  }
  return new RawDateTimeFormat(locales, options);
}

function toEpochMillis(config, resolvedOptions, ...slotsList) {
  const [, slotsToEpochNano, strictCalendarCheck] = config;
  return slotsList.map((slots => (slots.calendar && ((internalCalendarId, resolvedCalendarId, strictCalendarCheck) => {
    if ((strictCalendarCheck || internalCalendarId !== isoCalendarId) && internalCalendarId !== resolvedCalendarId) {
      throw new RangeError(mismatchingCalendars);
    }
  })(getId(slots.calendar), resolvedOptions.calendar, strictCalendarCheck), epochNanoToMilli(slotsToEpochNano(slots, resolvedOptions)))));
}

function getCurrentEpochNano() {
  return numberToBigNano(Date.now(), nanoInMilli);
}

const expectedInteger = (entityName, num) => `Non-integer ${entityName}: ${num}`, expectedPositive = (entityName, num) => `Non-positive ${entityName}: ${num}`, expectedFinite = (entityName, num) => `Non-finite ${entityName}: ${num}`, forbiddenBigIntToNumber = entityName => `Cannot convert bigint to ${entityName}`, invalidBigInt = arg => `Invalid bigint: ${arg}`, forbiddenSymbolToString = "Cannot convert Symbol to string", invalidObject = "Invalid object", numberOutOfRange = (entityName, val, min, max, choices) => choices ? numberOutOfRange(entityName, choices[val], choices[min], choices[max]) : invalidEntity(entityName, val) + `; must be between ${min}-${max}`, invalidEntity = (fieldName, val) => `Invalid ${fieldName}: ${val}`, missingField = fieldName => `Missing ${fieldName}`, forbiddenField = fieldName => `Invalid field ${fieldName}`, duplicateFields = fieldName => `Duplicate field ${fieldName}`, noValidFields = validFields => "No valid fields: " + validFields.join(), invalidChoice = (fieldName, val, choiceMap) => invalidEntity(fieldName, val) + "; must be " + Object.keys(choiceMap).join(), forbiddenEraParts = "Forbidden era/eraYear", mismatchingEraParts = "Mismatching era/eraYear", mismatchingYearAndEra = "Mismatching year/eraYear", invalidEra = era => `Invalid era: ${era}`, missingYear = allowEra => "Missing year" + (allowEra ? "/era/eraYear" : ""), invalidMonthCode = monthCode => `Invalid monthCode: ${monthCode}`, mismatchingMonthAndCode = "Mismatching month/monthCode", missingMonth = "Missing month/monthCode", invalidLeapMonth = "Invalid leap month", invalidProtocolResults = "Invalid protocol results", mismatchingCalendars = "Mismatching Calendars", invalidCalendar = calendarId => `Invalid Calendar: ${calendarId}`, forbiddenIcuTimeZone = "Forbidden ICU TimeZone", outOfBoundsOffset = "Out-of-bounds offset", outOfBoundsDstGap = "Out-of-bounds TimeZone gap", invalidOffsetForTimeZone = "Invalid TimeZone offset", ambigOffset = "Ambiguous offset", outOfBoundsDate = "Out-of-bounds date", outOfBoundsDuration = "Out-of-bounds duration", forbiddenDurationSigns = "Cannot mix duration signs", flippedSmallestLargestUnit = "smallestUnit > largestUnit", failedParse = s => `Cannot parse: ${s}`, invalidSubstring = substring => `Invalid substring: ${substring}`, forbiddenFormatTimeZone = "Cannot specify TimeZone", mapPropNamesToIndex = bindArgs(mapPropNames, ((_propVal, i) => i)), mapPropNamesToConstant = bindArgs(mapPropNames, ((_propVal, _i, constant) => constant)), padNumber2 = bindArgs(padNumber, 2), unitNameMap = {
  nanosecond: 0,
  microsecond: 1,
  millisecond: 2,
  second: 3,
  minute: 4,
  hour: 5,
  day: 6,
  week: 7,
  month: 8,
  year: 9
}, unitNamesAsc = Object.keys(unitNameMap), milliInDay = 864e5, milliInSec = 1e3, nanoInMicro = 1e3, nanoInMilli = 1e6, nanoInSec = 1e9, nanoInMinute = 6e10, nanoInHour = 36e11, nanoInUtcDay = 864e11, unitNanoMap = [ 1, nanoInMicro, nanoInMilli, nanoInSec, nanoInMinute, nanoInHour, nanoInUtcDay ], timeFieldNamesAsc = unitNamesAsc.slice(0, 6), timeFieldNamesAlpha = sortStrings(timeFieldNamesAsc), offsetFieldNames = [ "offset" ], timeZoneFieldNames = [ "timeZone" ], timeAndOffsetFieldNames = [ ...timeFieldNamesAsc, ...offsetFieldNames ], timeAndZoneFieldNames = [ ...timeAndOffsetFieldNames, ...timeZoneFieldNames ], eraYearFieldNames = [ "era", "eraYear" ], allYearFieldNames = [ ...eraYearFieldNames, "year" ], yearFieldNames = [ "year" ], monthCodeFieldNames = [ "monthCode" ], monthFieldNames = [ "month", ...monthCodeFieldNames ], dayFieldNames = [ "day" ], yearMonthFieldNames = [ ...monthFieldNames, ...yearFieldNames ], yearMonthCodeFieldNames = [ ...monthCodeFieldNames, ...yearFieldNames ], dateFieldNamesAlpha = [ ...dayFieldNames, ...yearMonthFieldNames ], monthDayFieldNames = [ ...dayFieldNames, ...monthFieldNames ], monthCodeDayFieldNames = [ ...dayFieldNames, ...monthCodeFieldNames ], timeFieldDefaults = mapPropNamesToConstant(timeFieldNamesAsc, 0), isoCalendarId = "iso8601", gregoryCalendarId = "gregory", eraOriginsByCalendarId = {
  [gregoryCalendarId]: {
    bce: -1,
    ce: 0
  },
  japanese: {
    bce: -1,
    ce: 0,
    meiji: 1867,
    taisho: 1911,
    showa: 1925,
    heisei: 1988,
    reiwa: 2018
  },
  ethioaa: {
    era0: 0
  },
  ethiopic: {
    era0: 0,
    era1: 5500
  },
  coptic: {
    era0: -1,
    era1: 0
  },
  roc: {
    beforeroc: -1,
    minguo: 0
  },
  buddhist: {
    be: 0
  },
  islamic: {
    ah: 0
  },
  indian: {
    saka: 0
  },
  persian: {
    ap: 0
  }
}, eraRemaps = {
  bc: "bce",
  ad: "ce"
}, leapMonthMetas = {
  chinese: 13,
  dangi: 13,
  hebrew: -6
}, durationFieldNamesAsc = unitNamesAsc.map((unitName => unitName + "s")), durationFieldNamesAlpha = sortStrings(durationFieldNamesAsc), durationTimeFieldNamesAsc = durationFieldNamesAsc.slice(0, 6), durationDateFieldNamesAsc = durationFieldNamesAsc.slice(6), durationCalendarFieldNamesAsc = durationDateFieldNamesAsc.slice(1), durationFieldIndexes = mapPropNamesToIndex(durationFieldNamesAsc), durationFieldDefaults = mapPropNamesToConstant(durationFieldNamesAsc, 0), durationTimeFieldDefaults = mapPropNamesToConstant(durationTimeFieldNamesAsc, 0), isoTimeFieldNamesAsc = [ "isoNanosecond", "isoMicrosecond", "isoMillisecond", "isoSecond", "isoMinute", "isoHour" ], isoDateFieldNamesAsc = [ "isoDay", "isoMonth", "isoYear" ], isoDateTimeFieldNamesAsc = [ ...isoTimeFieldNamesAsc, ...isoDateFieldNamesAsc ], isoDateFieldNamesAlpha = sortStrings(isoDateFieldNamesAsc), isoTimeFieldNamesAlpha = sortStrings(isoTimeFieldNamesAsc), isoDateTimeFieldNamesAlpha = sortStrings(isoDateTimeFieldNamesAsc), isoTimeFieldDefaults = mapPropNamesToConstant(isoTimeFieldNamesAlpha, 0), RawDateTimeFormat = Intl.DateTimeFormat, maxMilli = 1e8 * milliInDay, epochNanoMax = [ 1e8, 0 ], epochNanoMin = [ -1e8, 0 ], isoYearMax = 275760, isoYearMin = -271821, isoEpochOriginYear = 1970, isoEpochFirstLeapYear = 1972, isoMonthsInYear = 12, primaryJapaneseEraMilli = isoArgsToEpochMilli(1868, 9, 8), queryJapaneseEraParts = memoize((isoFields => {
  const epochMilli = isoToEpochMilli(isoFields);
  if (epochMilli < primaryJapaneseEraMilli) {
    return computeGregoryEraParts(isoFields);
  }
  const intlParts = hashIntlFormatParts(queryCalendarIntlFormat("japanese"), epochMilli), {era: era, eraYear: eraYear} = parseIntlYear(intlParts, "japanese");
  return [ era, eraYear ];
}), WeakMap), requireString = bindArgs(requireType, "string"), requireBoolean = bindArgs(requireType, "boolean"), requireNumber = bindArgs(requireType, "number"), requireFunction = bindArgs(requireType, "function"), smallestUnitStr = "smallestUnit", roundingIncName = "roundingIncrement", subsecDigitsName = "fractionalSecondDigits", overflowMap = {
  constrain: 0,
  reject: 1
}, overflowMapNames = Object.keys(overflowMap), refineSmallestUnit = bindArgs(refineUnitOption, smallestUnitStr), refineLargestUnit = bindArgs(refineUnitOption, "largestUnit"), refineTotalUnit = bindArgs(refineUnitOption, "unit"), refineOverflow = bindArgs(refineChoiceOption, "overflow", overflowMap), refineEpochDisambig = bindArgs(refineChoiceOption, "disambiguation", {
  compatible: 0,
  reject: 1,
  earlier: 2,
  later: 3
}), refineOffsetDisambig = bindArgs(refineChoiceOption, "offset", {
  reject: 0,
  use: 1,
  prefer: 2,
  ignore: 3
}), refineCalendarDisplay = bindArgs(refineChoiceOption, "calendarName", {
  auto: 0,
  never: 1,
  critical: 2,
  always: 3
}), refineTimeZoneDisplay = bindArgs(refineChoiceOption, "timeZoneName", {
  auto: 0,
  never: 1,
  critical: 2
}), refineOffsetDisplay = bindArgs(refineChoiceOption, "offset", {
  auto: 0,
  never: 1
}), refineRoundingMode = bindArgs(refineChoiceOption, "roundingMode", {
  floor: 0,
  halfFloor: 1,
  ceil: 2,
  halfCeil: 3,
  trunc: 4,
  halfTrunc: 5,
  expand: 6,
  halfExpand: 7,
  halfEven: 8
}), PlainYearMonthBranding = "PlainYearMonth", PlainMonthDayBranding = "PlainMonthDay", PlainDateBranding = "PlainDate", PlainDateTimeBranding = "PlainDateTime", PlainTimeBranding = "PlainTime", ZonedDateTimeBranding = "ZonedDateTime", InstantBranding = "Instant", DurationBranding = "Duration", roundingModeFuncs = [ Math.floor, num => hasHalf(num) ? Math.floor(num) : Math.round(num), Math.ceil, num => hasHalf(num) ? Math.ceil(num) : Math.round(num), Math.trunc, num => hasHalf(num) ? Math.trunc(num) || 0 : Math.round(num), num => num < 0 ? Math.floor(num) : Math.ceil(num), num => Math.sign(num) * Math.round(Math.abs(num)) || 0, num => hasHalf(num) ? (num = Math.trunc(num) || 0) + num % 2 : Math.round(num) ], utcTimeZoneId = "UTC", periodDur = 5184e3, minPossibleTransition = isoArgsToEpochSec(1847), maxPossibleTransition = isoArgsToEpochSec((new Date).getUTCFullYear() + 10), trailingZerosRE = /0+$/, zonedEpochSlotsToIso = memoize(((slots, getTimeZoneOps) => {
  const {epochNanoseconds: epochNanoseconds} = slots, offsetNanoseconds = (getTimeZoneOps.getOffsetNanosecondsFor ? getTimeZoneOps : getTimeZoneOps(slots.timeZone)).getOffsetNanosecondsFor(epochNanoseconds), isoDateTimeFields = epochNanoToIso(epochNanoseconds, offsetNanoseconds);
  return {
    calendar: slots.calendar,
    ...isoDateTimeFields,
    offsetNanoseconds: offsetNanoseconds
  };
}), WeakMap), maxCalendarUnit = 2 ** 32 - 1, queryNativeTimeZone = memoize((slotId => {
  const essence = getTimeZoneEssence(slotId);
  return "object" == typeof essence ? new IntlTimeZone(essence) : new FixedTimeZone(essence || 0);
}));

class FixedTimeZone {
  constructor(offsetNano) {
    this.offsetNano = offsetNano;
  }
  getOffsetNanosecondsFor() {
    return this.offsetNano;
  }
  getPossibleInstantsFor(isoDateTimeFields) {
    return [ isoToEpochNanoWithOffset(isoDateTimeFields, this.offsetNano) ];
  }
  getTransition() {}
}

class IntlTimeZone {
  constructor(format) {
    this.tzStore = (computeOffsetSec => {
      function getOffsetSec(epochSec) {
        const clampedEpochSec = clampNumber(epochSec, minTransition, maxTransition), [startEpochSec, endEpochSec] = computePeriod(clampedEpochSec), startOffsetSec = getSample(startEpochSec), endOffsetSec = getSample(endEpochSec);
        return startOffsetSec === endOffsetSec ? startOffsetSec : pinch(getSplit(startEpochSec, endEpochSec), startOffsetSec, endOffsetSec, epochSec);
      }
      function pinch(split, startOffsetSec, endOffsetSec, forEpochSec) {
        let offsetSec, splitDurSec;
        for (;(void 0 === forEpochSec || void 0 === (offsetSec = forEpochSec < split[0] ? startOffsetSec : forEpochSec >= split[1] ? endOffsetSec : void 0)) && (splitDurSec = split[1] - split[0]); ) {
          const middleEpochSec = split[0] + Math.floor(splitDurSec / 2);
          computeOffsetSec(middleEpochSec) === endOffsetSec ? split[1] = middleEpochSec : split[0] = middleEpochSec + 1;
        }
        return offsetSec;
      }
      const getSample = memoize(computeOffsetSec), getSplit = memoize(createSplitTuple);
      let minTransition = minPossibleTransition, maxTransition = maxPossibleTransition;
      return {
        getPossibleEpochSec(zonedEpochSec) {
          const wideOffsetSec0 = getOffsetSec(zonedEpochSec - 86400), wideOffsetSec1 = getOffsetSec(zonedEpochSec + 86400), wideUtcEpochSec0 = zonedEpochSec - wideOffsetSec0, wideUtcEpochSec1 = zonedEpochSec - wideOffsetSec1;
          if (wideOffsetSec0 === wideOffsetSec1) {
            return [ wideUtcEpochSec0 ];
          }
          const narrowOffsetSec0 = getOffsetSec(wideUtcEpochSec0);
          return narrowOffsetSec0 === getOffsetSec(wideUtcEpochSec1) ? [ zonedEpochSec - narrowOffsetSec0 ] : wideOffsetSec0 > wideOffsetSec1 ? [ wideUtcEpochSec0, wideUtcEpochSec1 ] : [];
        },
        getOffsetSec: getOffsetSec,
        getTransition(epochSec, direction) {
          const clampedEpochSec = clampNumber(epochSec, minTransition, maxTransition);
          let [startEpochSec, endEpochSec] = computePeriod(clampedEpochSec);
          const inc = periodDur * direction, inBounds = direction < 0 ? () => endEpochSec > minTransition || (minTransition = clampedEpochSec, 
          0) : () => startEpochSec < maxTransition || (maxTransition = clampedEpochSec, 0);
          for (;inBounds(); ) {
            const startOffsetSec = getSample(startEpochSec), endOffsetSec = getSample(endEpochSec);
            if (startOffsetSec !== endOffsetSec) {
              const split = getSplit(startEpochSec, endEpochSec);
              pinch(split, startOffsetSec, endOffsetSec);
              const transitionEpochSec = split[0];
              if ((compareNumbers(transitionEpochSec, epochSec) || 1) === direction) {
                return transitionEpochSec;
              }
            }
            startEpochSec += inc, endEpochSec += inc;
          }
        }
      };
    })((format => epochSec => {
      const intlParts = hashIntlFormatParts(format, epochSec * milliInSec);
      return isoArgsToEpochSec(parseIntlPartsYear(intlParts), parseInt(intlParts.month), parseInt(intlParts.day), parseInt(intlParts.hour), parseInt(intlParts.minute), parseInt(intlParts.second)) - epochSec;
    })(format));
  }
  getOffsetNanosecondsFor(epochNano) {
    return this.tzStore.getOffsetSec(epochNanoToSec(epochNano)) * nanoInSec;
  }
  getPossibleInstantsFor(isoFields) {
    const [zonedEpochSec, subsecNano] = [ isoArgsToEpochSec((isoDateTimeFields = isoFields).isoYear, isoDateTimeFields.isoMonth, isoDateTimeFields.isoDay, isoDateTimeFields.isoHour, isoDateTimeFields.isoMinute, isoDateTimeFields.isoSecond), isoDateTimeFields.isoMillisecond * nanoInMilli + isoDateTimeFields.isoMicrosecond * nanoInMicro + isoDateTimeFields.isoNanosecond ];
    var isoDateTimeFields;
    return this.tzStore.getPossibleEpochSec(zonedEpochSec).map((epochSec => checkEpochNanoInBounds(addBigNanoAndNumber(numberToBigNano(epochSec, nanoInSec), subsecNano))));
  }
  getTransition(epochNano, direction) {
    const [epochSec, subsecNano] = epochNanoToSecMod(epochNano), resEpochSec = this.tzStore.getTransition(epochSec + (direction > 0 || subsecNano ? 1 : 0), direction);
    if (void 0 !== resEpochSec) {
      return numberToBigNano(resEpochSec, nanoInSec);
    }
  }
}

const timeRegExpStr = "(\\d{2})(?::?(\\d{2})(?::?(\\d{2})(?:[.,](\\d{1,9}))?)?)?", offsetRegExpStr = "([+-])" + timeRegExpStr, dateTimeRegExpStr = "(?:(?:([+-])(\\d{6}))|(\\d{4}))-?(\\d{2})-?(\\d{2})(?:[T ]" + timeRegExpStr + "(Z|" + offsetRegExpStr + ")?)?", yearMonthRegExp = createRegExp("(?:(?:([+-])(\\d{6}))|(\\d{4}))-?(\\d{2})((?:\\[(!?)([^\\]]*)\\]){0,9})"), monthDayRegExp = createRegExp("(?:--)?(\\d{2})-?(\\d{2})((?:\\[(!?)([^\\]]*)\\]){0,9})"), dateTimeRegExp = createRegExp(dateTimeRegExpStr + "((?:\\[(!?)([^\\]]*)\\]){0,9})"), timeRegExp = createRegExp("T?" + timeRegExpStr + "(?:" + offsetRegExpStr + ")?((?:\\[(!?)([^\\]]*)\\]){0,9})"), offsetRegExp = createRegExp(offsetRegExpStr), annotationRegExp = new RegExp("\\[(!?)([^\\]]*)\\]", "g"), durationRegExp = createRegExp("([+-])?P(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(?:T(?:(\\d+)(?:[.,](\\d{1,9}))?H)?(?:(\\d+)(?:[.,](\\d{1,9}))?M)?(?:(\\d+)(?:[.,](\\d{1,9}))?S)?)?"), queryTimeZoneIntlFormat = memoize((id => new RawDateTimeFormat("en-GB", {
  timeZone: id,
  era: "short",
  year: "numeric",
  month: "numeric",
  day: "numeric",
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
}))), icuRegExp = /^(AC|AE|AG|AR|AS|BE|BS|CA|CN|CS|CT|EA|EC|IE|IS|JS|MI|NE|NS|PL|PN|PR|PS|SS|VS)T$/, queryIntlCalendar = memoize((calendarId => {
  function epochMilliToIntlFields(epochMilli) {
    return ((intlParts, calendarIdBase) => ({
      ...parseIntlYear(intlParts, calendarIdBase),
      month: intlParts.month,
      day: parseInt(intlParts.day)
    }))(hashIntlFormatParts(intlFormat, epochMilli), calendarIdBase);
  }
  const intlFormat = queryCalendarIntlFormat(calendarId), calendarIdBase = computeCalendarIdBase(calendarId);
  return {
    id: calendarId,
    queryFields: createIntlFieldCache(epochMilliToIntlFields),
    queryYearMonths: createIntlYearMonthCache(epochMilliToIntlFields)
  };
})), queryCalendarIntlFormat = memoize((id => new RawDateTimeFormat("en-GB", {
  calendar: id,
  timeZone: utcTimeZoneId,
  era: "short",
  year: "numeric",
  month: "short",
  day: "numeric"
}))), monthCodeRegExp = /^M(\d{2})(L?)$/, builtinRefiners = {
  era: toStringViaPrimitive,
  eraYear: toInteger,
  year: toInteger,
  month: toPositiveInteger,
  monthCode: toStringViaPrimitive,
  day: toPositiveInteger,
  ...mapPropNamesToConstant(timeFieldNamesAsc, toInteger),
  ...mapPropNamesToConstant(durationFieldNamesAsc, toStrictInteger),
  offset: toStringViaPrimitive
}, timeFieldsToIso = bindArgs(((oldNames, newNames, oldProps) => {
  const newProps = {};
  for (let i = 0; i < oldNames.length; i++) {
    newProps[newNames[i]] = oldProps[oldNames[i]];
  }
  return newProps;
}), timeFieldNamesAsc, isoTimeFieldNamesAsc), nativeStandardBase = {
  dateAdd(isoDateFields, durationFields, options) {
    const overflow = refineOverflowOptions(options);
    let epochMilli, {years: years, months: months, weeks: weeks, days: days} = durationFields;
    if (days += givenFieldsToBigNano(durationFields, 5, durationFieldNamesAsc)[0], years || months) {
      let [year, month, day] = this.dateParts(isoDateFields);
      if (years) {
        const [monthCodeNumber, isLeapMonth] = this.monthCodeParts(year, month);
        year += years, month = monthCodeNumberToMonth(monthCodeNumber, isLeapMonth, this.leapMonth(year)), 
        month = clampEntity("month", month, 1, this.monthsInYearPart(year), overflow);
      }
      months && ([year, month] = this.monthAdd(year, month, months)), day = clampEntity("day", day, 1, this.daysInMonthParts(year, month), overflow), 
      epochMilli = this.epochMilli(year, month, day);
    } else {
      if (!weeks && !days) {
        return isoDateFields;
      }
      epochMilli = isoToEpochMilli(isoDateFields);
    }
    return epochMilli += (7 * weeks + days) * milliInDay, checkIsoDateInBounds(epochMilliToIso(epochMilli));
  },
  dateUntil(startIsoFields, endIsoFields, largestUnit) {
    if (largestUnit <= 7) {
      let weeks = 0, days = diffDays(startIsoFields, endIsoFields);
      return 7 === largestUnit && ([weeks, days] = divModTrunc(days, 7)), {
        ...durationFieldDefaults,
        weeks: weeks,
        days: days
      };
    }
    const yearMonthDayStart = this.dateParts(startIsoFields), yearMonthDayEnd = this.dateParts(endIsoFields);
    let [years, months, days] = ((calendarNative, year0, month0, day0, year1, month1, day1) => {
      let yearDiff = year1 - year0, monthDiff = month1 - month0, dayDiff = day1 - day0;
      if (yearDiff || monthDiff) {
        const sign = Math.sign(yearDiff || monthDiff);
        let daysInMonth1 = calendarNative.daysInMonthParts(year1, month1), dayCorrect = 0;
        if (Math.sign(dayDiff) === -sign) {
          const origDaysInMonth1 = daysInMonth1;
          [year1, month1] = calendarNative.monthAdd(year1, month1, -sign), yearDiff = year1 - year0, 
          monthDiff = month1 - month0, daysInMonth1 = calendarNative.daysInMonthParts(year1, month1), 
          dayCorrect = sign < 0 ? -origDaysInMonth1 : daysInMonth1;
        }
        if (dayDiff = day1 - Math.min(day0, daysInMonth1) + dayCorrect, yearDiff) {
          const [monthCodeNumber0, isLeapYear0] = calendarNative.monthCodeParts(year0, month0), [monthCodeNumber1, isLeapYear1] = calendarNative.monthCodeParts(year1, month1);
          if (monthDiff = monthCodeNumber1 - monthCodeNumber0 || Number(isLeapYear1) - Number(isLeapYear0), 
          Math.sign(monthDiff) === -sign) {
            const monthCorrect = sign < 0 && -calendarNative.monthsInYearPart(year1);
            yearDiff = (year1 -= sign) - year0, monthDiff = month1 - monthCodeNumberToMonth(monthCodeNumber0, isLeapYear0, calendarNative.leapMonth(year1)) + (monthCorrect || calendarNative.monthsInYearPart(year1));
          }
        }
      }
      return [ yearDiff, monthDiff, dayDiff ];
    })(this, ...yearMonthDayStart, ...yearMonthDayEnd);
    return 8 === largestUnit && (months += this.monthsInYearSpan(years, yearMonthDayStart[0]), 
    years = 0), {
      ...durationFieldDefaults,
      years: years,
      months: months,
      days: days
    };
  },
  dateFromFields(fields, options) {
    const overflow = refineOverflowOptions(options), year = refineYear(this, fields), month = refineMonth(this, fields, year, overflow), day = refineDay(this, fields, month, year, overflow);
    return createPlainDateSlots(checkIsoDateInBounds(this.isoFields(year, month, day)), this.id || isoCalendarId);
  },
  yearMonthFromFields(fields, options) {
    const overflow = refineOverflowOptions(options), year = refineYear(this, fields), month = refineMonth(this, fields, year, overflow);
    return createPlainYearMonthSlots(checkIsoYearMonthInBounds(this.isoFields(year, month, 1)), this.id || isoCalendarId);
  },
  monthDayFromFields(fields, options) {
    const overflow = refineOverflowOptions(options), isIso = !this.id, {monthCode: monthCode, year: year, month: month} = fields;
    let monthCodeNumber, isLeapMonth, normalYear, normalMonth, normalDay;
    if (void 0 !== monthCode) {
      [monthCodeNumber, isLeapMonth] = parseMonthCode(monthCode), normalDay = getDefinedProp(fields, "day");
      const res = this.yearMonthForMonthDay(monthCodeNumber, isLeapMonth, normalDay);
      if (!res) {
        throw new RangeError("Cannot guess year");
      }
      if ([normalYear, normalMonth] = res, void 0 !== month && month !== normalMonth) {
        throw new RangeError(mismatchingMonthAndCode);
      }
      isIso && (normalMonth = clampEntity("month", normalMonth, 1, isoMonthsInYear, 1), 
      normalDay = clampEntity("day", normalDay, 1, computeIsoDaysInMonth(void 0 !== year ? year : normalYear, normalMonth), overflow));
    } else {
      normalYear = void 0 === year && isIso ? isoEpochFirstLeapYear : refineYear(this, fields), 
      normalMonth = refineMonth(this, fields, normalYear, overflow), normalDay = refineDay(this, fields, normalMonth, normalYear, overflow);
      const leapMonth = this.leapMonth(normalYear);
      isLeapMonth = normalMonth === leapMonth, monthCodeNumber = monthToMonthCodeNumber(normalMonth, leapMonth);
      const res = this.yearMonthForMonthDay(monthCodeNumber, isLeapMonth, normalDay);
      if (!res) {
        throw new RangeError("Cannot guess year");
      }
      [normalYear, normalMonth] = res;
    }
    return createPlainMonthDaySlots(this.isoFields(normalYear, normalMonth, normalDay), this.id || isoCalendarId);
  },
  fields(fieldNames) {
    return getCalendarEraOrigins(this) && fieldNames.includes("year") ? [ ...fieldNames, ...eraYearFieldNames ] : fieldNames;
  },
  mergeFields(baseFields, additionalFields) {
    const merged = Object.assign(Object.create(null), baseFields);
    return spliceFields(merged, additionalFields, monthFieldNames), getCalendarEraOrigins(this) && (spliceFields(merged, additionalFields, allYearFieldNames), 
    "japanese" === this.id && spliceFields(merged, additionalFields, monthDayFieldNames, eraYearFieldNames)), 
    merged;
  },
  inLeapYear(isoFields) {
    const [year] = this.dateParts(isoFields);
    return this.inLeapYearPart(year);
  },
  monthsInYear(isoFields) {
    const [year] = this.dateParts(isoFields);
    return this.monthsInYearPart(year);
  },
  daysInMonth(isoFields) {
    const [year, month] = this.dateParts(isoFields);
    return this.daysInMonthParts(year, month);
  },
  daysInYear(isoFields) {
    const [year] = this.dateParts(isoFields);
    return this.daysInYearPart(year);
  },
  era(isoFields) {
    return this.eraParts(isoFields)[0];
  },
  eraYear(isoFields) {
    return this.eraParts(isoFields)[1];
  },
  monthCode(isoFields) {
    const [year, month] = this.dateParts(isoFields), [monthCodeNumber, isLeapMonth] = this.monthCodeParts(year, month);
    return ((monthCodeNumber, isLeapMonth) => "M" + padNumber2(monthCodeNumber) + (isLeapMonth ? "L" : ""))(monthCodeNumber, isLeapMonth);
  },
  dayOfWeek: computeIsoDayOfWeek,
  daysInWeek() {
    return 7;
  }
}, isoWeekOps = {
  weekOfYear: computeNativeWeekOfYear,
  yearOfWeek: computeNativeYearOfWeek,
  weekParts(isoDateFields) {
    function computeWeekShift(yDayOfWeek) {
      return (7 - yDayOfWeek < minDaysInWeek ? 7 : 0) - yDayOfWeek;
    }
    function computeWeeksInYear(delta) {
      const daysInYear = computeIsoDaysInYear(yearOfWeek + delta), sign = delta || 1;
      return (daysInYear + (computeWeekShift(modFloor(y0DayOfWeek + daysInYear * sign, 7)) - y0WeekShift) * sign) / 7;
    }
    const minDaysInWeek = this.id ? 1 : 4, isoDayOfWeek = computeIsoDayOfWeek(isoDateFields), isoDayOfYear = computeIsoDayOfYear(isoDateFields), dayOfWeek = modFloor(isoDayOfWeek - 1, 7), dayOfYear = isoDayOfYear - 1, y0DayOfWeek = modFloor(dayOfWeek - dayOfYear, 7), y0WeekShift = computeWeekShift(y0DayOfWeek);
    let weekOfYear = Math.floor((dayOfYear - y0WeekShift) / 7) + 1, yearOfWeek = isoDateFields.isoYear;
    return weekOfYear ? weekOfYear > computeWeeksInYear(0) && (weekOfYear = 1, yearOfWeek++) : (weekOfYear = computeWeeksInYear(-1), 
    yearOfWeek--), [ weekOfYear, yearOfWeek ];
  }
}, isoStandardOps = {
  ...nativeStandardBase,
  ...isoWeekOps,
  dateParts(isoFields) {
    return [ isoFields.isoYear, isoFields.isoMonth, isoFields.isoDay ];
  },
  eraParts(isoFields) {
    return this.id === gregoryCalendarId ? computeGregoryEraParts(isoFields) : "japanese" === this.id ? queryJapaneseEraParts(isoFields) : [];
  },
  monthCodeParts(_isoYear, isoMonth) {
    return [ isoMonth, 0 ];
  },
  yearMonthForMonthDay(monthCodeNumber, isLeapMonth) {
    if (!isLeapMonth) {
      return [ isoEpochFirstLeapYear, monthCodeNumber ];
    }
  },
  inLeapYearPart: computeIsoInLeapYear,
  leapMonth() {},
  monthsInYearPart: computeIsoMonthsInYear,
  monthsInYearSpan: yearDelta => yearDelta * isoMonthsInYear,
  daysInMonthParts: computeIsoDaysInMonth,
  daysInYearPart: computeIsoDaysInYear,
  dayOfYear: computeIsoDayOfYear,
  isoFields(year, month, day) {
    return {
      isoYear: year,
      isoMonth: month,
      isoDay: day
    };
  },
  epochMilli: isoArgsToEpochMilli,
  monthAdd(year, month, monthDelta) {
    return year += divTrunc(monthDelta, isoMonthsInYear), (month += modTrunc(monthDelta, isoMonthsInYear)) < 1 ? (year--, 
    month += isoMonthsInYear) : month > isoMonthsInYear && (year++, month -= isoMonthsInYear), 
    [ year, month ];
  },
  year(isoFields) {
    return isoFields.isoYear;
  },
  month(isoFields) {
    return isoFields.isoMonth;
  },
  day: isoFields => isoFields.isoDay
}, intlWeekOps = {
  weekOfYear: computeNativeWeekOfYear,
  yearOfWeek: computeNativeYearOfWeek,
  weekParts() {
    return [];
  }
}, intlStandardOps = {
  ...nativeStandardBase,
  ...intlWeekOps,
  dateParts: computeIntlDateParts,
  eraParts(isoFields) {
    const intlFields = this.queryFields(isoFields);
    return [ intlFields.era, intlFields.eraYear ];
  },
  monthCodeParts(year, month) {
    const leapMonth = computeIntlLeapMonth.call(this, year);
    return [ monthToMonthCodeNumber(month, leapMonth), leapMonth === month ];
  },
  yearMonthForMonthDay(monthCodeNumber, isLeapMonth, day) {
    let [startYear, startMonth, startDay] = computeIntlDateParts.call(this, {
      isoYear: isoEpochFirstLeapYear,
      isoMonth: isoMonthsInYear,
      isoDay: 31
    });
    const startYearLeapMonth = computeIntlLeapMonth.call(this, startYear), startMonthIsLeap = startMonth === startYearLeapMonth;
    1 === (compareNumbers(monthCodeNumber, monthToMonthCodeNumber(startMonth, startYearLeapMonth)) || compareNumbers(Number(isLeapMonth), Number(startMonthIsLeap)) || compareNumbers(day, startDay)) && startYear--;
    for (let yearMove = 0; yearMove < 100; yearMove++) {
      const tryYear = startYear - yearMove, tryLeapMonth = computeIntlLeapMonth.call(this, tryYear), tryMonth = monthCodeNumberToMonth(monthCodeNumber, isLeapMonth, tryLeapMonth);
      if (isLeapMonth === (tryMonth === tryLeapMonth) && day <= computeIntlDaysInMonth.call(this, tryYear, tryMonth)) {
        return [ tryYear, tryMonth ];
      }
    }
  },
  inLeapYearPart(year) {
    const days = computeIntlDaysInYear.call(this, year);
    return days > computeIntlDaysInYear.call(this, year - 1) && days > computeIntlDaysInYear.call(this, year + 1);
  },
  leapMonth: computeIntlLeapMonth,
  monthsInYearPart: computeIntlMonthsInYear,
  monthsInYearSpan(yearDelta, yearStart) {
    const yearEnd = yearStart + yearDelta, yearSign = Math.sign(yearDelta), yearCorrection = yearSign < 0 ? -1 : 0;
    let months = 0;
    for (let year = yearStart; year !== yearEnd; year += yearSign) {
      months += computeIntlMonthsInYear.call(this, year + yearCorrection);
    }
    return months;
  },
  daysInMonthParts: computeIntlDaysInMonth,
  daysInYearPart: computeIntlDaysInYear,
  dayOfYear(isoFields) {
    const dayEpochMilli = isoToEpochMilli({
      ...isoFields,
      ...isoTimeFieldDefaults
    }), {year: year} = this.queryFields(isoFields);
    return diffEpochMilliByDay(computeIntlEpochMilli.call(this, year), dayEpochMilli) + 1;
  },
  isoFields(year, month, day) {
    return checkIsoDateInBounds({
      ...epochMilliToIso(computeIntlEpochMilli.call(this, year, month, day))
    });
  },
  epochMilli: computeIntlEpochMilli,
  monthAdd(year, month, monthDelta) {
    if (monthDelta) {
      if (month += monthDelta, !Number.isSafeInteger(month)) {
        throw new RangeError(outOfBoundsDate);
      }
      if (monthDelta < 0) {
        for (;month < 1; ) {
          month += computeIntlMonthsInYear.call(this, --year);
        }
      } else {
        let monthsInYear;
        for (;month > (monthsInYear = computeIntlMonthsInYear.call(this, year)); ) {
          month -= monthsInYear, year++;
        }
      }
    }
    return [ year, month ];
  },
  year(isoFields) {
    return this.queryFields(isoFields).year;
  },
  month(isoFields) {
    const {year: year, month: month} = this.queryFields(isoFields), {monthStrToIndex: monthStrToIndex} = this.queryYearMonths(year);
    return monthStrToIndex[month] + 1;
  },
  day(isoFields) {
    return this.queryFields(isoFields).day;
  }
}, createNativeStandardOps = (isoOps = isoStandardOps, intlOps = intlStandardOps, 
calendarId => calendarId === isoCalendarId ? isoOps : calendarId === gregoryCalendarId || "japanese" === calendarId ? Object.assign(Object.create(isoOps), {
  id: calendarId
}) : Object.assign(Object.create(intlOps), queryIntlCalendar(calendarId)));

var isoOps, intlOps;

const timeZoneNameStrs = [ "timeZoneName" ], monthDayFallbacks = {
  month: "numeric",
  day: "numeric"
}, yearMonthFallbacks = {
  year: "numeric",
  month: "numeric"
}, dateFallbacks = {
  ...yearMonthFallbacks,
  day: "numeric"
}, timeFallbacks = {
  hour: "numeric",
  minute: "numeric",
  second: "numeric"
}, dateTimeFallbacks = {
  ...dateFallbacks,
  ...timeFallbacks
}, zonedFallbacks = {
  ...dateTimeFallbacks,
  timeZoneName: "short"
}, monthDayValidNames = Object.keys(monthDayFallbacks), yearMonthValidNames = Object.keys(yearMonthFallbacks), dateValidNames = [ ...Object.keys(dateFallbacks), "weekday", "dateStyle" ], timeValidNames = [ ...Object.keys(timeFallbacks), "dayPeriod", "timeStyle" ], dateTimeValidNames = [ ...dateValidNames, ...timeValidNames ], zonedValidNames = [ ...dateTimeValidNames, ...timeZoneNameStrs ], dateExclusions = [ ...timeZoneNameStrs, ...timeValidNames ], timeExclusions = [ ...timeZoneNameStrs, ...dateValidNames ], yearMonthExclusions = [ ...timeZoneNameStrs, "day", "weekday", "dateStyle", ...timeValidNames ], transformMonthDayOptions = createOptionsTransformer(monthDayValidNames, monthDayFallbacks, [ ...timeZoneNameStrs, "year", "weekday", "dateStyle", ...timeValidNames ]), plainYearMonthConfig = [ createOptionsTransformer(yearMonthValidNames, yearMonthFallbacks, yearMonthExclusions), isoDateFieldsToEpochNano, 1 ], plainMonthDayConfig = [ transformMonthDayOptions, isoDateFieldsToEpochNano, 1 ], plainDateConfig = [ createOptionsTransformer(dateValidNames, dateFallbacks, dateExclusions), isoDateFieldsToEpochNano ], plainDateTimeConfig = [ createOptionsTransformer(dateTimeValidNames, dateTimeFallbacks, timeZoneNameStrs), isoDateFieldsToEpochNano ], plainTimeConfig = [ createOptionsTransformer(timeValidNames, timeFallbacks, timeExclusions), (internals, resolvedOptions) => getSingleInstantFor(queryNativeTimeZone(resolvedOptions.timeZone), {
  isoYear: isoEpochOriginYear,
  isoMonth: 1,
  isoDay: 1,
  ...internals
}) ], instantConfig = [ createOptionsTransformer(dateTimeValidNames, dateTimeFallbacks), extractEpochNano ], zonedDateTimeConfig = [ createOptionsTransformer(zonedValidNames, zonedFallbacks), extractEpochNano, 0, (slots0, slots1) => {
  const timeZoneId = getId(slots0.timeZone);
  if (slots1 && getId(slots1.timeZone) !== timeZoneId) {
    throw new RangeError("Mismatching TimeZones");
  }
  return timeZoneId;
} ], emptyOptions = {};

let currentTimeZoneId;

exports.DurationBranding = DurationBranding, exports.InstantBranding = InstantBranding, 
exports.PlainDateBranding = PlainDateBranding, exports.PlainDateTimeBranding = PlainDateTimeBranding, 
exports.PlainMonthDayBranding = PlainMonthDayBranding, exports.PlainTimeBranding = PlainTimeBranding, 
exports.PlainYearMonthBranding = PlainYearMonthBranding, exports.RawDateTimeFormat = RawDateTimeFormat, 
exports.ZonedDateTimeBranding = ZonedDateTimeBranding, exports.absDuration = slots => -1 === slots.sign ? negateDuration(slots) : slots, 
exports.addDurations = (refineRelativeTo, getCalendarOps, getTimeZoneOps, doSubtract, slots, otherSlots, options) => {
  const relativeToSlots = refineRelativeTo(normalizeOptions(options).relativeTo), largestUnit = Math.max(getLargestDurationUnit(slots), getLargestDurationUnit(otherSlots));
  if (largestUnit < 6 || 6 === largestUnit && (!relativeToSlots || !relativeToSlots.epochNanoseconds)) {
    return createDurationSlots(checkDurationUnits(((a, b, largestUnit, doSubtract) => {
      const combined = addBigNanos(durationFieldsToBigNano(a), durationFieldsToBigNano(b), doSubtract ? -1 : 1);
      if (!Number.isFinite(combined[0])) {
        throw new RangeError(outOfBoundsDate);
      }
      return {
        ...durationFieldDefaults,
        ...nanoToDurationDayTimeFields(combined, largestUnit)
      };
    })(slots, otherSlots, largestUnit, doSubtract)));
  }
  if (!relativeToSlots) {
    throw new RangeError("Missing relativeTo");
  }
  return doSubtract && (otherSlots = negateDurationFields(otherSlots)), createDurationSlots(spanDuration(slots, otherSlots, largestUnit, ...createRelativeSystem(getCalendarOps, getTimeZoneOps, relativeToSlots))[0]);
}, exports.bigNanoToNumber = bigNanoToNumber, exports.bindArgs = bindArgs, exports.buildZonedIsoFields = (getTimeZoneOps, zonedDateTimeSlots) => {
  const isoFields = zonedEpochSlotsToIso(zonedDateTimeSlots, getTimeZoneOps);
  return {
    calendar: zonedDateTimeSlots.calendar,
    ...pluckProps(isoDateTimeFieldNamesAlpha, isoFields),
    offset: formatOffsetNano(isoFields.offsetNanoseconds),
    timeZone: zonedDateTimeSlots.timeZone
  };
}, exports.compareBigNanos = compareBigNanos, exports.compareDurations = (refineRelativeTo, getCalendarOps, getTimeZoneOps, durationSlots0, durationSlots1, options) => {
  const relativeToSlots = refineRelativeTo(normalizeOptions(options).relativeTo), largestUnit = Math.max(getLargestDurationUnit(durationSlots0), getLargestDurationUnit(durationSlots1));
  if (allPropsEqual(durationFieldNamesAsc, durationSlots0, durationSlots1)) {
    return 0;
  }
  if (largestUnit < 6 || 6 === largestUnit && (!relativeToSlots || !relativeToSlots.epochNanoseconds)) {
    return compareBigNanos(givenFieldsToBigNano(durationSlots0, 6, durationFieldNamesAsc), givenFieldsToBigNano(durationSlots1, 6, durationFieldNamesAsc));
  }
  if (!relativeToSlots) {
    throw new RangeError("Missing relativeTo");
  }
  const [marker, calendarOps, timeZoneOps] = createRelativeSystem(getCalendarOps, getTimeZoneOps, relativeToSlots);
  return compareBigNanos(relativeMarkerToEpochNano(moveRelativeMarker(durationSlots0, marker, calendarOps, timeZoneOps), timeZoneOps), relativeMarkerToEpochNano(moveRelativeMarker(durationSlots1, marker, calendarOps, timeZoneOps), timeZoneOps));
}, exports.compareInstants = compareInstants, exports.compareIsoDateFields = compareIsoDateFields, 
exports.compareIsoDateTimeFields = compareIsoDateTimeFields, exports.compareIsoTimeFields = compareIsoTimeFields, 
exports.compareZonedDateTimes = compareZonedDateTimes, exports.computeHoursInDay = (getTimeZoneOps, zonedDateTimeSlots) => {
  const timeZoneOps = getTimeZoneOps(zonedDateTimeSlots.timeZone);
  return computeTimeInDay(timeZoneOps, zonedEpochSlotsToIso(zonedDateTimeSlots, timeZoneOps), nanoInHour);
}, exports.computeStartOfDay = (getTimeZoneOps, zonedDateTimeSlots) => {
  let {epochNanoseconds: epochNanoseconds, timeZone: timeZone, calendar: calendar} = zonedDateTimeSlots;
  const timeZoneOps = getTimeZoneOps(timeZone);
  return epochNanoseconds = getMatchingInstantFor(timeZoneOps, {
    ...zonedEpochSlotsToIso(zonedDateTimeSlots, timeZoneOps),
    ...isoTimeFieldDefaults
  }, void 0, 0, 0, 1), createZonedDateTimeSlots(epochNanoseconds, timeZone, calendar);
}, exports.constructDurationSlots = (years = 0, months = 0, weeks = 0, days = 0, hours = 0, minutes = 0, seconds = 0, milliseconds = 0, microseconds = 0, nanoseconds = 0) => createDurationSlots(checkDurationUnits(mapProps(toStrictInteger, zipProps(durationFieldNamesAsc, [ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds ])))), 
exports.constructInstantSlots = epochNano => createInstantSlots(checkEpochNanoInBounds(bigIntToBigNano(toBigInt(epochNano)))), 
exports.constructPlainDateSlots = (refineCalendarArg, isoYear, isoMonth, isoDay, calendarArg = isoCalendarId) => createPlainDateSlots(checkIsoDateInBounds(checkIsoDateFields(mapProps(toInteger, {
  isoYear: isoYear,
  isoMonth: isoMonth,
  isoDay: isoDay
}))), refineCalendarArg(calendarArg)), exports.constructPlainDateTimeSlots = (refineCalendarArg, isoYear, isoMonth, isoDay, isoHour = 0, isoMinute = 0, isoSecond = 0, isoMillisecond = 0, isoMicrosecond = 0, isoNanosecond = 0, calendarArg = isoCalendarId) => createPlainDateTimeSlots(checkIsoDateTimeInBounds(checkIsoDateTimeFields(mapProps(toInteger, zipProps(isoDateTimeFieldNamesAsc, [ isoYear, isoMonth, isoDay, isoHour, isoMinute, isoSecond, isoMillisecond, isoMicrosecond, isoNanosecond ])))), refineCalendarArg(calendarArg)), 
exports.constructPlainMonthDaySlots = (refineCalendarArg, isoMonth, isoDay, calendar = isoCalendarId, referenceIsoYear = isoEpochFirstLeapYear) => {
  const isoMonthInt = toInteger(isoMonth), isoDayInt = toInteger(isoDay), calendarSlot = refineCalendarArg(calendar);
  return createPlainMonthDaySlots(checkIsoDateInBounds(checkIsoDateFields({
    isoYear: toInteger(referenceIsoYear),
    isoMonth: isoMonthInt,
    isoDay: isoDayInt
  })), calendarSlot);
}, exports.constructPlainTimeSlots = (isoHour = 0, isoMinute = 0, isoSecond = 0, isoMillisecond = 0, isoMicrosecond = 0, isoNanosecond = 0) => createPlainTimeSlots(constrainIsoTimeFields(mapProps(toInteger, zipProps(isoTimeFieldNamesAsc, [ isoHour, isoMinute, isoSecond, isoMillisecond, isoMicrosecond, isoNanosecond ])), 1)), 
exports.constructPlainYearMonthSlots = (refineCalendarArg, isoYear, isoMonth, calendar = isoCalendarId, referenceIsoDay = 1) => {
  const isoYearInt = toInteger(isoYear), isoMonthInt = toInteger(isoMonth), calendarSlot = refineCalendarArg(calendar);
  return createPlainYearMonthSlots(checkIsoYearMonthInBounds(checkIsoDateFields({
    isoYear: isoYearInt,
    isoMonth: isoMonthInt,
    isoDay: toInteger(referenceIsoDay)
  })), calendarSlot);
}, exports.constructZonedDateTimeSlots = (refineCalendarArg, refineTimeZoneArg, epochNano, timeZoneArg, calendarArg = isoCalendarId) => createZonedDateTimeSlots(checkEpochNanoInBounds(bigIntToBigNano(toBigInt(epochNano))), refineTimeZoneArg(timeZoneArg), refineCalendarArg(calendarArg)), 
exports.copyOptions = copyOptions, exports.createDurationSlots = createDurationSlots, 
exports.createFormatForPrep = createFormatForPrep, exports.createFormatPrepper = (config, queryFormat = createFormatForPrep) => {
  const [transformOptions, , , getForcedTimeZoneId] = config;
  return (locales, options = emptyOptions, ...slotsList) => {
    const subformat = queryFormat(getForcedTimeZoneId ? getForcedTimeZoneId(...slotsList) : void 0, locales, options, transformOptions), resolvedOptions = subformat.resolvedOptions();
    return [ subformat, ...toEpochMillis(config, resolvedOptions, ...slotsList) ];
  };
}, exports.createGetterDescriptors = getters => mapProps((getter => ({
  get: getter,
  configurable: 1
})), getters), exports.createInstantSlots = createInstantSlots, exports.createNameDescriptors = name => createPropDescriptors({
  name: name
}, 1), exports.createNativeStandardOps = createNativeStandardOps, exports.createPlainDateSlots = createPlainDateSlots, 
exports.createPlainDateTimeSlots = createPlainDateTimeSlots, exports.createPlainTimeSlots = createPlainTimeSlots, 
exports.createPropDescriptors = createPropDescriptors, exports.createStringTagDescriptors = value => ({
  [Symbol.toStringTag]: {
    value: value,
    configurable: 1
  }
}), exports.createZonedDateTimeSlots = createZonedDateTimeSlots, exports.dateFieldNamesAlpha = dateFieldNamesAlpha, 
exports.diffBigNanos = diffBigNanos, exports.diffInstants = (invert, instantSlots0, instantSlots1, options) => {
  const optionsTuple = refineDiffOptions(invert, copyOptions(options), 3, 5), durationFields = diffEpochNano(instantSlots0.epochNanoseconds, instantSlots1.epochNanoseconds, ...optionsTuple);
  return createDurationSlots(invert ? negateDurationFields(durationFields) : durationFields);
}, exports.diffPlainDateTimes = (getCalendarOps, invert, plainDateTimeSlots0, plainDateTimeSlots1, options) => {
  const calendarSlot = getCommonCalendarSlot(plainDateTimeSlots0.calendar, plainDateTimeSlots1.calendar), optionsCopy = copyOptions(options), [largestUnit, smallestUnit, roundingInc, roundingMode] = refineDiffOptions(invert, optionsCopy, 6), startEpochNano = isoToEpochNano(plainDateTimeSlots0), endEpochNano = isoToEpochNano(plainDateTimeSlots1), sign = compareBigNanos(endEpochNano, startEpochNano);
  let durationFields;
  if (sign) {
    if (largestUnit <= 6) {
      durationFields = diffEpochNano(startEpochNano, endEpochNano, largestUnit, smallestUnit, roundingInc, roundingMode);
    } else {
      const calendarOps = getCalendarOps(calendarSlot);
      durationFields = diffDateTimesViaCalendar(calendarOps, sign, plainDateTimeSlots0, plainDateTimeSlots1, largestUnit, optionsCopy), 
      !sign || 0 === smallestUnit && 1 === roundingInc || (durationFields = roundRelativeDuration(durationFields, endEpochNano, largestUnit, smallestUnit, roundingInc, roundingMode, plainDateTimeSlots0, calendarOps));
    }
  } else {
    durationFields = durationFieldDefaults;
  }
  return createDurationSlots(invert ? negateDurationFields(durationFields) : durationFields);
}, exports.diffPlainDates = (getCalendarOps, invert, plainDateSlots0, plainDateSlots1, options) => {
  const calendarSlot = getCommonCalendarSlot(plainDateSlots0.calendar, plainDateSlots1.calendar), optionsCopy = copyOptions(options);
  return diffDateLike(invert || 0, (() => getCalendarOps(calendarSlot)), plainDateSlots0, plainDateSlots1, ...refineDiffOptions(invert, optionsCopy, 6, 9, 6), optionsCopy);
}, exports.diffPlainTimes = (invert, plainTimeSlots0, plainTimeSlots1, options) => {
  const optionsCopy = copyOptions(options), [largestUnit, smallestUnit, roundingInc, roundingMode] = refineDiffOptions(invert, optionsCopy, 5, 5), startTimeNano = isoTimeFieldsToNano(plainTimeSlots0), timeNano = roundByInc(isoTimeFieldsToNano(plainTimeSlots1) - startTimeNano, computeNanoInc(smallestUnit, roundingInc), roundingMode), durationFields = {
    ...durationFieldDefaults,
    ...nanoToDurationTimeFields(timeNano, largestUnit)
  };
  return createDurationSlots(invert ? negateDurationFields(durationFields) : durationFields);
}, exports.diffPlainYearMonth = (getCalendarOps, invert, plainYearMonthSlots0, plainYearMonthSlots1, options) => {
  const calendarSlot = getCommonCalendarSlot(plainYearMonthSlots0.calendar, plainYearMonthSlots1.calendar), optionsCopy = copyOptions(options), optionsTuple = refineDiffOptions(invert, optionsCopy, 9, 9, 8), calendarOps = getCalendarOps(calendarSlot);
  return diffDateLike(invert || 0, (() => calendarOps), moveToMonthStart(calendarOps, plainYearMonthSlots0), moveToMonthStart(calendarOps, plainYearMonthSlots1), ...optionsTuple, optionsCopy);
}, exports.diffZonedDateTimes = (getCalendarOps, getTimeZoneOps, invert, zonedDateTimeSlots0, zonedDateTimeSlots1, options) => {
  const calendarSlot = getCommonCalendarSlot(zonedDateTimeSlots0.calendar, zonedDateTimeSlots1.calendar), optionsCopy = copyOptions(options), [largestUnit, smallestUnit, roundingInc, roundingMode] = refineDiffOptions(invert, optionsCopy, 5), startEpochNano = zonedDateTimeSlots0.epochNanoseconds, endEpochNano = zonedDateTimeSlots1.epochNanoseconds, sign = compareBigNanos(endEpochNano, startEpochNano);
  let durationFields;
  if (sign) {
    if (largestUnit < 6) {
      durationFields = diffEpochNano(startEpochNano, endEpochNano, largestUnit, smallestUnit, roundingInc, roundingMode);
    } else {
      const timeZoneOps = getTimeZoneOps(((a, b) => {
        if (!isTimeZoneSlotsEqual(a, b)) {
          throw new RangeError("Mismatching TimeZones");
        }
        return a;
      })(zonedDateTimeSlots0.timeZone, zonedDateTimeSlots1.timeZone)), calendarOps = getCalendarOps(calendarSlot);
      durationFields = diffZonedEpochNanoViaCalendar(calendarOps, timeZoneOps, sign, zonedDateTimeSlots0, zonedDateTimeSlots1, largestUnit, optionsCopy), 
      !sign || 0 === smallestUnit && 1 === roundingInc || (durationFields = roundRelativeDuration(durationFields, endEpochNano, largestUnit, smallestUnit, roundingInc, roundingMode, zonedDateTimeSlots0, calendarOps, timeZoneOps));
    }
  } else {
    durationFields = durationFieldDefaults;
  }
  return createDurationSlots(invert ? negateDurationFields(durationFields) : durationFields);
}, exports.durationFieldNamesAsc = durationFieldNamesAsc, exports.durationWithFields = (slots, fields) => {
  return createDurationSlots((initialFields = slots, modFields = fields, checkDurationUnits({
    ...initialFields,
    ...refineFields(modFields, durationFieldNamesAlpha)
  })));
  var initialFields, modFields;
}, exports.epochMicroToInstant = epochMicro => createInstantSlots(checkEpochNanoInBounds(bigIntToBigNano(toBigInt(epochMicro), nanoInMicro))), 
exports.epochMilliToInstant = epochMilli => createInstantSlots(checkEpochNanoInBounds(numberToBigNano(epochMilli, nanoInMilli))), 
exports.epochNanoToInstant = epochNano => createInstantSlots(checkEpochNanoInBounds(bigIntToBigNano(toBigInt(epochNano)))), 
exports.epochNanoToIso = epochNanoToIso, exports.epochSecToInstant = epochSec => createInstantSlots(checkEpochNanoInBounds(numberToBigNano(epochSec, nanoInSec))), 
exports.excludePropsByName = excludePropsByName, exports.excludeUndefinedProps = props => {
  props = {
    ...props
  };
  const propNames = Object.keys(props);
  for (const propName of propNames) {
    void 0 === props[propName] && delete props[propName];
  }
  return props;
}, exports.forbiddenField = forbiddenField, exports.forbiddenValueOf = "Cannot use valueOf", 
exports.formatDurationIso = (slots, options) => {
  const [roundingMode, nanoInc, subsecDigits] = refineTimeDisplayOptions(options, 3);
  return nanoInc > 1 && (slots = {
    ...slots,
    ...balanceDayTimeDurationByInc(slots, Math.min(getLargestDurationUnit(slots), 6), nanoInc, roundingMode)
  }), ((durationSlots, subsecDigits) => {
    const {sign: sign} = durationSlots, abs = -1 === sign ? negateDurationFields(durationSlots) : durationSlots, {hours: hours, minutes: minutes} = abs, [wholeSeconds, subsecNano] = divModBigNano(givenFieldsToBigNano(abs, 3, durationFieldNamesAsc), nanoInSec, divModTrunc);
    checkDurationTimeUnit(wholeSeconds);
    const subsecNanoString = formatSubsecNano(subsecNano, subsecDigits), forceSeconds = subsecDigits >= 0 || !sign || subsecNanoString;
    return (sign < 0 ? "-" : "") + "P" + formatDurationFragments({
      Y: formatDurationNumber(abs.years),
      M: formatDurationNumber(abs.months),
      W: formatDurationNumber(abs.weeks),
      D: formatDurationNumber(abs.days)
    }) + (hours || minutes || wholeSeconds || forceSeconds ? "T" + formatDurationFragments({
      H: formatDurationNumber(hours),
      M: formatDurationNumber(minutes),
      S: formatDurationNumber(wholeSeconds, forceSeconds) + subsecNanoString
    }) : "");
  })(slots, subsecDigits);
}, exports.formatInstantIso = (refineTimeZoneArg, getTimeZoneOps, instantSlots, options) => {
  const [timeZoneArg, roundingMode, nanoInc, subsecDigits] = (options => {
    const timeDisplayTuple = refineTimeDisplayTuple(options = normalizeOptions(options));
    return [ options.timeZone, ...timeDisplayTuple ];
  })(options), providedTimeZone = void 0 !== timeZoneArg;
  return ((providedTimeZone, timeZoneOps, epochNano, roundingMode, nanoInc, subsecDigits) => {
    epochNano = roundBigNanoByInc(epochNano, nanoInc, roundingMode, 1);
    const offsetNano = timeZoneOps.getOffsetNanosecondsFor(epochNano);
    return formatIsoDateTimeFields(epochNanoToIso(epochNano, offsetNano), subsecDigits) + (providedTimeZone ? formatOffsetNano(roundToMinute(offsetNano)) : "Z");
  })(providedTimeZone, getTimeZoneOps(providedTimeZone ? refineTimeZoneArg(timeZoneArg) : utcTimeZoneId), instantSlots.epochNanoseconds, roundingMode, nanoInc, subsecDigits);
}, exports.formatOffsetNano = formatOffsetNano, exports.formatPlainDateIso = (plainDateSlots, options) => {
  return calendarIdLike = plainDateSlots.calendar, isoFields = plainDateSlots, calendarDisplay = refineDateDisplayOptions(options), 
  formatIsoDateFields(isoFields) + formatCalendar(calendarIdLike, calendarDisplay);
  var calendarIdLike, isoFields, calendarDisplay;
}, exports.formatPlainDateTimeIso = (plainDateTimeSlots0, options) => ((calendarIdLike, isoFields, calendarDisplay, roundingMode, nanoInc, subsecDigits) => formatIsoDateTimeFields(roundDateTimeToNano(isoFields, nanoInc, roundingMode), subsecDigits) + formatCalendar(calendarIdLike, calendarDisplay))(plainDateTimeSlots0.calendar, plainDateTimeSlots0, ...(options => (options = normalizeOptions(options), 
[ refineCalendarDisplay(options), ...refineTimeDisplayTuple(options) ]))(options)), 
exports.formatPlainMonthDayIso = (plainMonthDaySlots, options) => formatDateLikeIso(plainMonthDaySlots.calendar, formatIsoMonthDayFields, plainMonthDaySlots, refineDateDisplayOptions(options)), 
exports.formatPlainTimeIso = (slots, options) => ((fields, roundingMode, nanoInc, subsecDigits) => formatIsoTimeFields(roundTimeToNano(fields, nanoInc, roundingMode)[0], subsecDigits))(slots, ...refineTimeDisplayOptions(options)), 
exports.formatPlainYearMonthIso = (plainYearMonthSlots, options) => formatDateLikeIso(plainYearMonthSlots.calendar, formatIsoYearMonthFields, plainYearMonthSlots, refineDateDisplayOptions(options)), 
exports.formatZonedDateTimeIso = (getTimeZoneOps, zonedDateTimeSlots0, options) => ((getTimeZoneOps, calendarSlot, timeZoneSlot, epochNano, calendarDisplay, timeZoneDisplay, offsetDisplay, roundingMode, nanoInc, subsecDigits) => {
  epochNano = roundBigNanoByInc(epochNano, nanoInc, roundingMode, 1);
  const offsetNano = getTimeZoneOps(timeZoneSlot).getOffsetNanosecondsFor(epochNano);
  return formatIsoDateTimeFields(epochNanoToIso(epochNano, offsetNano), subsecDigits) + formatOffsetNano(roundToMinute(offsetNano), offsetDisplay) + ((timeZoneNative, timeZoneDisplay) => 1 !== timeZoneDisplay ? "[" + (2 === timeZoneDisplay ? "!" : "") + getId(timeZoneNative) + "]" : "")(timeZoneSlot, timeZoneDisplay) + formatCalendar(calendarSlot, calendarDisplay);
})(getTimeZoneOps, zonedDateTimeSlots0.calendar, zonedDateTimeSlots0.timeZone, zonedDateTimeSlots0.epochNanoseconds, ...(options => {
  options = normalizeOptions(options);
  const calendarDisplay = refineCalendarDisplay(options), subsecDigits = refineSubsecDigits(options), offsetDisplay = refineOffsetDisplay(options), roundingMode = refineRoundingMode(options, 4), smallestUnit = refineSmallestUnit(options, 4);
  return [ calendarDisplay, refineTimeZoneDisplay(options), offsetDisplay, roundingMode, ...refineSmallestUnitAndSubsecDigits(smallestUnit, subsecDigits) ];
})(options)), exports.getCurrentEpochNano = getCurrentEpochNano, exports.getCurrentIsoDateTime = timeZoneOps => {
  const epochNano = getCurrentEpochNano();
  return epochNanoToIso(epochNano, timeZoneOps.getOffsetNanosecondsFor(epochNano));
}, exports.getCurrentTimeZoneId = () => currentTimeZoneId || (currentTimeZoneId = (new RawDateTimeFormat).resolvedOptions().timeZone), 
exports.getDurationBlank = slots => !slots.sign, exports.getEpochMicroseconds = slots => bigNanoToBigInt(slots.epochNanoseconds, nanoInMicro), 
exports.getEpochMilliseconds = slots => epochNanoToMilli(slots.epochNanoseconds), 
exports.getEpochNanoseconds = slots => bigNanoToBigInt(slots.epochNanoseconds), 
exports.getEpochSeconds = slots => epochNanoToSec(slots.epochNanoseconds), exports.getId = getId, 
exports.getRequiredDateFields = calendarId => calendarId === isoCalendarId ? [ "year", "day" ] : [], 
exports.getRequiredMonthDayFields = calendarId => calendarId === isoCalendarId ? dayFieldNames : [], 
exports.getRequiredYearMonthFields = calendarId => calendarId === isoCalendarId ? yearFieldNames : [], 
exports.getSingleInstantFor = getSingleInstantFor, exports.hasAllPropsByName = (props, names) => {
  for (const name of names) {
    if (!(name in props)) {
      return 0;
    }
  }
  return 1;
}, exports.instantConfig = instantConfig, exports.instantToZonedDateTime = (instantSlots, timeZoneSlot, calendarSlot = isoCalendarId) => createZonedDateTimeSlots(instantSlots.epochNanoseconds, timeZoneSlot, calendarSlot), 
exports.instantsEqual = (instantSlots0, instantSlots1) => !compareInstants(instantSlots0, instantSlots1), 
exports.invalidBag = "Invalid bag", exports.invalidCallingContext = "Invalid calling context", 
exports.invalidFormatType = branding => `Cannot format ${branding}`, exports.invalidProtocol = "Invalid protocol", 
exports.isObjectLike = isObjectLike, exports.isTimeZoneSlotsEqual = isTimeZoneSlotsEqual, 
exports.isoCalendarId = isoCalendarId, exports.isoTimeFieldDefaults = isoTimeFieldDefaults, 
exports.isoTimeFieldNamesAsc = isoTimeFieldNamesAsc, exports.mapPropNames = mapPropNames, 
exports.mapProps = mapProps, exports.memoize = memoize, exports.mismatchingFormatTypes = "Mismatching types for formatting", 
exports.moveInstant = (doSubtract, instantSlots, durationSlots) => createInstantSlots(checkEpochNanoInBounds(addBigNanos(instantSlots.epochNanoseconds, (fields => {
  if (durationHasDateParts(fields)) {
    throw new RangeError("Cannot use large units");
  }
  return durationFieldsToBigNano(fields, 5);
})(doSubtract ? negateDurationFields(durationSlots) : durationSlots)))), exports.movePlainDate = (getCalendarOps, doSubtract, plainDateSlots, durationSlots, options) => {
  const {calendar: calendar} = plainDateSlots;
  return createPlainDateSlots(moveDateEfficient(getCalendarOps(calendar), plainDateSlots, doSubtract ? negateDurationFields(durationSlots) : durationSlots, options), calendar);
}, exports.movePlainDateTime = (getCalendarOps, doSubtract, plainDateTimeSlots, durationSlots, options = Object.create(null)) => {
  const {calendar: calendar} = plainDateTimeSlots;
  return createPlainDateTimeSlots(moveDateTime(getCalendarOps(calendar), plainDateTimeSlots, doSubtract ? negateDurationFields(durationSlots) : durationSlots, options), calendar);
}, exports.movePlainTime = (doSubtract, slots, durationSlots) => createPlainTimeSlots(moveTime(slots, doSubtract ? negateDurationFields(durationSlots) : durationSlots)[0]), 
exports.movePlainYearMonth = (getCalendarOps, doSubtract, plainYearMonthSlots, durationSlots, options = Object.create(null)) => {
  const calendarSlot = plainYearMonthSlots.calendar, calendarOps = getCalendarOps(calendarSlot);
  let isoDateFields = moveToMonthStart(calendarOps, plainYearMonthSlots);
  doSubtract && (durationSlots = negateDuration(durationSlots)), durationSlots.sign < 0 && (isoDateFields = calendarOps.dateAdd(isoDateFields, {
    ...durationFieldDefaults,
    months: 1
  }), isoDateFields = moveByIsoDays(isoDateFields, -1));
  const movedIsoDateFields = calendarOps.dateAdd(isoDateFields, durationSlots, options);
  return createPlainYearMonthSlots(moveToMonthStart(calendarOps, movedIsoDateFields), calendarSlot);
}, exports.moveZonedDateTime = (getCalendarOps, getTimeZoneOps, doSubtract, zonedDateTimeSlots, durationSlots, options = Object.create(null)) => {
  const timeZoneOps = getTimeZoneOps(zonedDateTimeSlots.timeZone), movedEpochNanoseconds = moveZonedEpochSlots(getCalendarOps(zonedDateTimeSlots.calendar), timeZoneOps, zonedDateTimeSlots, doSubtract ? negateDurationFields(durationSlots) : durationSlots, options);
  return {
    ...zonedDateTimeSlots,
    epochNanoseconds: movedEpochNanoseconds
  };
}, exports.nanoInMilli = nanoInMilli, exports.negateDuration = negateDuration, exports.numberToBigNano = numberToBigNano, 
exports.parseCalendarId = s => {
  const res = parseDateTimeLike(s) || parseYearMonthOnly(s) || parseMonthDayOnly(s);
  return res ? res.calendar : s;
}, exports.parseDuration = s => {
  const parsed = (s => {
    const parts = durationRegExp.exec(s);
    return parts ? (parts => {
      function parseUnit(wholeStr, fracStr, timeUnit) {
        let leftoverUnits = 0, wholeUnits = 0;
        if (timeUnit && ([leftoverUnits, leftoverNano] = divModFloor(leftoverNano, unitNanoMap[timeUnit])), 
        void 0 !== wholeStr) {
          if (hasAnyFrac) {
            throw new RangeError(invalidSubstring(wholeStr));
          }
          wholeUnits = (s => {
            const n = parseInt(s);
            if (!Number.isFinite(n)) {
              throw new RangeError(invalidSubstring(s));
            }
            return n;
          })(wholeStr), hasAny = 1, fracStr && (leftoverNano = parseSubsecNano(fracStr) * (unitNanoMap[timeUnit] / nanoInSec), 
          hasAnyFrac = 1);
        }
        return leftoverUnits + wholeUnits;
      }
      let hasAny = 0, hasAnyFrac = 0, leftoverNano = 0, durationFields = {
        ...zipProps(durationFieldNamesAsc, [ parseUnit(parts[2]), parseUnit(parts[3]), parseUnit(parts[4]), parseUnit(parts[5]), parseUnit(parts[6], parts[7], 5), parseUnit(parts[8], parts[9], 4), parseUnit(parts[10], parts[11], 3) ]),
        ...nanoToGivenFields(leftoverNano, 2, durationFieldNamesAsc)
      };
      if (!hasAny) {
        throw new RangeError(noValidFields(durationFieldNamesAsc));
      }
      return parseSign(parts[1]) < 0 && (durationFields = negateDurationFields(durationFields)), 
      durationFields;
    })(parts) : void 0;
  })(requireString(s));
  if (!parsed) {
    throw new RangeError(failedParse(s));
  }
  return createDurationSlots(checkDurationUnits(parsed));
}, exports.parseInstant = s => {
  const organized = parseDateTimeLike(s = toStringViaPrimitive(s));
  if (!organized) {
    throw new RangeError(failedParse(s));
  }
  let offsetNano;
  if (organized.hasZ) {
    offsetNano = 0;
  } else {
    if (!organized.offset) {
      throw new RangeError(failedParse(s));
    }
    offsetNano = parseOffsetNano(organized.offset);
  }
  return organized.timeZone && parseOffsetNanoMaybe(organized.timeZone, 1), createInstantSlots(isoToEpochNanoWithOffset(checkIsoDateTimeFields(organized), offsetNano));
}, exports.parsePlainDate = parsePlainDate, exports.parsePlainDateTime = s => {
  const organized = parseDateTimeLike(requireString(s));
  if (!organized || organized.hasZ) {
    throw new RangeError(failedParse(s));
  }
  return createPlainDateTimeSlots(finalizeDateTime(organized));
}, exports.parsePlainMonthDay = (getCalendarOps, s) => {
  const organized = parseMonthDayOnly(requireString(s));
  if (organized) {
    return requireIsoCalendar(organized), createPlainMonthDaySlots(checkIsoDateFields(organized));
  }
  const dateSlots = parsePlainDate(s), {calendar: calendar} = dateSlots, calendarOps = getCalendarOps(calendar), [origYear, origMonth, day] = calendarOps.dateParts(dateSlots), [monthCodeNumber, isLeapMonth] = calendarOps.monthCodeParts(origYear, origMonth), [year, month] = calendarOps.yearMonthForMonthDay(monthCodeNumber, isLeapMonth, day);
  return createPlainMonthDaySlots(calendarOps.isoFields(year, month, day), calendar);
}, exports.parsePlainTime = s => {
  let altParsed, organized = (s => {
    const parts = timeRegExp.exec(s);
    return parts ? (organizeAnnotationParts(parts[10]), organizeTimeParts(parts)) : void 0;
  })(requireString(s));
  if (!organized) {
    if (organized = parseDateTimeLike(s), !organized) {
      throw new RangeError(failedParse(s));
    }
    if (!organized.hasTime) {
      throw new RangeError(failedParse(s));
    }
    if (organized.hasZ) {
      throw new RangeError(invalidSubstring("Z"));
    }
    requireIsoCalendar(organized);
  }
  if ((altParsed = parseYearMonthOnly(s)) && isIsoDateFieldsValid(altParsed)) {
    throw new RangeError(failedParse(s));
  }
  if ((altParsed = parseMonthDayOnly(s)) && isIsoDateFieldsValid(altParsed)) {
    throw new RangeError(failedParse(s));
  }
  return createPlainTimeSlots(constrainIsoTimeFields(organized, 1));
}, exports.parsePlainYearMonth = (getCalendarOps, s) => {
  const organized = parseYearMonthOnly(requireString(s));
  if (organized) {
    return requireIsoCalendar(organized), createPlainYearMonthSlots(checkIsoYearMonthInBounds(checkIsoDateFields(organized)));
  }
  const isoFields = parsePlainDate(s), movedIsoFields = moveToMonthStart(getCalendarOps(isoFields.calendar), isoFields);
  return createPlainYearMonthSlots({
    ...isoFields,
    ...movedIsoFields
  });
}, exports.parseRelativeToSlots = s => {
  const organized = parseDateTimeLike(requireString(s));
  if (!organized) {
    throw new RangeError(failedParse(s));
  }
  if (organized.timeZone) {
    return finalizeZonedDateTime(organized, organized.offset ? parseOffsetNano(organized.offset) : void 0);
  }
  if (organized.hasZ) {
    throw new RangeError(failedParse(s));
  }
  return finalizeDate(organized);
}, exports.parseTimeZoneId = s => {
  const parsed = parseDateTimeLike(s);
  return parsed && (parsed.timeZone || parsed.hasZ && utcTimeZoneId || parsed.offset) || s;
}, exports.parseZonedDateTime = (s, options) => {
  const organized = parseDateTimeLike(requireString(s));
  if (!organized || !organized.timeZone) {
    throw new RangeError(failedParse(s));
  }
  const {offset: offset} = organized, offsetNano = offset ? parseOffsetNano(offset) : void 0, [, offsetDisambig, epochDisambig] = refineZonedFieldOptions(options);
  return finalizeZonedDateTime(organized, offsetNano, offsetDisambig, epochDisambig);
}, exports.plainDateConfig = plainDateConfig, exports.plainDateTimeConfig = plainDateTimeConfig, 
exports.plainDateTimeToPlainMonthDay = (getCalendarOps, plainDateTimeSlots, plainDateFields) => convertToPlainMonthDay(getCalendarOps(plainDateTimeSlots.calendar), plainDateFields), 
exports.plainDateTimeToPlainYearMonth = (getCalendarOps, plainDateTimeSlots, plainDateFields) => {
  const calendarOps = getCalendarOps(plainDateTimeSlots.calendar);
  return createPlainYearMonthSlots({
    ...plainDateTimeSlots,
    ...convertToPlainYearMonth(calendarOps, plainDateFields)
  });
}, exports.plainDateTimeToZonedDateTime = (getTimeZoneOps, plainDateTimeSlots, timeZoneSlot, options) => createZonedDateTimeSlots(((getTimeZoneOps, timeZoneSlot, isoFields, options) => {
  const epochDisambig = refineEpochDisambigOptions(options);
  return checkEpochNanoInBounds(getSingleInstantFor(getTimeZoneOps(timeZoneSlot), isoFields, epochDisambig));
})(getTimeZoneOps, timeZoneSlot, plainDateTimeSlots, options), timeZoneSlot, plainDateTimeSlots.calendar), 
exports.plainDateTimeWithFields = (getCalendarOps, plainDateTimeSlots, initialFields, modFields, options) => {
  const optionsCopy = copyOptions(options);
  return createPlainDateTimeSlots(((calendarOps, initialFields, modFields, options) => {
    const fields = mergeCalendarFields(calendarOps, initialFields, modFields, dateFieldNamesAlpha, timeFieldNamesAsc), overflow = refineOverflowOptions(options);
    return checkIsoDateTimeInBounds({
      ...calendarOps.dateFromFields(fields, overrideOverflowOptions(options, overflow)),
      ...refineTimeBag(fields, overflow)
    });
  })(getCalendarOps(plainDateTimeSlots.calendar), initialFields, modFields, optionsCopy));
}, exports.plainDateTimeWithPlainDate = (plainDateTimeSlots, plainDateSlots) => createPlainDateTimeSlots({
  ...plainDateTimeSlots,
  ...plainDateSlots
}, getPreferredCalendarSlot(plainDateTimeSlots.calendar, plainDateSlots.calendar)), 
exports.plainDateTimeWithPlainTime = (plainDateTimeSlots, plainTimeSlots = isoTimeFieldDefaults) => createPlainDateTimeSlots({
  ...plainDateTimeSlots,
  ...plainTimeSlots
}), exports.plainDateTimesEqual = (plainDateTimeSlots0, plainDateTimeSlots1) => !compareIsoDateTimeFields(plainDateTimeSlots0, plainDateTimeSlots1) && isIdLikeEqual(plainDateTimeSlots0.calendar, plainDateTimeSlots1.calendar), 
exports.plainDateToPlainDateTime = (plainDateSlots, plainTimeFields = isoTimeFieldDefaults) => createPlainDateTimeSlots(checkIsoDateTimeInBounds({
  ...plainDateSlots,
  ...plainTimeFields
})), exports.plainDateToPlainMonthDay = (getCalendarOps, plainDateSlots, plainDateFields) => convertToPlainMonthDay(getCalendarOps(plainDateSlots.calendar), plainDateFields), 
exports.plainDateToPlainYearMonth = (getCalendarOps, plainDateSlots, plainDateFields) => convertToPlainYearMonth(getCalendarOps(plainDateSlots.calendar), plainDateFields), 
exports.plainDateToZonedDateTime = (refineTimeZoneArg, refinePlainTimeArg, getTimeZoneOps, plainDateSlots, options) => {
  const timeZoneSlot = refineTimeZoneArg(options.timeZone), plainTimeArg = options.plainTime, isoTimeFields = void 0 !== plainTimeArg ? refinePlainTimeArg(plainTimeArg) : isoTimeFieldDefaults;
  return createZonedDateTimeSlots(getSingleInstantFor(getTimeZoneOps(timeZoneSlot), {
    ...plainDateSlots,
    ...isoTimeFields
  }), timeZoneSlot, plainDateSlots.calendar);
}, exports.plainDateWithFields = (getCalendarOps, plainDateSlots, initialFields, modFields, options) => {
  const optionsCopy = copyOptions(options);
  return ((calendarOps, initialFields, modFields, options) => {
    const fields = mergeCalendarFields(calendarOps, initialFields, modFields, dateFieldNamesAlpha);
    return calendarOps.dateFromFields(fields, options);
  })(getCalendarOps(plainDateSlots.calendar), initialFields, modFields, optionsCopy);
}, exports.plainDatesEqual = (plainDateSlots0, plainDateSlots1) => !compareIsoDateFields(plainDateSlots0, plainDateSlots1) && isIdLikeEqual(plainDateSlots0.calendar, plainDateSlots1.calendar), 
exports.plainMonthDayConfig = plainMonthDayConfig, exports.plainMonthDayToPlainDate = (getCalendarOps, plainMonthDaySlots, plainMonthDayFields, bag) => ((calendarOps, input, bag) => convertToIso(calendarOps, input, monthCodeDayFieldNames, requireObjectLike(bag), yearFieldNames))(getCalendarOps(plainMonthDaySlots.calendar), plainMonthDayFields, bag), 
exports.plainMonthDayWithFields = (getCalendarOps, plainMonthDaySlots, initialFields, modFields, options) => {
  const optionsCopy = copyOptions(options);
  return ((calendarOps, initialFields, modFields, options) => {
    const fields = mergeCalendarFields(calendarOps, initialFields, modFields, dateFieldNamesAlpha);
    return calendarOps.monthDayFromFields(fields, options);
  })(getCalendarOps(plainMonthDaySlots.calendar), initialFields, modFields, optionsCopy);
}, exports.plainMonthDaysEqual = (plainMonthDaySlots0, plainMonthDaySlots1) => !compareIsoDateFields(plainMonthDaySlots0, plainMonthDaySlots1) && isIdLikeEqual(plainMonthDaySlots0.calendar, plainMonthDaySlots1.calendar), 
exports.plainTimeConfig = plainTimeConfig, exports.plainTimeToPlainDateTime = (plainTimeSlots0, plainDateSlots1) => createPlainDateTimeSlots(checkIsoDateTimeInBounds({
  ...plainTimeSlots0,
  ...plainDateSlots1
})), exports.plainTimeToZonedDateTime = (refineTimeZoneArg, refinePlainDateArg, getTimeZoneOps, slots, options) => {
  const refinedOptions = requireObjectLike(options), plainDateSlots = refinePlainDateArg(refinedOptions.plainDate), timeZoneSlot = refineTimeZoneArg(refinedOptions.timeZone);
  return createZonedDateTimeSlots(getSingleInstantFor(getTimeZoneOps(timeZoneSlot), {
    ...plainDateSlots,
    ...slots
  }), timeZoneSlot, plainDateSlots.calendar);
}, exports.plainTimeWithFields = (initialFields, mod, options) => createPlainTimeSlots(((initialFields, modFields, options) => {
  const overflow = refineOverflowOptions(options);
  return refineTimeBag({
    ...pluckProps(timeFieldNamesAlpha, initialFields),
    ...refineFields(modFields, timeFieldNamesAlpha)
  }, overflow);
})(initialFields, mod, options)), exports.plainTimesEqual = (plainTimeSlots0, plainTimeSlots1) => !compareIsoTimeFields(plainTimeSlots0, plainTimeSlots1), 
exports.plainYearMonthConfig = plainYearMonthConfig, exports.plainYearMonthToPlainDate = (getCalendarOps, plainYearMonthSlots, plainYearMonthFields, bag) => ((calendarOps, input, bag) => convertToIso(calendarOps, input, yearMonthCodeFieldNames, requireObjectLike(bag), dayFieldNames))(getCalendarOps(plainYearMonthSlots.calendar), plainYearMonthFields, bag), 
exports.plainYearMonthWithFields = (getCalendarOps, plainYearMonthSlots, initialFields, modFields, options) => {
  const optionsCopy = copyOptions(options);
  return createPlainYearMonthSlots(((calendarOps, initialFields, modFields, options) => {
    const fields = mergeCalendarFields(calendarOps, initialFields, modFields, yearMonthFieldNames);
    return calendarOps.yearMonthFromFields(fields, options);
  })(getCalendarOps(plainYearMonthSlots.calendar), initialFields, modFields, optionsCopy));
}, exports.plainYearMonthsEqual = (plainYearMonthSlots0, plainYearMonthSlots1) => !compareIsoDateFields(plainYearMonthSlots0, plainYearMonthSlots1) && isIdLikeEqual(plainYearMonthSlots0.calendar, plainYearMonthSlots1.calendar), 
exports.pluckProps = pluckProps, exports.queryNativeTimeZone = queryNativeTimeZone, 
exports.refineCalendarDiffOptions = options => (options = normalizeOptions(options), 
refineLargestUnit(options, 9, 6, 1)), exports.refineDurationBag = bag => {
  const durationFields = refineFields(bag, durationFieldNamesAlpha);
  return createDurationSlots(checkDurationUnits({
    ...durationFieldDefaults,
    ...durationFields
  }));
}, exports.refineEpochDisambigOptions = refineEpochDisambigOptions, exports.refineMaybeZonedDateTimeBag = (refineTimeZoneArg, getTimeZoneOps, calendarOps, bag) => {
  const fields = refineCalendarFields(calendarOps, bag, dateFieldNamesAlpha, [], timeAndZoneFieldNames);
  if (void 0 !== fields.timeZone) {
    const isoDateFields = calendarOps.dateFromFields(fields), isoTimeFields = refineTimeBag(fields), timeZoneSlot = refineTimeZoneArg(fields.timeZone);
    return {
      epochNanoseconds: getMatchingInstantFor(getTimeZoneOps(timeZoneSlot), {
        ...isoDateFields,
        ...isoTimeFields
      }, void 0 !== fields.offset ? parseOffsetNano(fields.offset) : void 0),
      timeZone: timeZoneSlot
    };
  }
  return {
    ...calendarOps.dateFromFields(fields),
    ...isoTimeFieldDefaults
  };
}, exports.refineOverflowOptions = refineOverflowOptions, exports.refinePlainDateBag = (calendarOps, bag, options, requireFields = []) => {
  const fields = refineCalendarFields(calendarOps, bag, dateFieldNamesAlpha, requireFields);
  return calendarOps.dateFromFields(fields, options);
}, exports.refinePlainDateTimeBag = (calendarOps, bag, options) => {
  const fields = refineCalendarFields(calendarOps, bag, dateFieldNamesAlpha, [], timeFieldNamesAsc), overflow = refineOverflowOptions(options);
  return createPlainDateTimeSlots(checkIsoDateTimeInBounds({
    ...calendarOps.dateFromFields(fields, overrideOverflowOptions(options, overflow)),
    ...refineTimeBag(fields, overflow)
  }));
}, exports.refinePlainMonthDayBag = (calendarOps, calendarAbsent, bag, options, requireFields = []) => {
  const fields = refineCalendarFields(calendarOps, bag, dateFieldNamesAlpha, requireFields);
  return calendarAbsent && void 0 !== fields.month && void 0 === fields.monthCode && void 0 === fields.year && (fields.year = isoEpochFirstLeapYear), 
  calendarOps.monthDayFromFields(fields, options);
}, exports.refinePlainTimeBag = (bag, options) => {
  const overflow = refineOverflowOptions(options);
  return createPlainTimeSlots(refineTimeBag(refineFields(bag, timeFieldNamesAlpha, [], 1), overflow));
}, exports.refinePlainYearMonthBag = (calendarOps, bag, options, requireFields) => {
  const fields = refineCalendarFields(calendarOps, bag, yearMonthFieldNames, requireFields);
  return calendarOps.yearMonthFromFields(fields, options);
}, exports.refineZonedDateTimeBag = (refineTimeZoneArg, getTimeZoneOps, calendarOps, calendarSlot, bag, options) => {
  const fields = refineCalendarFields(calendarOps, bag, dateFieldNamesAlpha, timeZoneFieldNames, timeAndZoneFieldNames), timeZoneSlot = refineTimeZoneArg(fields.timeZone), [overflow, offsetDisambig, epochDisambig] = refineZonedFieldOptions(options), isoDateFields = calendarOps.dateFromFields(fields, overrideOverflowOptions(options, overflow)), isoTimeFields = refineTimeBag(fields, overflow);
  return createZonedDateTimeSlots(getMatchingInstantFor(getTimeZoneOps(timeZoneSlot), {
    ...isoDateFields,
    ...isoTimeFields
  }, void 0 !== fields.offset ? parseOffsetNano(fields.offset) : void 0, offsetDisambig, epochDisambig), timeZoneSlot, calendarSlot);
}, exports.refineZonedFieldOptions = refineZonedFieldOptions, exports.requireBoolean = requireBoolean, 
exports.requireFunction = requireFunction, exports.requireInteger = requireInteger, 
exports.requireIntegerOrUndefined = input => {
  if (void 0 !== input) {
    return requireInteger(input);
  }
}, exports.requireNonNullish = o => {
  if (null == o) {
    throw new TypeError("Cannot be null or undefined");
  }
  return o;
}, exports.requireObjectLike = requireObjectLike, exports.requirePositiveInteger = requirePositiveInteger, 
exports.requirePositiveIntegerOrUndefined = input => {
  if (void 0 !== input) {
    return requirePositiveInteger(input);
  }
}, exports.requireString = requireString, exports.requireStringOrUndefined = input => {
  if (void 0 !== input) {
    return requireString(input);
  }
}, exports.resolveCalendarId = resolveCalendarId, exports.resolveTimeZoneId = resolveTimeZoneId, 
exports.roundDuration = (refineRelativeTo, getCalendarOps, getTimeZoneOps, slots, options) => {
  const durationLargestUnit = getLargestDurationUnit(slots), [largestUnit, smallestUnit, roundingInc, roundingMode, relativeToSlots] = ((options, defaultLargestUnit, refineRelativeTo) => {
    options = normalizeUnitNameOptions(options, smallestUnitStr);
    let largestUnit = refineLargestUnit(options);
    const relativeToInternals = refineRelativeTo(options.relativeTo);
    let roundingInc = parseRoundingIncInteger(options);
    const roundingMode = refineRoundingMode(options, 7);
    let smallestUnit = refineSmallestUnit(options);
    if (void 0 === largestUnit && void 0 === smallestUnit) {
      throw new RangeError("Required smallestUnit or largestUnit");
    }
    return null == smallestUnit && (smallestUnit = 0), null == largestUnit && (largestUnit = Math.max(smallestUnit, defaultLargestUnit)), 
    checkLargestSmallestUnit(largestUnit, smallestUnit), roundingInc = refineRoundingInc(roundingInc, smallestUnit, 1), 
    [ largestUnit, smallestUnit, roundingInc, roundingMode, relativeToInternals ];
  })(options, durationLargestUnit, refineRelativeTo), maxLargestUnit = Math.max(durationLargestUnit, largestUnit);
  if (maxLargestUnit < 6 || 6 === maxLargestUnit && (!relativeToSlots || !relativeToSlots.epochNanoseconds)) {
    return createDurationSlots(checkDurationUnits(((durationFields, largestUnit, smallestUnit, roundingInc, roundingMode) => ({
      ...durationFieldDefaults,
      ...balanceDayTimeDuration(durationFields, largestUnit, smallestUnit, roundingInc, roundingMode)
    }))(slots, largestUnit, smallestUnit, roundingInc, roundingMode)));
  }
  if (!relativeToSlots) {
    throw new RangeError("Missing relativeTo");
  }
  const relativeSystem = createRelativeSystem(getCalendarOps, getTimeZoneOps, relativeToSlots);
  let transplantedWeeks = 0;
  slots.weeks && 7 === smallestUnit && (transplantedWeeks = slots.weeks, slots = {
    ...slots,
    weeks: 0
  });
  let [balancedDuration, endEpochNano] = spanDuration(slots, void 0, largestUnit, ...relativeSystem);
  const origSign = slots.sign, balancedSign = computeDurationSign(balancedDuration);
  if (origSign && balancedSign && origSign !== balancedSign) {
    throw new RangeError(invalidProtocolResults);
  }
  return !balancedSign || 0 === smallestUnit && 1 === roundingInc || (balancedDuration = roundRelativeDuration(balancedDuration, endEpochNano, largestUnit, smallestUnit, roundingInc, roundingMode, ...relativeSystem)), 
  balancedDuration.weeks += transplantedWeeks, createDurationSlots(balancedDuration);
}, exports.roundInstant = (instantSlots, options) => {
  const [smallestUnit, roundingInc, roundingMode] = refineRoundOptions(options, 5, 1);
  return createInstantSlots(roundBigNano(instantSlots.epochNanoseconds, smallestUnit, roundingInc, roundingMode, 1));
}, exports.roundPlainDateTime = (plainDateTimeSlots, options) => createPlainDateTimeSlots(roundDateTime(plainDateTimeSlots, ...refineRoundOptions(options)), plainDateTimeSlots.calendar), 
exports.roundPlainTime = (slots, options) => createPlainTimeSlots(((isoFields, smallestUnit, roundingInc, roundingMode) => roundTimeToNano(isoFields, computeNanoInc(smallestUnit, roundingInc), roundingMode)[0])(slots, ...refineRoundOptions(options, 5))), 
exports.roundZonedDateTime = (getTimeZoneOps, zonedDateTimeSlots, options) => {
  let {epochNanoseconds: epochNanoseconds, timeZone: timeZone, calendar: calendar} = zonedDateTimeSlots;
  const [smallestUnit, roundingInc, roundingMode] = refineRoundOptions(options);
  if (0 === smallestUnit && 1 === roundingInc) {
    return zonedDateTimeSlots;
  }
  const timeZoneOps = getTimeZoneOps(timeZone), offsetNano = timeZoneOps.getOffsetNanosecondsFor(epochNanoseconds);
  let isoDateTimeFields = {
    ...epochNanoToIso(epochNanoseconds, offsetNano),
    calendar: calendar
  };
  return isoDateTimeFields = {
    calendar: calendar,
    ...roundDateTime(isoDateTimeFields, smallestUnit, roundingInc, roundingMode, timeZoneOps)
  }, epochNanoseconds = getMatchingInstantFor(timeZoneOps, isoDateTimeFields, offsetNano, 2, 0, 1), 
  createZonedDateTimeSlots(epochNanoseconds, timeZone, calendar);
}, exports.slotsWithCalendar = (slots, calendarSlot) => ({
  ...slots,
  calendar: calendarSlot
}), exports.slotsWithTimeZone = (slots, timeZoneSlot) => ({
  ...slots,
  timeZone: timeZoneSlot
}), exports.timeFieldNamesAsc = timeFieldNamesAsc, exports.totalDuration = (refineRelativeTo, getCalendarOps, getTimeZoneOps, slots, options) => {
  const durationLargestUnit = getLargestDurationUnit(slots), [totalUnit, relativeToSlots] = ((options, refineRelativeTo) => {
    const relativeToInternals = refineRelativeTo((options = normalizeUnitNameOptions(options, "unit")).relativeTo);
    let totalUnit = refineTotalUnit(options);
    return totalUnit = requirePropDefined("unit", totalUnit), [ totalUnit, relativeToInternals ];
  })(options, refineRelativeTo), maxLargestUnit = Math.max(totalUnit, durationLargestUnit);
  if (maxLargestUnit < 6 || 6 === maxLargestUnit && (!relativeToSlots || !relativeToSlots.epochNanoseconds)) {
    return ((durationFields, totalUnit) => totalBigNano(durationFieldsToBigNano(durationFields), totalUnit))(slots, totalUnit);
  }
  if (!relativeToSlots) {
    throw new RangeError("Missing relativeTo");
  }
  const relativeSystem = createRelativeSystem(getCalendarOps, getTimeZoneOps, relativeToSlots);
  return ((durationFields, endEpochNano, totalUnit, marker, calendarOps, timeZoneOps) => {
    const sign = computeDurationSign(durationFields), [epochNano0, epochNano1] = clampRelativeDuration(clearDurationFields(durationFields, totalUnit - 1), totalUnit, sign, marker, calendarOps, timeZoneOps), frac = computeEpochNanoFrac(epochNano0, epochNano1, endEpochNano);
    return durationFields[durationFieldNamesAsc[totalUnit]] + frac * sign;
  })(...spanDuration(slots, void 0, totalUnit, ...relativeSystem), totalUnit, ...relativeSystem);
}, exports.unitNamesAsc = unitNamesAsc, exports.validateTimeZoneGap = validateTimeZoneGap, 
exports.validateTimeZoneOffset = validateTimeZoneOffset, exports.zonedDateTimeConfig = zonedDateTimeConfig, 
exports.zonedDateTimeToInstant = zonedDateTimeSlots0 => createInstantSlots(zonedDateTimeSlots0.epochNanoseconds), 
exports.zonedDateTimeToPlainDate = (getTimeZoneOps, zonedDateTimeSlots0) => createPlainDateSlots(zonedEpochSlotsToIso(zonedDateTimeSlots0, getTimeZoneOps)), 
exports.zonedDateTimeToPlainDateTime = (getTimeZoneOps, zonedDateTimeSlots0) => createPlainDateTimeSlots(zonedEpochSlotsToIso(zonedDateTimeSlots0, getTimeZoneOps)), 
exports.zonedDateTimeToPlainMonthDay = (getCalendarOps, zonedDateTimeSlots0, zonedDateTimeFields) => convertToPlainMonthDay(getCalendarOps(zonedDateTimeSlots0.calendar), zonedDateTimeFields), 
exports.zonedDateTimeToPlainTime = (getTimeZoneOps, zonedDateTimeSlots0) => createPlainTimeSlots(zonedEpochSlotsToIso(zonedDateTimeSlots0, getTimeZoneOps)), 
exports.zonedDateTimeToPlainYearMonth = (getCalendarOps, zonedDateTimeSlots0, zonedDateTimeFields) => convertToPlainYearMonth(getCalendarOps(zonedDateTimeSlots0.calendar), zonedDateTimeFields), 
exports.zonedDateTimeWithFields = (getCalendarOps, getTimeZoneOps, zonedDateTimeSlots, initialFields, modFields, options) => {
  const optionsCopy = copyOptions(options), {calendar: calendar, timeZone: timeZone} = zonedDateTimeSlots;
  return createZonedDateTimeSlots(((calendarOps, timeZoneOps, initialFields, modFields, options) => {
    const fields = mergeCalendarFields(calendarOps, initialFields, modFields, dateFieldNamesAlpha, timeAndOffsetFieldNames, offsetFieldNames), [overflow, offsetDisambig, epochDisambig] = refineZonedFieldOptions(options, 2);
    return getMatchingInstantFor(timeZoneOps, {
      ...calendarOps.dateFromFields(fields, overrideOverflowOptions(options, overflow)),
      ...refineTimeBag(fields, overflow)
    }, parseOffsetNano(fields.offset), offsetDisambig, epochDisambig);
  })(getCalendarOps(calendar), getTimeZoneOps(timeZone), initialFields, modFields, optionsCopy), timeZone, calendar);
}, exports.zonedDateTimeWithPlainDate = (getTimeZoneOps, zonedDateTimeSlots, plainDateSlots) => {
  const timeZoneSlot = zonedDateTimeSlots.timeZone, timeZoneOps = getTimeZoneOps(timeZoneSlot), isoFields = {
    ...zonedEpochSlotsToIso(zonedDateTimeSlots, timeZoneOps),
    ...plainDateSlots
  }, calendar = getPreferredCalendarSlot(zonedDateTimeSlots.calendar, plainDateSlots.calendar);
  return createZonedDateTimeSlots(getMatchingInstantFor(timeZoneOps, isoFields, isoFields.offsetNanoseconds, 2), timeZoneSlot, calendar);
}, exports.zonedDateTimeWithPlainTime = (getTimeZoneOps, zonedDateTimeSlots, plainTimeSlots = isoTimeFieldDefaults) => {
  const timeZoneSlot = zonedDateTimeSlots.timeZone, timeZoneOps = getTimeZoneOps(timeZoneSlot), isoFields = {
    ...zonedEpochSlotsToIso(zonedDateTimeSlots, timeZoneOps),
    ...plainTimeSlots
  };
  return createZonedDateTimeSlots(getMatchingInstantFor(timeZoneOps, isoFields, isoFields.offsetNanoseconds, 2), timeZoneSlot, zonedDateTimeSlots.calendar);
}, exports.zonedDateTimesEqual = (zonedDateTimeSlots0, zonedDateTimeSlots1) => !compareZonedDateTimes(zonedDateTimeSlots0, zonedDateTimeSlots1) && !!isTimeZoneSlotsEqual(zonedDateTimeSlots0.timeZone, zonedDateTimeSlots1.timeZone) && isIdLikeEqual(zonedDateTimeSlots0.calendar, zonedDateTimeSlots1.calendar), 
exports.zonedEpochSlotsToIso = zonedEpochSlotsToIso;


/***/ }),

/***/ "./node_modules/temporal-polyfill/impl.cjs":
/*!*************************************************!*\
  !*** ./node_modules/temporal-polyfill/impl.cjs ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var temporal = __webpack_require__(/*! ./chunks/EHDzkv8k.cjs */ "./node_modules/temporal-polyfill/chunks/EHDzkv8k.cjs"), internal = __webpack_require__(/*! ./chunks/tM8Arf6G.cjs */ "./node_modules/temporal-polyfill/chunks/tM8Arf6G.cjs");

const IntlExtended = Object.defineProperties(Object.create(Intl), internal.createPropDescriptors({
  DateTimeFormat: temporal.DateTimeFormat
}));

exports.Temporal = temporal.Temporal, exports.toTemporalInstant = temporal.toTemporalInstant, 
exports.Intl = IntlExtended;


/***/ }),

/***/ "./node_modules/temporal-polyfill/index.cjs":
/*!**************************************************!*\
  !*** ./node_modules/temporal-polyfill/index.cjs ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var temporal = __webpack_require__(/*! ./chunks/EHDzkv8k.cjs */ "./node_modules/temporal-polyfill/chunks/EHDzkv8k.cjs"), impl = __webpack_require__(/*! ./impl.cjs */ "./node_modules/temporal-polyfill/impl.cjs");

exports.Temporal = temporal.Temporal, exports.toTemporalInstant = temporal.toTemporalInstant, 
exports.Intl = impl.Intl;


/***/ }),

/***/ "./output/00.msag.mjs":
/*!****************************!*\
  !*** ./output/00.msag.mjs ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.MSAG["00"] = {
  "001": "&1&2&3&4",
  "002": "needed by abapGit unit test",
  "003": "needed by abapGit unit test",
};
//# sourceMappingURL=00.msag.mjs.map

/***/ }),

/***/ "./output/_init.mjs":
/*!**************************!*\
  !*** ./output/_init.mjs ***!
  \**************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initializeABAP": () => (/* binding */ initializeABAP)
/* harmony export */ });
/* harmony import */ var _top_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_top.mjs */ "./output/_top.mjs");
/* harmony import */ var _23ui2_23cl_json_clas_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./%23ui2%23cl_json.clas.mjs */ "?d19c");
/* harmony import */ var _00_msag_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./00.msag.mjs */ "./output/00.msag.mjs");
/* harmony import */ var _abap_type_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abap.type.mjs */ "./output/abap.type.mjs");
/* harmony import */ var _abap_boolean_dtel_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abap_boolean.dtel.mjs */ "./output/abap_boolean.dtel.mjs");
/* harmony import */ var _abap_callstack_ttyp_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abap_callstack.ttyp.mjs */ "./output/abap_callstack.ttyp.mjs");
/* harmony import */ var _abap_callstack_line_tabl_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abap_callstack_line.tabl.mjs */ "./output/abap_callstack_line.tabl.mjs");
/* harmony import */ var _abap_encod_dtel_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./abap_encod.dtel.mjs */ "./output/abap_encod.dtel.mjs");
/* harmony import */ var _abap_sortorder_tabl_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./abap_sortorder.tabl.mjs */ "./output/abap_sortorder.tabl.mjs");
/* harmony import */ var _abap_sortorder_tab_ttyp_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./abap_sortorder_tab.ttyp.mjs */ "./output/abap_sortorder_tab.ttyp.mjs");
/* harmony import */ var _balmnr_dtel_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./balmnr.dtel.mjs */ "./output/balmnr.dtel.mjs");
/* harmony import */ var _balognr_dtel_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./balognr.dtel.mjs */ "./output/balognr.dtel.mjs");
/* harmony import */ var _bapi_fld_dtel_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./bapi_fld.dtel.mjs */ "./output/bapi_fld.dtel.mjs");
/* harmony import */ var _bapi_line_dtel_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./bapi_line.dtel.mjs */ "./output/bapi_line.dtel.mjs");
/* harmony import */ var _bapi_msg_dtel_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./bapi_msg.dtel.mjs */ "./output/bapi_msg.dtel.mjs");
/* harmony import */ var _bapi_mtype_dtel_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./bapi_mtype.dtel.mjs */ "./output/bapi_mtype.dtel.mjs");
/* harmony import */ var _bapi_param_dtel_mjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./bapi_param.dtel.mjs */ "./output/bapi_param.dtel.mjs");
/* harmony import */ var _bapi_rcode_dtel_mjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./bapi_rcode.dtel.mjs */ "./output/bapi_rcode.dtel.mjs");
/* harmony import */ var _bapilogsys_dtel_mjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./bapilogsys.dtel.mjs */ "./output/bapilogsys.dtel.mjs");
/* harmony import */ var _bapioption_dtel_mjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./bapioption.dtel.mjs */ "./output/bapioption.dtel.mjs");
/* harmony import */ var _bapiret2_tabl_mjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./bapiret2.tabl.mjs */ "./output/bapiret2.tabl.mjs");
/* harmony import */ var _bapirettab_ttyp_mjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./bapirettab.ttyp.mjs */ "./output/bapirettab.ttyp.mjs");
/* harmony import */ var _bapireturn_tabl_mjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./bapireturn.tabl.mjs */ "./output/bapireturn.tabl.mjs");
/* harmony import */ var _bapisign_dtel_mjs__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./bapisign.dtel.mjs */ "./output/bapisign.dtel.mjs");
/* harmony import */ var _boole_d_dtel_mjs__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./boole_d.dtel.mjs */ "./output/boole_d.dtel.mjs");
/* harmony import */ var _boolean_dtel_mjs__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./boolean.dtel.mjs */ "./output/boolean.dtel.mjs");
/* harmony import */ var _char1_dtel_mjs__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./char1.dtel.mjs */ "./output/char1.dtel.mjs");
/* harmony import */ var _char10_dtel_mjs__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./char10.dtel.mjs */ "./output/char10.dtel.mjs");
/* harmony import */ var _char120_dtel_mjs__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./char120.dtel.mjs */ "./output/char120.dtel.mjs");
/* harmony import */ var _char15_dtel_mjs__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./char15.dtel.mjs */ "./output/char15.dtel.mjs");
/* harmony import */ var _char2_dtel_mjs__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./char2.dtel.mjs */ "./output/char2.dtel.mjs");
/* harmony import */ var _char20_dtel_mjs__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./char20.dtel.mjs */ "./output/char20.dtel.mjs");
/* harmony import */ var _char25_dtel_mjs__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./char25.dtel.mjs */ "./output/char25.dtel.mjs");
/* harmony import */ var _char255_dtel_mjs__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./char255.dtel.mjs */ "./output/char255.dtel.mjs");
/* harmony import */ var _char3_dtel_mjs__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./char3.dtel.mjs */ "./output/char3.dtel.mjs");
/* harmony import */ var _char30_dtel_mjs__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./char30.dtel.mjs */ "./output/char30.dtel.mjs");
/* harmony import */ var _char32_dtel_mjs__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./char32.dtel.mjs */ "./output/char32.dtel.mjs");
/* harmony import */ var _char4_dtel_mjs__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./char4.dtel.mjs */ "./output/char4.dtel.mjs");
/* harmony import */ var _char6_dtel_mjs__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./char6.dtel.mjs */ "./output/char6.dtel.mjs");
/* harmony import */ var _char70_dtel_mjs__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./char70.dtel.mjs */ "./output/char70.dtel.mjs");
/* harmony import */ var _char8_dtel_mjs__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./char8.dtel.mjs */ "./output/char8.dtel.mjs");
/* harmony import */ var _char80_dtel_mjs__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./char80.dtel.mjs */ "./output/char80.dtel.mjs");
/* harmony import */ var _cl_abap_char_utilities_clas_mjs__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./cl_abap_char_utilities.clas.mjs */ "./output/cl_abap_char_utilities.clas.mjs");
/* harmony import */ var _cl_abap_classdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./cl_abap_classdescr.clas.mjs */ "./output/cl_abap_classdescr.clas.mjs");
/* harmony import */ var _cl_abap_codepage_clas_mjs__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./cl_abap_codepage.clas.mjs */ "./output/cl_abap_codepage.clas.mjs");
/* harmony import */ var _cl_abap_complexdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./cl_abap_complexdescr.clas.mjs */ "./output/cl_abap_complexdescr.clas.mjs");
/* harmony import */ var _cl_abap_conv_codepage_clas_mjs__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./cl_abap_conv_codepage.clas.mjs */ "./output/cl_abap_conv_codepage.clas.mjs");
/* harmony import */ var _cl_abap_conv_in_ce_clas_mjs__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./cl_abap_conv_in_ce.clas.mjs */ "./output/cl_abap_conv_in_ce.clas.mjs");
/* harmony import */ var _cl_abap_conv_out_ce_clas_mjs__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./cl_abap_conv_out_ce.clas.mjs */ "./output/cl_abap_conv_out_ce.clas.mjs");
/* harmony import */ var _cl_abap_datadescr_clas_mjs__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./cl_abap_datadescr.clas.mjs */ "./output/cl_abap_datadescr.clas.mjs");
/* harmony import */ var _cl_abap_datfm_clas_mjs__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./cl_abap_datfm.clas.mjs */ "./output/cl_abap_datfm.clas.mjs");
/* harmony import */ var _cl_abap_dyn_prg_clas_mjs__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./cl_abap_dyn_prg.clas.mjs */ "./output/cl_abap_dyn_prg.clas.mjs");
/* harmony import */ var _cl_abap_elemdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./cl_abap_elemdescr.clas.mjs */ "./output/cl_abap_elemdescr.clas.mjs");
/* harmony import */ var _cl_abap_enumdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./cl_abap_enumdescr.clas.mjs */ "./output/cl_abap_enumdescr.clas.mjs");
/* harmony import */ var _cl_abap_exceptional_values_clas_mjs__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./cl_abap_exceptional_values.clas.mjs */ "./output/cl_abap_exceptional_values.clas.mjs");
/* harmony import */ var _cl_abap_format_clas_mjs__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./cl_abap_format.clas.mjs */ "./output/cl_abap_format.clas.mjs");
/* harmony import */ var _cl_abap_gzip_clas_mjs__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./cl_abap_gzip.clas.mjs */ "./output/cl_abap_gzip.clas.mjs");
/* harmony import */ var _cl_abap_hmac_clas_mjs__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./cl_abap_hmac.clas.mjs */ "./output/cl_abap_hmac.clas.mjs");
/* harmony import */ var _cl_abap_intfdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./cl_abap_intfdescr.clas.mjs */ "./output/cl_abap_intfdescr.clas.mjs");
/* harmony import */ var _cl_abap_matcher_clas_mjs__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./cl_abap_matcher.clas.mjs */ "./output/cl_abap_matcher.clas.mjs");
/* harmony import */ var _cl_abap_math_clas_mjs__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./cl_abap_math.clas.mjs */ "./output/cl_abap_math.clas.mjs");
/* harmony import */ var _cl_abap_message_digest_clas_mjs__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./cl_abap_message_digest.clas.mjs */ "./output/cl_abap_message_digest.clas.mjs");
/* harmony import */ var _cl_abap_objectdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./cl_abap_objectdescr.clas.mjs */ "./output/cl_abap_objectdescr.clas.mjs");
/* harmony import */ var _cl_abap_random_clas_mjs__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./cl_abap_random.clas.mjs */ "./output/cl_abap_random.clas.mjs");
/* harmony import */ var _cl_abap_random_int_clas_mjs__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./cl_abap_random_int.clas.mjs */ "./output/cl_abap_random_int.clas.mjs");
/* harmony import */ var _cl_abap_refdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./cl_abap_refdescr.clas.mjs */ "./output/cl_abap_refdescr.clas.mjs");
/* harmony import */ var _cl_abap_regex_clas_mjs__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./cl_abap_regex.clas.mjs */ "./output/cl_abap_regex.clas.mjs");
/* harmony import */ var _cl_abap_structdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./cl_abap_structdescr.clas.mjs */ "./output/cl_abap_structdescr.clas.mjs");
/* harmony import */ var _cl_abap_tabledescr_clas_mjs__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./cl_abap_tabledescr.clas.mjs */ "./output/cl_abap_tabledescr.clas.mjs");
/* harmony import */ var _cl_abap_timefm_clas_mjs__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./cl_abap_timefm.clas.mjs */ "./output/cl_abap_timefm.clas.mjs");
/* harmony import */ var _cl_abap_tstmp_clas_mjs__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./cl_abap_tstmp.clas.mjs */ "./output/cl_abap_tstmp.clas.mjs");
/* harmony import */ var _cl_abap_typedescr_clas_mjs__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./cl_abap_typedescr.clas.mjs */ "./output/cl_abap_typedescr.clas.mjs");
/* harmony import */ var _cl_abap_unit_assert_clas_mjs__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./cl_abap_unit_assert.clas.mjs */ "./output/cl_abap_unit_assert.clas.mjs");
/* harmony import */ var _cl_abap_weak_reference_clas_mjs__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./cl_abap_weak_reference.clas.mjs */ "./output/cl_abap_weak_reference.clas.mjs");
/* harmony import */ var _cl_abap_zip_clas_mjs__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./cl_abap_zip.clas.mjs */ "./output/cl_abap_zip.clas.mjs");
/* harmony import */ var _cl_apc_tcp_client_manager_clas_mjs__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./cl_apc_tcp_client_manager.clas.mjs */ "./output/cl_apc_tcp_client_manager.clas.mjs");
/* harmony import */ var _cl_apc_wsp_ext_stateless_base_clas_mjs__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./cl_apc_wsp_ext_stateless_base.clas.mjs */ "./output/cl_apc_wsp_ext_stateless_base.clas.mjs");
/* harmony import */ var _cl_bcs_clas_mjs__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./cl_bcs.clas.mjs */ "./output/cl_bcs.clas.mjs");
/* harmony import */ var _cl_bcs_convert_clas_mjs__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./cl_bcs_convert.clas.mjs */ "./output/cl_bcs_convert.clas.mjs");
/* harmony import */ var _cl_cam_address_bcs_clas_mjs__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./cl_cam_address_bcs.clas.mjs */ "./output/cl_cam_address_bcs.clas.mjs");
/* harmony import */ var _cl_demo_output_clas_mjs__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./cl_demo_output.clas.mjs */ "./output/cl_demo_output.clas.mjs");
/* harmony import */ var _cl_document_bcs_clas_mjs__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./cl_document_bcs.clas.mjs */ "./output/cl_document_bcs.clas.mjs");
/* harmony import */ var _cl_express_icf_shim_clas_mjs__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./cl_express_icf_shim.clas.mjs */ "./output/cl_express_icf_shim.clas.mjs");
/* harmony import */ var _cl_function_test_environment_clas_mjs__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./cl_function_test_environment.clas.mjs */ "./output/cl_function_test_environment.clas.mjs");
/* harmony import */ var _cl_gdt_conversion_clas_mjs__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./cl_gdt_conversion.clas.mjs */ "./output/cl_gdt_conversion.clas.mjs");
/* harmony import */ var _cl_gui_cfw_clas_mjs__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./cl_gui_cfw.clas.mjs */ "./output/cl_gui_cfw.clas.mjs");
/* harmony import */ var _cl_gui_container_clas_mjs__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./cl_gui_container.clas.mjs */ "./output/cl_gui_container.clas.mjs");
/* harmony import */ var _cl_gui_frontend_services_clas_mjs__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./cl_gui_frontend_services.clas.mjs */ "./output/cl_gui_frontend_services.clas.mjs");
/* harmony import */ var _cl_http_client_clas_mjs__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./cl_http_client.clas.mjs */ "./output/cl_http_client.clas.mjs");
/* harmony import */ var _cl_http_entity_clas_mjs__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./cl_http_entity.clas.mjs */ "./output/cl_http_entity.clas.mjs");
/* harmony import */ var _cl_http_server_clas_mjs__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./cl_http_server.clas.mjs */ "./output/cl_http_server.clas.mjs");
/* harmony import */ var _cl_http_utility_clas_mjs__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./cl_http_utility.clas.mjs */ "./output/cl_http_utility.clas.mjs");
/* harmony import */ var _cl_i18n_languages_clas_mjs__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./cl_i18n_languages.clas.mjs */ "./output/cl_i18n_languages.clas.mjs");
/* harmony import */ var _cl_icf_tree_clas_mjs__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./cl_icf_tree.clas.mjs */ "./output/cl_icf_tree.clas.mjs");
/* harmony import */ var _cl_ixml_clas_mjs__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./cl_ixml.clas.mjs */ "./output/cl_ixml.clas.mjs");
/* harmony import */ var _cl_message_helper_clas_mjs__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./cl_message_helper.clas.mjs */ "./output/cl_message_helper.clas.mjs");
/* harmony import */ var _cl_mime_repository_api_clas_mjs__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./cl_mime_repository_api.clas.mjs */ "./output/cl_mime_repository_api.clas.mjs");
/* harmony import */ var _cl_numberrange_runtime_clas_mjs__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./cl_numberrange_runtime.clas.mjs */ "./output/cl_numberrange_runtime.clas.mjs");
/* harmony import */ var _cl_oauth2_client_clas_mjs__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./cl_oauth2_client.clas.mjs */ "./output/cl_oauth2_client.clas.mjs");
/* harmony import */ var _cl_oo_factory_clas_mjs__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./cl_oo_factory.clas.mjs */ "./output/cl_oo_factory.clas.mjs");
/* harmony import */ var _cl_osql_test_environment_clas_mjs__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./cl_osql_test_environment.clas.mjs */ "./output/cl_osql_test_environment.clas.mjs");
/* harmony import */ var _cl_progress_indicator_clas_mjs__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./cl_progress_indicator.clas.mjs */ "./output/cl_progress_indicator.clas.mjs");
/* harmony import */ var _cl_salv_aggregations_clas_mjs__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./cl_salv_aggregations.clas.mjs */ "./output/cl_salv_aggregations.clas.mjs");
/* harmony import */ var _cl_salv_column_clas_mjs__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./cl_salv_column.clas.mjs */ "./output/cl_salv_column.clas.mjs");
/* harmony import */ var _cl_salv_columns_table_clas_mjs__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./cl_salv_columns_table.clas.mjs */ "./output/cl_salv_columns_table.clas.mjs");
/* harmony import */ var _cl_salv_events_table_clas_mjs__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./cl_salv_events_table.clas.mjs */ "./output/cl_salv_events_table.clas.mjs");
/* harmony import */ var _cl_salv_filters_clas_mjs__WEBPACK_IMPORTED_MODULE_106__ = __webpack_require__(/*! ./cl_salv_filters.clas.mjs */ "./output/cl_salv_filters.clas.mjs");
/* harmony import */ var _cl_salv_functional_settings_clas_mjs__WEBPACK_IMPORTED_MODULE_107__ = __webpack_require__(/*! ./cl_salv_functional_settings.clas.mjs */ "./output/cl_salv_functional_settings.clas.mjs");
/* harmony import */ var _cl_salv_functions_list_clas_mjs__WEBPACK_IMPORTED_MODULE_108__ = __webpack_require__(/*! ./cl_salv_functions_list.clas.mjs */ "./output/cl_salv_functions_list.clas.mjs");
/* harmony import */ var _cl_salv_hyperlinks_clas_mjs__WEBPACK_IMPORTED_MODULE_109__ = __webpack_require__(/*! ./cl_salv_hyperlinks.clas.mjs */ "./output/cl_salv_hyperlinks.clas.mjs");
/* harmony import */ var _cl_salv_layout_clas_mjs__WEBPACK_IMPORTED_MODULE_110__ = __webpack_require__(/*! ./cl_salv_layout.clas.mjs */ "./output/cl_salv_layout.clas.mjs");
/* harmony import */ var _cl_salv_sorts_clas_mjs__WEBPACK_IMPORTED_MODULE_111__ = __webpack_require__(/*! ./cl_salv_sorts.clas.mjs */ "./output/cl_salv_sorts.clas.mjs");
/* harmony import */ var _cl_salv_table_clas_mjs__WEBPACK_IMPORTED_MODULE_112__ = __webpack_require__(/*! ./cl_salv_table.clas.mjs */ "./output/cl_salv_table.clas.mjs");
/* harmony import */ var _cl_shm_area_clas_mjs__WEBPACK_IMPORTED_MODULE_113__ = __webpack_require__(/*! ./cl_shm_area.clas.mjs */ "./output/cl_shm_area.clas.mjs");
/* harmony import */ var _cl_shm_service_clas_mjs__WEBPACK_IMPORTED_MODULE_114__ = __webpack_require__(/*! ./cl_shm_service.clas.mjs */ "./output/cl_shm_service.clas.mjs");
/* harmony import */ var _cl_sql_result_set_clas_mjs__WEBPACK_IMPORTED_MODULE_115__ = __webpack_require__(/*! ./cl_sql_result_set.clas.mjs */ "./output/cl_sql_result_set.clas.mjs");
/* harmony import */ var _cl_sql_statement_clas_mjs__WEBPACK_IMPORTED_MODULE_116__ = __webpack_require__(/*! ./cl_sql_statement.clas.mjs */ "./output/cl_sql_statement.clas.mjs");
/* harmony import */ var _cl_sxml_string_reader_clas_mjs__WEBPACK_IMPORTED_MODULE_117__ = __webpack_require__(/*! ./cl_sxml_string_reader.clas.mjs */ "./output/cl_sxml_string_reader.clas.mjs");
/* harmony import */ var _cl_sxml_string_writer_clas_mjs__WEBPACK_IMPORTED_MODULE_118__ = __webpack_require__(/*! ./cl_sxml_string_writer.clas.mjs */ "./output/cl_sxml_string_writer.clas.mjs");
/* harmony import */ var _cl_system_uuid_clas_mjs__WEBPACK_IMPORTED_MODULE_119__ = __webpack_require__(/*! ./cl_system_uuid.clas.mjs */ "./output/cl_system_uuid.clas.mjs");
/* harmony import */ var _cl_web_http_utility_clas_mjs__WEBPACK_IMPORTED_MODULE_120__ = __webpack_require__(/*! ./cl_web_http_utility.clas.mjs */ "./output/cl_web_http_utility.clas.mjs");
/* harmony import */ var _cx_abap_datfm_clas_mjs__WEBPACK_IMPORTED_MODULE_121__ = __webpack_require__(/*! ./cx_abap_datfm.clas.mjs */ "./output/cx_abap_datfm.clas.mjs");
/* harmony import */ var _cx_abap_message_digest_clas_mjs__WEBPACK_IMPORTED_MODULE_122__ = __webpack_require__(/*! ./cx_abap_message_digest.clas.mjs */ "./output/cx_abap_message_digest.clas.mjs");
/* harmony import */ var _cx_abap_not_a_table_clas_mjs__WEBPACK_IMPORTED_MODULE_123__ = __webpack_require__(/*! ./cx_abap_not_a_table.clas.mjs */ "./output/cx_abap_not_a_table.clas.mjs");
/* harmony import */ var _cx_abap_not_in_package_clas_mjs__WEBPACK_IMPORTED_MODULE_124__ = __webpack_require__(/*! ./cx_abap_not_in_package.clas.mjs */ "./output/cx_abap_not_in_package.clas.mjs");
/* harmony import */ var _cx_abap_not_in_whitelist_clas_mjs__WEBPACK_IMPORTED_MODULE_125__ = __webpack_require__(/*! ./cx_abap_not_in_whitelist.clas.mjs */ "./output/cx_abap_not_in_whitelist.clas.mjs");
/* harmony import */ var _cx_abap_random_clas_mjs__WEBPACK_IMPORTED_MODULE_126__ = __webpack_require__(/*! ./cx_abap_random.clas.mjs */ "./output/cx_abap_random.clas.mjs");
/* harmony import */ var _cx_abap_timefm_invalid_clas_mjs__WEBPACK_IMPORTED_MODULE_127__ = __webpack_require__(/*! ./cx_abap_timefm_invalid.clas.mjs */ "./output/cx_abap_timefm_invalid.clas.mjs");
/* harmony import */ var _cx_apc_error_clas_mjs__WEBPACK_IMPORTED_MODULE_128__ = __webpack_require__(/*! ./cx_apc_error.clas.mjs */ "./output/cx_apc_error.clas.mjs");
/* harmony import */ var _cx_bcs_clas_mjs__WEBPACK_IMPORTED_MODULE_129__ = __webpack_require__(/*! ./cx_bcs.clas.mjs */ "./output/cx_bcs.clas.mjs");
/* harmony import */ var _cx_dynamic_check_clas_mjs__WEBPACK_IMPORTED_MODULE_130__ = __webpack_require__(/*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs");
/* harmony import */ var _cx_ftd_parameter_not_found_clas_mjs__WEBPACK_IMPORTED_MODULE_131__ = __webpack_require__(/*! ./cx_ftd_parameter_not_found.clas.mjs */ "./output/cx_ftd_parameter_not_found.clas.mjs");
/* harmony import */ var _cx_gdt_conversion_clas_mjs__WEBPACK_IMPORTED_MODULE_132__ = __webpack_require__(/*! ./cx_gdt_conversion.clas.mjs */ "./output/cx_gdt_conversion.clas.mjs");
/* harmony import */ var _cx_no_check_clas_mjs__WEBPACK_IMPORTED_MODULE_133__ = __webpack_require__(/*! ./cx_no_check.clas.mjs */ "./output/cx_no_check.clas.mjs");
/* harmony import */ var _cx_oo_clif_not_exists_clas_mjs__WEBPACK_IMPORTED_MODULE_134__ = __webpack_require__(/*! ./cx_oo_clif_not_exists.clas.mjs */ "./output/cx_oo_clif_not_exists.clas.mjs");
/* harmony import */ var _cx_parameter_invalid_clas_mjs__WEBPACK_IMPORTED_MODULE_135__ = __webpack_require__(/*! ./cx_parameter_invalid.clas.mjs */ "./output/cx_parameter_invalid.clas.mjs");
/* harmony import */ var _cx_parameter_invalid_range_clas_mjs__WEBPACK_IMPORTED_MODULE_136__ = __webpack_require__(/*! ./cx_parameter_invalid_range.clas.mjs */ "./output/cx_parameter_invalid_range.clas.mjs");
/* harmony import */ var _cx_parameter_invalid_type_clas_mjs__WEBPACK_IMPORTED_MODULE_137__ = __webpack_require__(/*! ./cx_parameter_invalid_type.clas.mjs */ "./output/cx_parameter_invalid_type.clas.mjs");
/* harmony import */ var _cx_root_clas_mjs__WEBPACK_IMPORTED_MODULE_138__ = __webpack_require__(/*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs");
/* harmony import */ var _cx_salv_access_error_clas_mjs__WEBPACK_IMPORTED_MODULE_139__ = __webpack_require__(/*! ./cx_salv_access_error.clas.mjs */ "./output/cx_salv_access_error.clas.mjs");
/* harmony import */ var _cx_salv_data_error_clas_mjs__WEBPACK_IMPORTED_MODULE_140__ = __webpack_require__(/*! ./cx_salv_data_error.clas.mjs */ "./output/cx_salv_data_error.clas.mjs");
/* harmony import */ var _cx_salv_error_clas_mjs__WEBPACK_IMPORTED_MODULE_141__ = __webpack_require__(/*! ./cx_salv_error.clas.mjs */ "./output/cx_salv_error.clas.mjs");
/* harmony import */ var _cx_salv_existing_clas_mjs__WEBPACK_IMPORTED_MODULE_142__ = __webpack_require__(/*! ./cx_salv_existing.clas.mjs */ "./output/cx_salv_existing.clas.mjs");
/* harmony import */ var _cx_salv_msg_clas_mjs__WEBPACK_IMPORTED_MODULE_143__ = __webpack_require__(/*! ./cx_salv_msg.clas.mjs */ "./output/cx_salv_msg.clas.mjs");
/* harmony import */ var _cx_salv_not_found_clas_mjs__WEBPACK_IMPORTED_MODULE_144__ = __webpack_require__(/*! ./cx_salv_not_found.clas.mjs */ "./output/cx_salv_not_found.clas.mjs");
/* harmony import */ var _cx_salv_static_check_clas_mjs__WEBPACK_IMPORTED_MODULE_145__ = __webpack_require__(/*! ./cx_salv_static_check.clas.mjs */ "./output/cx_salv_static_check.clas.mjs");
/* harmony import */ var _cx_shm_already_detached_clas_mjs__WEBPACK_IMPORTED_MODULE_146__ = __webpack_require__(/*! ./cx_shm_already_detached.clas.mjs */ "./output/cx_shm_already_detached.clas.mjs");
/* harmony import */ var _cx_shm_attach_error_clas_mjs__WEBPACK_IMPORTED_MODULE_147__ = __webpack_require__(/*! ./cx_shm_attach_error.clas.mjs */ "./output/cx_shm_attach_error.clas.mjs");
/* harmony import */ var _cx_shm_build_failed_clas_mjs__WEBPACK_IMPORTED_MODULE_148__ = __webpack_require__(/*! ./cx_shm_build_failed.clas.mjs */ "./output/cx_shm_build_failed.clas.mjs");
/* harmony import */ var _cx_shm_change_lock_active_clas_mjs__WEBPACK_IMPORTED_MODULE_149__ = __webpack_require__(/*! ./cx_shm_change_lock_active.clas.mjs */ "./output/cx_shm_change_lock_active.clas.mjs");
/* harmony import */ var _cx_shm_completion_error_clas_mjs__WEBPACK_IMPORTED_MODULE_150__ = __webpack_require__(/*! ./cx_shm_completion_error.clas.mjs */ "./output/cx_shm_completion_error.clas.mjs");
/* harmony import */ var _cx_shm_detach_error_clas_mjs__WEBPACK_IMPORTED_MODULE_151__ = __webpack_require__(/*! ./cx_shm_detach_error.clas.mjs */ "./output/cx_shm_detach_error.clas.mjs");
/* harmony import */ var _cx_shm_error_clas_mjs__WEBPACK_IMPORTED_MODULE_152__ = __webpack_require__(/*! ./cx_shm_error.clas.mjs */ "./output/cx_shm_error.clas.mjs");
/* harmony import */ var _cx_shm_event_execution_failed_clas_mjs__WEBPACK_IMPORTED_MODULE_153__ = __webpack_require__(/*! ./cx_shm_event_execution_failed.clas.mjs */ "./output/cx_shm_event_execution_failed.clas.mjs");
/* harmony import */ var _cx_shm_exclusive_lock_active_clas_mjs__WEBPACK_IMPORTED_MODULE_154__ = __webpack_require__(/*! ./cx_shm_exclusive_lock_active.clas.mjs */ "./output/cx_shm_exclusive_lock_active.clas.mjs");
/* harmony import */ var _cx_shm_general_error_clas_mjs__WEBPACK_IMPORTED_MODULE_155__ = __webpack_require__(/*! ./cx_shm_general_error.clas.mjs */ "./output/cx_shm_general_error.clas.mjs");
/* harmony import */ var _cx_shm_inconsistent_clas_mjs__WEBPACK_IMPORTED_MODULE_156__ = __webpack_require__(/*! ./cx_shm_inconsistent.clas.mjs */ "./output/cx_shm_inconsistent.clas.mjs");
/* harmony import */ var _cx_shm_initial_reference_clas_mjs__WEBPACK_IMPORTED_MODULE_157__ = __webpack_require__(/*! ./cx_shm_initial_reference.clas.mjs */ "./output/cx_shm_initial_reference.clas.mjs");
/* harmony import */ var _cx_shm_no_active_version_clas_mjs__WEBPACK_IMPORTED_MODULE_158__ = __webpack_require__(/*! ./cx_shm_no_active_version.clas.mjs */ "./output/cx_shm_no_active_version.clas.mjs");
/* harmony import */ var _cx_shm_parameter_error_clas_mjs__WEBPACK_IMPORTED_MODULE_159__ = __webpack_require__(/*! ./cx_shm_parameter_error.clas.mjs */ "./output/cx_shm_parameter_error.clas.mjs");
/* harmony import */ var _cx_shm_pending_lock_removed_clas_mjs__WEBPACK_IMPORTED_MODULE_160__ = __webpack_require__(/*! ./cx_shm_pending_lock_removed.clas.mjs */ "./output/cx_shm_pending_lock_removed.clas.mjs");
/* harmony import */ var _cx_shm_read_lock_active_clas_mjs__WEBPACK_IMPORTED_MODULE_161__ = __webpack_require__(/*! ./cx_shm_read_lock_active.clas.mjs */ "./output/cx_shm_read_lock_active.clas.mjs");
/* harmony import */ var _cx_shm_secondary_commit_clas_mjs__WEBPACK_IMPORTED_MODULE_162__ = __webpack_require__(/*! ./cx_shm_secondary_commit.clas.mjs */ "./output/cx_shm_secondary_commit.clas.mjs");
/* harmony import */ var _cx_shm_version_limit_exceeded_clas_mjs__WEBPACK_IMPORTED_MODULE_163__ = __webpack_require__(/*! ./cx_shm_version_limit_exceeded.clas.mjs */ "./output/cx_shm_version_limit_exceeded.clas.mjs");
/* harmony import */ var _cx_shm_wrong_handle_clas_mjs__WEBPACK_IMPORTED_MODULE_164__ = __webpack_require__(/*! ./cx_shm_wrong_handle.clas.mjs */ "./output/cx_shm_wrong_handle.clas.mjs");
/* harmony import */ var _cx_shma_dynamic_clas_mjs__WEBPACK_IMPORTED_MODULE_165__ = __webpack_require__(/*! ./cx_shma_dynamic.clas.mjs */ "./output/cx_shma_dynamic.clas.mjs");
/* harmony import */ var _cx_shma_inconsistent_clas_mjs__WEBPACK_IMPORTED_MODULE_166__ = __webpack_require__(/*! ./cx_shma_inconsistent.clas.mjs */ "./output/cx_shma_inconsistent.clas.mjs");
/* harmony import */ var _cx_shma_not_configured_clas_mjs__WEBPACK_IMPORTED_MODULE_167__ = __webpack_require__(/*! ./cx_shma_not_configured.clas.mjs */ "./output/cx_shma_not_configured.clas.mjs");
/* harmony import */ var _cx_sql_exception_clas_mjs__WEBPACK_IMPORTED_MODULE_168__ = __webpack_require__(/*! ./cx_sql_exception.clas.mjs */ "./output/cx_sql_exception.clas.mjs");
/* harmony import */ var _cx_st_error_clas_mjs__WEBPACK_IMPORTED_MODULE_169__ = __webpack_require__(/*! ./cx_st_error.clas.mjs */ "./output/cx_st_error.clas.mjs");
/* harmony import */ var _cx_static_check_clas_mjs__WEBPACK_IMPORTED_MODULE_170__ = __webpack_require__(/*! ./cx_static_check.clas.mjs */ "./output/cx_static_check.clas.mjs");
/* harmony import */ var _cx_sxml_error_clas_mjs__WEBPACK_IMPORTED_MODULE_171__ = __webpack_require__(/*! ./cx_sxml_error.clas.mjs */ "./output/cx_sxml_error.clas.mjs");
/* harmony import */ var _cx_sxml_illegal_argument_error_clas_mjs__WEBPACK_IMPORTED_MODULE_172__ = __webpack_require__(/*! ./cx_sxml_illegal_argument_error.clas.mjs */ "./output/cx_sxml_illegal_argument_error.clas.mjs");
/* harmony import */ var _cx_sxml_name_error_clas_mjs__WEBPACK_IMPORTED_MODULE_173__ = __webpack_require__(/*! ./cx_sxml_name_error.clas.mjs */ "./output/cx_sxml_name_error.clas.mjs");
/* harmony import */ var _cx_sxml_parse_error_clas_mjs__WEBPACK_IMPORTED_MODULE_174__ = __webpack_require__(/*! ./cx_sxml_parse_error.clas.mjs */ "./output/cx_sxml_parse_error.clas.mjs");
/* harmony import */ var _cx_sxml_state_error_clas_mjs__WEBPACK_IMPORTED_MODULE_175__ = __webpack_require__(/*! ./cx_sxml_state_error.clas.mjs */ "./output/cx_sxml_state_error.clas.mjs");
/* harmony import */ var _cx_sy_arithmetic_error_clas_mjs__WEBPACK_IMPORTED_MODULE_176__ = __webpack_require__(/*! ./cx_sy_arithmetic_error.clas.mjs */ "./output/cx_sy_arithmetic_error.clas.mjs");
/* harmony import */ var _cx_sy_arithmetic_overflow_clas_mjs__WEBPACK_IMPORTED_MODULE_177__ = __webpack_require__(/*! ./cx_sy_arithmetic_overflow.clas.mjs */ "./output/cx_sy_arithmetic_overflow.clas.mjs");
/* harmony import */ var _cx_sy_buffer_overflow_clas_mjs__WEBPACK_IMPORTED_MODULE_178__ = __webpack_require__(/*! ./cx_sy_buffer_overflow.clas.mjs */ "./output/cx_sy_buffer_overflow.clas.mjs");
/* harmony import */ var _cx_sy_codepage_converter_init_clas_mjs__WEBPACK_IMPORTED_MODULE_179__ = __webpack_require__(/*! ./cx_sy_codepage_converter_init.clas.mjs */ "./output/cx_sy_codepage_converter_init.clas.mjs");
/* harmony import */ var _cx_sy_compression_error_clas_mjs__WEBPACK_IMPORTED_MODULE_180__ = __webpack_require__(/*! ./cx_sy_compression_error.clas.mjs */ "./output/cx_sy_compression_error.clas.mjs");
/* harmony import */ var _cx_sy_conversion_codepage_clas_mjs__WEBPACK_IMPORTED_MODULE_181__ = __webpack_require__(/*! ./cx_sy_conversion_codepage.clas.mjs */ "./output/cx_sy_conversion_codepage.clas.mjs");
/* harmony import */ var _cx_sy_conversion_data_loss_clas_mjs__WEBPACK_IMPORTED_MODULE_182__ = __webpack_require__(/*! ./cx_sy_conversion_data_loss.clas.mjs */ "./output/cx_sy_conversion_data_loss.clas.mjs");
/* harmony import */ var _cx_sy_conversion_error_clas_mjs__WEBPACK_IMPORTED_MODULE_183__ = __webpack_require__(/*! ./cx_sy_conversion_error.clas.mjs */ "./output/cx_sy_conversion_error.clas.mjs");
/* harmony import */ var _cx_sy_conversion_no_number_clas_mjs__WEBPACK_IMPORTED_MODULE_184__ = __webpack_require__(/*! ./cx_sy_conversion_no_number.clas.mjs */ "./output/cx_sy_conversion_no_number.clas.mjs");
/* harmony import */ var _cx_sy_conversion_overflow_clas_mjs__WEBPACK_IMPORTED_MODULE_185__ = __webpack_require__(/*! ./cx_sy_conversion_overflow.clas.mjs */ "./output/cx_sy_conversion_overflow.clas.mjs");
/* harmony import */ var _cx_sy_create_data_error_clas_mjs__WEBPACK_IMPORTED_MODULE_186__ = __webpack_require__(/*! ./cx_sy_create_data_error.clas.mjs */ "./output/cx_sy_create_data_error.clas.mjs");
/* harmony import */ var _cx_sy_create_object_error_clas_mjs__WEBPACK_IMPORTED_MODULE_187__ = __webpack_require__(/*! ./cx_sy_create_object_error.clas.mjs */ "./output/cx_sy_create_object_error.clas.mjs");
/* harmony import */ var _cx_sy_data_access_error_clas_mjs__WEBPACK_IMPORTED_MODULE_188__ = __webpack_require__(/*! ./cx_sy_data_access_error.clas.mjs */ "./output/cx_sy_data_access_error.clas.mjs");
/* harmony import */ var _cx_sy_duplicate_key_clas_mjs__WEBPACK_IMPORTED_MODULE_189__ = __webpack_require__(/*! ./cx_sy_duplicate_key.clas.mjs */ "./output/cx_sy_duplicate_key.clas.mjs");
/* harmony import */ var _cx_sy_dyn_call_error_clas_mjs__WEBPACK_IMPORTED_MODULE_190__ = __webpack_require__(/*! ./cx_sy_dyn_call_error.clas.mjs */ "./output/cx_sy_dyn_call_error.clas.mjs");
/* harmony import */ var _cx_sy_dyn_call_illegal_class_clas_mjs__WEBPACK_IMPORTED_MODULE_191__ = __webpack_require__(/*! ./cx_sy_dyn_call_illegal_class.clas.mjs */ "./output/cx_sy_dyn_call_illegal_class.clas.mjs");
/* harmony import */ var _cx_sy_dyn_call_illegal_form_clas_mjs__WEBPACK_IMPORTED_MODULE_192__ = __webpack_require__(/*! ./cx_sy_dyn_call_illegal_form.clas.mjs */ "./output/cx_sy_dyn_call_illegal_form.clas.mjs");
/* harmony import */ var _cx_sy_dyn_call_illegal_func_clas_mjs__WEBPACK_IMPORTED_MODULE_193__ = __webpack_require__(/*! ./cx_sy_dyn_call_illegal_func.clas.mjs */ "./output/cx_sy_dyn_call_illegal_func.clas.mjs");
/* harmony import */ var _cx_sy_dyn_call_illegal_method_clas_mjs__WEBPACK_IMPORTED_MODULE_194__ = __webpack_require__(/*! ./cx_sy_dyn_call_illegal_method.clas.mjs */ "./output/cx_sy_dyn_call_illegal_method.clas.mjs");
/* harmony import */ var _cx_sy_dyn_call_param_not_found_clas_mjs__WEBPACK_IMPORTED_MODULE_195__ = __webpack_require__(/*! ./cx_sy_dyn_call_param_not_found.clas.mjs */ "./output/cx_sy_dyn_call_param_not_found.clas.mjs");
/* harmony import */ var _cx_sy_dyn_call_parameter_error_clas_mjs__WEBPACK_IMPORTED_MODULE_196__ = __webpack_require__(/*! ./cx_sy_dyn_call_parameter_error.clas.mjs */ "./output/cx_sy_dyn_call_parameter_error.clas.mjs");
/* harmony import */ var _cx_sy_dynamic_osql_error_clas_mjs__WEBPACK_IMPORTED_MODULE_197__ = __webpack_require__(/*! ./cx_sy_dynamic_osql_error.clas.mjs */ "./output/cx_sy_dynamic_osql_error.clas.mjs");
/* harmony import */ var _cx_sy_dynamic_osql_semantics_clas_mjs__WEBPACK_IMPORTED_MODULE_198__ = __webpack_require__(/*! ./cx_sy_dynamic_osql_semantics.clas.mjs */ "./output/cx_sy_dynamic_osql_semantics.clas.mjs");
/* harmony import */ var _cx_sy_itab_duplicate_key_clas_mjs__WEBPACK_IMPORTED_MODULE_199__ = __webpack_require__(/*! ./cx_sy_itab_duplicate_key.clas.mjs */ "./output/cx_sy_itab_duplicate_key.clas.mjs");
/* harmony import */ var _cx_sy_itab_error_clas_mjs__WEBPACK_IMPORTED_MODULE_200__ = __webpack_require__(/*! ./cx_sy_itab_error.clas.mjs */ "./output/cx_sy_itab_error.clas.mjs");
/* harmony import */ var _cx_sy_itab_line_not_found_clas_mjs__WEBPACK_IMPORTED_MODULE_201__ = __webpack_require__(/*! ./cx_sy_itab_line_not_found.clas.mjs */ "./output/cx_sy_itab_line_not_found.clas.mjs");
/* harmony import */ var _cx_sy_message_illegal_text_clas_mjs__WEBPACK_IMPORTED_MODULE_202__ = __webpack_require__(/*! ./cx_sy_message_illegal_text.clas.mjs */ "./output/cx_sy_message_illegal_text.clas.mjs");
/* harmony import */ var _cx_sy_move_cast_error_clas_mjs__WEBPACK_IMPORTED_MODULE_203__ = __webpack_require__(/*! ./cx_sy_move_cast_error.clas.mjs */ "./output/cx_sy_move_cast_error.clas.mjs");
/* harmony import */ var _cx_sy_open_sql_error_clas_mjs__WEBPACK_IMPORTED_MODULE_204__ = __webpack_require__(/*! ./cx_sy_open_sql_error.clas.mjs */ "./output/cx_sy_open_sql_error.clas.mjs");
/* harmony import */ var _cx_sy_range_out_of_bounds_clas_mjs__WEBPACK_IMPORTED_MODULE_205__ = __webpack_require__(/*! ./cx_sy_range_out_of_bounds.clas.mjs */ "./output/cx_sy_range_out_of_bounds.clas.mjs");
/* harmony import */ var _cx_sy_ref_is_initial_clas_mjs__WEBPACK_IMPORTED_MODULE_206__ = __webpack_require__(/*! ./cx_sy_ref_is_initial.clas.mjs */ "./output/cx_sy_ref_is_initial.clas.mjs");
/* harmony import */ var _cx_sy_sql_error_clas_mjs__WEBPACK_IMPORTED_MODULE_207__ = __webpack_require__(/*! ./cx_sy_sql_error.clas.mjs */ "./output/cx_sy_sql_error.clas.mjs");
/* harmony import */ var _cx_sy_strg_par_val_clas_mjs__WEBPACK_IMPORTED_MODULE_208__ = __webpack_require__(/*! ./cx_sy_strg_par_val.clas.mjs */ "./output/cx_sy_strg_par_val.clas.mjs");
/* harmony import */ var _cx_sy_struct_attributes_clas_mjs__WEBPACK_IMPORTED_MODULE_209__ = __webpack_require__(/*! ./cx_sy_struct_attributes.clas.mjs */ "./output/cx_sy_struct_attributes.clas.mjs");
/* harmony import */ var _cx_sy_struct_comp_name_clas_mjs__WEBPACK_IMPORTED_MODULE_210__ = __webpack_require__(/*! ./cx_sy_struct_comp_name.clas.mjs */ "./output/cx_sy_struct_comp_name.clas.mjs");
/* harmony import */ var _cx_sy_struct_comp_type_clas_mjs__WEBPACK_IMPORTED_MODULE_211__ = __webpack_require__(/*! ./cx_sy_struct_comp_type.clas.mjs */ "./output/cx_sy_struct_comp_type.clas.mjs");
/* harmony import */ var _cx_sy_struct_creation_clas_mjs__WEBPACK_IMPORTED_MODULE_212__ = __webpack_require__(/*! ./cx_sy_struct_creation.clas.mjs */ "./output/cx_sy_struct_creation.clas.mjs");
/* harmony import */ var _cx_sy_type_creation_clas_mjs__WEBPACK_IMPORTED_MODULE_213__ = __webpack_require__(/*! ./cx_sy_type_creation.clas.mjs */ "./output/cx_sy_type_creation.clas.mjs");
/* harmony import */ var _cx_sy_zerodivide_clas_mjs__WEBPACK_IMPORTED_MODULE_214__ = __webpack_require__(/*! ./cx_sy_zerodivide.clas.mjs */ "./output/cx_sy_zerodivide.clas.mjs");
/* harmony import */ var _cx_transformation_error_clas_mjs__WEBPACK_IMPORTED_MODULE_215__ = __webpack_require__(/*! ./cx_transformation_error.clas.mjs */ "./output/cx_transformation_error.clas.mjs");
/* harmony import */ var _cx_uuid_error_clas_mjs__WEBPACK_IMPORTED_MODULE_216__ = __webpack_require__(/*! ./cx_uuid_error.clas.mjs */ "./output/cx_uuid_error.clas.mjs");
/* harmony import */ var _cx_xslt_exception_clas_mjs__WEBPACK_IMPORTED_MODULE_217__ = __webpack_require__(/*! ./cx_xslt_exception.clas.mjs */ "./output/cx_xslt_exception.clas.mjs");
/* harmony import */ var _cx_xslt_format_error_clas_mjs__WEBPACK_IMPORTED_MODULE_218__ = __webpack_require__(/*! ./cx_xslt_format_error.clas.mjs */ "./output/cx_xslt_format_error.clas.mjs");
/* harmony import */ var _cx_xslt_runtime_error_clas_mjs__WEBPACK_IMPORTED_MODULE_219__ = __webpack_require__(/*! ./cx_xslt_runtime_error.clas.mjs */ "./output/cx_xslt_runtime_error.clas.mjs");
/* harmony import */ var _cx_xslt_serialization_error_clas_mjs__WEBPACK_IMPORTED_MODULE_220__ = __webpack_require__(/*! ./cx_xslt_serialization_error.clas.mjs */ "./output/cx_xslt_serialization_error.clas.mjs");
/* harmony import */ var _cx_xslt_system_error_clas_mjs__WEBPACK_IMPORTED_MODULE_221__ = __webpack_require__(/*! ./cx_xslt_system_error.clas.mjs */ "./output/cx_xslt_system_error.clas.mjs");
/* harmony import */ var _dats_dtel_mjs__WEBPACK_IMPORTED_MODULE_222__ = __webpack_require__(/*! ./dats.dtel.mjs */ "./output/dats.dtel.mjs");
/* harmony import */ var _ddfields_ttyp_mjs__WEBPACK_IMPORTED_MODULE_223__ = __webpack_require__(/*! ./ddfields.ttyp.mjs */ "./output/ddfields.ttyp.mjs");
/* harmony import */ var _ddoption_dtel_mjs__WEBPACK_IMPORTED_MODULE_224__ = __webpack_require__(/*! ./ddoption.dtel.mjs */ "./output/ddoption.dtel.mjs");
/* harmony import */ var _ddsign_dtel_mjs__WEBPACK_IMPORTED_MODULE_225__ = __webpack_require__(/*! ./ddsign.dtel.mjs */ "./output/ddsign.dtel.mjs");
/* harmony import */ var _devclass_dtel_mjs__WEBPACK_IMPORTED_MODULE_226__ = __webpack_require__(/*! ./devclass.dtel.mjs */ "./output/devclass.dtel.mjs");
/* harmony import */ var _dfies_tabl_mjs__WEBPACK_IMPORTED_MODULE_227__ = __webpack_require__(/*! ./dfies.tabl.mjs */ "./output/dfies.tabl.mjs");
/* harmony import */ var _doku_obj_dtel_mjs__WEBPACK_IMPORTED_MODULE_228__ = __webpack_require__(/*! ./doku_obj.dtel.mjs */ "./output/doku_obj.dtel.mjs");
/* harmony import */ var _dynprofld_dtel_mjs__WEBPACK_IMPORTED_MODULE_229__ = __webpack_require__(/*! ./dynprofld.dtel.mjs */ "./output/dynprofld.dtel.mjs");
/* harmony import */ var _file_table_tabl_mjs__WEBPACK_IMPORTED_MODULE_230__ = __webpack_require__(/*! ./file_table.tabl.mjs */ "./output/file_table.tabl.mjs");
/* harmony import */ var _filetable_ttyp_mjs__WEBPACK_IMPORTED_MODULE_231__ = __webpack_require__(/*! ./filetable.ttyp.mjs */ "./output/filetable.ttyp.mjs");
/* harmony import */ var _flag_dtel_mjs__WEBPACK_IMPORTED_MODULE_232__ = __webpack_require__(/*! ./flag.dtel.mjs */ "./output/flag.dtel.mjs");
/* harmony import */ var _funcname_dtel_mjs__WEBPACK_IMPORTED_MODULE_233__ = __webpack_require__(/*! ./funcname.dtel.mjs */ "./output/funcname.dtel.mjs");
/* harmony import */ var _guid_dtel_mjs__WEBPACK_IMPORTED_MODULE_234__ = __webpack_require__(/*! ./guid.dtel.mjs */ "./output/guid.dtel.mjs");
/* harmony import */ var _icon_type_mjs__WEBPACK_IMPORTED_MODULE_235__ = __webpack_require__(/*! ./icon.type.mjs */ "./output/icon.type.mjs");
/* harmony import */ var _icon_d_dtel_mjs__WEBPACK_IMPORTED_MODULE_236__ = __webpack_require__(/*! ./icon_d.dtel.mjs */ "./output/icon_d.dtel.mjs");
/* harmony import */ var _if_abap_channel_types_intf_mjs__WEBPACK_IMPORTED_MODULE_237__ = __webpack_require__(/*! ./if_abap_channel_types.intf.mjs */ "./output/if_abap_channel_types.intf.mjs");
/* harmony import */ var _if_abap_conv_in_intf_mjs__WEBPACK_IMPORTED_MODULE_238__ = __webpack_require__(/*! ./if_abap_conv_in.intf.mjs */ "./output/if_abap_conv_in.intf.mjs");
/* harmony import */ var _if_abap_conv_out_intf_mjs__WEBPACK_IMPORTED_MODULE_239__ = __webpack_require__(/*! ./if_abap_conv_out.intf.mjs */ "./output/if_abap_conv_out.intf.mjs");
/* harmony import */ var _if_abap_unit_constant_intf_mjs__WEBPACK_IMPORTED_MODULE_240__ = __webpack_require__(/*! ./if_abap_unit_constant.intf.mjs */ "./output/if_abap_unit_constant.intf.mjs");
/* harmony import */ var _if_amdp_marker_hdb_intf_mjs__WEBPACK_IMPORTED_MODULE_241__ = __webpack_require__(/*! ./if_amdp_marker_hdb.intf.mjs */ "./output/if_amdp_marker_hdb.intf.mjs");
/* harmony import */ var _if_apc_tcp_frame_types_intf_mjs__WEBPACK_IMPORTED_MODULE_242__ = __webpack_require__(/*! ./if_apc_tcp_frame_types.intf.mjs */ "./output/if_apc_tcp_frame_types.intf.mjs");
/* harmony import */ var _if_apc_wsp_binding_manager_intf_mjs__WEBPACK_IMPORTED_MODULE_243__ = __webpack_require__(/*! ./if_apc_wsp_binding_manager.intf.mjs */ "./output/if_apc_wsp_binding_manager.intf.mjs");
/* harmony import */ var _if_apc_wsp_client_intf_mjs__WEBPACK_IMPORTED_MODULE_244__ = __webpack_require__(/*! ./if_apc_wsp_client.intf.mjs */ "./output/if_apc_wsp_client.intf.mjs");
/* harmony import */ var _if_apc_wsp_event_handler_intf_mjs__WEBPACK_IMPORTED_MODULE_245__ = __webpack_require__(/*! ./if_apc_wsp_event_handler.intf.mjs */ "./output/if_apc_wsp_event_handler.intf.mjs");
/* harmony import */ var _if_apc_wsp_extension_intf_mjs__WEBPACK_IMPORTED_MODULE_246__ = __webpack_require__(/*! ./if_apc_wsp_extension.intf.mjs */ "./output/if_apc_wsp_extension.intf.mjs");
/* harmony import */ var _if_apc_wsp_initial_request_intf_mjs__WEBPACK_IMPORTED_MODULE_247__ = __webpack_require__(/*! ./if_apc_wsp_initial_request.intf.mjs */ "./output/if_apc_wsp_initial_request.intf.mjs");
/* harmony import */ var _if_apc_wsp_message_intf_mjs__WEBPACK_IMPORTED_MODULE_248__ = __webpack_require__(/*! ./if_apc_wsp_message.intf.mjs */ "./output/if_apc_wsp_message.intf.mjs");
/* harmony import */ var _if_apc_wsp_message_manager_intf_mjs__WEBPACK_IMPORTED_MODULE_249__ = __webpack_require__(/*! ./if_apc_wsp_message_manager.intf.mjs */ "./output/if_apc_wsp_message_manager.intf.mjs");
/* harmony import */ var _if_apc_wsp_server_context_intf_mjs__WEBPACK_IMPORTED_MODULE_250__ = __webpack_require__(/*! ./if_apc_wsp_server_context.intf.mjs */ "./output/if_apc_wsp_server_context.intf.mjs");
/* harmony import */ var _if_aunit_constants_intf_mjs__WEBPACK_IMPORTED_MODULE_251__ = __webpack_require__(/*! ./if_aunit_constants.intf.mjs */ "./output/if_aunit_constants.intf.mjs");
/* harmony import */ var _if_document_bcs_intf_mjs__WEBPACK_IMPORTED_MODULE_252__ = __webpack_require__(/*! ./if_document_bcs.intf.mjs */ "./output/if_document_bcs.intf.mjs");
/* harmony import */ var _if_ftd_input_arguments_intf_mjs__WEBPACK_IMPORTED_MODULE_253__ = __webpack_require__(/*! ./if_ftd_input_arguments.intf.mjs */ "./output/if_ftd_input_arguments.intf.mjs");
/* harmony import */ var _if_ftd_input_config_setter_intf_mjs__WEBPACK_IMPORTED_MODULE_254__ = __webpack_require__(/*! ./if_ftd_input_config_setter.intf.mjs */ "./output/if_ftd_input_config_setter.intf.mjs");
/* harmony import */ var _if_ftd_invocation_answer_intf_mjs__WEBPACK_IMPORTED_MODULE_255__ = __webpack_require__(/*! ./if_ftd_invocation_answer.intf.mjs */ "./output/if_ftd_invocation_answer.intf.mjs");
/* harmony import */ var _if_ftd_invocation_result_intf_mjs__WEBPACK_IMPORTED_MODULE_256__ = __webpack_require__(/*! ./if_ftd_invocation_result.intf.mjs */ "./output/if_ftd_invocation_result.intf.mjs");
/* harmony import */ var _if_ftd_output_config_setter_intf_mjs__WEBPACK_IMPORTED_MODULE_257__ = __webpack_require__(/*! ./if_ftd_output_config_setter.intf.mjs */ "./output/if_ftd_output_config_setter.intf.mjs");
/* harmony import */ var _if_ftd_output_configuration_intf_mjs__WEBPACK_IMPORTED_MODULE_258__ = __webpack_require__(/*! ./if_ftd_output_configuration.intf.mjs */ "./output/if_ftd_output_configuration.intf.mjs");
/* harmony import */ var _if_function_test_environment_intf_mjs__WEBPACK_IMPORTED_MODULE_259__ = __webpack_require__(/*! ./if_function_test_environment.intf.mjs */ "./output/if_function_test_environment.intf.mjs");
/* harmony import */ var _if_function_testdouble_intf_mjs__WEBPACK_IMPORTED_MODULE_260__ = __webpack_require__(/*! ./if_function_testdouble.intf.mjs */ "./output/if_function_testdouble.intf.mjs");
/* harmony import */ var _if_http_client_intf_mjs__WEBPACK_IMPORTED_MODULE_261__ = __webpack_require__(/*! ./if_http_client.intf.mjs */ "./output/if_http_client.intf.mjs");
/* harmony import */ var _if_http_entity_intf_mjs__WEBPACK_IMPORTED_MODULE_262__ = __webpack_require__(/*! ./if_http_entity.intf.mjs */ "./output/if_http_entity.intf.mjs");
/* harmony import */ var _if_http_extension_intf_mjs__WEBPACK_IMPORTED_MODULE_263__ = __webpack_require__(/*! ./if_http_extension.intf.mjs */ "./output/if_http_extension.intf.mjs");
/* harmony import */ var _if_http_request_intf_mjs__WEBPACK_IMPORTED_MODULE_264__ = __webpack_require__(/*! ./if_http_request.intf.mjs */ "./output/if_http_request.intf.mjs");
/* harmony import */ var _if_http_response_intf_mjs__WEBPACK_IMPORTED_MODULE_265__ = __webpack_require__(/*! ./if_http_response.intf.mjs */ "./output/if_http_response.intf.mjs");
/* harmony import */ var _if_http_server_intf_mjs__WEBPACK_IMPORTED_MODULE_266__ = __webpack_require__(/*! ./if_http_server.intf.mjs */ "./output/if_http_server.intf.mjs");
/* harmony import */ var _if_http_utility_intf_mjs__WEBPACK_IMPORTED_MODULE_267__ = __webpack_require__(/*! ./if_http_utility.intf.mjs */ "./output/if_http_utility.intf.mjs");
/* harmony import */ var _if_icf_tree_intf_mjs__WEBPACK_IMPORTED_MODULE_268__ = __webpack_require__(/*! ./if_icf_tree.intf.mjs */ "./output/if_icf_tree.intf.mjs");
/* harmony import */ var _if_ixml_intf_mjs__WEBPACK_IMPORTED_MODULE_269__ = __webpack_require__(/*! ./if_ixml.intf.mjs */ "./output/if_ixml.intf.mjs");
/* harmony import */ var _if_ixml_attribute_intf_mjs__WEBPACK_IMPORTED_MODULE_270__ = __webpack_require__(/*! ./if_ixml_attribute.intf.mjs */ "./output/if_ixml_attribute.intf.mjs");
/* harmony import */ var _if_ixml_document_intf_mjs__WEBPACK_IMPORTED_MODULE_271__ = __webpack_require__(/*! ./if_ixml_document.intf.mjs */ "./output/if_ixml_document.intf.mjs");
/* harmony import */ var _if_ixml_element_intf_mjs__WEBPACK_IMPORTED_MODULE_272__ = __webpack_require__(/*! ./if_ixml_element.intf.mjs */ "./output/if_ixml_element.intf.mjs");
/* harmony import */ var _if_ixml_encoding_intf_mjs__WEBPACK_IMPORTED_MODULE_273__ = __webpack_require__(/*! ./if_ixml_encoding.intf.mjs */ "./output/if_ixml_encoding.intf.mjs");
/* harmony import */ var _if_ixml_istream_intf_mjs__WEBPACK_IMPORTED_MODULE_274__ = __webpack_require__(/*! ./if_ixml_istream.intf.mjs */ "./output/if_ixml_istream.intf.mjs");
/* harmony import */ var _if_ixml_named_node_map_intf_mjs__WEBPACK_IMPORTED_MODULE_275__ = __webpack_require__(/*! ./if_ixml_named_node_map.intf.mjs */ "./output/if_ixml_named_node_map.intf.mjs");
/* harmony import */ var _if_ixml_node_intf_mjs__WEBPACK_IMPORTED_MODULE_276__ = __webpack_require__(/*! ./if_ixml_node.intf.mjs */ "./output/if_ixml_node.intf.mjs");
/* harmony import */ var _if_ixml_node_collection_intf_mjs__WEBPACK_IMPORTED_MODULE_277__ = __webpack_require__(/*! ./if_ixml_node_collection.intf.mjs */ "./output/if_ixml_node_collection.intf.mjs");
/* harmony import */ var _if_ixml_node_filter_intf_mjs__WEBPACK_IMPORTED_MODULE_278__ = __webpack_require__(/*! ./if_ixml_node_filter.intf.mjs */ "./output/if_ixml_node_filter.intf.mjs");
/* harmony import */ var _if_ixml_node_iterator_intf_mjs__WEBPACK_IMPORTED_MODULE_279__ = __webpack_require__(/*! ./if_ixml_node_iterator.intf.mjs */ "./output/if_ixml_node_iterator.intf.mjs");
/* harmony import */ var _if_ixml_node_list_intf_mjs__WEBPACK_IMPORTED_MODULE_280__ = __webpack_require__(/*! ./if_ixml_node_list.intf.mjs */ "./output/if_ixml_node_list.intf.mjs");
/* harmony import */ var _if_ixml_ostream_intf_mjs__WEBPACK_IMPORTED_MODULE_281__ = __webpack_require__(/*! ./if_ixml_ostream.intf.mjs */ "./output/if_ixml_ostream.intf.mjs");
/* harmony import */ var _if_ixml_parse_error_intf_mjs__WEBPACK_IMPORTED_MODULE_282__ = __webpack_require__(/*! ./if_ixml_parse_error.intf.mjs */ "./output/if_ixml_parse_error.intf.mjs");
/* harmony import */ var _if_ixml_parser_intf_mjs__WEBPACK_IMPORTED_MODULE_283__ = __webpack_require__(/*! ./if_ixml_parser.intf.mjs */ "./output/if_ixml_parser.intf.mjs");
/* harmony import */ var _if_ixml_renderer_intf_mjs__WEBPACK_IMPORTED_MODULE_284__ = __webpack_require__(/*! ./if_ixml_renderer.intf.mjs */ "./output/if_ixml_renderer.intf.mjs");
/* harmony import */ var _if_ixml_stream_factory_intf_mjs__WEBPACK_IMPORTED_MODULE_285__ = __webpack_require__(/*! ./if_ixml_stream_factory.intf.mjs */ "./output/if_ixml_stream_factory.intf.mjs");
/* harmony import */ var _if_ixml_unknown_intf_mjs__WEBPACK_IMPORTED_MODULE_286__ = __webpack_require__(/*! ./if_ixml_unknown.intf.mjs */ "./output/if_ixml_unknown.intf.mjs");
/* harmony import */ var _if_message_intf_mjs__WEBPACK_IMPORTED_MODULE_287__ = __webpack_require__(/*! ./if_message.intf.mjs */ "./output/if_message.intf.mjs");
/* harmony import */ var _if_mr_api_intf_mjs__WEBPACK_IMPORTED_MODULE_288__ = __webpack_require__(/*! ./if_mr_api.intf.mjs */ "./output/if_mr_api.intf.mjs");
/* harmony import */ var _if_oauth2_client_intf_mjs__WEBPACK_IMPORTED_MODULE_289__ = __webpack_require__(/*! ./if_oauth2_client.intf.mjs */ "./output/if_oauth2_client.intf.mjs");
/* harmony import */ var _if_oo_adt_classrun_intf_mjs__WEBPACK_IMPORTED_MODULE_290__ = __webpack_require__(/*! ./if_oo_adt_classrun.intf.mjs */ "./output/if_oo_adt_classrun.intf.mjs");
/* harmony import */ var _if_oo_adt_classrun_out_intf_mjs__WEBPACK_IMPORTED_MODULE_291__ = __webpack_require__(/*! ./if_oo_adt_classrun_out.intf.mjs */ "./output/if_oo_adt_classrun_out.intf.mjs");
/* harmony import */ var _if_oo_clif_source_intf_mjs__WEBPACK_IMPORTED_MODULE_292__ = __webpack_require__(/*! ./if_oo_clif_source.intf.mjs */ "./output/if_oo_clif_source.intf.mjs");
/* harmony import */ var _if_osql_test_environment_intf_mjs__WEBPACK_IMPORTED_MODULE_293__ = __webpack_require__(/*! ./if_osql_test_environment.intf.mjs */ "./output/if_osql_test_environment.intf.mjs");
/* harmony import */ var _if_recipient_bcs_intf_mjs__WEBPACK_IMPORTED_MODULE_294__ = __webpack_require__(/*! ./if_recipient_bcs.intf.mjs */ "./output/if_recipient_bcs.intf.mjs");
/* harmony import */ var _if_salv_c_aggregation_intf_mjs__WEBPACK_IMPORTED_MODULE_295__ = __webpack_require__(/*! ./if_salv_c_aggregation.intf.mjs */ "./output/if_salv_c_aggregation.intf.mjs");
/* harmony import */ var _if_salv_c_bool_sap_intf_mjs__WEBPACK_IMPORTED_MODULE_296__ = __webpack_require__(/*! ./if_salv_c_bool_sap.intf.mjs */ "./output/if_salv_c_bool_sap.intf.mjs");
/* harmony import */ var _if_salv_c_selection_mode_intf_mjs__WEBPACK_IMPORTED_MODULE_297__ = __webpack_require__(/*! ./if_salv_c_selection_mode.intf.mjs */ "./output/if_salv_c_selection_mode.intf.mjs");
/* harmony import */ var _if_sender_bcs_intf_mjs__WEBPACK_IMPORTED_MODULE_298__ = __webpack_require__(/*! ./if_sender_bcs.intf.mjs */ "./output/if_sender_bcs.intf.mjs");
/* harmony import */ var _if_serializable_object_intf_mjs__WEBPACK_IMPORTED_MODULE_299__ = __webpack_require__(/*! ./if_serializable_object.intf.mjs */ "./output/if_serializable_object.intf.mjs");
/* harmony import */ var _if_shm_build_instance_intf_mjs__WEBPACK_IMPORTED_MODULE_300__ = __webpack_require__(/*! ./if_shm_build_instance.intf.mjs */ "./output/if_shm_build_instance.intf.mjs");
/* harmony import */ var _if_shm_trace_intf_mjs__WEBPACK_IMPORTED_MODULE_301__ = __webpack_require__(/*! ./if_shm_trace.intf.mjs */ "./output/if_shm_trace.intf.mjs");
/* harmony import */ var _if_sxml_intf_mjs__WEBPACK_IMPORTED_MODULE_302__ = __webpack_require__(/*! ./if_sxml.intf.mjs */ "./output/if_sxml.intf.mjs");
/* harmony import */ var _if_sxml_attribute_intf_mjs__WEBPACK_IMPORTED_MODULE_303__ = __webpack_require__(/*! ./if_sxml_attribute.intf.mjs */ "./output/if_sxml_attribute.intf.mjs");
/* harmony import */ var _if_sxml_close_element_intf_mjs__WEBPACK_IMPORTED_MODULE_304__ = __webpack_require__(/*! ./if_sxml_close_element.intf.mjs */ "./output/if_sxml_close_element.intf.mjs");
/* harmony import */ var _if_sxml_named_intf_mjs__WEBPACK_IMPORTED_MODULE_305__ = __webpack_require__(/*! ./if_sxml_named.intf.mjs */ "./output/if_sxml_named.intf.mjs");
/* harmony import */ var _if_sxml_node_intf_mjs__WEBPACK_IMPORTED_MODULE_306__ = __webpack_require__(/*! ./if_sxml_node.intf.mjs */ "./output/if_sxml_node.intf.mjs");
/* harmony import */ var _if_sxml_open_element_intf_mjs__WEBPACK_IMPORTED_MODULE_307__ = __webpack_require__(/*! ./if_sxml_open_element.intf.mjs */ "./output/if_sxml_open_element.intf.mjs");
/* harmony import */ var _if_sxml_reader_intf_mjs__WEBPACK_IMPORTED_MODULE_308__ = __webpack_require__(/*! ./if_sxml_reader.intf.mjs */ "./output/if_sxml_reader.intf.mjs");
/* harmony import */ var _if_sxml_value_intf_mjs__WEBPACK_IMPORTED_MODULE_309__ = __webpack_require__(/*! ./if_sxml_value.intf.mjs */ "./output/if_sxml_value.intf.mjs");
/* harmony import */ var _if_sxml_value_node_intf_mjs__WEBPACK_IMPORTED_MODULE_310__ = __webpack_require__(/*! ./if_sxml_value_node.intf.mjs */ "./output/if_sxml_value_node.intf.mjs");
/* harmony import */ var _if_sxml_writer_intf_mjs__WEBPACK_IMPORTED_MODULE_311__ = __webpack_require__(/*! ./if_sxml_writer.intf.mjs */ "./output/if_sxml_writer.intf.mjs");
/* harmony import */ var _if_sxmlp_factory_intf_mjs__WEBPACK_IMPORTED_MODULE_312__ = __webpack_require__(/*! ./if_sxmlp_factory.intf.mjs */ "./output/if_sxmlp_factory.intf.mjs");
/* harmony import */ var _if_sxmlp_list_intf_mjs__WEBPACK_IMPORTED_MODULE_313__ = __webpack_require__(/*! ./if_sxmlp_list.intf.mjs */ "./output/if_sxmlp_list.intf.mjs");
/* harmony import */ var _if_sxmlp_part_intf_mjs__WEBPACK_IMPORTED_MODULE_314__ = __webpack_require__(/*! ./if_sxmlp_part.intf.mjs */ "./output/if_sxmlp_part.intf.mjs");
/* harmony import */ var _if_sxmlp_simple_intf_mjs__WEBPACK_IMPORTED_MODULE_315__ = __webpack_require__(/*! ./if_sxmlp_simple.intf.mjs */ "./output/if_sxmlp_simple.intf.mjs");
/* harmony import */ var _if_system_uuid_rfc4122_static_intf_mjs__WEBPACK_IMPORTED_MODULE_316__ = __webpack_require__(/*! ./if_system_uuid_rfc4122_static.intf.mjs */ "./output/if_system_uuid_rfc4122_static.intf.mjs");
/* harmony import */ var _if_system_uuid_static_intf_mjs__WEBPACK_IMPORTED_MODULE_317__ = __webpack_require__(/*! ./if_system_uuid_static.intf.mjs */ "./output/if_system_uuid_static.intf.mjs");
/* harmony import */ var _if_t100_dyn_msg_intf_mjs__WEBPACK_IMPORTED_MODULE_318__ = __webpack_require__(/*! ./if_t100_dyn_msg.intf.mjs */ "./output/if_t100_dyn_msg.intf.mjs");
/* harmony import */ var _if_t100_message_intf_mjs__WEBPACK_IMPORTED_MODULE_319__ = __webpack_require__(/*! ./if_t100_message.intf.mjs */ "./output/if_t100_message.intf.mjs");
/* harmony import */ var _ihttpnvp_tabl_mjs__WEBPACK_IMPORTED_MODULE_320__ = __webpack_require__(/*! ./ihttpnvp.tabl.mjs */ "./output/ihttpnvp.tabl.mjs");
/* harmony import */ var _int1_dtel_mjs__WEBPACK_IMPORTED_MODULE_321__ = __webpack_require__(/*! ./int1.dtel.mjs */ "./output/int1.dtel.mjs");
/* harmony import */ var _int2_dtel_mjs__WEBPACK_IMPORTED_MODULE_322__ = __webpack_require__(/*! ./int2.dtel.mjs */ "./output/int2.dtel.mjs");
/* harmony import */ var _int4_dtel_mjs__WEBPACK_IMPORTED_MODULE_323__ = __webpack_require__(/*! ./int4.dtel.mjs */ "./output/int4.dtel.mjs");
/* harmony import */ var _kernel_authority_check_clas_mjs__WEBPACK_IMPORTED_MODULE_324__ = __webpack_require__(/*! ./kernel_authority_check.clas.mjs */ "./output/kernel_authority_check.clas.mjs");
/* harmony import */ var _kernel_call_clas_mjs__WEBPACK_IMPORTED_MODULE_325__ = __webpack_require__(/*! ./kernel_call.clas.mjs */ "./output/kernel_call.clas.mjs");
/* harmony import */ var _kernel_call_transformation_clas_mjs__WEBPACK_IMPORTED_MODULE_326__ = __webpack_require__(/*! ./kernel_call_transformation.clas.mjs */ "./output/kernel_call_transformation.clas.mjs");
/* harmony import */ var _kernel_create_data_handle_clas_mjs__WEBPACK_IMPORTED_MODULE_327__ = __webpack_require__(/*! ./kernel_create_data_handle.clas.mjs */ "./output/kernel_create_data_handle.clas.mjs");
/* harmony import */ var _kernel_cx_assert_clas_mjs__WEBPACK_IMPORTED_MODULE_328__ = __webpack_require__(/*! ./kernel_cx_assert.clas.mjs */ "./output/kernel_cx_assert.clas.mjs");
/* harmony import */ var _kernel_fugr_test_clas_mjs__WEBPACK_IMPORTED_MODULE_329__ = __webpack_require__(/*! ./kernel_fugr_test.clas.mjs */ "./output/kernel_fugr_test.clas.mjs");
/* harmony import */ var _kernel_internal_name_clas_mjs__WEBPACK_IMPORTED_MODULE_330__ = __webpack_require__(/*! ./kernel_internal_name.clas.mjs */ "./output/kernel_internal_name.clas.mjs");
/* harmony import */ var _kernel_ixml_json_to_data_clas_mjs__WEBPACK_IMPORTED_MODULE_331__ = __webpack_require__(/*! ./kernel_ixml_json_to_data.clas.mjs */ "./output/kernel_ixml_json_to_data.clas.mjs");
/* harmony import */ var _kernel_ixml_xml_to_data_clas_mjs__WEBPACK_IMPORTED_MODULE_332__ = __webpack_require__(/*! ./kernel_ixml_xml_to_data.clas.mjs */ "./output/kernel_ixml_xml_to_data.clas.mjs");
/* harmony import */ var _kernel_json_to_ixml_clas_mjs__WEBPACK_IMPORTED_MODULE_333__ = __webpack_require__(/*! ./kernel_json_to_ixml.clas.mjs */ "./output/kernel_json_to_ixml.clas.mjs");
/* harmony import */ var _kernel_lock_clas_mjs__WEBPACK_IMPORTED_MODULE_334__ = __webpack_require__(/*! ./kernel_lock.clas.mjs */ "./output/kernel_lock.clas.mjs");
/* harmony import */ var _kernel_numberrange_clas_mjs__WEBPACK_IMPORTED_MODULE_335__ = __webpack_require__(/*! ./kernel_numberrange.clas.mjs */ "./output/kernel_numberrange.clas.mjs");
/* harmony import */ var _kernel_push_channels_clas_mjs__WEBPACK_IMPORTED_MODULE_336__ = __webpack_require__(/*! ./kernel_push_channels.clas.mjs */ "./output/kernel_push_channels.clas.mjs");
/* harmony import */ var _kernel_scan_abap_source_clas_mjs__WEBPACK_IMPORTED_MODULE_337__ = __webpack_require__(/*! ./kernel_scan_abap_source.clas.mjs */ "./output/kernel_scan_abap_source.clas.mjs");
/* harmony import */ var _kernel_unit_runner_clas_mjs__WEBPACK_IMPORTED_MODULE_338__ = __webpack_require__(/*! ./kernel_unit_runner.clas.mjs */ "./output/kernel_unit_runner.clas.mjs");
/* harmony import */ var _laiso_dtel_mjs__WEBPACK_IMPORTED_MODULE_339__ = __webpack_require__(/*! ./laiso.dtel.mjs */ "./output/laiso.dtel.mjs");
/* harmony import */ var _land1_dtel_mjs__WEBPACK_IMPORTED_MODULE_340__ = __webpack_require__(/*! ./land1.dtel.mjs */ "./output/land1.dtel.mjs");
/* harmony import */ var _langu_dtel_mjs__WEBPACK_IMPORTED_MODULE_341__ = __webpack_require__(/*! ./langu.dtel.mjs */ "./output/langu.dtel.mjs");
/* harmony import */ var _lvc_nokeyc_dtel_mjs__WEBPACK_IMPORTED_MODULE_342__ = __webpack_require__(/*! ./lvc_nokeyc.dtel.mjs */ "./output/lvc_nokeyc.dtel.mjs");
/* harmony import */ var _mandt_dtel_mjs__WEBPACK_IMPORTED_MODULE_343__ = __webpack_require__(/*! ./mandt.dtel.mjs */ "./output/mandt.dtel.mjs");
/* harmony import */ var _match_result_tabl_mjs__WEBPACK_IMPORTED_MODULE_344__ = __webpack_require__(/*! ./match_result.tabl.mjs */ "./output/match_result.tabl.mjs");
/* harmony import */ var _match_result_tab_ttyp_mjs__WEBPACK_IMPORTED_MODULE_345__ = __webpack_require__(/*! ./match_result_tab.ttyp.mjs */ "./output/match_result_tab.ttyp.mjs");
/* harmony import */ var _matnr_dtel_mjs__WEBPACK_IMPORTED_MODULE_346__ = __webpack_require__(/*! ./matnr.dtel.mjs */ "./output/matnr.dtel.mjs");
/* harmony import */ var _meins_dtel_mjs__WEBPACK_IMPORTED_MODULE_347__ = __webpack_require__(/*! ./meins.dtel.mjs */ "./output/meins.dtel.mjs");
/* harmony import */ var _menge_d_dtel_mjs__WEBPACK_IMPORTED_MODULE_348__ = __webpack_require__(/*! ./menge_d.dtel.mjs */ "./output/menge_d.dtel.mjs");
/* harmony import */ var _msehi_dtel_mjs__WEBPACK_IMPORTED_MODULE_349__ = __webpack_require__(/*! ./msehi.dtel.mjs */ "./output/msehi.dtel.mjs");
/* harmony import */ var _number_get_next_fugr_number_get_next_mjs__WEBPACK_IMPORTED_MODULE_350__ = __webpack_require__(/*! ./number_get_next.fugr.number_get_next.mjs */ "./output/number_get_next.fugr.number_get_next.mjs");
/* harmony import */ var _numc4_dtel_mjs__WEBPACK_IMPORTED_MODULE_351__ = __webpack_require__(/*! ./numc4.dtel.mjs */ "./output/numc4.dtel.mjs");
/* harmony import */ var _openabap_fugr_call_v1_ping_mjs__WEBPACK_IMPORTED_MODULE_352__ = __webpack_require__(/*! ./openabap.fugr.call_v1_ping.mjs */ "./output/openabap.fugr.call_v1_ping.mjs");
/* harmony import */ var _openabap_fugr_conversion_exit_alpha_input_mjs__WEBPACK_IMPORTED_MODULE_353__ = __webpack_require__(/*! ./openabap.fugr.conversion_exit_alpha_input.mjs */ "./output/openabap.fugr.conversion_exit_alpha_input.mjs");
/* harmony import */ var _openabap_fugr_conversion_exit_alpha_output_mjs__WEBPACK_IMPORTED_MODULE_354__ = __webpack_require__(/*! ./openabap.fugr.conversion_exit_alpha_output.mjs */ "./output/openabap.fugr.conversion_exit_alpha_output.mjs");
/* harmony import */ var _openabap_fugr_conversion_exit_isola_input_mjs__WEBPACK_IMPORTED_MODULE_355__ = __webpack_require__(/*! ./openabap.fugr.conversion_exit_isola_input.mjs */ "./output/openabap.fugr.conversion_exit_isola_input.mjs");
/* harmony import */ var _openabap_fugr_conversion_exit_isola_output_mjs__WEBPACK_IMPORTED_MODULE_356__ = __webpack_require__(/*! ./openabap.fugr.conversion_exit_isola_output.mjs */ "./output/openabap.fugr.conversion_exit_isola_output.mjs");
/* harmony import */ var _openabap_fugr_convert_itf_to_stream_text_mjs__WEBPACK_IMPORTED_MODULE_357__ = __webpack_require__(/*! ./openabap.fugr.convert_itf_to_stream_text.mjs */ "./output/openabap.fugr.convert_itf_to_stream_text.mjs");
/* harmony import */ var _openabap_fugr_docu_get_mjs__WEBPACK_IMPORTED_MODULE_358__ = __webpack_require__(/*! ./openabap.fugr.docu_get.mjs */ "./output/openabap.fugr.docu_get.mjs");
/* harmony import */ var _openabap_fugr_function_exists_mjs__WEBPACK_IMPORTED_MODULE_359__ = __webpack_require__(/*! ./openabap.fugr.function_exists.mjs */ "./output/openabap.fugr.function_exists.mjs");
/* harmony import */ var _openabap_fugr_generate_sec_random_mjs__WEBPACK_IMPORTED_MODULE_360__ = __webpack_require__(/*! ./openabap.fugr.generate_sec_random.mjs */ "./output/openabap.fugr.generate_sec_random.mjs");
/* harmony import */ var _openabap_fugr_get_system_timezone_mjs__WEBPACK_IMPORTED_MODULE_361__ = __webpack_require__(/*! ./openabap.fugr.get_system_timezone.mjs */ "./output/openabap.fugr.get_system_timezone.mjs");
/* harmony import */ var _openabap_fugr_system_callstack_mjs__WEBPACK_IMPORTED_MODULE_362__ = __webpack_require__(/*! ./openabap.fugr.system_callstack.mjs */ "./output/openabap.fugr.system_callstack.mjs");
/* harmony import */ var _openabap_fugr_system_installed_languages_mjs__WEBPACK_IMPORTED_MODULE_363__ = __webpack_require__(/*! ./openabap.fugr.system_installed_languages.mjs */ "./output/openabap.fugr.system_installed_languages.mjs");
/* harmony import */ var _openabap_fugr_text_split_mjs__WEBPACK_IMPORTED_MODULE_364__ = __webpack_require__(/*! ./openabap.fugr.text_split.mjs */ "./output/openabap.fugr.text_split.mjs");
/* harmony import */ var _openabap_fugr_unit_conversion_simple_mjs__WEBPACK_IMPORTED_MODULE_365__ = __webpack_require__(/*! ./openabap.fugr.unit_conversion_simple.mjs */ "./output/openabap.fugr.unit_conversion_simple.mjs");
/* harmony import */ var _reposrc_tabl_mjs__WEBPACK_IMPORTED_MODULE_366__ = __webpack_require__(/*! ./reposrc.tabl.mjs */ "./output/reposrc.tabl.mjs");
/* harmony import */ var _rfcdest_dtel_mjs__WEBPACK_IMPORTED_MODULE_367__ = __webpack_require__(/*! ./rfcdest.dtel.mjs */ "./output/rfcdest.dtel.mjs");
/* harmony import */ var _scrtext_l_dtel_mjs__WEBPACK_IMPORTED_MODULE_368__ = __webpack_require__(/*! ./scrtext_l.dtel.mjs */ "./output/scrtext_l.dtel.mjs");
/* harmony import */ var _scrtext_m_dtel_mjs__WEBPACK_IMPORTED_MODULE_369__ = __webpack_require__(/*! ./scrtext_m.dtel.mjs */ "./output/scrtext_m.dtel.mjs");
/* harmony import */ var _scrtext_s_dtel_mjs__WEBPACK_IMPORTED_MODULE_370__ = __webpack_require__(/*! ./scrtext_s.dtel.mjs */ "./output/scrtext_s.dtel.mjs");
/* harmony import */ var _scx_attrname_dtel_mjs__WEBPACK_IMPORTED_MODULE_371__ = __webpack_require__(/*! ./scx_attrname.dtel.mjs */ "./output/scx_attrname.dtel.mjs");
/* harmony import */ var _scx_t100key_tabl_mjs__WEBPACK_IMPORTED_MODULE_372__ = __webpack_require__(/*! ./scx_t100key.tabl.mjs */ "./output/scx_t100key.tabl.mjs");
/* harmony import */ var _sdok_class_dtel_mjs__WEBPACK_IMPORTED_MODULE_373__ = __webpack_require__(/*! ./sdok_class.dtel.mjs */ "./output/sdok_class.dtel.mjs");
/* harmony import */ var _sdok_docid_dtel_mjs__WEBPACK_IMPORTED_MODULE_374__ = __webpack_require__(/*! ./sdok_docid.dtel.mjs */ "./output/sdok_docid.dtel.mjs");
/* harmony import */ var _sdokobject_tabl_mjs__WEBPACK_IMPORTED_MODULE_375__ = __webpack_require__(/*! ./sdokobject.tabl.mjs */ "./output/sdokobject.tabl.mjs");
/* harmony import */ var _seoclsname_dtel_mjs__WEBPACK_IMPORTED_MODULE_376__ = __webpack_require__(/*! ./seoclsname.dtel.mjs */ "./output/seoclsname.dtel.mjs");
/* harmony import */ var _shm_affect_server_dtel_mjs__WEBPACK_IMPORTED_MODULE_377__ = __webpack_require__(/*! ./shm_affect_server.dtel.mjs */ "./output/shm_affect_server.dtel.mjs");
/* harmony import */ var _shm_area_name_dtel_mjs__WEBPACK_IMPORTED_MODULE_378__ = __webpack_require__(/*! ./shm_area_name.dtel.mjs */ "./output/shm_area_name.dtel.mjs");
/* harmony import */ var _shm_attach_mode_dtel_mjs__WEBPACK_IMPORTED_MODULE_379__ = __webpack_require__(/*! ./shm_attach_mode.dtel.mjs */ "./output/shm_attach_mode.dtel.mjs");
/* harmony import */ var _shm_auto_build_class_name_dtel_mjs__WEBPACK_IMPORTED_MODULE_380__ = __webpack_require__(/*! ./shm_auto_build_class_name.dtel.mjs */ "./output/shm_auto_build_class_name.dtel.mjs");
/* harmony import */ var _shm_client_dtel_mjs__WEBPACK_IMPORTED_MODULE_381__ = __webpack_require__(/*! ./shm_client.dtel.mjs */ "./output/shm_client.dtel.mjs");
/* harmony import */ var _shm_constr_invocation_mode_dtel_mjs__WEBPACK_IMPORTED_MODULE_382__ = __webpack_require__(/*! ./shm_constr_invocation_mode.dtel.mjs */ "./output/shm_constr_invocation_mode.dtel.mjs");
/* harmony import */ var _shm_inst_info_tabl_mjs__WEBPACK_IMPORTED_MODULE_383__ = __webpack_require__(/*! ./shm_inst_info.tabl.mjs */ "./output/shm_inst_info.tabl.mjs");
/* harmony import */ var _shm_inst_infos_ttyp_mjs__WEBPACK_IMPORTED_MODULE_384__ = __webpack_require__(/*! ./shm_inst_infos.ttyp.mjs */ "./output/shm_inst_infos.ttyp.mjs");
/* harmony import */ var _shm_inst_name_dtel_mjs__WEBPACK_IMPORTED_MODULE_385__ = __webpack_require__(/*! ./shm_inst_name.dtel.mjs */ "./output/shm_inst_name.dtel.mjs");
/* harmony import */ var _shm_life_context_dtel_mjs__WEBPACK_IMPORTED_MODULE_386__ = __webpack_require__(/*! ./shm_life_context.dtel.mjs */ "./output/shm_life_context.dtel.mjs");
/* harmony import */ var _shm_properties_tabl_mjs__WEBPACK_IMPORTED_MODULE_387__ = __webpack_require__(/*! ./shm_properties.tabl.mjs */ "./output/shm_properties.tabl.mjs");
/* harmony import */ var _shm_rc_dtel_mjs__WEBPACK_IMPORTED_MODULE_388__ = __webpack_require__(/*! ./shm_rc.dtel.mjs */ "./output/shm_rc.dtel.mjs");
/* harmony import */ var _shma_attributes_tabl_mjs__WEBPACK_IMPORTED_MODULE_389__ = __webpack_require__(/*! ./shma_attributes.tabl.mjs */ "./output/shma_attributes.tabl.mjs");
/* harmony import */ var _shma_client_dtel_mjs__WEBPACK_IMPORTED_MODULE_390__ = __webpack_require__(/*! ./shma_client.dtel.mjs */ "./output/shma_client.dtel.mjs");
/* harmony import */ var _shmm_trc_variant_name_dtel_mjs__WEBPACK_IMPORTED_MODULE_391__ = __webpack_require__(/*! ./shmm_trc_variant_name.dtel.mjs */ "./output/shmm_trc_variant_name.dtel.mjs");
/* harmony import */ var _skwf_io_tabl_mjs__WEBPACK_IMPORTED_MODULE_392__ = __webpack_require__(/*! ./skwf_io.tabl.mjs */ "./output/skwf_io.tabl.mjs");
/* harmony import */ var _skwf_ioty_dtel_mjs__WEBPACK_IMPORTED_MODULE_393__ = __webpack_require__(/*! ./skwf_ioty.dtel.mjs */ "./output/skwf_ioty.dtel.mjs");
/* harmony import */ var _so_raw255_dtel_mjs__WEBPACK_IMPORTED_MODULE_394__ = __webpack_require__(/*! ./so_raw255.dtel.mjs */ "./output/so_raw255.dtel.mjs");
/* harmony import */ var _so_text255_dtel_mjs__WEBPACK_IMPORTED_MODULE_395__ = __webpack_require__(/*! ./so_text255.dtel.mjs */ "./output/so_text255.dtel.mjs");
/* harmony import */ var _soli_tabl_mjs__WEBPACK_IMPORTED_MODULE_396__ = __webpack_require__(/*! ./soli.tabl.mjs */ "./output/soli.tabl.mjs");
/* harmony import */ var _soli_tab_ttyp_mjs__WEBPACK_IMPORTED_MODULE_397__ = __webpack_require__(/*! ./soli_tab.ttyp.mjs */ "./output/soli_tab.ttyp.mjs");
/* harmony import */ var _solix_tabl_mjs__WEBPACK_IMPORTED_MODULE_398__ = __webpack_require__(/*! ./solix.tabl.mjs */ "./output/solix.tabl.mjs");
/* harmony import */ var _solix_tab_ttyp_mjs__WEBPACK_IMPORTED_MODULE_399__ = __webpack_require__(/*! ./solix_tab.ttyp.mjs */ "./output/solix_tab.ttyp.mjs");
/* harmony import */ var _sotr_conc_dtel_mjs__WEBPACK_IMPORTED_MODULE_400__ = __webpack_require__(/*! ./sotr_conc.dtel.mjs */ "./output/sotr_conc.dtel.mjs");
/* harmony import */ var _spras_dtel_mjs__WEBPACK_IMPORTED_MODULE_401__ = __webpack_require__(/*! ./spras.dtel.mjs */ "./output/spras.dtel.mjs");
/* harmony import */ var _ssfapplssl_dtel_mjs__WEBPACK_IMPORTED_MODULE_402__ = __webpack_require__(/*! ./ssfapplssl.dtel.mjs */ "./output/ssfapplssl.dtel.mjs");
/* harmony import */ var _sstmnt_tabl_mjs__WEBPACK_IMPORTED_MODULE_403__ = __webpack_require__(/*! ./sstmnt.tabl.mjs */ "./output/sstmnt.tabl.mjs");
/* harmony import */ var _sstmnt_tab_ttyp_mjs__WEBPACK_IMPORTED_MODULE_404__ = __webpack_require__(/*! ./sstmnt_tab.ttyp.mjs */ "./output/sstmnt_tab.ttyp.mjs");
/* harmony import */ var _sstruc_tabl_mjs__WEBPACK_IMPORTED_MODULE_405__ = __webpack_require__(/*! ./sstruc.tabl.mjs */ "./output/sstruc.tabl.mjs");
/* harmony import */ var _sstruc_tab_ttyp_mjs__WEBPACK_IMPORTED_MODULE_406__ = __webpack_require__(/*! ./sstruc_tab.ttyp.mjs */ "./output/sstruc_tab.ttyp.mjs");
/* harmony import */ var _stokes_tabl_mjs__WEBPACK_IMPORTED_MODULE_407__ = __webpack_require__(/*! ./stokes.tabl.mjs */ "./output/stokes.tabl.mjs");
/* harmony import */ var _stokes_tab_ttyp_mjs__WEBPACK_IMPORTED_MODULE_408__ = __webpack_require__(/*! ./stokes_tab.ttyp.mjs */ "./output/stokes_tab.ttyp.mjs");
/* harmony import */ var _stokesx_tabl_mjs__WEBPACK_IMPORTED_MODULE_409__ = __webpack_require__(/*! ./stokesx.tabl.mjs */ "./output/stokesx.tabl.mjs");
/* harmony import */ var _string_table_ttyp_mjs__WEBPACK_IMPORTED_MODULE_410__ = __webpack_require__(/*! ./string_table.ttyp.mjs */ "./output/string_table.ttyp.mjs");
/* harmony import */ var _stringtab_ttyp_mjs__WEBPACK_IMPORTED_MODULE_411__ = __webpack_require__(/*! ./stringtab.ttyp.mjs */ "./output/stringtab.ttyp.mjs");
/* harmony import */ var _submatch_result_tabl_mjs__WEBPACK_IMPORTED_MODULE_412__ = __webpack_require__(/*! ./submatch_result.tabl.mjs */ "./output/submatch_result.tabl.mjs");
/* harmony import */ var _submatch_result_tab_ttyp_mjs__WEBPACK_IMPORTED_MODULE_413__ = __webpack_require__(/*! ./submatch_result_tab.ttyp.mjs */ "./output/submatch_result_tab.ttyp.mjs");
/* harmony import */ var _sxco_fm_name_dtel_mjs__WEBPACK_IMPORTED_MODULE_414__ = __webpack_require__(/*! ./sxco_fm_name.dtel.mjs */ "./output/sxco_fm_name.dtel.mjs");
/* harmony import */ var _sxco_transport_dtel_mjs__WEBPACK_IMPORTED_MODULE_415__ = __webpack_require__(/*! ./sxco_transport.dtel.mjs */ "./output/sxco_transport.dtel.mjs");
/* harmony import */ var _sydate_dtel_mjs__WEBPACK_IMPORTED_MODULE_416__ = __webpack_require__(/*! ./sydate.dtel.mjs */ "./output/sydate.dtel.mjs");
/* harmony import */ var _symsg_tabl_mjs__WEBPACK_IMPORTED_MODULE_417__ = __webpack_require__(/*! ./symsg.tabl.mjs */ "./output/symsg.tabl.mjs");
/* harmony import */ var _symsgid_dtel_mjs__WEBPACK_IMPORTED_MODULE_418__ = __webpack_require__(/*! ./symsgid.dtel.mjs */ "./output/symsgid.dtel.mjs");
/* harmony import */ var _symsgno_dtel_mjs__WEBPACK_IMPORTED_MODULE_419__ = __webpack_require__(/*! ./symsgno.dtel.mjs */ "./output/symsgno.dtel.mjs");
/* harmony import */ var _symsgty_dtel_mjs__WEBPACK_IMPORTED_MODULE_420__ = __webpack_require__(/*! ./symsgty.dtel.mjs */ "./output/symsgty.dtel.mjs");
/* harmony import */ var _symsgv_dtel_mjs__WEBPACK_IMPORTED_MODULE_421__ = __webpack_require__(/*! ./symsgv.dtel.mjs */ "./output/symsgv.dtel.mjs");
/* harmony import */ var _syrepid_dtel_mjs__WEBPACK_IMPORTED_MODULE_422__ = __webpack_require__(/*! ./syrepid.dtel.mjs */ "./output/syrepid.dtel.mjs");
/* harmony import */ var _syst_host_dtel_mjs__WEBPACK_IMPORTED_MODULE_423__ = __webpack_require__(/*! ./syst_host.dtel.mjs */ "./output/syst_host.dtel.mjs");
/* harmony import */ var _sysubrc_dtel_mjs__WEBPACK_IMPORTED_MODULE_424__ = __webpack_require__(/*! ./sysubrc.dtel.mjs */ "./output/sysubrc.dtel.mjs");
/* harmony import */ var _sysuuid_c22_dtel_mjs__WEBPACK_IMPORTED_MODULE_425__ = __webpack_require__(/*! ./sysuuid_c22.dtel.mjs */ "./output/sysuuid_c22.dtel.mjs");
/* harmony import */ var _sysuuid_c32_dtel_mjs__WEBPACK_IMPORTED_MODULE_426__ = __webpack_require__(/*! ./sysuuid_c32.dtel.mjs */ "./output/sysuuid_c32.dtel.mjs");
/* harmony import */ var _sysuuid_c36_dtel_mjs__WEBPACK_IMPORTED_MODULE_427__ = __webpack_require__(/*! ./sysuuid_c36.dtel.mjs */ "./output/sysuuid_c36.dtel.mjs");
/* harmony import */ var _sysuuid_x16_dtel_mjs__WEBPACK_IMPORTED_MODULE_428__ = __webpack_require__(/*! ./sysuuid_x16.dtel.mjs */ "./output/sysuuid_x16.dtel.mjs");
/* harmony import */ var _syuname_dtel_mjs__WEBPACK_IMPORTED_MODULE_429__ = __webpack_require__(/*! ./syuname.dtel.mjs */ "./output/syuname.dtel.mjs");
/* harmony import */ var _t000_tabl_mjs__WEBPACK_IMPORTED_MODULE_430__ = __webpack_require__(/*! ./t000.tabl.mjs */ "./output/t000.tabl.mjs");
/* harmony import */ var _t100_tabl_mjs__WEBPACK_IMPORTED_MODULE_431__ = __webpack_require__(/*! ./t100.tabl.mjs */ "./output/t100.tabl.mjs");
/* harmony import */ var _tabfdpos_dtel_mjs__WEBPACK_IMPORTED_MODULE_432__ = __webpack_require__(/*! ./tabfdpos.dtel.mjs */ "./output/tabfdpos.dtel.mjs");
/* harmony import */ var _tabname_dtel_mjs__WEBPACK_IMPORTED_MODULE_433__ = __webpack_require__(/*! ./tabname.dtel.mjs */ "./output/tabname.dtel.mjs");
/* harmony import */ var _tadir_tabl_mjs__WEBPACK_IMPORTED_MODULE_434__ = __webpack_require__(/*! ./tadir.tabl.mjs */ "./output/tadir.tabl.mjs");
/* harmony import */ var _tdevc_tabl_mjs__WEBPACK_IMPORTED_MODULE_435__ = __webpack_require__(/*! ./tdevc.tabl.mjs */ "./output/tdevc.tabl.mjs");
/* harmony import */ var _tdline_dtel_mjs__WEBPACK_IMPORTED_MODULE_436__ = __webpack_require__(/*! ./tdline.dtel.mjs */ "./output/tdline.dtel.mjs");
/* harmony import */ var _text20_dtel_mjs__WEBPACK_IMPORTED_MODULE_437__ = __webpack_require__(/*! ./text20.dtel.mjs */ "./output/text20.dtel.mjs");
/* harmony import */ var _text200_dtel_mjs__WEBPACK_IMPORTED_MODULE_438__ = __webpack_require__(/*! ./text200.dtel.mjs */ "./output/text200.dtel.mjs");
/* harmony import */ var _text255_dtel_mjs__WEBPACK_IMPORTED_MODULE_439__ = __webpack_require__(/*! ./text255.dtel.mjs */ "./output/text255.dtel.mjs");
/* harmony import */ var _text30_dtel_mjs__WEBPACK_IMPORTED_MODULE_440__ = __webpack_require__(/*! ./text30.dtel.mjs */ "./output/text30.dtel.mjs");
/* harmony import */ var _text80_dtel_mjs__WEBPACK_IMPORTED_MODULE_441__ = __webpack_require__(/*! ./text80.dtel.mjs */ "./output/text80.dtel.mjs");
/* harmony import */ var _textpool_tabl_mjs__WEBPACK_IMPORTED_MODULE_442__ = __webpack_require__(/*! ./textpool.tabl.mjs */ "./output/textpool.tabl.mjs");
/* harmony import */ var _tfdir_tabl_mjs__WEBPACK_IMPORTED_MODULE_443__ = __webpack_require__(/*! ./tfdir.tabl.mjs */ "./output/tfdir.tabl.mjs");
/* harmony import */ var _tihttpnvp_ttyp_mjs__WEBPACK_IMPORTED_MODULE_444__ = __webpack_require__(/*! ./tihttpnvp.ttyp.mjs */ "./output/tihttpnvp.ttyp.mjs");
/* harmony import */ var _timestamp_dtel_mjs__WEBPACK_IMPORTED_MODULE_445__ = __webpack_require__(/*! ./timestamp.dtel.mjs */ "./output/timestamp.dtel.mjs");
/* harmony import */ var _timestampl_dtel_mjs__WEBPACK_IMPORTED_MODULE_446__ = __webpack_require__(/*! ./timestampl.dtel.mjs */ "./output/timestampl.dtel.mjs");
/* harmony import */ var _timezone_dtel_mjs__WEBPACK_IMPORTED_MODULE_447__ = __webpack_require__(/*! ./timezone.dtel.mjs */ "./output/timezone.dtel.mjs");
/* harmony import */ var _timn_dtel_mjs__WEBPACK_IMPORTED_MODULE_448__ = __webpack_require__(/*! ./timn.dtel.mjs */ "./output/timn.dtel.mjs");
/* harmony import */ var _tline_tabl_mjs__WEBPACK_IMPORTED_MODULE_449__ = __webpack_require__(/*! ./tline.tabl.mjs */ "./output/tline.tabl.mjs");
/* harmony import */ var _tline_tab_ttyp_mjs__WEBPACK_IMPORTED_MODULE_450__ = __webpack_require__(/*! ./tline_tab.ttyp.mjs */ "./output/tline_tab.ttyp.mjs");
/* harmony import */ var _trfunction_dtel_mjs__WEBPACK_IMPORTED_MODULE_451__ = __webpack_require__(/*! ./trfunction.dtel.mjs */ "./output/trfunction.dtel.mjs");
/* harmony import */ var _trkorr_dtel_mjs__WEBPACK_IMPORTED_MODULE_452__ = __webpack_require__(/*! ./trkorr.dtel.mjs */ "./output/trkorr.dtel.mjs");
/* harmony import */ var _tzntstmpl_dtel_mjs__WEBPACK_IMPORTED_MODULE_453__ = __webpack_require__(/*! ./tzntstmpl.dtel.mjs */ "./output/tzntstmpl.dtel.mjs");
/* harmony import */ var _tzntstmps_dtel_mjs__WEBPACK_IMPORTED_MODULE_454__ = __webpack_require__(/*! ./tzntstmps.dtel.mjs */ "./output/tzntstmps.dtel.mjs");
/* harmony import */ var _uname_dtel_mjs__WEBPACK_IMPORTED_MODULE_455__ = __webpack_require__(/*! ./uname.dtel.mjs */ "./output/uname.dtel.mjs");
/* harmony import */ var _usnam_dtel_mjs__WEBPACK_IMPORTED_MODULE_456__ = __webpack_require__(/*! ./usnam.dtel.mjs */ "./output/usnam.dtel.mjs");
/* harmony import */ var _w3mime_tabl_mjs__WEBPACK_IMPORTED_MODULE_457__ = __webpack_require__(/*! ./w3mime.tabl.mjs */ "./output/w3mime.tabl.mjs");
/* harmony import */ var _waers_dtel_mjs__WEBPACK_IMPORTED_MODULE_458__ = __webpack_require__(/*! ./waers.dtel.mjs */ "./output/waers.dtel.mjs");
/* harmony import */ var _waers_curc_dtel_mjs__WEBPACK_IMPORTED_MODULE_459__ = __webpack_require__(/*! ./waers_curc.dtel.mjs */ "./output/waers_curc.dtel.mjs");
/* harmony import */ var _wwwdatatab_tabl_mjs__WEBPACK_IMPORTED_MODULE_460__ = __webpack_require__(/*! ./wwwdatatab.tabl.mjs */ "./output/wwwdatatab.tabl.mjs");
/* harmony import */ var _wwwparams_tabl_mjs__WEBPACK_IMPORTED_MODULE_461__ = __webpack_require__(/*! ./wwwparams.tabl.mjs */ "./output/wwwparams.tabl.mjs");
/* harmony import */ var _xfeld_dtel_mjs__WEBPACK_IMPORTED_MODULE_462__ = __webpack_require__(/*! ./xfeld.dtel.mjs */ "./output/xfeld.dtel.mjs");
/* harmony import */ var _xsdboolean_dtel_mjs__WEBPACK_IMPORTED_MODULE_463__ = __webpack_require__(/*! ./xsdboolean.dtel.mjs */ "./output/xsdboolean.dtel.mjs");
/* harmony import */ var _xsddatetime_z_dtel_mjs__WEBPACK_IMPORTED_MODULE_464__ = __webpack_require__(/*! ./xsddatetime_z.dtel.mjs */ "./output/xsddatetime_z.dtel.mjs");
/* harmony import */ var _xsdtime_t_dtel_mjs__WEBPACK_IMPORTED_MODULE_465__ = __webpack_require__(/*! ./xsdtime_t.dtel.mjs */ "./output/xsdtime_t.dtel.mjs");
/* harmony import */ var _zcl_http_handler_clas_mjs__WEBPACK_IMPORTED_MODULE_466__ = __webpack_require__(/*! ./zcl_http_handler.clas.mjs */ "./output/zcl_http_handler.clas.mjs");
/* harmony import */ var _zcl_otm_table_maintenance_clas_mjs__WEBPACK_IMPORTED_MODULE_467__ = __webpack_require__(/*! ./zcl_otm_table_maintenance.clas.mjs */ "./output/zcl_otm_table_maintenance.clas.mjs");
/* harmony import */ var _zopentest_tabl_mjs__WEBPACK_IMPORTED_MODULE_468__ = __webpack_require__(/*! ./zopentest.tabl.mjs */ "./output/zopentest.tabl.mjs");
/* harmony import */ var _zw3mi_fugr_wwwdata_export_mjs__WEBPACK_IMPORTED_MODULE_469__ = __webpack_require__(/*! ./zw3mi.fugr.wwwdata_export.mjs */ "./output/zw3mi.fugr.wwwdata_export.mjs");
/* harmony import */ var _zw3mi_fugr_wwwdata_import_mjs__WEBPACK_IMPORTED_MODULE_470__ = __webpack_require__(/*! ./zw3mi.fugr.wwwdata_import.mjs */ "./output/zw3mi.fugr.wwwdata_import.mjs");
/* harmony import */ var _zw3mi_fugr_wwwparams_insert_mjs__WEBPACK_IMPORTED_MODULE_471__ = __webpack_require__(/*! ./zw3mi.fugr.wwwparams_insert.mjs */ "./output/zw3mi.fugr.wwwparams_insert.mjs");
/* harmony import */ var _zw3mi_fugr_wwwparams_read_mjs__WEBPACK_IMPORTED_MODULE_472__ = __webpack_require__(/*! ./zw3mi.fugr.wwwparams_read.mjs */ "./output/zw3mi.fugr.wwwparams_read.mjs");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_cl_abap_char_utilities_clas_mjs__WEBPACK_IMPORTED_MODULE_42__, _cl_abap_classdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_43__, _cl_abap_codepage_clas_mjs__WEBPACK_IMPORTED_MODULE_44__, _cl_abap_complexdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_45__, _cl_abap_conv_codepage_clas_mjs__WEBPACK_IMPORTED_MODULE_46__, _cl_abap_conv_in_ce_clas_mjs__WEBPACK_IMPORTED_MODULE_47__, _cl_abap_conv_out_ce_clas_mjs__WEBPACK_IMPORTED_MODULE_48__, _cl_abap_datadescr_clas_mjs__WEBPACK_IMPORTED_MODULE_49__, _cl_abap_datfm_clas_mjs__WEBPACK_IMPORTED_MODULE_50__, _cl_abap_dyn_prg_clas_mjs__WEBPACK_IMPORTED_MODULE_51__, _cl_abap_elemdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_52__, _cl_abap_enumdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_53__, _cl_abap_exceptional_values_clas_mjs__WEBPACK_IMPORTED_MODULE_54__, _cl_abap_format_clas_mjs__WEBPACK_IMPORTED_MODULE_55__, _cl_abap_gzip_clas_mjs__WEBPACK_IMPORTED_MODULE_56__, _cl_abap_hmac_clas_mjs__WEBPACK_IMPORTED_MODULE_57__, _cl_abap_intfdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_58__, _cl_abap_matcher_clas_mjs__WEBPACK_IMPORTED_MODULE_59__, _cl_abap_math_clas_mjs__WEBPACK_IMPORTED_MODULE_60__, _cl_abap_message_digest_clas_mjs__WEBPACK_IMPORTED_MODULE_61__, _cl_abap_objectdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_62__, _cl_abap_random_clas_mjs__WEBPACK_IMPORTED_MODULE_63__, _cl_abap_random_int_clas_mjs__WEBPACK_IMPORTED_MODULE_64__, _cl_abap_refdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_65__, _cl_abap_regex_clas_mjs__WEBPACK_IMPORTED_MODULE_66__, _cl_abap_structdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_67__, _cl_abap_tabledescr_clas_mjs__WEBPACK_IMPORTED_MODULE_68__, _cl_abap_timefm_clas_mjs__WEBPACK_IMPORTED_MODULE_69__, _cl_abap_tstmp_clas_mjs__WEBPACK_IMPORTED_MODULE_70__, _cl_abap_typedescr_clas_mjs__WEBPACK_IMPORTED_MODULE_71__, _cl_abap_unit_assert_clas_mjs__WEBPACK_IMPORTED_MODULE_72__, _cl_abap_weak_reference_clas_mjs__WEBPACK_IMPORTED_MODULE_73__, _cl_abap_zip_clas_mjs__WEBPACK_IMPORTED_MODULE_74__, _cl_apc_tcp_client_manager_clas_mjs__WEBPACK_IMPORTED_MODULE_75__, _cl_apc_wsp_ext_stateless_base_clas_mjs__WEBPACK_IMPORTED_MODULE_76__, _cl_bcs_clas_mjs__WEBPACK_IMPORTED_MODULE_77__, _cl_bcs_convert_clas_mjs__WEBPACK_IMPORTED_MODULE_78__, _cl_cam_address_bcs_clas_mjs__WEBPACK_IMPORTED_MODULE_79__, _cl_demo_output_clas_mjs__WEBPACK_IMPORTED_MODULE_80__, _cl_document_bcs_clas_mjs__WEBPACK_IMPORTED_MODULE_81__, _cl_express_icf_shim_clas_mjs__WEBPACK_IMPORTED_MODULE_82__, _cl_function_test_environment_clas_mjs__WEBPACK_IMPORTED_MODULE_83__, _cl_gdt_conversion_clas_mjs__WEBPACK_IMPORTED_MODULE_84__, _cl_gui_cfw_clas_mjs__WEBPACK_IMPORTED_MODULE_85__, _cl_gui_container_clas_mjs__WEBPACK_IMPORTED_MODULE_86__, _cl_gui_frontend_services_clas_mjs__WEBPACK_IMPORTED_MODULE_87__, _cl_http_client_clas_mjs__WEBPACK_IMPORTED_MODULE_88__, _cl_http_entity_clas_mjs__WEBPACK_IMPORTED_MODULE_89__, _cl_http_server_clas_mjs__WEBPACK_IMPORTED_MODULE_90__, _cl_http_utility_clas_mjs__WEBPACK_IMPORTED_MODULE_91__, _cl_i18n_languages_clas_mjs__WEBPACK_IMPORTED_MODULE_92__, _cl_icf_tree_clas_mjs__WEBPACK_IMPORTED_MODULE_93__, _cl_ixml_clas_mjs__WEBPACK_IMPORTED_MODULE_94__, _cl_message_helper_clas_mjs__WEBPACK_IMPORTED_MODULE_95__, _cl_mime_repository_api_clas_mjs__WEBPACK_IMPORTED_MODULE_96__, _cl_numberrange_runtime_clas_mjs__WEBPACK_IMPORTED_MODULE_97__, _cl_oauth2_client_clas_mjs__WEBPACK_IMPORTED_MODULE_98__, _cl_oo_factory_clas_mjs__WEBPACK_IMPORTED_MODULE_99__, _cl_osql_test_environment_clas_mjs__WEBPACK_IMPORTED_MODULE_100__, _cl_progress_indicator_clas_mjs__WEBPACK_IMPORTED_MODULE_101__, _cl_salv_aggregations_clas_mjs__WEBPACK_IMPORTED_MODULE_102__, _cl_salv_column_clas_mjs__WEBPACK_IMPORTED_MODULE_103__, _cl_salv_columns_table_clas_mjs__WEBPACK_IMPORTED_MODULE_104__, _cl_salv_events_table_clas_mjs__WEBPACK_IMPORTED_MODULE_105__, _cl_salv_filters_clas_mjs__WEBPACK_IMPORTED_MODULE_106__, _cl_salv_functional_settings_clas_mjs__WEBPACK_IMPORTED_MODULE_107__, _cl_salv_functions_list_clas_mjs__WEBPACK_IMPORTED_MODULE_108__, _cl_salv_hyperlinks_clas_mjs__WEBPACK_IMPORTED_MODULE_109__, _cl_salv_layout_clas_mjs__WEBPACK_IMPORTED_MODULE_110__, _cl_salv_sorts_clas_mjs__WEBPACK_IMPORTED_MODULE_111__, _cl_salv_table_clas_mjs__WEBPACK_IMPORTED_MODULE_112__, _cl_shm_area_clas_mjs__WEBPACK_IMPORTED_MODULE_113__, _cl_shm_service_clas_mjs__WEBPACK_IMPORTED_MODULE_114__, _cl_sql_result_set_clas_mjs__WEBPACK_IMPORTED_MODULE_115__, _cl_sql_statement_clas_mjs__WEBPACK_IMPORTED_MODULE_116__, _cl_sxml_string_reader_clas_mjs__WEBPACK_IMPORTED_MODULE_117__, _cl_sxml_string_writer_clas_mjs__WEBPACK_IMPORTED_MODULE_118__, _cl_system_uuid_clas_mjs__WEBPACK_IMPORTED_MODULE_119__, _cl_web_http_utility_clas_mjs__WEBPACK_IMPORTED_MODULE_120__, _cx_abap_datfm_clas_mjs__WEBPACK_IMPORTED_MODULE_121__, _cx_abap_message_digest_clas_mjs__WEBPACK_IMPORTED_MODULE_122__, _cx_abap_not_a_table_clas_mjs__WEBPACK_IMPORTED_MODULE_123__, _cx_abap_not_in_package_clas_mjs__WEBPACK_IMPORTED_MODULE_124__, _cx_abap_not_in_whitelist_clas_mjs__WEBPACK_IMPORTED_MODULE_125__, _cx_abap_random_clas_mjs__WEBPACK_IMPORTED_MODULE_126__, _cx_abap_timefm_invalid_clas_mjs__WEBPACK_IMPORTED_MODULE_127__, _cx_apc_error_clas_mjs__WEBPACK_IMPORTED_MODULE_128__, _cx_bcs_clas_mjs__WEBPACK_IMPORTED_MODULE_129__, _cx_dynamic_check_clas_mjs__WEBPACK_IMPORTED_MODULE_130__, _cx_ftd_parameter_not_found_clas_mjs__WEBPACK_IMPORTED_MODULE_131__, _cx_gdt_conversion_clas_mjs__WEBPACK_IMPORTED_MODULE_132__, _cx_no_check_clas_mjs__WEBPACK_IMPORTED_MODULE_133__, _cx_oo_clif_not_exists_clas_mjs__WEBPACK_IMPORTED_MODULE_134__, _cx_parameter_invalid_clas_mjs__WEBPACK_IMPORTED_MODULE_135__, _cx_parameter_invalid_range_clas_mjs__WEBPACK_IMPORTED_MODULE_136__, _cx_parameter_invalid_type_clas_mjs__WEBPACK_IMPORTED_MODULE_137__, _cx_salv_access_error_clas_mjs__WEBPACK_IMPORTED_MODULE_139__, _cx_salv_data_error_clas_mjs__WEBPACK_IMPORTED_MODULE_140__, _cx_salv_error_clas_mjs__WEBPACK_IMPORTED_MODULE_141__, _cx_salv_existing_clas_mjs__WEBPACK_IMPORTED_MODULE_142__, _cx_salv_msg_clas_mjs__WEBPACK_IMPORTED_MODULE_143__, _cx_salv_not_found_clas_mjs__WEBPACK_IMPORTED_MODULE_144__, _cx_salv_static_check_clas_mjs__WEBPACK_IMPORTED_MODULE_145__, _cx_shm_already_detached_clas_mjs__WEBPACK_IMPORTED_MODULE_146__, _cx_shm_attach_error_clas_mjs__WEBPACK_IMPORTED_MODULE_147__, _cx_shm_build_failed_clas_mjs__WEBPACK_IMPORTED_MODULE_148__, _cx_shm_change_lock_active_clas_mjs__WEBPACK_IMPORTED_MODULE_149__, _cx_shm_completion_error_clas_mjs__WEBPACK_IMPORTED_MODULE_150__, _cx_shm_detach_error_clas_mjs__WEBPACK_IMPORTED_MODULE_151__, _cx_shm_error_clas_mjs__WEBPACK_IMPORTED_MODULE_152__, _cx_shm_event_execution_failed_clas_mjs__WEBPACK_IMPORTED_MODULE_153__, _cx_shm_exclusive_lock_active_clas_mjs__WEBPACK_IMPORTED_MODULE_154__, _cx_shm_general_error_clas_mjs__WEBPACK_IMPORTED_MODULE_155__, _cx_shm_inconsistent_clas_mjs__WEBPACK_IMPORTED_MODULE_156__, _cx_shm_initial_reference_clas_mjs__WEBPACK_IMPORTED_MODULE_157__, _cx_shm_no_active_version_clas_mjs__WEBPACK_IMPORTED_MODULE_158__, _cx_shm_parameter_error_clas_mjs__WEBPACK_IMPORTED_MODULE_159__, _cx_shm_pending_lock_removed_clas_mjs__WEBPACK_IMPORTED_MODULE_160__, _cx_shm_read_lock_active_clas_mjs__WEBPACK_IMPORTED_MODULE_161__, _cx_shm_secondary_commit_clas_mjs__WEBPACK_IMPORTED_MODULE_162__, _cx_shm_version_limit_exceeded_clas_mjs__WEBPACK_IMPORTED_MODULE_163__, _cx_shm_wrong_handle_clas_mjs__WEBPACK_IMPORTED_MODULE_164__, _cx_shma_dynamic_clas_mjs__WEBPACK_IMPORTED_MODULE_165__, _cx_shma_inconsistent_clas_mjs__WEBPACK_IMPORTED_MODULE_166__, _cx_shma_not_configured_clas_mjs__WEBPACK_IMPORTED_MODULE_167__, _cx_sql_exception_clas_mjs__WEBPACK_IMPORTED_MODULE_168__, _cx_st_error_clas_mjs__WEBPACK_IMPORTED_MODULE_169__, _cx_static_check_clas_mjs__WEBPACK_IMPORTED_MODULE_170__, _cx_sxml_error_clas_mjs__WEBPACK_IMPORTED_MODULE_171__, _cx_sxml_illegal_argument_error_clas_mjs__WEBPACK_IMPORTED_MODULE_172__, _cx_sxml_name_error_clas_mjs__WEBPACK_IMPORTED_MODULE_173__, _cx_sxml_parse_error_clas_mjs__WEBPACK_IMPORTED_MODULE_174__, _cx_sxml_state_error_clas_mjs__WEBPACK_IMPORTED_MODULE_175__, _cx_sy_arithmetic_error_clas_mjs__WEBPACK_IMPORTED_MODULE_176__, _cx_sy_arithmetic_overflow_clas_mjs__WEBPACK_IMPORTED_MODULE_177__, _cx_sy_buffer_overflow_clas_mjs__WEBPACK_IMPORTED_MODULE_178__, _cx_sy_codepage_converter_init_clas_mjs__WEBPACK_IMPORTED_MODULE_179__, _cx_sy_compression_error_clas_mjs__WEBPACK_IMPORTED_MODULE_180__, _cx_sy_conversion_codepage_clas_mjs__WEBPACK_IMPORTED_MODULE_181__, _cx_sy_conversion_data_loss_clas_mjs__WEBPACK_IMPORTED_MODULE_182__, _cx_sy_conversion_error_clas_mjs__WEBPACK_IMPORTED_MODULE_183__, _cx_sy_conversion_no_number_clas_mjs__WEBPACK_IMPORTED_MODULE_184__, _cx_sy_conversion_overflow_clas_mjs__WEBPACK_IMPORTED_MODULE_185__, _cx_sy_create_data_error_clas_mjs__WEBPACK_IMPORTED_MODULE_186__, _cx_sy_create_object_error_clas_mjs__WEBPACK_IMPORTED_MODULE_187__, _cx_sy_data_access_error_clas_mjs__WEBPACK_IMPORTED_MODULE_188__, _cx_sy_duplicate_key_clas_mjs__WEBPACK_IMPORTED_MODULE_189__, _cx_sy_dyn_call_error_clas_mjs__WEBPACK_IMPORTED_MODULE_190__, _cx_sy_dyn_call_illegal_class_clas_mjs__WEBPACK_IMPORTED_MODULE_191__, _cx_sy_dyn_call_illegal_form_clas_mjs__WEBPACK_IMPORTED_MODULE_192__, _cx_sy_dyn_call_illegal_func_clas_mjs__WEBPACK_IMPORTED_MODULE_193__, _cx_sy_dyn_call_illegal_method_clas_mjs__WEBPACK_IMPORTED_MODULE_194__, _cx_sy_dyn_call_param_not_found_clas_mjs__WEBPACK_IMPORTED_MODULE_195__, _cx_sy_dyn_call_parameter_error_clas_mjs__WEBPACK_IMPORTED_MODULE_196__, _cx_sy_dynamic_osql_error_clas_mjs__WEBPACK_IMPORTED_MODULE_197__, _cx_sy_dynamic_osql_semantics_clas_mjs__WEBPACK_IMPORTED_MODULE_198__, _cx_sy_itab_duplicate_key_clas_mjs__WEBPACK_IMPORTED_MODULE_199__, _cx_sy_itab_error_clas_mjs__WEBPACK_IMPORTED_MODULE_200__, _cx_sy_itab_line_not_found_clas_mjs__WEBPACK_IMPORTED_MODULE_201__, _cx_sy_message_illegal_text_clas_mjs__WEBPACK_IMPORTED_MODULE_202__, _cx_sy_move_cast_error_clas_mjs__WEBPACK_IMPORTED_MODULE_203__, _cx_sy_open_sql_error_clas_mjs__WEBPACK_IMPORTED_MODULE_204__, _cx_sy_range_out_of_bounds_clas_mjs__WEBPACK_IMPORTED_MODULE_205__, _cx_sy_ref_is_initial_clas_mjs__WEBPACK_IMPORTED_MODULE_206__, _cx_sy_sql_error_clas_mjs__WEBPACK_IMPORTED_MODULE_207__, _cx_sy_strg_par_val_clas_mjs__WEBPACK_IMPORTED_MODULE_208__, _cx_sy_struct_attributes_clas_mjs__WEBPACK_IMPORTED_MODULE_209__, _cx_sy_struct_comp_name_clas_mjs__WEBPACK_IMPORTED_MODULE_210__, _cx_sy_struct_comp_type_clas_mjs__WEBPACK_IMPORTED_MODULE_211__, _cx_sy_struct_creation_clas_mjs__WEBPACK_IMPORTED_MODULE_212__, _cx_sy_type_creation_clas_mjs__WEBPACK_IMPORTED_MODULE_213__, _cx_sy_zerodivide_clas_mjs__WEBPACK_IMPORTED_MODULE_214__, _cx_transformation_error_clas_mjs__WEBPACK_IMPORTED_MODULE_215__, _cx_uuid_error_clas_mjs__WEBPACK_IMPORTED_MODULE_216__, _cx_xslt_exception_clas_mjs__WEBPACK_IMPORTED_MODULE_217__, _cx_xslt_format_error_clas_mjs__WEBPACK_IMPORTED_MODULE_218__, _cx_xslt_runtime_error_clas_mjs__WEBPACK_IMPORTED_MODULE_219__, _cx_xslt_serialization_error_clas_mjs__WEBPACK_IMPORTED_MODULE_220__, _cx_xslt_system_error_clas_mjs__WEBPACK_IMPORTED_MODULE_221__, _kernel_authority_check_clas_mjs__WEBPACK_IMPORTED_MODULE_324__, _kernel_call_clas_mjs__WEBPACK_IMPORTED_MODULE_325__, _kernel_call_transformation_clas_mjs__WEBPACK_IMPORTED_MODULE_326__, _kernel_create_data_handle_clas_mjs__WEBPACK_IMPORTED_MODULE_327__, _kernel_cx_assert_clas_mjs__WEBPACK_IMPORTED_MODULE_328__, _kernel_fugr_test_clas_mjs__WEBPACK_IMPORTED_MODULE_329__, _kernel_internal_name_clas_mjs__WEBPACK_IMPORTED_MODULE_330__, _kernel_ixml_json_to_data_clas_mjs__WEBPACK_IMPORTED_MODULE_331__, _kernel_ixml_xml_to_data_clas_mjs__WEBPACK_IMPORTED_MODULE_332__, _kernel_json_to_ixml_clas_mjs__WEBPACK_IMPORTED_MODULE_333__, _kernel_lock_clas_mjs__WEBPACK_IMPORTED_MODULE_334__, _kernel_numberrange_clas_mjs__WEBPACK_IMPORTED_MODULE_335__, _kernel_push_channels_clas_mjs__WEBPACK_IMPORTED_MODULE_336__, _kernel_scan_abap_source_clas_mjs__WEBPACK_IMPORTED_MODULE_337__, _kernel_unit_runner_clas_mjs__WEBPACK_IMPORTED_MODULE_338__, _number_get_next_fugr_number_get_next_mjs__WEBPACK_IMPORTED_MODULE_350__, _openabap_fugr_call_v1_ping_mjs__WEBPACK_IMPORTED_MODULE_352__, _openabap_fugr_conversion_exit_alpha_input_mjs__WEBPACK_IMPORTED_MODULE_353__, _openabap_fugr_conversion_exit_alpha_output_mjs__WEBPACK_IMPORTED_MODULE_354__, _openabap_fugr_conversion_exit_isola_input_mjs__WEBPACK_IMPORTED_MODULE_355__, _openabap_fugr_conversion_exit_isola_output_mjs__WEBPACK_IMPORTED_MODULE_356__, _openabap_fugr_convert_itf_to_stream_text_mjs__WEBPACK_IMPORTED_MODULE_357__, _openabap_fugr_docu_get_mjs__WEBPACK_IMPORTED_MODULE_358__, _openabap_fugr_function_exists_mjs__WEBPACK_IMPORTED_MODULE_359__, _openabap_fugr_generate_sec_random_mjs__WEBPACK_IMPORTED_MODULE_360__, _openabap_fugr_get_system_timezone_mjs__WEBPACK_IMPORTED_MODULE_361__, _openabap_fugr_system_callstack_mjs__WEBPACK_IMPORTED_MODULE_362__, _openabap_fugr_system_installed_languages_mjs__WEBPACK_IMPORTED_MODULE_363__, _openabap_fugr_text_split_mjs__WEBPACK_IMPORTED_MODULE_364__, _openabap_fugr_unit_conversion_simple_mjs__WEBPACK_IMPORTED_MODULE_365__, _zcl_http_handler_clas_mjs__WEBPACK_IMPORTED_MODULE_466__, _zcl_otm_table_maintenance_clas_mjs__WEBPACK_IMPORTED_MODULE_467__, _zw3mi_fugr_wwwdata_export_mjs__WEBPACK_IMPORTED_MODULE_469__, _zw3mi_fugr_wwwdata_import_mjs__WEBPACK_IMPORTED_MODULE_470__, _zw3mi_fugr_wwwparams_insert_mjs__WEBPACK_IMPORTED_MODULE_471__, _zw3mi_fugr_wwwparams_read_mjs__WEBPACK_IMPORTED_MODULE_472__]);
([_cl_abap_char_utilities_clas_mjs__WEBPACK_IMPORTED_MODULE_42__, _cl_abap_classdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_43__, _cl_abap_codepage_clas_mjs__WEBPACK_IMPORTED_MODULE_44__, _cl_abap_complexdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_45__, _cl_abap_conv_codepage_clas_mjs__WEBPACK_IMPORTED_MODULE_46__, _cl_abap_conv_in_ce_clas_mjs__WEBPACK_IMPORTED_MODULE_47__, _cl_abap_conv_out_ce_clas_mjs__WEBPACK_IMPORTED_MODULE_48__, _cl_abap_datadescr_clas_mjs__WEBPACK_IMPORTED_MODULE_49__, _cl_abap_datfm_clas_mjs__WEBPACK_IMPORTED_MODULE_50__, _cl_abap_dyn_prg_clas_mjs__WEBPACK_IMPORTED_MODULE_51__, _cl_abap_elemdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_52__, _cl_abap_enumdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_53__, _cl_abap_exceptional_values_clas_mjs__WEBPACK_IMPORTED_MODULE_54__, _cl_abap_format_clas_mjs__WEBPACK_IMPORTED_MODULE_55__, _cl_abap_gzip_clas_mjs__WEBPACK_IMPORTED_MODULE_56__, _cl_abap_hmac_clas_mjs__WEBPACK_IMPORTED_MODULE_57__, _cl_abap_intfdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_58__, _cl_abap_matcher_clas_mjs__WEBPACK_IMPORTED_MODULE_59__, _cl_abap_math_clas_mjs__WEBPACK_IMPORTED_MODULE_60__, _cl_abap_message_digest_clas_mjs__WEBPACK_IMPORTED_MODULE_61__, _cl_abap_objectdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_62__, _cl_abap_random_clas_mjs__WEBPACK_IMPORTED_MODULE_63__, _cl_abap_random_int_clas_mjs__WEBPACK_IMPORTED_MODULE_64__, _cl_abap_refdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_65__, _cl_abap_regex_clas_mjs__WEBPACK_IMPORTED_MODULE_66__, _cl_abap_structdescr_clas_mjs__WEBPACK_IMPORTED_MODULE_67__, _cl_abap_tabledescr_clas_mjs__WEBPACK_IMPORTED_MODULE_68__, _cl_abap_timefm_clas_mjs__WEBPACK_IMPORTED_MODULE_69__, _cl_abap_tstmp_clas_mjs__WEBPACK_IMPORTED_MODULE_70__, _cl_abap_typedescr_clas_mjs__WEBPACK_IMPORTED_MODULE_71__, _cl_abap_unit_assert_clas_mjs__WEBPACK_IMPORTED_MODULE_72__, _cl_abap_weak_reference_clas_mjs__WEBPACK_IMPORTED_MODULE_73__, _cl_abap_zip_clas_mjs__WEBPACK_IMPORTED_MODULE_74__, _cl_apc_tcp_client_manager_clas_mjs__WEBPACK_IMPORTED_MODULE_75__, _cl_apc_wsp_ext_stateless_base_clas_mjs__WEBPACK_IMPORTED_MODULE_76__, _cl_bcs_clas_mjs__WEBPACK_IMPORTED_MODULE_77__, _cl_bcs_convert_clas_mjs__WEBPACK_IMPORTED_MODULE_78__, _cl_cam_address_bcs_clas_mjs__WEBPACK_IMPORTED_MODULE_79__, _cl_demo_output_clas_mjs__WEBPACK_IMPORTED_MODULE_80__, _cl_document_bcs_clas_mjs__WEBPACK_IMPORTED_MODULE_81__, _cl_express_icf_shim_clas_mjs__WEBPACK_IMPORTED_MODULE_82__, _cl_function_test_environment_clas_mjs__WEBPACK_IMPORTED_MODULE_83__, _cl_gdt_conversion_clas_mjs__WEBPACK_IMPORTED_MODULE_84__, _cl_gui_cfw_clas_mjs__WEBPACK_IMPORTED_MODULE_85__, _cl_gui_container_clas_mjs__WEBPACK_IMPORTED_MODULE_86__, _cl_gui_frontend_services_clas_mjs__WEBPACK_IMPORTED_MODULE_87__, _cl_http_client_clas_mjs__WEBPACK_IMPORTED_MODULE_88__, _cl_http_entity_clas_mjs__WEBPACK_IMPORTED_MODULE_89__, _cl_http_server_clas_mjs__WEBPACK_IMPORTED_MODULE_90__, _cl_http_utility_clas_mjs__WEBPACK_IMPORTED_MODULE_91__, _cl_i18n_languages_clas_mjs__WEBPACK_IMPORTED_MODULE_92__, _cl_icf_tree_clas_mjs__WEBPACK_IMPORTED_MODULE_93__, _cl_ixml_clas_mjs__WEBPACK_IMPORTED_MODULE_94__, _cl_message_helper_clas_mjs__WEBPACK_IMPORTED_MODULE_95__, _cl_mime_repository_api_clas_mjs__WEBPACK_IMPORTED_MODULE_96__, _cl_numberrange_runtime_clas_mjs__WEBPACK_IMPORTED_MODULE_97__, _cl_oauth2_client_clas_mjs__WEBPACK_IMPORTED_MODULE_98__, _cl_oo_factory_clas_mjs__WEBPACK_IMPORTED_MODULE_99__, _cl_osql_test_environment_clas_mjs__WEBPACK_IMPORTED_MODULE_100__, _cl_progress_indicator_clas_mjs__WEBPACK_IMPORTED_MODULE_101__, _cl_salv_aggregations_clas_mjs__WEBPACK_IMPORTED_MODULE_102__, _cl_salv_column_clas_mjs__WEBPACK_IMPORTED_MODULE_103__, _cl_salv_columns_table_clas_mjs__WEBPACK_IMPORTED_MODULE_104__, _cl_salv_events_table_clas_mjs__WEBPACK_IMPORTED_MODULE_105__, _cl_salv_filters_clas_mjs__WEBPACK_IMPORTED_MODULE_106__, _cl_salv_functional_settings_clas_mjs__WEBPACK_IMPORTED_MODULE_107__, _cl_salv_functions_list_clas_mjs__WEBPACK_IMPORTED_MODULE_108__, _cl_salv_hyperlinks_clas_mjs__WEBPACK_IMPORTED_MODULE_109__, _cl_salv_layout_clas_mjs__WEBPACK_IMPORTED_MODULE_110__, _cl_salv_sorts_clas_mjs__WEBPACK_IMPORTED_MODULE_111__, _cl_salv_table_clas_mjs__WEBPACK_IMPORTED_MODULE_112__, _cl_shm_area_clas_mjs__WEBPACK_IMPORTED_MODULE_113__, _cl_shm_service_clas_mjs__WEBPACK_IMPORTED_MODULE_114__, _cl_sql_result_set_clas_mjs__WEBPACK_IMPORTED_MODULE_115__, _cl_sql_statement_clas_mjs__WEBPACK_IMPORTED_MODULE_116__, _cl_sxml_string_reader_clas_mjs__WEBPACK_IMPORTED_MODULE_117__, _cl_sxml_string_writer_clas_mjs__WEBPACK_IMPORTED_MODULE_118__, _cl_system_uuid_clas_mjs__WEBPACK_IMPORTED_MODULE_119__, _cl_web_http_utility_clas_mjs__WEBPACK_IMPORTED_MODULE_120__, _cx_abap_datfm_clas_mjs__WEBPACK_IMPORTED_MODULE_121__, _cx_abap_message_digest_clas_mjs__WEBPACK_IMPORTED_MODULE_122__, _cx_abap_not_a_table_clas_mjs__WEBPACK_IMPORTED_MODULE_123__, _cx_abap_not_in_package_clas_mjs__WEBPACK_IMPORTED_MODULE_124__, _cx_abap_not_in_whitelist_clas_mjs__WEBPACK_IMPORTED_MODULE_125__, _cx_abap_random_clas_mjs__WEBPACK_IMPORTED_MODULE_126__, _cx_abap_timefm_invalid_clas_mjs__WEBPACK_IMPORTED_MODULE_127__, _cx_apc_error_clas_mjs__WEBPACK_IMPORTED_MODULE_128__, _cx_bcs_clas_mjs__WEBPACK_IMPORTED_MODULE_129__, _cx_dynamic_check_clas_mjs__WEBPACK_IMPORTED_MODULE_130__, _cx_ftd_parameter_not_found_clas_mjs__WEBPACK_IMPORTED_MODULE_131__, _cx_gdt_conversion_clas_mjs__WEBPACK_IMPORTED_MODULE_132__, _cx_no_check_clas_mjs__WEBPACK_IMPORTED_MODULE_133__, _cx_oo_clif_not_exists_clas_mjs__WEBPACK_IMPORTED_MODULE_134__, _cx_parameter_invalid_clas_mjs__WEBPACK_IMPORTED_MODULE_135__, _cx_parameter_invalid_range_clas_mjs__WEBPACK_IMPORTED_MODULE_136__, _cx_parameter_invalid_type_clas_mjs__WEBPACK_IMPORTED_MODULE_137__, _cx_salv_access_error_clas_mjs__WEBPACK_IMPORTED_MODULE_139__, _cx_salv_data_error_clas_mjs__WEBPACK_IMPORTED_MODULE_140__, _cx_salv_error_clas_mjs__WEBPACK_IMPORTED_MODULE_141__, _cx_salv_existing_clas_mjs__WEBPACK_IMPORTED_MODULE_142__, _cx_salv_msg_clas_mjs__WEBPACK_IMPORTED_MODULE_143__, _cx_salv_not_found_clas_mjs__WEBPACK_IMPORTED_MODULE_144__, _cx_salv_static_check_clas_mjs__WEBPACK_IMPORTED_MODULE_145__, _cx_shm_already_detached_clas_mjs__WEBPACK_IMPORTED_MODULE_146__, _cx_shm_attach_error_clas_mjs__WEBPACK_IMPORTED_MODULE_147__, _cx_shm_build_failed_clas_mjs__WEBPACK_IMPORTED_MODULE_148__, _cx_shm_change_lock_active_clas_mjs__WEBPACK_IMPORTED_MODULE_149__, _cx_shm_completion_error_clas_mjs__WEBPACK_IMPORTED_MODULE_150__, _cx_shm_detach_error_clas_mjs__WEBPACK_IMPORTED_MODULE_151__, _cx_shm_error_clas_mjs__WEBPACK_IMPORTED_MODULE_152__, _cx_shm_event_execution_failed_clas_mjs__WEBPACK_IMPORTED_MODULE_153__, _cx_shm_exclusive_lock_active_clas_mjs__WEBPACK_IMPORTED_MODULE_154__, _cx_shm_general_error_clas_mjs__WEBPACK_IMPORTED_MODULE_155__, _cx_shm_inconsistent_clas_mjs__WEBPACK_IMPORTED_MODULE_156__, _cx_shm_initial_reference_clas_mjs__WEBPACK_IMPORTED_MODULE_157__, _cx_shm_no_active_version_clas_mjs__WEBPACK_IMPORTED_MODULE_158__, _cx_shm_parameter_error_clas_mjs__WEBPACK_IMPORTED_MODULE_159__, _cx_shm_pending_lock_removed_clas_mjs__WEBPACK_IMPORTED_MODULE_160__, _cx_shm_read_lock_active_clas_mjs__WEBPACK_IMPORTED_MODULE_161__, _cx_shm_secondary_commit_clas_mjs__WEBPACK_IMPORTED_MODULE_162__, _cx_shm_version_limit_exceeded_clas_mjs__WEBPACK_IMPORTED_MODULE_163__, _cx_shm_wrong_handle_clas_mjs__WEBPACK_IMPORTED_MODULE_164__, _cx_shma_dynamic_clas_mjs__WEBPACK_IMPORTED_MODULE_165__, _cx_shma_inconsistent_clas_mjs__WEBPACK_IMPORTED_MODULE_166__, _cx_shma_not_configured_clas_mjs__WEBPACK_IMPORTED_MODULE_167__, _cx_sql_exception_clas_mjs__WEBPACK_IMPORTED_MODULE_168__, _cx_st_error_clas_mjs__WEBPACK_IMPORTED_MODULE_169__, _cx_static_check_clas_mjs__WEBPACK_IMPORTED_MODULE_170__, _cx_sxml_error_clas_mjs__WEBPACK_IMPORTED_MODULE_171__, _cx_sxml_illegal_argument_error_clas_mjs__WEBPACK_IMPORTED_MODULE_172__, _cx_sxml_name_error_clas_mjs__WEBPACK_IMPORTED_MODULE_173__, _cx_sxml_parse_error_clas_mjs__WEBPACK_IMPORTED_MODULE_174__, _cx_sxml_state_error_clas_mjs__WEBPACK_IMPORTED_MODULE_175__, _cx_sy_arithmetic_error_clas_mjs__WEBPACK_IMPORTED_MODULE_176__, _cx_sy_arithmetic_overflow_clas_mjs__WEBPACK_IMPORTED_MODULE_177__, _cx_sy_buffer_overflow_clas_mjs__WEBPACK_IMPORTED_MODULE_178__, _cx_sy_codepage_converter_init_clas_mjs__WEBPACK_IMPORTED_MODULE_179__, _cx_sy_compression_error_clas_mjs__WEBPACK_IMPORTED_MODULE_180__, _cx_sy_conversion_codepage_clas_mjs__WEBPACK_IMPORTED_MODULE_181__, _cx_sy_conversion_data_loss_clas_mjs__WEBPACK_IMPORTED_MODULE_182__, _cx_sy_conversion_error_clas_mjs__WEBPACK_IMPORTED_MODULE_183__, _cx_sy_conversion_no_number_clas_mjs__WEBPACK_IMPORTED_MODULE_184__, _cx_sy_conversion_overflow_clas_mjs__WEBPACK_IMPORTED_MODULE_185__, _cx_sy_create_data_error_clas_mjs__WEBPACK_IMPORTED_MODULE_186__, _cx_sy_create_object_error_clas_mjs__WEBPACK_IMPORTED_MODULE_187__, _cx_sy_data_access_error_clas_mjs__WEBPACK_IMPORTED_MODULE_188__, _cx_sy_duplicate_key_clas_mjs__WEBPACK_IMPORTED_MODULE_189__, _cx_sy_dyn_call_error_clas_mjs__WEBPACK_IMPORTED_MODULE_190__, _cx_sy_dyn_call_illegal_class_clas_mjs__WEBPACK_IMPORTED_MODULE_191__, _cx_sy_dyn_call_illegal_form_clas_mjs__WEBPACK_IMPORTED_MODULE_192__, _cx_sy_dyn_call_illegal_func_clas_mjs__WEBPACK_IMPORTED_MODULE_193__, _cx_sy_dyn_call_illegal_method_clas_mjs__WEBPACK_IMPORTED_MODULE_194__, _cx_sy_dyn_call_param_not_found_clas_mjs__WEBPACK_IMPORTED_MODULE_195__, _cx_sy_dyn_call_parameter_error_clas_mjs__WEBPACK_IMPORTED_MODULE_196__, _cx_sy_dynamic_osql_error_clas_mjs__WEBPACK_IMPORTED_MODULE_197__, _cx_sy_dynamic_osql_semantics_clas_mjs__WEBPACK_IMPORTED_MODULE_198__, _cx_sy_itab_duplicate_key_clas_mjs__WEBPACK_IMPORTED_MODULE_199__, _cx_sy_itab_error_clas_mjs__WEBPACK_IMPORTED_MODULE_200__, _cx_sy_itab_line_not_found_clas_mjs__WEBPACK_IMPORTED_MODULE_201__, _cx_sy_message_illegal_text_clas_mjs__WEBPACK_IMPORTED_MODULE_202__, _cx_sy_move_cast_error_clas_mjs__WEBPACK_IMPORTED_MODULE_203__, _cx_sy_open_sql_error_clas_mjs__WEBPACK_IMPORTED_MODULE_204__, _cx_sy_range_out_of_bounds_clas_mjs__WEBPACK_IMPORTED_MODULE_205__, _cx_sy_ref_is_initial_clas_mjs__WEBPACK_IMPORTED_MODULE_206__, _cx_sy_sql_error_clas_mjs__WEBPACK_IMPORTED_MODULE_207__, _cx_sy_strg_par_val_clas_mjs__WEBPACK_IMPORTED_MODULE_208__, _cx_sy_struct_attributes_clas_mjs__WEBPACK_IMPORTED_MODULE_209__, _cx_sy_struct_comp_name_clas_mjs__WEBPACK_IMPORTED_MODULE_210__, _cx_sy_struct_comp_type_clas_mjs__WEBPACK_IMPORTED_MODULE_211__, _cx_sy_struct_creation_clas_mjs__WEBPACK_IMPORTED_MODULE_212__, _cx_sy_type_creation_clas_mjs__WEBPACK_IMPORTED_MODULE_213__, _cx_sy_zerodivide_clas_mjs__WEBPACK_IMPORTED_MODULE_214__, _cx_transformation_error_clas_mjs__WEBPACK_IMPORTED_MODULE_215__, _cx_uuid_error_clas_mjs__WEBPACK_IMPORTED_MODULE_216__, _cx_xslt_exception_clas_mjs__WEBPACK_IMPORTED_MODULE_217__, _cx_xslt_format_error_clas_mjs__WEBPACK_IMPORTED_MODULE_218__, _cx_xslt_runtime_error_clas_mjs__WEBPACK_IMPORTED_MODULE_219__, _cx_xslt_serialization_error_clas_mjs__WEBPACK_IMPORTED_MODULE_220__, _cx_xslt_system_error_clas_mjs__WEBPACK_IMPORTED_MODULE_221__, _kernel_authority_check_clas_mjs__WEBPACK_IMPORTED_MODULE_324__, _kernel_call_clas_mjs__WEBPACK_IMPORTED_MODULE_325__, _kernel_call_transformation_clas_mjs__WEBPACK_IMPORTED_MODULE_326__, _kernel_create_data_handle_clas_mjs__WEBPACK_IMPORTED_MODULE_327__, _kernel_cx_assert_clas_mjs__WEBPACK_IMPORTED_MODULE_328__, _kernel_fugr_test_clas_mjs__WEBPACK_IMPORTED_MODULE_329__, _kernel_internal_name_clas_mjs__WEBPACK_IMPORTED_MODULE_330__, _kernel_ixml_json_to_data_clas_mjs__WEBPACK_IMPORTED_MODULE_331__, _kernel_ixml_xml_to_data_clas_mjs__WEBPACK_IMPORTED_MODULE_332__, _kernel_json_to_ixml_clas_mjs__WEBPACK_IMPORTED_MODULE_333__, _kernel_lock_clas_mjs__WEBPACK_IMPORTED_MODULE_334__, _kernel_numberrange_clas_mjs__WEBPACK_IMPORTED_MODULE_335__, _kernel_push_channels_clas_mjs__WEBPACK_IMPORTED_MODULE_336__, _kernel_scan_abap_source_clas_mjs__WEBPACK_IMPORTED_MODULE_337__, _kernel_unit_runner_clas_mjs__WEBPACK_IMPORTED_MODULE_338__, _number_get_next_fugr_number_get_next_mjs__WEBPACK_IMPORTED_MODULE_350__, _openabap_fugr_call_v1_ping_mjs__WEBPACK_IMPORTED_MODULE_352__, _openabap_fugr_conversion_exit_alpha_input_mjs__WEBPACK_IMPORTED_MODULE_353__, _openabap_fugr_conversion_exit_alpha_output_mjs__WEBPACK_IMPORTED_MODULE_354__, _openabap_fugr_conversion_exit_isola_input_mjs__WEBPACK_IMPORTED_MODULE_355__, _openabap_fugr_conversion_exit_isola_output_mjs__WEBPACK_IMPORTED_MODULE_356__, _openabap_fugr_convert_itf_to_stream_text_mjs__WEBPACK_IMPORTED_MODULE_357__, _openabap_fugr_docu_get_mjs__WEBPACK_IMPORTED_MODULE_358__, _openabap_fugr_function_exists_mjs__WEBPACK_IMPORTED_MODULE_359__, _openabap_fugr_generate_sec_random_mjs__WEBPACK_IMPORTED_MODULE_360__, _openabap_fugr_get_system_timezone_mjs__WEBPACK_IMPORTED_MODULE_361__, _openabap_fugr_system_callstack_mjs__WEBPACK_IMPORTED_MODULE_362__, _openabap_fugr_system_installed_languages_mjs__WEBPACK_IMPORTED_MODULE_363__, _openabap_fugr_text_split_mjs__WEBPACK_IMPORTED_MODULE_364__, _openabap_fugr_unit_conversion_simple_mjs__WEBPACK_IMPORTED_MODULE_365__, _zcl_http_handler_clas_mjs__WEBPACK_IMPORTED_MODULE_466__, _zcl_otm_table_maintenance_clas_mjs__WEBPACK_IMPORTED_MODULE_467__, _zw3mi_fugr_wwwdata_export_mjs__WEBPACK_IMPORTED_MODULE_469__, _zw3mi_fugr_wwwdata_import_mjs__WEBPACK_IMPORTED_MODULE_470__, _zw3mi_fugr_wwwparams_insert_mjs__WEBPACK_IMPORTED_MODULE_471__, _zw3mi_fugr_wwwparams_read_mjs__WEBPACK_IMPORTED_MODULE_472__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
/* eslint-disable import/newline-after-import */


























































































































































































































































































































































































































































































async function initializeABAP() {
  const sqlite = [];
  sqlite.push(`CREATE TABLE 'zopentest' ('keyfield' NCHAR(4) COLLATE RTRIM, 'valuefield' NCHAR(10) COLLATE RTRIM, 'boolean' NCHAR(1) COLLATE RTRIM, PRIMARY KEY('keyfield'));`);
  sqlite.push(`CREATE TABLE 't000' ('mandt' NCHAR(3) COLLATE RTRIM, 'cccategory' NCHAR(1) COLLATE RTRIM, 'ccnocliind' NCHAR(1) COLLATE RTRIM, 'mtext' NCHAR(25) COLLATE RTRIM, PRIMARY KEY('mandt'));`);
  sqlite.push(`CREATE TABLE 't100' ('sprsl' NCHAR(1) COLLATE RTRIM, 'arbgb' NCHAR(20) COLLATE RTRIM, 'msgnr' NCHAR(3) COLLATE RTRIM, 'text' NCHAR(73) COLLATE RTRIM, PRIMARY KEY('sprsl','arbgb','msgnr'));`);
  sqlite.push(`CREATE TABLE 'tadir' ('pgmid' NCHAR(4) COLLATE RTRIM, 'object' NCHAR(4) COLLATE RTRIM, 'obj_name' NCHAR(40) COLLATE RTRIM, 'devclass' NCHAR(30) COLLATE RTRIM, 'korrnum' NCHAR(10) COLLATE RTRIM, 'delflag' NCHAR(1) COLLATE RTRIM, 'genflag' NCHAR(1) COLLATE RTRIM, 'srcsystem' NCHAR(5) COLLATE RTRIM, 'edtflag' NCHAR(1) COLLATE RTRIM, 'masterlang' NCHAR(1) COLLATE RTRIM, PRIMARY KEY('pgmid','object','obj_name'));`);
  sqlite.push(`CREATE TABLE 'tdevc' ('devclass' NCHAR(30) COLLATE RTRIM, 'dlvunit' NCHAR(30) COLLATE RTRIM, 'component' NCHAR(20) COLLATE RTRIM, 'parentcl' NCHAR(30) COLLATE RTRIM, 'as4user' NCHAR(12) COLLATE RTRIM, 'created_by' NCHAR(12) COLLATE RTRIM, 'created_on' NCHAR(8), 'ctext' NCHAR(60) COLLATE RTRIM, 'changed_by' NCHAR(12) COLLATE RTRIM, 'changed_on' NCHAR(8), 'namespace' NCHAR(10) COLLATE RTRIM, PRIMARY KEY('devclass'));`);
  sqlite.push(`CREATE TABLE 'tfdir' ('funcname' NCHAR(30) COLLATE RTRIM, PRIMARY KEY('funcname'));`);
  sqlite.push(`CREATE TABLE 'reposrc' ('progname' NCHAR(40) COLLATE RTRIM, 'data' TEXT COLLATE RTRIM, 'unam' NCHAR(12) COLLATE RTRIM, 'udat' NCHAR(8), 'utime' NCHAR(6), PRIMARY KEY('progname'));`);
  const hdb = `todo`;
  const pg = [];
  pg.push(`CREATE TABLE "zopentest" ("keyfield" NCHAR(4), "valuefield" NCHAR(10), "boolean" NCHAR(1), PRIMARY KEY("keyfield"));`);
  pg.push(`CREATE TABLE "t000" ("mandt" NCHAR(3), "cccategory" NCHAR(1), "ccnocliind" NCHAR(1), "mtext" NCHAR(25), PRIMARY KEY("mandt"));`);
  pg.push(`CREATE TABLE "t100" ("sprsl" NCHAR(1), "arbgb" NCHAR(20), "msgnr" NCHAR(3), "text" NCHAR(73), PRIMARY KEY("sprsl","arbgb","msgnr"));`);
  pg.push(`CREATE TABLE "tadir" ("pgmid" NCHAR(4), "object" NCHAR(4), "obj_name" NCHAR(40), "devclass" NCHAR(30), "korrnum" NCHAR(10), "delflag" NCHAR(1), "genflag" NCHAR(1), "srcsystem" NCHAR(5), "edtflag" NCHAR(1), "masterlang" NCHAR(1), PRIMARY KEY("pgmid","object","obj_name"));`);
  pg.push(`CREATE TABLE "tdevc" ("devclass" NCHAR(30), "dlvunit" NCHAR(30), "component" NCHAR(20), "parentcl" NCHAR(30), "as4user" NCHAR(12), "created_by" NCHAR(12), "created_on" NCHAR(8), "ctext" NCHAR(60), "changed_by" NCHAR(12), "changed_on" NCHAR(8), "namespace" NCHAR(10), PRIMARY KEY("devclass"));`);
  pg.push(`CREATE TABLE "tfdir" ("funcname" NCHAR(30), PRIMARY KEY("funcname"));`);
  pg.push(`CREATE TABLE "reposrc" ("progname" NCHAR(40), "data" TEXT, "unam" NCHAR(12), "udat" NCHAR(8), "utime" NCHAR(6), PRIMARY KEY("progname"));`);
  const snowflake = [];
  snowflake.push(`CREATE TABLE "zopentest" ("keyfield" NCHAR(4) COLLATE 'rtrim', "valuefield" NCHAR(10) COLLATE 'rtrim', "boolean" NCHAR(1) COLLATE 'rtrim', PRIMARY KEY("keyfield"));`);
  snowflake.push(`CREATE TABLE "t000" ("mandt" NCHAR(3) COLLATE 'rtrim', "cccategory" NCHAR(1) COLLATE 'rtrim', "ccnocliind" NCHAR(1) COLLATE 'rtrim', "mtext" NCHAR(25) COLLATE 'rtrim', PRIMARY KEY("mandt"));`);
  snowflake.push(`CREATE TABLE "t100" ("sprsl" NCHAR(1) COLLATE 'rtrim', "arbgb" NCHAR(20) COLLATE 'rtrim', "msgnr" NCHAR(3) COLLATE 'rtrim', "text" NCHAR(73) COLLATE 'rtrim', PRIMARY KEY("sprsl","arbgb","msgnr"));`);
  snowflake.push(`CREATE TABLE "tadir" ("pgmid" NCHAR(4) COLLATE 'rtrim', "object" NCHAR(4) COLLATE 'rtrim', "obj_name" NCHAR(40) COLLATE 'rtrim', "devclass" NCHAR(30) COLLATE 'rtrim', "korrnum" NCHAR(10) COLLATE 'rtrim', "delflag" NCHAR(1) COLLATE 'rtrim', "genflag" NCHAR(1) COLLATE 'rtrim', "srcsystem" NCHAR(5) COLLATE 'rtrim', "edtflag" NCHAR(1) COLLATE 'rtrim', "masterlang" NCHAR(1) COLLATE 'rtrim', PRIMARY KEY("pgmid","object","obj_name"));`);
  snowflake.push(`CREATE TABLE "tdevc" ("devclass" NCHAR(30) COLLATE 'rtrim', "dlvunit" NCHAR(30) COLLATE 'rtrim', "component" NCHAR(20) COLLATE 'rtrim', "parentcl" NCHAR(30) COLLATE 'rtrim', "as4user" NCHAR(12) COLLATE 'rtrim', "created_by" NCHAR(12) COLLATE 'rtrim', "created_on" NCHAR(8), "ctext" NCHAR(60) COLLATE 'rtrim', "changed_by" NCHAR(12) COLLATE 'rtrim', "changed_on" NCHAR(8), "namespace" NCHAR(10) COLLATE 'rtrim', PRIMARY KEY("devclass"));`);
  snowflake.push(`CREATE TABLE "tfdir" ("funcname" NCHAR(30) COLLATE 'rtrim', PRIMARY KEY("funcname"));`);
  snowflake.push(`CREATE TABLE "reposrc" ("progname" NCHAR(40) COLLATE 'rtrim', "data" TEXT, "unam" NCHAR(12) COLLATE 'rtrim', "udat" NCHAR(8), "utime" NCHAR(6), PRIMARY KEY("progname"));`);
  const schemas = {sqlite, hdb, pg, snowflake};

  const insert = [];
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('ZCL_HTTP_HANDLER                        ', 'CLASS zcl_http_handler DEFINITION PUBLIC.
  PUBLIC SECTION.
    INTERFACES if_http_extension.
ENDCLASS.

CLASS zcl_http_handler IMPLEMENTATION.

  METHOD if_http_extension~handle_request.

    DATA temp1 TYPE zcl_otm_table_maintenance=>ty_request.
    DATA result TYPE zcl_otm_table_maintenance=>ty_http.
    DATA temp3 TYPE REF TO zcl_otm_table_maintenance.
    DATA temp2 TYPE string.
    CLEAR temp1.
    temp1-method = server->request->get_method( ).
    temp1-path = server->request->get_header_field( ''~path'' ).
    temp1-body = server->request->get_data( ).
    
    
    CREATE OBJECT temp3 TYPE zcl_otm_table_maintenance EXPORTING IV_TABLE = ''ZOPENTEST''.
    result = temp3->serve( temp1 ).

    server->response->set_data( result-body ).
    server->response->set_content_type( result-content_type ).
    
    temp2 = result-status.
    server->response->set_status(
      code   = result-status
      reason = temp2 ).

  ENDMETHOD.

ENDCLASS.
');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('ZCL_OTM_TABLE_MAINTENANCE               ', 'CLASS zcl_otm_table_maintenance DEFINITION
  PUBLIC
  CREATE PUBLIC .

  PUBLIC SECTION.
* MIT License, Copyright (c) 2021 open-abap
* https://github.com/open-abap/open-table-maintenance

    TYPES:
      BEGIN OF ty_request,
        method TYPE string,
        path   TYPE string,
        body   TYPE xstring,
      END OF ty_request.
    TYPES:
      BEGIN OF ty_http,
        status       TYPE i,
        content_type TYPE string,
        body         TYPE xstring,
      END OF ty_http .

    METHODS constructor
      IMPORTING
        !iv_table TYPE tabname .
    METHODS serve
      IMPORTING
        !is_request    TYPE ty_request
      RETURNING
        VALUE(rs_http) TYPE ty_http .
  PROTECTED SECTION.
  PRIVATE SECTION.

    TYPES:
      ty_names TYPE STANDARD TABLE OF abap_compname WITH DEFAULT KEY .
    TYPES:
* there is no common released type for both steampunk and on-prem, workaround:
      BEGIN OF ty_fixvalue,
        low        TYPE c LENGTH 10,
        high       TYPE c LENGTH 10,
        option     TYPE c LENGTH 2,
        ddlanguage TYPE c LENGTH 1,
        ddtext     TYPE c LENGTH 60,
      END OF ty_fixvalue .
    TYPES:
      ty_fixvalues TYPE STANDARD TABLE OF ty_fixvalue WITH DEFAULT KEY .
    TYPES:
      BEGIN OF ty_fielddata,
        name      TYPE abap_compname,
        key       TYPE abap_bool,
        type_kind TYPE abap_typekind,
        length    TYPE i,
        fixvalues TYPE ty_fixvalues,
      END OF ty_fielddata .
    TYPES:
      ty_metadata TYPE STANDARD TABLE OF ty_fielddata WITH DEFAULT KEY .

    DATA mv_table TYPE tabname .

    METHODS from_xstring
      IMPORTING
        !xstring      TYPE xstring
      RETURNING
        VALUE(string) TYPE string .
    METHODS get_html
      RETURNING
        VALUE(rv_html) TYPE string .
    METHODS read_table
      RETURNING
        VALUE(rv_json) TYPE string .
    METHODS save_table
      IMPORTING
        !iv_json TYPE string
      RAISING
        cx_sy_conversion_data_loss .
    METHODS to_json
      IMPORTING
        !ref           TYPE REF TO data
      RETURNING
        VALUE(rv_json) TYPE string .
    METHODS to_xstring
      IMPORTING
        !string        TYPE string
      RETURNING
        VALUE(xstring) TYPE xstring .
    METHODS list_key_fields
      RETURNING
        VALUE(names) TYPE ty_names .
    METHODS build_metadata
      RETURNING
        VALUE(rt_metadata) TYPE ty_metadata .
ENDCLASS.



CLASS zcl_otm_table_maintenance IMPLEMENTATION.


  METHOD build_metadata.
    DATA lv_key TYPE abap_bool.
    DATA lo_element TYPE REF TO cl_abap_elemdescr.
    DATA lt_values TYPE ty_fixvalues.

    DATA lt_key_fields TYPE zcl_otm_table_maintenance=>ty_names.
    DATA temp1 TYPE REF TO cl_abap_structdescr.
    DATA lt_components TYPE abap_component_tab.
    DATA ls_component LIKE LINE OF lt_components.
      DATA temp2 TYPE zcl_otm_table_maintenance=>ty_fielddata.
    lt_key_fields = list_key_fields( ).
    
    temp1 ?= cl_abap_typedescr=>describe_by_name( mv_table ).
    
    lt_components = temp1->get_components( ).

    
    LOOP AT lt_components INTO ls_component.

      lo_element ?= ls_component-type.
      lt_values = lo_element->get_ddic_fixed_values( ).

      READ TABLE lt_key_fields WITH KEY table_line = ls_component-name TRANSPORTING NO FIELDS.
      lv_key = boolc( sy-subrc = 0 ).
      
      CLEAR temp2.
      temp2-name = ls_component-name.
      temp2-key = lv_key.
      temp2-type_kind = ls_component-type->type_kind.
      temp2-length = ls_component-type->length.
      temp2-fixvalues = lt_values.
      APPEND temp2 TO rt_metadata.
    ENDLOOP.

  ENDMETHOD.


  METHOD constructor.
    ASSERT iv_table IS NOT INITIAL.
    mv_table = iv_table.
  ENDMETHOD.


  METHOD from_xstring.

    DATA conv TYPE REF TO object.
        DATA conv_in_class TYPE c LENGTH 18.

    TRY.
        CALL METHOD (''CL_ABAP_CONV_CODEPAGE'')=>create_in
          RECEIVING
            instance = conv.

        CALL METHOD conv->(''IF_ABAP_CONV_IN~CONVERT'')
          EXPORTING
            source = xstring
          RECEIVING
            result = string.
      CATCH cx_sy_dyn_call_illegal_class.
        
        conv_in_class = ''CL_ABAP_CONV_IN_CE''.
        CALL METHOD (conv_in_class)=>create
          EXPORTING
            encoding = ''UTF-8''
          RECEIVING
            conv     = conv.

        CALL METHOD conv->(''CONVERT'')
          EXPORTING
            input = xstring
          IMPORTING
            data  = string.
    ENDTRY.

  ENDMETHOD.


  METHOD get_html.
    rv_html = |<!DOCTYPE html>\\n| &&
      |<html>\\n| &&
      |<head>\\n| &&
      |<title>open-table-maintenance</title>\\n| &&
      |<script src="https://bossanova.uk/jspreadsheet/v4/jexcel.js" async></script>\\n| &&
      |<script src="https://jsuites.net/v4/jsuites.js" async></script>\\n| &&
      |<link rel="stylesheet" href="https://jsuites.net/v4/jsuites.css" type="text/css" />\\n| &&
      |<link rel="stylesheet" href="https://bossanova.uk/jspreadsheet/v4/jexcel.css" type="text/css" />\\n| &&
      |<script>\\n| &&
      ''let jtable;'' && |\\n| &&
      ''let columnNames;'' && |\\n| &&
      ''const url = window.location.pathname + "/rest";'' && |\\n| &&
      ''function run() {'' && |\\n| &&
      ''  fetch(url).then((response) => {'' && |\\n| &&
      ''    return response.json();'' && |\\n| &&
      ''    }).then((parsed) => {'' && |\\n| &&
      ''    document.getElementById("tablename").innerHTML = '' && |\\n| &&
      ''      "<h1 style=\\"display:inline\\">hello " + parsed.TABLENAME + "</h1>&nbsp;<tt>" + '' && |\\n| &&
      ''       parsed.SY.SYSID + "-" + parsed.SY.MANDT + "</tt>";'' && |\\n| &&
      ''    const data = parsed.DATA;'' && |\\n| &&
      ''    if (data.length === 0) { '' && |\\n| &&
      ''       const obj = {};'' && |\\n| &&
      ''       obj[parsed.META[0]["NAME"]] = "_";'' && |\\n| &&
      ''       data.push(obj);'' && |\\n| &&
      ''    }'' && |\\n| &&
      ''    columnNames = parsed.META.map(n => n.NAME);'' && |\\n| &&
      ''    document.getElementById("content").innerHTML = "";'' && |\\n| &&
      ''    let columnSettings = parsed.META.map(n => {return {'' && |\\n| &&
      ''      "type": n.FIXVALUES.length > 0 ? "dropdown" : undefined,'' && |\\n| &&
      ''      "title": n.NAME,'' && |\\n| &&
      ''      "source": n.FIXVALUES.map(f => f.LOW),'' && |\\n| &&
      ''      "width": Math.min(200, n.LENGTH * 20)'' && |\\n| &&
      ''    };});'' && |\\n| &&
      ''    jtable = jspreadsheet(document.getElementById("content"), {'' && |\\n| &&
      ''      defaultColAlign:"left",'' && |\\n| &&
      ''      allowInsertRow:true,'' && |\\n| &&
      ''      allowManualInsertRow:true,'' && |\\n| &&
      ''      allowInsertColumn:false,'' && |\\n| &&
      ''      allowManualInsertColumn:false,'' && |\\n| &&
      ''      allowDeleteRow:true,'' && |\\n| &&
      ''      allowRenameColumn:false,'' && |\\n| &&
      ''      allowDeleteColumn:false,'' && |\\n| &&
      ''      data: data,'' && |\\n| &&
      ''      onload: function(instance) {'' && |\\n| &&
      ''        const keyCount = parsed.META.filter(n => n.KEY === "X").length;'' && |\\n| &&
      ''        for (let i = 0; i < keyCount; i++) {'' && |\\n| &&
      ''          instance.jexcel.colgroup[i].style.backgroundColor="#F8F8F8";'' && |\\n| &&
      ''        }'' && |\\n| &&
      ''      },'' && |\\n| &&
      ''      columns: columnSettings});'' && |\\n| &&
      ''  });'' && |\\n| &&
      ''}'' && |\\n| &&
      ''function toObject(row) {'' && |\\n| &&
      ''  let ret = {};'' && |\\n| &&
      ''  for (let i = 0; i < columnNames.length; i++) {'' && |\\n| &&
      ''    ret[columnNames[i]] = row[i];'' && |\\n| &&
      ''  }'' && |\\n| &&
      ''  return ret;'' && |\\n| &&
      ''}'' && |\\n| &&
      ''function save() {'' && |\\n| &&
      ''  const body = {"DATA": jtable.getData().map(toObject)};'' && |\\n| &&
      ''  fetch(url, {method: "POST", body: JSON.stringify(body)}).then(() => {alert("data saved");});'' && |\\n| &&
      ''}'' && |\\n| &&
      |</script>\\n| &&
      |</head>\\n| &&
      |<body onload="run()">\\n| &&
      |<div id="tablename"><h1>open-table-maintenance</h1></div>\\n| &&
      |<button type="button" onclick="save()">Save</button><br>\\n| &&
      |<div id="content">loading</div><br>\\n| &&
      |</body>\\n| &&
      |</html>|.
  ENDMETHOD.


  METHOD list_key_fields.
    DATA obj TYPE REF TO object.
    DATA lv_tabname TYPE c LENGTH 16.
    DATA lr_ddfields TYPE REF TO data.
    FIELD-SYMBOLS <any> TYPE any.
    FIELD-SYMBOLS <field> TYPE simple.
    FIELD-SYMBOLS <ddfields> TYPE ANY TABLE.
        DATA workaround TYPE c LENGTH 8.
        DATA temp3 TYPE REF TO cl_abap_structdescr.

* convert to correct type,
    lv_tabname = mv_table.

    TRY.
        CALL METHOD (''XCO_CP_ABAP_DICTIONARY'')=>database_table
          EXPORTING
            iv_name           = lv_tabname
          RECEIVING
            ro_database_table = obj.
        ASSIGN obj->(''IF_XCO_DATABASE_TABLE~FIELDS->IF_XCO_DBT_FIELDS_FACTORY~KEY'') TO <any>.
        ASSERT sy-subrc = 0.
        obj = <any>.
        CALL METHOD obj->(''IF_XCO_DBT_FIELDS~GET_NAMES'')
          RECEIVING
            rt_names = names.
      CATCH cx_sy_dyn_call_illegal_class.
        
        workaround = ''DDFIELDS''.
        CREATE DATA lr_ddfields TYPE (workaround).
        ASSIGN lr_ddfields->* TO <ddfields>.
        ASSERT sy-subrc = 0.
        
        temp3 ?= cl_abap_typedescr=>describe_by_name( lv_tabname ).
        <ddfields> = temp3->get_ddic_field_list( ).
        LOOP AT <ddfields> ASSIGNING <any>.
          ASSIGN COMPONENT ''KEYFLAG'' OF STRUCTURE <any> TO <field>.
          IF sy-subrc <> 0 OR <field> <> abap_true.
            CONTINUE.
          ENDIF.
          ASSIGN COMPONENT ''FIELDNAME'' OF STRUCTURE <any> TO <field>.
          ASSERT sy-subrc = 0.
          APPEND <field> TO names.
        ENDLOOP.
    ENDTRY.

  ENDMETHOD.


  METHOD read_table.

    FIELD-SYMBOLS <fs> TYPE STANDARD TABLE.
    DATA dref TYPE REF TO data.
    CREATE DATA dref TYPE STANDARD TABLE OF (mv_table) WITH DEFAULT KEY.
    ASSIGN dref->* TO <fs>.
    ASSERT sy-subrc = 0.

    " dont check SUBRC, the table might be empty
    SELECT * FROM (mv_table) ORDER BY PRIMARY KEY INTO TABLE <fs> ##SUBRC_OK.

    rv_json = to_json( dref ).

  ENDMETHOD.


  METHOD save_table.

    FIELD-SYMBOLS <fs> TYPE STANDARD TABLE.
    DATA dref TYPE REF TO data.
    CREATE DATA dref TYPE STANDARD TABLE OF (mv_table) WITH DEFAULT KEY.
    ASSIGN dref->* TO <fs>.
    ASSERT sy-subrc = 0.

    CALL TRANSFORMATION id SOURCE XML iv_json RESULT data = <fs>.

    MODIFY (mv_table) FROM TABLE <fs> ##SUBRC_OK.

  ENDMETHOD.


  METHOD serve.
            DATA lv_body TYPE string.

    TRY.
        rs_http-status = 200.
        IF is_request-path CP ''*/rest''.
          IF is_request-method = ''GET''.
            
            lv_body = read_table( ).
            rs_http-content_type = ''application/json''.
          ELSEIF is_request-method = ''POST''.
            save_table( from_xstring( is_request-body ) ).
          ELSE.
            ASSERT 1 = 2.
          ENDIF.
        ELSE.
          lv_body = get_html( ).
          rs_http-content_type = ''text/html''.
        ENDIF.
        rs_http-body = to_xstring( lv_body ).
      CATCH cx_root.
        rs_http-status = 500.
        rs_http-body   = to_xstring( |Exception occurred| ).
    ENDTRY.

  ENDMETHOD.


  METHOD to_json.

    FIELD-SYMBOLS <fs> TYPE STANDARD TABLE.
    DATA meta TYPE zcl_otm_table_maintenance=>ty_metadata.
    DATA writer TYPE REF TO cl_sxml_string_writer.
    ASSIGN ref->* TO <fs>.
    ASSERT sy-subrc = 0.

    
    meta = build_metadata( ).
    
    writer = cl_sxml_string_writer=>create( if_sxml=>co_xt_json ).
    CALL TRANSFORMATION id
      SOURCE
        data      = <fs>
        meta      = meta
        tablename = mv_table
        sy        = sy
      RESULT XML writer.
    rv_json = from_xstring( writer->get_output( ) ).

  ENDMETHOD.


  METHOD to_xstring.

    DATA conv TYPE REF TO object.
        DATA conv_out_class TYPE c LENGTH 19.

    TRY.
        CALL METHOD (''CL_ABAP_CONV_CODEPAGE'')=>create_out
          RECEIVING
            instance = conv.

        CALL METHOD conv->(''IF_ABAP_CONV_OUT~CONVERT'')
          EXPORTING
            source = string
          RECEIVING
            result = xstring.
      CATCH cx_sy_dyn_call_illegal_class.
        
        conv_out_class = ''CL_ABAP_CONV_OUT_CE''.
        CALL METHOD (conv_out_class)=>create
          EXPORTING
            encoding = ''UTF-8''
          RECEIVING
            conv     = conv.

        CALL METHOD conv->(''CONVERT'')
          EXPORTING
            data   = string
          IMPORTING
            buffer = xstring.
    ENDTRY.

  ENDMETHOD.
ENDCLASS.
');`);
  insert.push(`INSERT INTO "t100" ("sprsl", "arbgb", "msgnr", "text") VALUES ('E', '00                  ', '001', '&1&2&3&4                                                                 ');`);
  insert.push(`INSERT INTO "t100" ("sprsl", "arbgb", "msgnr", "text") VALUES ('E', '00                  ', '002', 'needed by abapGit unit test                                              ');`);
  insert.push(`INSERT INTO "t100" ("sprsl", "arbgb", "msgnr", "text") VALUES ('E', '00                  ', '003', 'needed by abapGit unit test                                              ');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_CHAR_UTILITIES                  ', 'CLASS cl_abap_char_utilities DEFINITION PUBLIC.
  PUBLIC SECTION.
* https://en.wikipedia.org/wiki/Byte_order_mark, 0xEF,0xBB,0xBF
    CONSTANTS byte_order_mark_utf8   TYPE x LENGTH 3 VALUE ''EFBBBF''.
    CONSTANTS byte_order_mark_big    TYPE x LENGTH 2 VALUE ''FEFF''.
    CONSTANTS byte_order_mark_little TYPE x LENGTH 2 VALUE ''FFFE''.
    CONSTANTS charsize               TYPE i VALUE 2.
* open-abap is little endian
    CONSTANTS endian                 TYPE abap_endian VALUE ''L''.

    CONSTANTS backspace      TYPE abap_char1 VALUE %_backspace.
    CONSTANTS cr_lf          TYPE abap_cr_lf VALUE %_cr_lf.
    CONSTANTS form_feed      TYPE abap_char1 VALUE %_formfeed.
    CONSTANTS horizontal_tab TYPE abap_char1 VALUE %_horizontal_tab.
    CONSTANTS newline        TYPE abap_char1 VALUE %_newline.
    CONSTANTS vertical_tab   TYPE abap_char1 VALUE %_vertical_tab.

    CONSTANTS maxchar        TYPE abap_char1 VALUE ''_''.
    CONSTANTS minchar        TYPE abap_char1 VALUE ''_''.

    CLASS-METHODS class_constructor.

    CLASS-METHODS get_simple_spaces_for_cur_cp
      RETURNING
        VALUE(s_str) TYPE string.
ENDCLASS.

CLASS cl_abap_char_utilities IMPLEMENTATION.

  METHOD class_constructor.
    WRITE ''@KERNEL cl_abap_char_utilities.maxchar.set(Buffer.from("FDFF", "hex").toString());''.
    WRITE ''@KERNEL cl_abap_char_utilities.minchar.set(Buffer.from("0000", "hex").toString());''.
  ENDMETHOD.

  METHOD get_simple_spaces_for_cur_cp.
    CONCATENATE \` \` horizontal_tab vertical_tab newline cr_lf(1) form_feed INTO s_str.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_EXCEPTIONAL_VALUES              ', 'CLASS cl_abap_exceptional_values DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS get_max_value
      IMPORTING
        in_ TYPE any
      RETURNING
        VALUE(out) TYPE REF TO data.

    CLASS-METHODS get_min_value
      IMPORTING
        in_ TYPE any
      RETURNING
        VALUE(out) TYPE REF TO data.
ENDCLASS.

CLASS cl_abap_exceptional_values IMPLEMENTATION.

  METHOD get_max_value.
    DATA lv_type     TYPE c LENGTH 1.
    DATA lv_length   TYPE i.
    DATA lv_decimals TYPE i.
    FIELD-SYMBOLS <out> TYPE any.

    DESCRIBE FIELD in_ TYPE lv_type.

    CASE lv_type.
      WHEN cl_abap_typedescr=>typekind_int.
        GET REFERENCE OF cl_abap_math=>max_int4 INTO out.
      WHEN cl_abap_typedescr=>typekind_packed.
        DESCRIBE FIELD in_ LENGTH lv_length IN BYTE MODE DECIMALS lv_decimals.

        CREATE DATA out TYPE p LENGTH lv_length DECIMALS lv_decimals.
        ASSIGN out->* TO <out>.

        IF lv_length = 3 AND lv_decimals = 1.
          <out> = ''9999.9''.
        ELSEIF lv_length = 4 AND lv_decimals = 1.
          <out> = ''999999.9''.
        ELSEIF lv_length = 7 AND lv_decimals = 3.
          <out> = ''9999999999.999''.
        ELSE.
          ASSERT 1 = ''todo''.
        ENDIF.
      WHEN OTHERS.
        WRITE ''@KERNEL console.dir(INPUT);''.
        ASSERT 1 = ''todo''.
    ENDCASE.
  ENDMETHOD.

  METHOD get_min_value.
    DATA lv_type TYPE c LENGTH 1.
    FIELD-SYMBOLS <out> TYPE any.

    DESCRIBE FIELD in_ TYPE lv_type.

    CASE lv_type.
      WHEN cl_abap_typedescr=>typekind_int.
        GET REFERENCE OF cl_abap_math=>min_int4 INTO out.
      WHEN cl_abap_typedescr=>typekind_packed.
        out = get_max_value( in_ ).
        ASSIGN out->* TO <out>.
        <out> = <out> * -1.
      WHEN OTHERS.
        WRITE ''@KERNEL console.dir(INPUT);''.
        ASSERT 1 = ''todo''.
    ENDCASE.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_FORMAT                          ', 'CLASS cl_abap_format DEFINITION PUBLIC.
  PUBLIC SECTION.
    CONSTANTS e_html_attr    TYPE i VALUE 5.
    CONSTANTS e_html_js      TYPE i VALUE 8.
    CONSTANTS e_html_js_html TYPE i VALUE 10.
    CONSTANTS e_html_text    TYPE i VALUE 4.
    CONSTANTS e_json_string  TYPE i VALUE 24.
    CONSTANTS e_url          TYPE i VALUE 12.
    CONSTANTS e_xml_attr     TYPE i VALUE 1.
    CONSTANTS e_xss_ml       TYPE i VALUE 26.
ENDCLASS.

CLASS cl_abap_format IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_GZIP                            ', 'CLASS cl_abap_gzip DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS decompress_binary
      IMPORTING
        gzip_in     TYPE xstring
      EXPORTING
        raw_out     TYPE xstring
        raw_out_len TYPE i.

    CLASS-METHODS compress_binary
      IMPORTING
        compress_level TYPE i OPTIONAL
        raw_in         TYPE xstring
      EXPORTING
        gzip_out       TYPE xstring
        gzip_out_len   TYPE i.

    CLASS-METHODS decompress_text
      IMPORTING
        gzip_in     TYPE xsequence
        gzip_in_len TYPE i DEFAULT -1
        conversion  TYPE abap_encod DEFAULT ''DEFAULT''
      EXPORTING
        text_out     TYPE csequence
        text_out_len TYPE i
      RAISING
        cx_parameter_invalid_range
        cx_sy_buffer_overflow
        cx_sy_conversion_codepage
        cx_sy_compression_error.

    CLASS-METHODS compress_text
      IMPORTING
        text_in        TYPE csequence
        text_in_len    TYPE i DEFAULT -1
        compress_level TYPE i DEFAULT 6
        conversion     TYPE abap_encod DEFAULT ''DEFAULT''
      EXPORTING
        gzip_out TYPE xsequence
        gzip_out_len TYPE i
      RAISING
        cx_parameter_invalid_range
        cx_sy_buffer_overflow
        cx_sy_conversion_codepage
        cx_sy_compression_error.

    CLASS-METHODS decompress_binary_with_header
      IMPORTING
        gzip_in TYPE xstring
      EXPORTING
        raw_out TYPE xstring
      RAISING
        cx_parameter_invalid
        cx_sy_buffer_overflow
        cx_sy_compression_error.
ENDCLASS.

CLASS cl_abap_gzip IMPLEMENTATION.
  METHOD decompress_binary_with_header.
* with gzip RFC 1952 header
    WRITE ''@KERNEL const zlib = await import("zlib");''.
    WRITE ''@KERNEL const buf = Buffer.from(gzip_in.get(), "hex");''.
    WRITE ''@KERNEL const decompress = zlib.gunzipSync(buf).toString("hex").toUpperCase();''.

    WRITE ''@KERNEL raw_out.set(decompress);''.
  ENDMETHOD.

  METHOD decompress_text.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD compress_text.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD decompress_binary.
    WRITE ''@KERNEL const zlib = await import("zlib");''.
    WRITE ''@KERNEL const buf = Buffer.from(gzip_in.get(), "hex");''.
    WRITE ''@KERNEL const decompress = zlib.inflateRawSync(buf, {finishFlush: zlib.constants.Z_SYNC_FLUSH}).toString("hex").toUpperCase();''.

    WRITE ''@KERNEL raw_out.set(decompress);''.
    raw_out_len = xstrlen( raw_out ).
  ENDMETHOD.

  METHOD compress_binary.
* todo, input parameter COMPRESS_LEVEL corresponds to "level" in "options" for Node?
    WRITE ''@KERNEL const zlib = await import("zlib");''.
    WRITE ''@KERNEL const buf = Buffer.from(raw_in.get(), "hex");''.
    WRITE ''@KERNEL const gzi = zlib.deflateRawSync(buf).toString("hex").toUpperCase();''.

    WRITE ''@KERNEL gzip_out.set(gzi);''.
    gzip_out_len = xstrlen( gzip_out ).
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_WEAK_REFERENCE                  ', 'CLASS cl_abap_weak_reference DEFINITION PUBLIC.
  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        oref TYPE REF TO object.

    METHODS get
      RETURNING
        VALUE(oref) TYPE REF TO object.
  PRIVATE SECTION.
    DATA mv_ref TYPE x LENGTH 1.
ENDCLASS.

CLASS cl_abap_weak_reference IMPLEMENTATION.
  METHOD constructor.
    ASSERT oref IS NOT INITIAL.
* https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakRef
    WRITE ''@KERNEL this.mv_ref = new WeakRef(oref);''.
  ENDMETHOD.

  METHOD get.
    WRITE ''@KERNEL oref.set(this.mv_ref.deref());''.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_ZIP                             ', 'CLASS cl_abap_zip DEFINITION PUBLIC.

  PUBLIC SECTION.
    METHODS add
      IMPORTING
        name TYPE string
        content TYPE xstring.

    METHODS save
      RETURNING
        VALUE(val) TYPE xstring.

    METHODS load
      IMPORTING
        zip TYPE xstring.

    METHODS get
      IMPORTING
        name    TYPE string OPTIONAL
        index   TYPE i OPTIONAL
      EXPORTING
        content TYPE xstring.

    METHODS delete
      IMPORTING
        name  TYPE string OPTIONAL
        index TYPE i DEFAULT 0
      EXCEPTIONS
        zip_index_error.

    CLASS-METHODS crc32
      IMPORTING content TYPE xstring
      RETURNING VALUE(crc) TYPE i.

    TYPES: BEGIN OF t_file,
             name TYPE string,
             size TYPE i,
           END OF t_file.
    TYPES t_files TYPE STANDARD TABLE OF t_file WITH DEFAULT KEY.
    DATA files TYPE t_files.

  PRIVATE SECTION.
    TYPES: BEGIN OF ty_contents,
             name          TYPE string,
* todo, optimize memory usage, dont store both compressed and original,
             content       TYPE xstring,
             compressed    TYPE xstring,
           END OF ty_contents.
    DATA mt_contents TYPE STANDARD TABLE OF ty_contents WITH DEFAULT KEY.

ENDCLASS.

CLASS cl_abap_zip IMPLEMENTATION.

  METHOD crc32.
    DATA lo_stream TYPE REF TO lcl_stream.
    CREATE OBJECT lo_stream.
    crc = lo_stream->append_crc(
      iv_little_endian = abap_false
      iv_xstring       = content ).
  ENDMETHOD.

  METHOD delete.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get.
    DATA ls_length   TYPE i.
    DATA ls_contents LIKE LINE OF mt_contents.

    ASSERT name IS NOT INITIAL.
    ASSERT index IS INITIAL.

    READ TABLE mt_contents WITH KEY name = name INTO ls_contents.
    cl_abap_gzip=>decompress_binary(
      EXPORTING
        gzip_in     = ls_contents-compressed
      IMPORTING
        raw_out     = content
        raw_out_len = ls_length ).
  ENDMETHOD.

  METHOD add.
    DATA ls_contents LIKE LINE OF mt_contents.

    ls_contents-name = name.
    ls_contents-content = content.
    cl_abap_gzip=>compress_binary(
      EXPORTING
        raw_in   = content
      IMPORTING
        gzip_out = ls_contents-compressed ).
    INSERT ls_contents INTO TABLE mt_contents.
  ENDMETHOD.

  METHOD load.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD save.
* https://en.wikipedia.org/wiki/ZIP_(file_format)
* https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT

    DATA lo_total    TYPE REF TO lcl_stream.
    DATA lo_file     TYPE REF TO lcl_stream.
    DATA lo_central  TYPE REF TO lcl_stream.
    DATA ls_contents LIKE LINE OF mt_contents.
    DATA lv_buffer   TYPE xstring.
    DATA lv_tmp      TYPE xstring.
    DATA lv_start    TYPE i.
    DATA lo_conv     TYPE REF TO cl_abap_conv_out_ce.

    CREATE OBJECT lo_central.
    CREATE OBJECT lo_total.
    lo_conv = cl_abap_conv_out_ce=>create( ).

    LOOP AT mt_contents INTO ls_contents.
      lo_conv->convert( EXPORTING data = ls_contents-name
                        IMPORTING buffer = lv_buffer ).

****************************************
* LOCAL FILE RECORD
      CREATE OBJECT lo_file.
* 0, 4, Local file header signature
      lo_file->append( ''504B0304'' ).
* 4, 2, Version needed to extract (minimum)
      lo_file->append( ''1400'' ).
* 6, 2, General purpose bit flag
      lo_file->append( ''0000'' ).
* 8, 2, Compression method; e.g. none = 0, DEFLATE = 8 (or "0x08 0x00")
      lo_file->append( ''0800'' ).
* 10, 2, File last modification time
      lo_file->append( ''0699'' ). "lo_stream->append_time( sy-uzeit ).
* 12, 2, File last modification date
      lo_file->append( ''F856'' ). "lo_stream->append_date( sy-datum ).
* 14, 4, CRC-32 of uncompressed data
      lo_file->append_crc(
        iv_little_endian = abap_true
        iv_xstring       = ls_contents-content ).
* 18, 4, Compressed size (or 0xffffffff for ZIP64)
      lo_file->append_int4( xstrlen( ls_contents-compressed ) ).
* 22, 4, Uncompressed size (or 0xffffffff for ZIP64)
      lo_file->append_int4( xstrlen( ls_contents-content ) ).
* 26, 2, File name length (n)
      lo_file->append_int2( xstrlen( lv_buffer ) ).
* 28, 2, Extra field length (m)
      lo_file->append( ''0000'' ).
* 30, n, File name
      lo_file->append( lv_buffer ).
* 30+n, m, Extra field
* empty
* compressed data,
      lo_file->append( ls_contents-compressed ).

****************************************
* CENTRAL DIRECTORY FILE RECORD
* 0, 4, Central directory file header signature = 0x02014b50
      lo_central->append( ''504B0102'' ).
* 4, 2, Version made by
      lo_central->append( ''1400'' ).

* 6, 2, Version needed to extract (minimum)
* 8, 2, General purpose bit flag
* 10, 2, Compression method
* 12, 2, File last modification time
* 14, 2, File last modification date
* 16, 4, CRC-32 of uncompressed data
* 20, 4, Compressed size (or 0xffffffff for ZIP64)
* 24, 4, Uncompressed size (or 0xffffffff for ZIP64)
* 28, 2, File name length (n)
* 30, 2, Extra field length (m)
      lv_tmp = lo_file->get( ).
      lo_central->append( lv_tmp+4(26) ).

* 32, 2, File comment length (k)
      lo_central->append_int2( 0 ).
* 34, 2, Disk number where file starts (or 0xffff for ZIP64)
      lo_central->append_int2( 0 ).
* 36, 2, Internal file attributes
      lo_central->append_int2( 0 ).
* 38, 4, External file attributes
      lo_central->append_int4( 0 ).
* 42, 4, Relative offset of local file header (or 0xffffffff for ZIP64). This is the number of bytes between the start of the first disk on which the file occurs, and the start of the local file header. This allows software reading the central directory to locate the position of the file inside the ZIP file.
      lo_central->append_int4( xstrlen( lo_total->get( ) ) ).
* 46, n, File name
      lo_central->append( lv_buffer ).

      lo_total->append( lo_file->get( ) ).
    ENDLOOP.

    lv_start = xstrlen( lo_total->get( ) ).
    lo_total->append( lo_central->get( ) ).

****************************************
* END OF CENTRAL DIRECTORY
* 0, 4, End of central directory signature = 0x06054b50
    lo_total->append( ''504B0506'' ).
* 4, 2, Number of this disk (or 0xffff for ZIP64)
    lo_total->append_int2( 0 ).
* 6, 2, Disk where central directory starts (or 0xffff for ZIP64)
    lo_total->append_int2( 0 ).
* 8, 2, Number of central directory records on this disk (or 0xffff for ZIP64)
    lo_total->append_int2( lines( mt_contents ) ).
* 10, 2, Total number of central directory records (or 0xffff for ZIP64)
    lo_total->append_int2( lines( mt_contents ) ).
* 12, 4, Size of central directory (bytes) (or 0xffffffff for ZIP64)
    lo_total->append_int4( xstrlen( lo_central->get( ) ) ).
* 16, 4, Offset of start of central directory, relative to start of archive (or 0xffffffff for ZIP64)
    lo_total->append_int4( lv_start ).
* 20, 2, Comment length (n)
    lo_total->append_int2( 0 ).
* 22, n, Comment
* empty

    val = lo_total->get( ).
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_DYN_PRG                         ', 'CLASS cl_abap_dyn_prg DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS check_table_name_str
      IMPORTING
        val            TYPE csequence
        packages       TYPE csequence
      RETURNING
        VALUE(val_str) TYPE string
      RAISING
        cx_abap_not_a_table
        cx_abap_not_in_package.

    CLASS-METHODS check_whitelist_str
      IMPORTING
        val            TYPE csequence
        whitelist      TYPE csequence
      RETURNING
        VALUE(val_str) TYPE string
      RAISING
        cx_abap_not_in_whitelist.

    CLASS-METHODS quote
      IMPORTING
        val        TYPE csequence
      RETURNING
        VALUE(out) TYPE string.

    CLASS-METHODS escape_quotes
      IMPORTING
        val        TYPE csequence
      RETURNING
        VALUE(out) TYPE string.

    CLASS-METHODS escape_xss_xml_html
      IMPORTING
        val        TYPE csequence
      RETURNING
        VALUE(out) TYPE string.

    CLASS-METHODS escape_xss_url
      IMPORTING
        val        TYPE csequence
      RETURNING
        VALUE(out) TYPE string.
ENDCLASS.

CLASS cl_abap_dyn_prg IMPLEMENTATION.

  METHOD check_table_name_str.
* allow everything
    val_str = val.
  ENDMETHOD.

  METHOD check_whitelist_str.
* allow everything
    val_str = val.
  ENDMETHOD.

  METHOD quote.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD escape_xss_url.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD escape_quotes.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD escape_xss_xml_html.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_ABAP_NOT_A_TABLE                     ', 'CLASS cx_abap_not_a_table DEFINITION PUBLIC INHERITING FROM cx_static_check.

ENDCLASS.

CLASS cx_abap_not_a_table IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_ABAP_NOT_IN_PACKAGE                  ', 'CLASS cx_abap_not_in_package DEFINITION PUBLIC INHERITING FROM cx_static_check.

ENDCLASS.

CLASS cx_abap_not_in_package IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_ABAP_NOT_IN_WHITELIST                ', 'CLASS cx_abap_not_in_whitelist DEFINITION PUBLIC INHERITING FROM cx_static_check.

ENDCLASS.

CLASS cx_abap_not_in_whitelist IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_HMAC                            ', 'CLASS cl_abap_hmac DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS calculate_hmac_for_raw
      IMPORTING
        if_algorithm   TYPE string DEFAULT ''SHA1''
        if_key         TYPE xstring
        if_data        TYPE xstring
        if_length      TYPE i OPTIONAL
      EXPORTING
        ef_hmacstring     TYPE string
        ef_hmacxstring    TYPE xstring
        ef_hmacb64string  TYPE string
      RAISING
        cx_abap_message_digest.

    CLASS-METHODS calculate_hmac_for_char
      IMPORTING
        if_algorithm     TYPE string DEFAULT ''SHA1''
        if_key           TYPE xstring
        if_data          TYPE string
      EXPORTING
        ef_hmacstring    TYPE string
        ef_hmacxstring   TYPE xstring
        ef_hmacb64string TYPE string
      RAISING
        cx_abap_message_digest.

    CLASS-METHODS string_to_xstring
      IMPORTING
        if_input TYPE string
      RETURNING
        VALUE(er_output) TYPE xstring
      RAISING
        cx_abap_message_digest.
ENDCLASS.

CLASS cl_abap_hmac IMPLEMENTATION.
  METHOD calculate_hmac_for_raw.

    DATA lv_algorithm TYPE string.

    CLEAR ef_hmacstring.
    CLEAR ef_hmacxstring.

    " todo,
    ASSERT if_length = 0.

    lv_algorithm = to_lower( if_algorithm ).
    ASSERT lv_algorithm = ''sha1'' OR lv_algorithm = ''md5'' OR lv_algorithm = ''sha256''.

* todo, this doesnt work in browser?
    WRITE ''@KERNEL const crypto = await import("crypto");''.
    IF if_key IS INITIAL.
      WRITE ''@KERNEL var shasum = crypto.createHash(lv_algorithm.get());''.
      WRITE ''@KERNEL shasum.update(if_data.get(), "hex");''.
      WRITE ''@KERNEL ef_hmacstring.set(shasum.digest("hex").toUpperCase());''.
    ELSE.
      WRITE ''@KERNEL let hmac = crypto.createHmac(lv_algorithm.get(), Buffer.from(if_key.get(), "hex")).update(if_data.get(), "hex").digest("hex").toUpperCase();''.
      WRITE ''@KERNEL ef_hmacstring.set(hmac);''.
    ENDIF.

    WRITE ''@KERNEL ef_hmacb64string.set(Buffer.from(ef_hmacstring.get(), "hex").toString("base64"));''.

    ef_hmacxstring = ef_hmacstring.

  ENDMETHOD.

  METHOD calculate_hmac_for_char.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD string_to_xstring.
    ASSERT 1 = ''todo''.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_MESSAGE_DIGEST                  ', 'CLASS cl_abap_message_digest DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS calculate_hash_for_raw
      IMPORTING
        if_algorithm   TYPE string DEFAULT ''SHA1''
        if_data        TYPE xstring
      EXPORTING
        ef_hashxstring TYPE xstring
      RAISING
        cx_abap_message_digest.

    CLASS-METHODS calculate_hash_for_char
      IMPORTING
        if_algorithm     TYPE string DEFAULT ''SHA1''
        if_data          TYPE string
      EXPORTING
        ef_hashxstring   TYPE xstring
        ef_hashstring    TYPE string
        ef_hashb64string TYPE string
      RAISING
        cx_abap_message_digest.
ENDCLASS.

CLASS cl_abap_message_digest IMPLEMENTATION.
  METHOD calculate_hash_for_raw.

    DATA lv_algorithm TYPE string.

    lv_algorithm = to_lower( if_algorithm ).
    ASSERT lv_algorithm = ''sha1'' OR lv_algorithm = ''md5'' OR lv_algorithm = ''sha256''.

* todo, this doesnt work in browser?
    WRITE ''@KERNEL const crypto = await import("crypto");''.
    WRITE ''@KERNEL var shasum = crypto.createHash(lv_algorithm.get());''.
    WRITE ''@KERNEL shasum.update(if_data.get(), "hex");''.
    WRITE ''@KERNEL ef_hashxstring.set(shasum.digest("hex").toUpperCase());''.

  ENDMETHOD.

  METHOD calculate_hash_for_char.

    DATA lv_algorithm TYPE string.

    lv_algorithm = to_lower( if_algorithm ).
    ASSERT lv_algorithm = ''sha1'' OR lv_algorithm = ''md5'' OR lv_algorithm = ''sha256''.

* todo, this doesnt work in browser?
    WRITE ''@KERNEL const crypto = await import("crypto");''.
    WRITE ''@KERNEL var shasum = crypto.createHash(lv_algorithm.get());''.
    WRITE ''@KERNEL shasum.update(if_data.get());''.
    WRITE ''@KERNEL ef_hashxstring.set(shasum.digest("hex").toUpperCase());''.
    WRITE ''@KERNEL ef_hashb64string.set(Buffer.from(ef_hashxstring.get(), "hex").toString("base64"));''.

    ef_hashstring = ef_hashxstring.

  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_ABAP_MESSAGE_DIGEST                  ', 'CLASS cx_abap_message_digest DEFINITION PUBLIC INHERITING FROM cx_static_check.

ENDCLASS.

CLASS cx_abap_message_digest IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_MATH                            ', 'CLASS cl_abap_math DEFINITION PUBLIC.
  PUBLIC SECTION.
    CONSTANTS min_int4 TYPE i VALUE -2147483648.
    CONSTANTS max_int4 TYPE i VALUE 2147483647.

    CONSTANTS max_int8 TYPE int8 VALUE 9223372036854775807.
    CONSTANTS min_int8 TYPE int8 VALUE -9223372036854775808.

    CONSTANTS round_ceiling   TYPE i VALUE 0.
    CONSTANTS round_up        TYPE i VALUE 1.
    CONSTANTS round_half_up   TYPE i VALUE 2.
    CONSTANTS round_half_even TYPE i VALUE 3.
    CONSTANTS round_half_down TYPE i VALUE 4.
    CONSTANTS round_down      TYPE i VALUE 5.
    CONSTANTS round_floor     TYPE i VALUE 6.
ENDCLASS.

CLASS cl_abap_math IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_RANDOM                          ', 'CLASS cl_abap_random DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS create
      IMPORTING
        seed             TYPE i OPTIONAL
      RETURNING
        VALUE(ro_random) TYPE REF TO cl_abap_random.

    METHODS int
      RETURNING
        VALUE(rv_integer) TYPE i.

    METHODS intinrange
      IMPORTING
        low               TYPE i
        high              TYPE i
      RETURNING
        VALUE(rv_integer) TYPE i.

    CLASS-METHODS seed
      RETURNING
        VALUE(rv_seed) TYPE i.
* todo, use "crypto." instead for generating random numbers? see cl_abap_hmac which also uses crypto
ENDCLASS.

CLASS cl_abap_random IMPLEMENTATION.
  METHOD create.
    CREATE OBJECT ro_random.
  ENDMETHOD.

  METHOD int.
* todo, currently only positive integers are returned
    WRITE ''@KERNEL rv_integer.set(Math.floor(Math.random() * 2147483647));''.
  ENDMETHOD.

  METHOD seed.
    WRITE ''@KERNEL rv_seed.set(Math.floor(Math.random() * 2147483647));''.
  ENDMETHOD.

  METHOD intinrange.
* including "low" and "high" numbers
    DATA lv_interval TYPE i.

    ASSERT high > low.
    ASSERT low >= 0.
    lv_interval = high - low + 1.
    rv_integer = abs( int( ) ).
    rv_integer = rv_integer MOD lv_interval.
    rv_integer = rv_integer + low.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_RANDOM_INT                      ', 'CLASS cl_abap_random_int DEFINITION PUBLIC FINAL CREATE PRIVATE.
  PUBLIC SECTION.
    CLASS-METHODS create
      IMPORTING
        seed TYPE i OPTIONAL
        min  TYPE i DEFAULT -2147483648
        max  TYPE i DEFAULT 2147483647
        PREFERRED PARAMETER seed
      RETURNING
        VALUE(prng) TYPE REF TO cl_abap_random_int
      RAISING
        cx_abap_random.

    METHODS get_next
      RETURNING
        VALUE(value) TYPE i.

  PRIVATE SECTION.
    DATA mv_min TYPE i.
    DATA mv_max TYPE i.
ENDCLASS.

CLASS cl_abap_random_int IMPLEMENTATION.
  METHOD create.
    CREATE OBJECT prng.
    prng->mv_min = min.
    prng->mv_max = max.
  ENDMETHOD.

  METHOD get_next.
    value = cl_abap_random=>create( )->intinrange(
      low  = mv_min
      high = mv_max ).
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_ABAP_RANDOM                          ', 'CLASS cx_abap_random DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_abap_random IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_MATCHER                         ', 'CLASS cl_abap_matcher DEFINITION PUBLIC.

  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        pattern TYPE clike
        ignore_case TYPE abap_bool
        text TYPE clike.

    METHODS find_all
      RETURNING
        VALUE(rt_matches) TYPE match_result_tab.

    METHODS find_next
      RETURNING
        VALUE(found) TYPE abap_bool.

    METHODS get_submatch
      IMPORTING
        index TYPE i
      RETURNING
        VALUE(match) TYPE string.

    METHODS get_offset
      RETURNING
        VALUE(offset) TYPE i.

    METHODS match
      RETURNING
        VALUE(success) TYPE abap_bool.

    METHODS get_length
      RETURNING
        VALUE(length) TYPE i.

  PRIVATE SECTION.
    DATA mt_matches TYPE match_result_tab.
    DATA mv_index TYPE i.
    DATA mv_text TYPE string.
    DATA mv_pattern TYPE string.

ENDCLASS.

CLASS cl_abap_matcher IMPLEMENTATION.

  METHOD constructor.
    IF ignore_case = abap_true.
      FIND ALL OCCURRENCES OF REGEX pattern IN text RESULTS mt_matches IGNORING CASE.
    ELSE.
      FIND ALL OCCURRENCES OF REGEX pattern IN text RESULTS mt_matches.
    ENDIF.
    mv_pattern = pattern.
    mv_text = text.
  ENDMETHOD.

  METHOD match.
    FIND ALL OCCURRENCES OF REGEX |^{ mv_pattern }$| IN mv_text.
    success = boolc( sy-subrc = 0 ).
  ENDMETHOD.

  METHOD find_all.
    rt_matches = mt_matches.
  ENDMETHOD.

  METHOD find_next.
    mv_index = mv_index + 1.
    READ TABLE mt_matches INDEX mv_index TRANSPORTING NO FIELDS.
    found = boolc( sy-subrc = 0 ).
  ENDMETHOD.

  METHOD get_submatch.
    DATA ls_match LIKE LINE OF mt_matches.
    DATA ls_submatch LIKE LINE OF ls_match-submatches.
    READ TABLE mt_matches INDEX mv_index INTO ls_match.
    READ TABLE ls_match-submatches INDEX index INTO ls_submatch.
    IF sy-subrc = 0.
      match = mv_text+ls_submatch-offset(ls_submatch-length).
    ENDIF.
  ENDMETHOD.

  METHOD get_offset.
    DATA ls_match LIKE LINE OF mt_matches.
    READ TABLE mt_matches INDEX mv_index INTO ls_match.
    offset = ls_match-offset.
  ENDMETHOD.

  METHOD get_length.
    DATA ls_match LIKE LINE OF mt_matches.
    READ TABLE mt_matches INDEX mv_index INTO ls_match.
    length = ls_match-length.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_REGEX                           ', 'CLASS cl_abap_regex DEFINITION PUBLIC.

  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        pattern     TYPE clike
        ignore_case TYPE abap_bool DEFAULT abap_false.

    METHODS create_matcher
      IMPORTING
        text              TYPE clike
      RETURNING
        VALUE(ro_matcher) TYPE REF TO cl_abap_matcher.

    CLASS-METHODS create_pcre
      IMPORTING
        pattern      TYPE clike
        ignore_case  TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(regex) TYPE REF TO cl_abap_regex.

  PRIVATE SECTION.
    DATA mv_pattern     TYPE string.
    DATA mv_ignore_case TYPE abap_bool.

ENDCLASS.

CLASS cl_abap_regex IMPLEMENTATION.

  METHOD constructor.
    mv_pattern = pattern.
    mv_ignore_case = ignore_case.
  ENDMETHOD.

  METHOD create_pcre.
    CREATE OBJECT regex
      EXPORTING
        pattern     = pattern
        ignore_case = ignore_case.
  ENDMETHOD.

  METHOD create_matcher.
    CREATE OBJECT ro_matcher
      EXPORTING
        pattern     = mv_pattern
        ignore_case = mv_ignore_case
        text        = text.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SQL_RESULT_SET                       ', 'CLASS cl_sql_result_set DEFINITION PUBLIC.
  PUBLIC SECTION.
    METHODS set_param
      IMPORTING
        data_ref TYPE REF TO data
      RAISING
        cx_parameter_invalid.

    METHODS set_param_table
      IMPORTING
        itab_ref TYPE REF TO data
      RAISING
        cx_parameter_invalid.

    METHODS next
      RETURNING
        VALUE(rows_ret) TYPE i
      RAISING
        cx_sql_exception.

    METHODS close.

    METHODS next_package
      RAISING
        cx_sql_exception
        cx_parameter_invalid_type.
  PRIVATE SECTION.
    DATA mv_magic TYPE x LENGTH 1.
    DATA mv_index TYPE i.
    DATA mv_ref   TYPE REF TO data.
ENDCLASS.

CLASS cl_sql_result_set IMPLEMENTATION.

  METHOD set_param.
    mv_ref = data_ref.
  ENDMETHOD.

  METHOD next.
* todo, more work needed here

    DATA lv_total TYPE i.
    DATA lv_value TYPE string.

    WRITE ''@KERNEL lv_total.set(this.mv_magic.length);''.
*    WRITE ''@KERNEL console.dir(this.mv_magic);''.
    WRITE ''@KERNEL const current = this.mv_magic[this.mv_index.get()];''.
    WRITE ''@KERNEL lv_value.set(Object.values(current)[0]);''.

    mv_ref->* = lv_value.

    mv_index = mv_index + 1.
    rows_ret = lv_total - mv_index.
  ENDMETHOD.

  METHOD close.
* nothing here,
    RETURN.
  ENDMETHOD.

  METHOD set_param_table.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD next_package.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SQL_STATEMENT                        ', 'CLASS cl_sql_statement DEFINITION PUBLIC.
  PUBLIC SECTION.
    METHODS constructor
      IMPORTING con_ref TYPE REF TO object OPTIONAL.

    METHODS execute_update
      IMPORTING
        statement TYPE string
      RAISING
        cx_sql_exception.

    METHODS execute_query
      IMPORTING
        statement         TYPE string
      RETURNING
        VALUE(result_set) TYPE REF TO cl_sql_result_set
      RAISING
        cx_sql_exception.

    METHODS execute_ddl
      IMPORTING
        statement TYPE string
      RAISING
        cx_sql_exception.
ENDCLASS.

CLASS cl_sql_statement IMPLEMENTATION.

  METHOD constructor.
* todo,
    ASSERT con_ref IS INITIAL.
  ENDMETHOD.

  METHOD execute_ddl.
    ASSERT 1 = ''not supported''.
  ENDMETHOD.

  METHOD execute_update.

    DATA lv_sql_message TYPE string.

    ASSERT statement IS NOT INITIAL.

    WRITE ''@KERNEL if (abap.context.databaseConnections["DEFAULT"] === undefined) {''.
    lv_sql_message = ''not connected to db''.
    WRITE ''@KERNEL }''.
    IF lv_sql_message IS NOT INITIAL.
      RAISE EXCEPTION TYPE cx_sql_exception.
    ENDIF.

    WRITE ''@KERNEL try {''.
    WRITE ''@KERNEL   await abap.context.databaseConnections["DEFAULT"].execute(statement.get());''.
    WRITE ''@KERNEL } catch(e) {''.
    WRITE ''@KERNEL   lv_sql_message.set(e + "");''.
    WRITE ''@KERNEL }''.
    IF lv_sql_message IS NOT INITIAL.
      RAISE EXCEPTION TYPE cx_sql_exception.
    ENDIF.

  ENDMETHOD.

  METHOD execute_query.
    DATA lv_sql_message TYPE string.

    ASSERT statement IS NOT INITIAL.

    WRITE ''@KERNEL if (abap.context.databaseConnections["DEFAULT"] === undefined) {''.
    lv_sql_message = ''not connected to db''.
    WRITE ''@KERNEL }''.
    IF lv_sql_message IS NOT INITIAL.
      RAISE EXCEPTION TYPE cx_sql_exception.
    ENDIF.

    CREATE OBJECT result_set.

    WRITE ''@KERNEL try {''.
    WRITE ''@KERNEL   const res = await abap.context.databaseConnections["DEFAULT"].select({select: statement.get()});''.
*    WRITE ''@KERNEL   console.dir(res.rows);''.
    WRITE ''@KERNEL   result_set.get().mv_magic = res.rows;''.
    WRITE ''@KERNEL } catch(e) {''.
    WRITE ''@KERNEL   lv_sql_message.set(e + "");''.
    WRITE ''@KERNEL }''.
    IF lv_sql_message IS NOT INITIAL.
      RAISE EXCEPTION TYPE cx_sql_exception.
    ENDIF.

  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SQL_EXCEPTION                        ', 'CLASS cx_sql_exception DEFINITION PUBLIC INHERITING FROM cx_static_check.

ENDCLASS.

CLASS cx_sql_exception IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_BCS                                  ', 'CLASS cl_bcs DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS create_persistent
      RETURNING
        VALUE(result) TYPE REF TO cl_bcs
      RAISING
        cx_bcs.

    METHODS add_recipient
      IMPORTING
        i_recipient  TYPE REF TO if_recipient_bcs
        i_express    TYPE abap_bool OPTIONAL
        i_copy       TYPE abap_bool OPTIONAL
        i_blind_copy TYPE abap_bool OPTIONAL
        i_no_forward TYPE abap_bool OPTIONAL
      RAISING
        cx_bcs.

    METHODS set_sender
      IMPORTING
        i_sender TYPE REF TO if_sender_bcs
      RAISING
        cx_bcs.

    METHODS set_status_attributes
      IMPORTING
        i_requested_status TYPE any.

    METHODS set_document
      IMPORTING
        i_document TYPE REF TO if_document_bcs
      RAISING
        cx_bcs.

    METHODS set_message_subject
      IMPORTING
        ip_subject TYPE string
      RAISING
        cx_bcs.

    METHODS send
      IMPORTING
        i_with_error_screen TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(result) TYPE abap_bool
      RAISING
        cx_bcs.

    METHODS set_send_immediately
      IMPORTING
        i_send_immediately TYPE abap_bool
      RAISING
        cx_bcs.
ENDCLASS.

CLASS cl_bcs IMPLEMENTATION.

  METHOD set_document.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD set_status_attributes.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD set_send_immediately.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD set_message_subject.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD set_sender.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD send.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD create_persistent.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD add_recipient.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_BCS_CONVERT                          ', 'CLASS cl_bcs_convert DEFINITION PUBLIC.
  PUBLIC SECTION.

    CLASS-METHODS string_to_soli
      IMPORTING
        iv_string      TYPE string
      RETURNING
        VALUE(et_soli) TYPE soli_tab.

    CLASS-METHODS xstring_to_solix
      IMPORTING
        iv_xstring      TYPE xstring
      RETURNING
        VALUE(et_solix) TYPE solix_tab.

    CLASS-METHODS raw_to_string
      IMPORTING
        it_soli          TYPE soli_tab
      RETURNING
        VALUE(ev_string) TYPE string
      RAISING
        cx_bcs.

    CLASS-METHODS solix_to_xstring
      IMPORTING
        it_solix TYPE solix_tab
        iv_size TYPE i OPTIONAL
      RETURNING
        VALUE(ev_xstring) TYPE xstring.

ENDCLASS.

CLASS cl_bcs_convert IMPLEMENTATION.

  METHOD string_to_soli.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD solix_to_xstring.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD xstring_to_solix.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD raw_to_string.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_CAM_ADDRESS_BCS                      ', 'CLASS cl_cam_address_bcs DEFINITION PUBLIC.
  PUBLIC SECTION.
    INTERFACES if_recipient_bcs.
    INTERFACES if_sender_bcs.

    CLASS-METHODS create_internet_address
      IMPORTING
        i_address_string TYPE clike
        i_address_name   TYPE clike OPTIONAL
        i_incl_sapuser   TYPE abap_bool OPTIONAL
      RETURNING
        VALUE(result)    TYPE REF TO cl_cam_address_bcs
      RAISING
        cx_bcs.

ENDCLASS.

CLASS cl_cam_address_bcs IMPLEMENTATION.

  METHOD create_internet_address.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_DOCUMENT_BCS                         ', 'CLASS cl_document_bcs DEFINITION PUBLIC.
  PUBLIC SECTION.
    INTERFACES if_document_bcs.

    CLASS-METHODS create_document
      IMPORTING
        i_type    TYPE string
        i_subject TYPE clike
        i_text    TYPE any OPTIONAL
        i_length  TYPE i OPTIONAL
      RETURNING
        VALUE(result) TYPE REF TO cl_document_bcs
      RAISING
        cx_bcs.

    METHODS add_attachment
      IMPORTING
        i_attachment_type    TYPE string
        i_attachment_subject TYPE string
        i_attachment_size    TYPE i OPTIONAL
        i_att_content_text   TYPE any OPTIONAL
        i_att_content_hex    TYPE any OPTIONAL
        i_attachment_header  TYPE soli_tab OPTIONAL
      RAISING
        cx_bcs.

ENDCLASS.

CLASS cl_document_bcs IMPLEMENTATION.

  METHOD create_document.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD add_attachment.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_BCS                                  ', 'CLASS cx_bcs DEFINITION PUBLIC INHERITING FROM cx_static_check.

ENDCLASS.

CLASS cx_bcs IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_DOCUMENT_BCS                         ', 'INTERFACE if_document_bcs PUBLIC.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_RECIPIENT_BCS                        ', 'INTERFACE if_recipient_bcs PUBLIC.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SENDER_BCS                           ', 'INTERFACE if_sender_bcs PUBLIC.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_I18N_LANGUAGES                       ', 'CLASS cl_i18n_languages DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS sap1_to_sap2
      IMPORTING
        im_lang_sap1        TYPE sy-langu
      RETURNING
        VALUE(re_lang_sap2) TYPE string
      EXCEPTIONS
        no_assignment.

    CLASS-METHODS sap2_to_sap1
      IMPORTING
        im_lang_sap2 TYPE laiso
      RETURNING
        VALUE(re_lang_sap1) TYPE sy-langu
      EXCEPTIONS
        no_assignment.

    CLASS-METHODS sap2_to_iso639_1
      IMPORTING
        im_lang_sap2   TYPE laiso
      EXPORTING
        ex_lang_iso639 TYPE string
        ex_country     TYPE land1
      EXCEPTIONS
        no_assignment.
ENDCLASS.

CLASS cl_i18n_languages IMPLEMENTATION.
  METHOD sap2_to_sap1.
    CASE to_upper( im_lang_sap2 ).
      WHEN ''SR''.
        re_lang_sap1 = ''0''.
      WHEN ''ZH''.
        re_lang_sap1 = ''1''.
      WHEN ''TH''.
        re_lang_sap1 = ''2''.
      WHEN ''KO''.
        re_lang_sap1 = ''3''.
      WHEN ''RO''.
        re_lang_sap1 = ''4''.
      WHEN ''SL''.
        re_lang_sap1 = ''5''.
      WHEN ''HR''.
        re_lang_sap1 = ''6''.
      WHEN ''MS''.
        re_lang_sap1 = ''7''.
      WHEN ''UK''.
        re_lang_sap1 = ''8''.
      WHEN ''ET''.
        re_lang_sap1 = ''9''.
      WHEN ''AR''.
        re_lang_sap1 = ''A''.
      WHEN ''HE''.
        re_lang_sap1 = ''B''.
      WHEN ''CS''.
        re_lang_sap1 = ''C''.
      WHEN ''DE''.
        re_lang_sap1 = ''D''.
      WHEN ''EN''.
        re_lang_sap1 = ''E''.
      WHEN ''FR''.
        re_lang_sap1 = ''F''.
      WHEN ''EL''.
        re_lang_sap1 = ''G''.
      WHEN ''HU''.
        re_lang_sap1 = ''H''.
      WHEN ''IT''.
        re_lang_sap1 = ''I''.
      WHEN ''JA''.
        re_lang_sap1 = ''J''.
      WHEN ''DA''.
        re_lang_sap1 = ''K''.
      WHEN ''PL''.
        re_lang_sap1 = ''L''.
      WHEN ''ZF''.
        re_lang_sap1 = ''M''.
      WHEN ''NL''.
        re_lang_sap1 = ''N''.
      WHEN ''NO''.
        re_lang_sap1 = ''O''.
      WHEN ''PT''.
        re_lang_sap1 = ''P''.
      WHEN ''SK''.
        re_lang_sap1 = ''Q''.
      WHEN ''RU''.
        re_lang_sap1 = ''R''.
      WHEN ''ES''.
        re_lang_sap1 = ''S''.
      WHEN ''TR''.
        re_lang_sap1 = ''T''.
      WHEN ''FI''.
        re_lang_sap1 = ''U''.
      WHEN ''SV''.
        re_lang_sap1 = ''V''.
      WHEN ''BG''.
        re_lang_sap1 = ''W''.
      WHEN ''LT''.
        re_lang_sap1 = ''X''.
      WHEN ''LV''.
        re_lang_sap1 = ''Y''.
      WHEN ''Z1''.
        re_lang_sap1 = ''Z''.
      WHEN ''AF''.
        re_lang_sap1 = ''a''.
      WHEN ''IS''.
        re_lang_sap1 = ''b''.
      WHEN ''CA''.
        re_lang_sap1 = ''c''.
      WHEN ''SH''.
        re_lang_sap1 = ''d''.
      WHEN ''ID''.
        re_lang_sap1 = ''i''.
      WHEN ''1Q''.
        re_lang_sap1 = ''''.
      WHEN OTHERS.
        RAISE no_assignment.
    ENDCASE.
  ENDMETHOD.

  METHOD sap1_to_sap2.
* todo, ideally this should look up in a database table first
* if there is no database attached, fallback to the CASE below
    CASE im_lang_sap1.
      WHEN ''0''.
        re_lang_sap2 = ''SR''.
      WHEN ''1''.
        re_lang_sap2 = ''ZH''.
      WHEN ''2''.
        re_lang_sap2 = ''TH''.
      WHEN ''3''.
        re_lang_sap2 = ''KO''.
      WHEN ''4''.
        re_lang_sap2 = ''RO''.
      WHEN ''5''.
        re_lang_sap2 = ''SL''.
      WHEN ''6''.
        re_lang_sap2 = ''HR''.
      WHEN ''7''.
        re_lang_sap2 = ''MS''.
      WHEN ''8''.
        re_lang_sap2 = ''UK''.
      WHEN ''9''.
        re_lang_sap2 = ''ET''.
      WHEN ''A''.
        re_lang_sap2 = ''AR''.
      WHEN ''B''.
        re_lang_sap2 = ''HE''.
      WHEN ''C''.
        re_lang_sap2 = ''CS''.
      WHEN ''D''.
        re_lang_sap2 = ''DE''.
      WHEN ''E''.
        re_lang_sap2 = ''EN''.
      WHEN ''F''.
        re_lang_sap2 = ''FR''.
      WHEN ''G''.
        re_lang_sap2 = ''EL''.
      WHEN ''H''.
        re_lang_sap2 = ''HU''.
      WHEN ''I''.
        re_lang_sap2 = ''IT''.
      WHEN ''J''.
        re_lang_sap2 = ''JA''.
      WHEN ''K''.
        re_lang_sap2 = ''DA''.
      WHEN ''L''.
        re_lang_sap2 = ''PL''.
      WHEN ''M''.
        re_lang_sap2 = ''ZF''.
      WHEN ''N''.
        re_lang_sap2 = ''NL''.
      WHEN ''O''.
        re_lang_sap2 = ''NO''.
      WHEN ''P''.
        re_lang_sap2 = ''PT''.
      WHEN ''Q''.
        re_lang_sap2 = ''SK''.
      WHEN ''R''.
        re_lang_sap2 = ''RU''.
      WHEN ''S''.
        re_lang_sap2 = ''ES''.
      WHEN ''T''.
        re_lang_sap2 = ''TR''.
      WHEN ''U''.
        re_lang_sap2 = ''FI''.
      WHEN ''V''.
        re_lang_sap2 = ''SV''.
      WHEN ''W''.
        re_lang_sap2 = ''BG''.
      WHEN ''X''.
        re_lang_sap2 = ''LT''.
      WHEN ''Y''.
        re_lang_sap2 = ''LV''.
      WHEN ''Z''.
        re_lang_sap2 = ''Z1''.
      WHEN ''a''.
        re_lang_sap2 = ''AF''.
      WHEN ''b''.
        re_lang_sap2 = ''IS''.
      WHEN ''c''.
        re_lang_sap2 = ''CA''.
      WHEN ''d''.
        re_lang_sap2 = ''SH''.
      WHEN ''i''.
        re_lang_sap2 = ''ID''.
      WHEN OTHERS.
        RAISE no_assignment.
    ENDCASE.
  ENDMETHOD.

  METHOD sap2_to_iso639_1.
    CASE im_lang_sap2.
      WHEN ''SR''.
        ex_lang_iso639 = ''sr''.
      WHEN ''ZH''.
        ex_lang_iso639 = ''zh''.
        ex_country = ''CN''.
      WHEN ''TH''.
        ex_lang_iso639 = ''th''.
      WHEN ''KO''.
        ex_lang_iso639 = ''ko''.
        ex_country = ''KR''.
      WHEN ''RO''.
        ex_lang_iso639 = ''ro''.
        ex_country = ''RO''.
      WHEN ''SL''.
        ex_lang_iso639 = ''sl''.
      WHEN ''HR''.
        ex_lang_iso639 = ''hr''.
      WHEN ''MS''.
        ex_lang_iso639 = ''ms''.
        ex_country = ''MY''.
      WHEN ''UK''.
        ex_lang_iso639 = ''uk''.
      WHEN ''ET''.
        ex_lang_iso639 = ''et''.
      WHEN ''AR''.
        ex_lang_iso639 = ''ar''.
        ex_country = ''SA''.
      WHEN ''HE''.
        ex_lang_iso639 = ''he''.
      WHEN ''CS''.
        ex_lang_iso639 = ''cs''.
      WHEN ''DE''.
        ex_lang_iso639 = ''de''.
        ex_country = ''DE''.
      WHEN ''EN''.
        ex_lang_iso639 = ''en''.
        ex_country = ''US''.
      WHEN ''FR''.
        ex_lang_iso639 = ''fr''.
        ex_country = ''FR''.
      WHEN ''EL''.
        ex_lang_iso639 = ''el''.
      WHEN ''HU''.
        ex_lang_iso639 = ''hu''.
      WHEN ''IT''.
        ex_lang_iso639 = ''it''.
        ex_country = ''IT''.
      WHEN ''JA''.
        ex_lang_iso639 = ''ja''.
      WHEN ''DA''.
        ex_lang_iso639 = ''da''.
      WHEN ''PL''.
        ex_lang_iso639 = ''pl''.
      WHEN ''ZF''.
        ex_lang_iso639 = ''zh''.
        ex_country = ''TW''.
      WHEN ''NL''.
        ex_lang_iso639 = ''nl''.
        ex_country = ''NL''.
      WHEN ''NO''.
        ex_lang_iso639 = ''no''.
      WHEN ''PT''.
        ex_lang_iso639 = ''pt''.
        ex_country = ''BR''.
      WHEN ''SK''.
        ex_lang_iso639 = ''sk''.
      WHEN ''RU''.
        ex_lang_iso639 = ''ru''.
        ex_country = ''RU''.
      WHEN ''ES''.
        ex_lang_iso639 = ''es''.
        ex_country = ''ES''.
      WHEN ''TR''.
        ex_lang_iso639 = ''tr''.
      WHEN ''FI''.
        ex_lang_iso639 = ''fi''.
      WHEN ''SV''.
        ex_lang_iso639 = ''sv''.
      WHEN ''BG''.
        ex_lang_iso639 = ''bg''.
      WHEN ''LT''.
        ex_lang_iso639 = ''lt''.
      WHEN ''LV''.
        ex_lang_iso639 = ''lv''.
      WHEN ''AF''.
        ex_lang_iso639 = ''af''.
      WHEN ''IS''.
        ex_lang_iso639 = ''is''.
      WHEN ''CA''.
        ex_lang_iso639 = ''ca''.
      WHEN ''SH''.
        ex_lang_iso639 = ''sr''.
      WHEN ''ID''.
        ex_lang_iso639 = ''id''.
      WHEN OTHERS.
        RAISE no_assignment.
    ENDCASE.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_MESSAGE_HELPER                       ', 'CLASS cl_message_helper DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS set_msg_vars_for_if_msg
      IMPORTING
        text TYPE REF TO if_message
      EXPORTING
        VALUE(string) TYPE string.

    CLASS-METHODS set_msg_vars_for_clike
      IMPORTING
        text TYPE clike.

    CLASS-METHODS get_text_for_message
      IMPORTING
        text TYPE REF TO if_message
      RETURNING
        VALUE(result) TYPE string.

    CLASS-METHODS check_msg_kind
      IMPORTING
        msg     TYPE REF TO object
      EXPORTING
        t100key TYPE scx_t100key
        textid  TYPE sotr_conc.

    CLASS-METHODS get_otr_text_raw
      IMPORTING
        textid TYPE sotr_conc
      EXPORTING
        result TYPE string.

    CLASS-METHODS replace_text_params
      IMPORTING
        obj    TYPE REF TO object
      CHANGING
        result TYPE string.
  PRIVATE SECTION.
    CONSTANTS gc_fallback TYPE string VALUE ''An exception was raised.''.
ENDCLASS.

CLASS cl_message_helper IMPLEMENTATION.

  METHOD get_otr_text_raw.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD replace_text_params.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get_text_for_message.

    DATA lv_msgid LIKE sy-msgid.
    DATA lv_msgno LIKE sy-msgno.
    DATA lv_msgv1 LIKE sy-msgv1.
    DATA lv_msgv2 LIKE sy-msgv2.
    DATA lv_msgv3 LIKE sy-msgv3.
    DATA lv_msgv4 LIKE sy-msgv4.

* when the transpiler can do more, the below can be implemented in ABAP instead of using KERNEL,
    WRITE ''@KERNEL if (text.get()?.if_t100_message$t100key === undefined) { result.set(this.gc_fallback); return result; };''.

    WRITE ''@KERNEL lv_msgid.set(text.get().if_t100_message$t100key.get().msgid);''.
    WRITE ''@KERNEL lv_msgno.set(text.get().if_t100_message$t100key.get().msgno);''.
    WRITE ''@KERNEL lv_msgv1.set(text.get()[text.get().if_t100_message$t100key.get().attr1.get().toLowerCase().replace("~", "$").trimEnd()] ? text.get()[text.get().if_t100_message$t100key.get().attr1.get().toLowerCase().replace("~", "$").trimEnd()].get() : "");''.
    WRITE ''@KERNEL lv_msgv2.set(text.get()[text.get().if_t100_message$t100key.get().attr2.get().toLowerCase().replace("~", "$").trimEnd()] ? text.get()[text.get().if_t100_message$t100key.get().attr2.get().toLowerCase().replace("~", "$").trimEnd()].get() : "");''.
    WRITE ''@KERNEL lv_msgv3.set(text.get()[text.get().if_t100_message$t100key.get().attr3.get().toLowerCase().replace("~", "$").trimEnd()] ? text.get()[text.get().if_t100_message$t100key.get().attr3.get().toLowerCase().replace("~", "$").trimEnd()].get() : "");''.
    WRITE ''@KERNEL lv_msgv4.set(text.get()[text.get().if_t100_message$t100key.get().attr4.get().toLowerCase().replace("~", "$").trimEnd()] ? text.get()[text.get().if_t100_message$t100key.get().attr4.get().toLowerCase().replace("~", "$").trimEnd()].get() : "");''.

    MESSAGE ID lv_msgid TYPE ''I'' NUMBER lv_msgno WITH lv_msgv1 lv_msgv2 lv_msgv3 lv_msgv4 INTO result.

  ENDMETHOD.

  METHOD set_msg_vars_for_if_msg.
    IF text IS INITIAL.
      RAISE EXCEPTION TYPE cx_sy_message_illegal_text.
    ENDIF.

* first try if_t100_message
    string = get_text_for_message( text ).
    IF string <> gc_fallback.
      CLEAR sy-msgty.
      RETURN.
    ENDIF.

    string = text->get_text( ).
    IF string IS INITIAL.
      ASSERT 1 = ''todo''.
    ENDIF.

    set_msg_vars_for_clike( string ).
  ENDMETHOD.

  METHOD set_msg_vars_for_clike.

    DATA lv_char200 TYPE c LENGTH 200.

    " move to char200 to avoid checking out of bound
    lv_char200 = text.

    sy-msgid = ''00''.
    sy-msgno = ''001''.

    sy-msgv1 = lv_char200.
    IF lv_char200+49(1) = space.
      lv_char200 = lv_char200+49.
    ELSE.
      lv_char200 = text+50.
    ENDIF.

    sy-msgv2 = lv_char200.
    IF lv_char200+49(1) = space.
      lv_char200 = lv_char200+49.
    ELSE.
      lv_char200 = lv_char200+50.
    ENDIF.

    sy-msgv3 = lv_char200.
    IF lv_char200+49(1) = space.
      lv_char200 = lv_char200+49.
    ELSE.
      lv_char200 = lv_char200+50.
    ENDIF.

    sy-msgv4 = lv_char200.

  ENDMETHOD.

  METHOD check_msg_kind.

    DATA li_t100_message TYPE REF TO if_t100_message.

    TRY.
        li_t100_message ?= msg.
        t100key = li_t100_message->t100key.
      CATCH cx_sy_move_cast_error.
        ASSERT 1 = ''todo''.
    ENDTRY.

  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_OO_ADT_CLASSRUN                      ', 'INTERFACE if_oo_adt_classrun PUBLIC.
  METHODS main IMPORTING out TYPE REF TO if_oo_adt_classrun_out.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_OO_ADT_CLASSRUN_OUT                  ', 'INTERFACE if_oo_adt_classrun_out PUBLIC.

  METHODS write
    IMPORTING
      data TYPE any
      name TYPE string OPTIONAL
    RETURNING
      VALUE(output) TYPE REF TO if_oo_adt_classrun_out.

  METHODS get
    IMPORTING
      data TYPE any OPTIONAL
      name TYPE string OPTIONAL PREFERRED PARAMETER data
    RETURNING
      VALUE(output) TYPE string.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_CODEPAGE                        ', 'CLASS cl_abap_codepage DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS convert_to
      IMPORTING
        codepage      TYPE string OPTIONAL
        source        TYPE string
      RETURNING
        VALUE(output) TYPE xstring.

    CLASS-METHODS convert_from
      IMPORTING
        codepage      TYPE string OPTIONAL
        source        TYPE xstring
      RETURNING
        VALUE(output) TYPE string.

    CLASS-METHODS sap_codepage
      IMPORTING
        encoding TYPE string
      RETURNING
        VALUE(codepage) TYPE abap_encoding.
ENDCLASS.

CLASS cl_abap_codepage IMPLEMENTATION.
  METHOD convert_to.
    DATA conv TYPE REF TO cl_abap_conv_out_ce.
    conv = cl_abap_conv_out_ce=>create( encoding = ''UTF-8'' ).
    conv->convert( EXPORTING data   = source
                   IMPORTING buffer = output ).
  ENDMETHOD.

  METHOD convert_from.
    DATA conv TYPE REF TO cl_abap_conv_in_ce.
    DATA data TYPE string.
    conv = cl_abap_conv_in_ce=>create( encoding = ''UTF-8'' ).
    conv->convert(
      EXPORTING input = source
      IMPORTING data = output ).
  ENDMETHOD.

  METHOD sap_codepage.
    ASSERT encoding = ''UTF-16LE''.
    codepage = ''4103''.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_CONV_CODEPAGE                   ', 'CLASS cl_abap_conv_codepage DEFINITION PUBLIC FINAL CREATE PRIVATE.

  PUBLIC SECTION.

    CLASS-METHODS create_in
      RETURNING
        VALUE(instance) TYPE REF TO if_abap_conv_in
      RAISING
        cx_parameter_invalid_range.

    CLASS-METHODS create_out
      RETURNING
        VALUE(instance) TYPE REF TO if_abap_conv_out
      RAISING
        cx_parameter_invalid_range.

ENDCLASS.

CLASS cl_abap_conv_codepage IMPLEMENTATION.

  METHOD create_in.
    CREATE OBJECT instance TYPE lcl_in.
  ENDMETHOD.

  METHOD create_out.
    CREATE OBJECT instance TYPE lcl_out.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_CONV_IN_CE                      ', 'CLASS cl_abap_conv_in_ce DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS
      create
        IMPORTING
          encoding    TYPE abap_encoding DEFAULT ''UTF-8''
          input       TYPE xstring OPTIONAL
          replacement TYPE char1 DEFAULT ''#''
          ignore_cerr TYPE abap_bool DEFAULT abap_false
          endian      TYPE char1 OPTIONAL
        RETURNING
          VALUE(ret)  TYPE REF TO cl_abap_conv_in_ce.

    CLASS-METHODS
      uccpi
        IMPORTING
          value TYPE i
        RETURNING
          VALUE(ret) TYPE string.

    TYPES ty_char2 TYPE c LENGTH 2.
    CLASS-METHODS uccp
      IMPORTING
        uccp        TYPE simple
      RETURNING
        VALUE(char_) TYPE ty_char2.

    METHODS convert
      IMPORTING
        input TYPE xsequence
        n     TYPE i OPTIONAL
      EXPORTING
        data  TYPE string.

    METHODS read
      IMPORTING
        n     TYPE i OPTIONAL
      EXPORTING
        data  TYPE string.
  PRIVATE SECTION.
    DATA mv_input TYPE xstring.
    DATA mv_js_encoding TYPE string.
    DATA mv_ignore_cerr TYPE abap_bool.
ENDCLASS.

CLASS cl_abap_conv_in_ce IMPLEMENTATION.
  METHOD create.
    ASSERT replacement = ''#''. " todo
    ASSERT endian IS INITIAL. " todo

    CREATE OBJECT ret.

    CASE encoding.
      WHEN ''UTF-8''.
        ret->mv_js_encoding = ''utf8''.
      WHEN ''4103''.
        ret->mv_js_encoding = ''utf-16le''.
      WHEN OTHERS.
        ASSERT 1 = ''not supported''.
    ENDCASE.

    ret->mv_input = input.
    ret->mv_ignore_cerr = ignore_cerr.
  ENDMETHOD.

  METHOD uccp.
    DATA int TYPE i.
    DATA hex TYPE x LENGTH 2.
    hex = uccp.
    int = hex.
    TRY.
        char_ = uccpi( int ).
      CATCH cx_sy_conversion_codepage.
* todo, hmm
    ENDTRY.
  ENDMETHOD.

  METHOD uccpi.
    DATA lv_hex TYPE x LENGTH 2.
    DATA lo_in  TYPE REF TO cl_abap_conv_in_ce.

    lv_hex = value.
    " switch to little endian
    CONCATENATE lv_hex+1(1) lv_hex(1) INTO lv_hex IN BYTE MODE.

    lo_in = create( encoding = ''4103'' ).

    lo_in->convert(
      EXPORTING
        input = lv_hex
      IMPORTING
        data  = ret ).
  ENDMETHOD.

  METHOD convert.
    DATA lv_error TYPE abap_bool.

    ASSERT mv_js_encoding IS NOT INITIAL.
    WRITE ''@KERNEL let buf = Buffer.from(input.get(), "hex");''.

    " Try TextDecoder first, if it runs in browser,
    WRITE ''@KERNEL const decoder = TextDecoder || await import("util").TextDecoder;''.
    WRITE ''@KERNEL const td = new decoder(this.mv_js_encoding.get(), {fatal: this.mv_ignore_cerr.get() !== "X"});''.
    WRITE ''@KERNEL try {''.
    WRITE ''@KERNEL   data.set(td.decode(buf));''.
    WRITE ''@KERNEL } catch {''.
    lv_error = abap_true.
    WRITE ''@KERNEL }''.

    IF lv_error = abap_true.
      RAISE EXCEPTION TYPE cx_sy_conversion_codepage.
    ENDIF.

* old    WRITE ''@KERNEL let result = buf.toString(this.mv_js_encoding.get());''.
* old    WRITE ''@KERNEL data.set(result);''.
  ENDMETHOD.

  METHOD read.
    convert(
      EXPORTING
        input = mv_input
        n     = n
      IMPORTING
        data  = data ).
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_CONV_OUT_CE                     ', 'CLASS cl_abap_conv_out_ce DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS
      create
        IMPORTING
          encoding    TYPE abap_encoding OPTIONAL
          ignore_cerr TYPE abap_bool DEFAULT abap_false
          endian      TYPE string OPTIONAL
          replacement TYPE string OPTIONAL
        RETURNING
          VALUE(ret)  TYPE REF TO cl_abap_conv_out_ce.

    CLASS-METHODS
      uccpi
        IMPORTING
          char_       TYPE clike
        RETURNING
          VALUE(ret) TYPE i.

    TYPES hex02 TYPE x LENGTH 2.
    CLASS-METHODS uccp
      IMPORTING
        char_        TYPE clike
      RETURNING
        VALUE(uccp) TYPE hex02
      RAISING
        cx_sy_conversion_codepage
        cx_sy_codepage_converter_init
        cx_parameter_invalid_range.

    METHODS
      convert
        IMPORTING
          data   TYPE simple
          n      TYPE i OPTIONAL
        EXPORTING
          buffer TYPE xstring.

    METHODS write
      IMPORTING
        data TYPE any.

    METHODS get_buffer
      RETURNING
        VALUE(buffer) TYPE xstring.

    METHODS reset.
  PRIVATE SECTION.
    DATA mv_js_encoding TYPE string.
    DATA mv_buffer TYPE xstring.
ENDCLASS.

CLASS cl_abap_conv_out_ce IMPLEMENTATION.
  METHOD create.
    CREATE OBJECT ret.
    CASE encoding.
      WHEN ''UTF-8'' OR ''''.
        ret->mv_js_encoding = ''utf8''.
      WHEN ''4103''.
        ret->mv_js_encoding = ''utf16le''.
      WHEN OTHERS.
        ASSERT 1 = ''not supported''.
    ENDCASE.
  ENDMETHOD.

  METHOD uccpi.
    DATA lo_out TYPE REF TO cl_abap_conv_out_ce.
    DATA lv_hex TYPE xstring.

    lo_out = create( encoding = ''4103'' ).
    lo_out->convert(
      EXPORTING
        data   = char_
      IMPORTING
        buffer = lv_hex ).
    ASSERT xstrlen( lv_hex ) = 2.
    ret = lv_hex(1).
    ret = ret + lv_hex+1(1) * 255.
  ENDMETHOD.

  METHOD write.
    DATA res TYPE xstring.
    convert( EXPORTING data = data
             IMPORTING buffer = res ).
    CONCATENATE mv_buffer res INTO mv_buffer IN BYTE MODE.
  ENDMETHOD.

  METHOD get_buffer.
    buffer = mv_buffer.
  ENDMETHOD.

  METHOD uccp.
    DATA lv_char TYPE c LENGTH 1.
    DATA lo_obj  TYPE REF TO cl_abap_conv_out_ce.

    lv_char = char_(1).
    lo_obj = create( encoding = ''4103'' ).

    lo_obj->convert( EXPORTING data = lv_char
                     IMPORTING buffer = uccp ).

    SHIFT uccp LEFT CIRCULAR IN BYTE MODE.
  ENDMETHOD.

  METHOD reset.
    CLEAR mv_buffer.
  ENDMETHOD.

  METHOD convert.
    DATA lv_str TYPE string.

    WRITE ''@KERNEL let result = "";''.
*    WRITE ''@KERNEL console.dir(n);''.
    IF n IS SUPPLIED.
      lv_str = data.
      lv_str = lv_str(n).
      WRITE ''@KERNEL result = Buffer.from(lv_str.get(), this.mv_js_encoding.get()).toString("hex");''.
    ELSE.
      WRITE ''@KERNEL result = Buffer.from(data.get(), this.mv_js_encoding.get()).toString("hex");''.
    ENDIF.
    WRITE ''@KERNEL buffer.set(result.toUpperCase());''.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_GDT_CONVERSION                       ', 'CLASS cl_gdt_conversion DEFINITION PUBLIC.

  PUBLIC SECTION.
    CLASS-METHODS language_code_outbound
      IMPORTING
        im_value TYPE spras
      EXPORTING
        ex_value TYPE laiso.

    CLASS-METHODS language_code_inbound
      IMPORTING
        im_value TYPE csequence
      EXPORTING
        ex_value TYPE spras
      RAISING
        cx_gdt_conversion.

    CLASS-METHODS amount_outbound
      IMPORTING
        im_value         TYPE p
        im_currency_code TYPE clike
      EXPORTING
        ex_value         TYPE p
      RAISING
        cx_gdt_conversion.

    CLASS-METHODS country_code_outbound
      IMPORTING
        im_value TYPE land1
      EXPORTING
        ex_value TYPE csequence
      RAISING
        cx_gdt_conversion.

    CLASS-METHODS date_time_inbound
      IMPORTING
        im_value       TYPE csequence
      EXPORTING
        ex_value_short TYPE timestamp
      RAISING
        cx_gdt_conversion.

    CLASS-METHODS unit_code_inbound
      IMPORTING
        im_value TYPE csequence
      EXPORTING
        ex_value TYPE msehi
      RAISING
        cx_gdt_conversion.

    CLASS-METHODS unit_code_outbound
      IMPORTING
        im_value TYPE msehi
      EXPORTING
        ex_value TYPE csequence
      RAISING
        cx_gdt_conversion.

ENDCLASS.

CLASS cl_gdt_conversion IMPLEMENTATION.

  METHOD amount_outbound.
    CASE im_currency_code.
      WHEN ''DKK'' OR ''EUR'' OR ''USD''.
        ex_value = im_value.
      WHEN ''VND''.
        ex_value = im_value * 100.
      WHEN OTHERS.
        ASSERT 1 = ''todo''.
    ENDCASE.
  ENDMETHOD.

  METHOD language_code_inbound.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD unit_code_outbound.
    CASE im_value.
      WHEN ''''.
        RAISE EXCEPTION TYPE cx_gdt_conversion.
      WHEN ''ST''.
        ex_value = ''PCE''.
      WHEN ''KG''.
        ex_value = ''KGM''.
      WHEN ''CDM''.
        ex_value = ''DMQ''.
      WHEN OTHERS.
        ASSERT 1 = ''todo''.
    ENDCASE.
  ENDMETHOD.

  METHOD country_code_outbound.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD date_time_inbound.
    DATA lv_str TYPE string.

    IF im_value NP ''*Z''.
      ASSERT 1 = ''todo, only handles UTC for now''.
    ENDIF.

    lv_str = im_value.
    REPLACE ALL OCCURRENCES OF ''-'' IN lv_str WITH ''''.
    REPLACE ALL OCCURRENCES OF '':'' IN lv_str WITH ''''.
    REPLACE ALL OCCURRENCES OF ''T'' IN lv_str WITH ''''.
    REPLACE ALL OCCURRENCES OF ''Z'' IN lv_str WITH ''''.
    ex_value_short = lv_str.
  ENDMETHOD.

  METHOD unit_code_inbound.

* todo, first look up in database, if there is no database connected, fallback to below

    CASE im_value.
      WHEN ''MTR''.
        ex_value = ''M''.
      WHEN ''PCE''.
        ex_value = ''PC''.
      WHEN ''KGM''.
        ex_value = ''KG''.
      WHEN ''LTR''.
        ex_value = ''L''.
      WHEN OTHERS.
        ASSERT 1 = ''todo''.
    ENDCASE.

  ENDMETHOD.

  METHOD language_code_outbound.

    cl_i18n_languages=>sap1_to_sap2(
      EXPORTING
        im_lang_sap1  = im_value
      RECEIVING
        re_lang_sap2  = ex_value
      EXCEPTIONS
        no_assignment = 1
        OTHERS        = 2 ).
    TRANSLATE ex_value TO LOWER CASE.
    IF sy-subrc <> 0.
      RAISE EXCEPTION TYPE cx_gdt_conversion.
    ENDIF.

  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_GDT_CONVERSION                       ', 'CLASS cx_gdt_conversion DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_gdt_conversion IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_ABAP_CONV_IN                         ', 'INTERFACE if_abap_conv_in PUBLIC.

  METHODS convert
    IMPORTING
      source TYPE xstring
    RETURNING
      VALUE(result) TYPE string
    RAISING
      cx_sy_conversion_codepage.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_ABAP_CONV_OUT                        ', 'INTERFACE if_abap_conv_out PUBLIC.

  METHODS convert
    IMPORTING
      source TYPE string
    RETURNING
      VALUE(result) TYPE xstring
    RAISING
      cx_sy_conversion_codepage.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_DATFM                           ', 'CLASS cl_abap_datfm DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS conv_date_ext_to_int
      IMPORTING
        im_datext    TYPE csequence
        im_datfmdes  TYPE char1 OPTIONAL
      EXPORTING
        ex_datint    TYPE d
        ex_datfmused TYPE char1
      RAISING
        cx_abap_datfm.

    CLASS-METHODS get_date_format_des
      IMPORTING
        im_datfm      TYPE char1 OPTIONAL
        im_langu      TYPE spras DEFAULT sy-langu
        im_plain      TYPE abap_bool DEFAULT abap_false
        im_long       TYPE abap_bool DEFAULT abap_false
      EXPORTING
        ex_dateformat TYPE csequence
      RAISING
        cx_abap_datfm.

    CLASS-METHODS conv_period_ext_to_int
      IMPORTING
        im_periodext TYPE csequence
      EXPORTING
        ex_periodint TYPE csequence
      RAISING
        cx_abap_datfm.

  PRIVATE SECTION.
    CONSTANTS ddmmyyyy_dot_seperated TYPE c VALUE ''1''.
    CONSTANTS yyyymmdd_dot_seperated TYPE c VALUE ''4''.
ENDCLASS.

CLASS cl_abap_datfm IMPLEMENTATION.

  METHOD conv_period_ext_to_int.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD conv_date_ext_to_int.
    DATA regex_ddmmyyyy_dot_seperated TYPE string VALUE ''^(0[0-9]|[12][0-9]|3[01])[- \\..](0[0-9]|1[012])[- \\..]\\d\\d\\d\\d$''.
    DATA regex_yyyymmdd_dot_seperated TYPE string VALUE ''^\\d\\d\\d\\d[- \\..](0[0-9]|1[012])[- \\..](0[0-9]|[12][0-9]|3[01])$''.
    DATA regex_yyyymmdd_no_dot TYPE string VALUE ''^(\\d{4})(0[0-9]|1[012])(0[0-9]|[12][0-9]|3[01])$''.

    IF im_datfmdes <> ddmmyyyy_dot_seperated
        AND im_datfmdes <> yyyymmdd_dot_seperated.
      RAISE EXCEPTION TYPE cx_abap_datfm.
    ENDIF.

    FIND ALL OCCURRENCES OF REGEX regex_ddmmyyyy_dot_seperated IN im_datext.
    IF sy-subrc = 0.
      ex_datint = im_datext+6(4) && im_datext+3(2) && im_datext(2).
      ex_datfmused = ddmmyyyy_dot_seperated.
      RETURN.
    ENDIF.

    FIND ALL OCCURRENCES OF REGEX regex_yyyymmdd_dot_seperated IN im_datext.
    IF sy-subrc = 0.
      ex_datint = im_datext(4) && im_datext+5(2) && im_datext+8(2).
      ex_datfmused = yyyymmdd_dot_seperated.
      RETURN.
    ENDIF.

    FIND ALL OCCURRENCES OF REGEX regex_yyyymmdd_no_dot IN im_datext.
    IF sy-subrc = 0.
      ex_datint = im_datext.
      ex_datfmused = yyyymmdd_dot_seperated.
      RETURN.
    ENDIF.

    RAISE EXCEPTION TYPE cx_abap_datfm.
  ENDMETHOD.

  METHOD get_date_format_des.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_TIMEFM                          ', 'CLASS cl_abap_timefm DEFINITION PUBLIC.
  PUBLIC SECTION.
    TYPES ty_format TYPE i.
    TYPES ty_timefm TYPE c LENGTH 1.

    CLASS-METHODS conv_time_ext_to_int
      IMPORTING
        time_ext        TYPE csequence
        is_24_allowed   TYPE abap_bool DEFAULT abap_false
      EXPORTING
        time_int        TYPE t
      RAISING
        cx_abap_timefm_invalid.

    CLASS-METHODS conv_time_int_to_ext
      IMPORTING
        time_int TYPE t
      EXPORTING
        time_ext TYPE string
      RAISING
        cx_parameter_invalid_range.

    CLASS-METHODS get_environment_timefm
      RETURNING
        VALUE(timefm) TYPE ty_timefm.
ENDCLASS.

CLASS cl_abap_timefm IMPLEMENTATION.

  METHOD conv_time_ext_to_int.
    DATA lv_text TYPE string.

* todo,
    ASSERT is_24_allowed = abap_true.

    FIND REGEX ''^([0-1]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$'' IN time_ext.
    IF sy-subrc <> 0.
      RAISE EXCEPTION TYPE cx_abap_timefm_invalid.
    ENDIF.

    lv_text = time_ext.
    REPLACE ALL OCCURRENCES OF '':'' IN lv_text WITH ''''.
    time_int = lv_text.
  ENDMETHOD.

  METHOD conv_time_int_to_ext.
    time_ext = |{ time_int TIME = ISO }|.
  ENDMETHOD.

  METHOD get_environment_timefm.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_TSTMP                           ', 'CLASS cl_abap_tstmp DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS subtract
      IMPORTING
        tstmp1        TYPE p
        tstmp2        TYPE p
      RETURNING
        VALUE(r_secs) TYPE i.

    CLASS-METHODS add
      IMPORTING
        tstmp       TYPE p
        secs        TYPE numeric
      RETURNING
        VALUE(time) TYPE timestamp.

    CLASS-METHODS subtractsecs
      IMPORTING
        tstmp       TYPE p
        secs        TYPE numeric
      RETURNING
        VALUE(time) TYPE timestamp.

    CLASS-METHODS td_add
      IMPORTING
        date     TYPE d
        time     TYPE t
        secs     TYPE numeric
      EXPORTING
        res_date TYPE d
        res_time TYPE t.

    CLASS-METHODS move
      IMPORTING
        tstmp_src TYPE p
      EXPORTING
        tstmp_tgt TYPE p.

    CLASS-METHODS systemtstmp_syst2utc
      IMPORTING
        syst_date TYPE d
        syst_time TYPE t
      EXPORTING
        utc_tstmp TYPE p
      RAISING
        cx_parameter_invalid_range.

    CLASS-METHODS move_to_short
      IMPORTING
        tstmp_src        TYPE tzntstmpl
      RETURNING
        VALUE(tstmp_out) TYPE tzntstmps
      RAISING
        cx_parameter_invalid_type
        cx_parameter_invalid_range.

    CLASS-METHODS td_subtract
      IMPORTING
        date1 TYPE d
        time1 TYPE t
        date2 TYPE d
        time2 TYPE t
      EXPORTING
        res_secs TYPE numeric
      RAISING
        cx_parameter_invalid_type
        cx_parameter_invalid_range.

    CLASS-METHODS systemtstmp_utc2syst
      IMPORTING
        utc_tstmp TYPE timestamp
      EXPORTING
        syst_date TYPE d
        syst_time TYPE t
      RAISING
        cx_parameter_invalid_range.
ENDCLASS.

CLASS cl_abap_tstmp IMPLEMENTATION.

  METHOD td_add.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD systemtstmp_utc2syst.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD move.
* todo, this is most likely wrong, but will also work in some cases
* todo, input is generic packed? which is unknown to abaplint
    tstmp_tgt = tstmp_src.
  ENDMETHOD.

  METHOD systemtstmp_syst2utc.
* system timezone is always UTC for open-abap, so no conversion needed
    IF syst_date IS INITIAL.
      RAISE EXCEPTION TYPE cx_parameter_invalid_range.
    ENDIF.

    utc_tstmp = |{ syst_date }{ syst_time }|.
  ENDMETHOD.

  METHOD subtract.
    DATA str      TYPE string.
    DATA lv_dummy TYPE string.
    str = |{ tstmp1 TIMESTAMP = ISO }|.
    IF str CA '',''.
      SPLIT str AT '','' INTO str lv_dummy.
    ENDIF.
    WRITE ''@KERNEL let t1 = Date.parse(str.get());''.
    str = |{ tstmp2 TIMESTAMP = ISO }|.
    IF str CA '',''.
      SPLIT str AT '','' INTO str lv_dummy.
    ENDIF.
    WRITE ''@KERNEL let t2 = Date.parse(str.get());''.
    WRITE ''@KERNEL r_secs.set((t1 - t2)/1000);''.
  ENDMETHOD.

  METHOD add.
    DATA str      TYPE string.
    DATA lv_dummy TYPE string.
    str = |{ tstmp TIMESTAMP = ISO }|.
    IF str CA '',''.
      SPLIT str AT '','' INTO str lv_dummy.
    ENDIF.
    WRITE ''@KERNEL let t1 = new Date(Date.parse(str.get() + "Z"));''.
    WRITE ''@KERNEL t1.setSeconds( t1.getSeconds() + secs.get() );''.
    WRITE ''@KERNEL time.set(t1.toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", ""));''.
  ENDMETHOD.

  METHOD subtractsecs.
    DATA lv_secs TYPE i.
    lv_secs = secs * -1.
    time = add(
      tstmp = tstmp
      secs  = lv_secs ).
  ENDMETHOD.

  METHOD move_to_short.
    move(
      EXPORTING
        tstmp_src = tstmp_src
      IMPORTING
        tstmp_tgt = tstmp_out ).
  ENDMETHOD.

  METHOD td_subtract.
    DATA lv_stamp1 TYPE timestamp.
    DATA lv_stamp2 TYPE timestamp.

    CONVERT DATE date1 TIME time1 INTO TIME STAMP lv_stamp1.
    CONVERT DATE date2 TIME time2 INTO TIME STAMP lv_stamp2.

    res_secs = subtract(
      tstmp1 = lv_stamp1
      tstmp2 = lv_stamp2 ).
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_ABAP_DATFM                           ', 'CLASS cx_abap_datfm DEFINITION PUBLIC INHERITING FROM cx_static_check.

ENDCLASS.

CLASS cx_abap_datfm IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_ABAP_TIMEFM_INVALID                  ', 'CLASS cx_abap_timefm_invalid DEFINITION PUBLIC INHERITING FROM cx_static_check.

ENDCLASS.

CLASS cx_abap_timefm_invalid IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_DYNAMIC_CHECK                        ', 'CLASS cx_dynamic_check DEFINITION ABSTRACT PUBLIC INHERITING FROM cx_root.

ENDCLASS.

CLASS cx_dynamic_check IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_NO_CHECK                             ', 'CLASS cx_no_check DEFINITION PUBLIC INHERITING FROM cx_root.

  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        textid   LIKE textid OPTIONAL
        previous TYPE REF TO cx_root OPTIONAL.

ENDCLASS.

CLASS cx_no_check IMPLEMENTATION.

  METHOD constructor.
    super->constructor(
      previous = previous
      textid   = textid ).
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_PARAMETER_INVALID                    ', 'CLASS cx_parameter_invalid DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.
  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        textid    LIKE textid OPTIONAL
        previous  LIKE previous OPTIONAL
        parameter TYPE string OPTIONAL.
ENDCLASS.

CLASS cx_parameter_invalid IMPLEMENTATION.
  METHOD constructor.
    super->constructor(
      textid   = textid
      previous = previous ).
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_PARAMETER_INVALID_RANGE              ', 'CLASS cx_parameter_invalid_range DEFINITION PUBLIC INHERITING FROM cx_parameter_invalid.
  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        textid    LIKE textid OPTIONAL
        previous  LIKE previous OPTIONAL
        parameter TYPE string OPTIONAL
        value     TYPE string OPTIONAL.
ENDCLASS.

CLASS cx_parameter_invalid_range IMPLEMENTATION.
  METHOD constructor.
    super->constructor(
      textid    = textid
      previous  = previous
      parameter = parameter ).
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_PARAMETER_INVALID_TYPE               ', 'CLASS cx_parameter_invalid_type DEFINITION PUBLIC INHERITING FROM cx_parameter_invalid.

ENDCLASS.

CLASS cx_parameter_invalid_type IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_ROOT                                 ', 'CLASS cx_root DEFINITION ABSTRACT PUBLIC.
  PUBLIC SECTION.
    DATA previous TYPE REF TO cx_root.
    DATA textid   TYPE c LENGTH 32.

    METHODS constructor
      IMPORTING
        textid   LIKE textid OPTIONAL
        previous TYPE REF TO cx_root OPTIONAL.

    METHODS get_source_position
      EXPORTING
        program_name TYPE string
        include_name TYPE string
        source_line  TYPE i.

    INTERFACES if_message.
    ALIASES get_longtext FOR if_message~get_longtext.
    ALIASES get_text FOR if_message~get_text.

ENDCLASS.

CLASS cx_root IMPLEMENTATION.

  METHOD constructor.
    me->previous = previous.
    me->textid = textid.
  ENDMETHOD.

  METHOD get_source_position.
    CLEAR program_name.
    CLEAR include_name.
    CLEAR source_line.

    WRITE ''@KERNEL source_line.set(this.EXTRA_CX.INTERNAL_LINE || 1);''.
    WRITE ''@KERNEL program_name.set(this.EXTRA_CX.INTERNAL_FILENAME || "error");''.
  ENDMETHOD.

  METHOD if_message~get_longtext.
    result = ''OpenAbapGetLongtextDummyValue''.
  ENDMETHOD.

  METHOD if_message~get_text.
    result = cl_message_helper=>get_text_for_message( me ).
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_ST_ERROR                             ', 'CLASS cx_st_error DEFINITION PUBLIC INHERITING FROM cx_transformation_error.

ENDCLASS.

CLASS cx_st_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_STATIC_CHECK                         ', 'CLASS cx_static_check DEFINITION PUBLIC INHERITING FROM cx_root.

  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        textid   LIKE textid OPTIONAL
        previous TYPE REF TO cx_root OPTIONAL.
ENDCLASS.

CLASS cx_static_check IMPLEMENTATION.

  METHOD constructor.
    super->constructor(
      textid   = textid
      previous = previous ).
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_ARITHMETIC_ERROR                  ', 'CLASS cx_sy_arithmetic_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_sy_arithmetic_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_ARITHMETIC_OVERFLOW               ', 'CLASS cx_sy_arithmetic_overflow DEFINITION PUBLIC INHERITING FROM cx_sy_arithmetic_error.

  PUBLIC SECTION.
    METHODS if_message~get_text REDEFINITION.

ENDCLASS.

CLASS cx_sy_arithmetic_overflow IMPLEMENTATION.

  METHOD if_message~get_text.
    result = ''Arithmetic overflow''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_BUFFER_OVERFLOW                   ', 'CLASS cx_sy_buffer_overflow DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_sy_buffer_overflow IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_CODEPAGE_CONVERTER_INIT           ', 'CLASS cx_sy_codepage_converter_init DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_sy_codepage_converter_init IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_COMPRESSION_ERROR                 ', 'CLASS cx_sy_compression_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_sy_compression_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_CONVERSION_CODEPAGE               ', 'CLASS cx_sy_conversion_codepage DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.
  PUBLIC SECTION.
    DATA source_extract TYPE xstring.
ENDCLASS.

CLASS cx_sy_conversion_codepage IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_CONVERSION_DATA_LOSS              ', 'CLASS cx_sy_conversion_data_loss DEFINITION PUBLIC INHERITING FROM cx_sy_conversion_error.

ENDCLASS.

CLASS cx_sy_conversion_data_loss IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_CONVERSION_ERROR                  ', 'CLASS cx_sy_conversion_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_sy_conversion_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_CONVERSION_NO_NUMBER              ', 'CLASS cx_sy_conversion_no_number DEFINITION PUBLIC INHERITING FROM cx_sy_conversion_error.

  PUBLIC SECTION.
    METHODS if_message~get_text REDEFINITION.

ENDCLASS.

CLASS cx_sy_conversion_no_number IMPLEMENTATION.

  METHOD if_message~get_text.
    result = ''Conversion no number''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_CONVERSION_OVERFLOW               ', 'CLASS cx_sy_conversion_overflow DEFINITION PUBLIC INHERITING FROM cx_sy_conversion_error.
  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        textid   LIKE textid OPTIONAL
        previous LIKE previous OPTIONAL
        value    TYPE string OPTIONAL.
ENDCLASS.

CLASS cx_sy_conversion_overflow IMPLEMENTATION.
  METHOD constructor.
    super->constructor(
      textid   = textid
      previous = previous ).
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_CREATE_DATA_ERROR                 ', 'CLASS cx_sy_create_data_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_sy_create_data_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_CREATE_OBJECT_ERROR               ', 'CLASS cx_sy_create_object_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.
  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        textid    LIKE textid OPTIONAL
        previous  LIKE previous OPTIONAL
        classname TYPE string OPTIONAL.

    METHODS if_message~get_text REDEFINITION.

    DATA classname TYPE string READ-ONLY.
ENDCLASS.

CLASS cx_sy_create_object_error IMPLEMENTATION.

  METHOD constructor.
    super->constructor(
      textid   = textid
      previous = previous ).
    me->classname = classname.
  ENDMETHOD.

  METHOD if_message~get_text.
    result = ''The object could not be created: The class ??? does not exist.''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_DATA_ACCESS_ERROR                 ', 'CLASS cx_sy_data_access_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_sy_data_access_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_DUPLICATE_KEY                     ', 'CLASS cx_sy_duplicate_key DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_sy_duplicate_key IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_DYN_CALL_ERROR                    ', 'CLASS cx_sy_dyn_call_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_sy_dyn_call_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_DYN_CALL_ILLEGAL_CLASS            ', 'CLASS cx_sy_dyn_call_illegal_class DEFINITION PUBLIC INHERITING FROM cx_sy_dyn_call_error.

ENDCLASS.

CLASS cx_sy_dyn_call_illegal_class IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_DYN_CALL_ILLEGAL_FORM             ', 'CLASS cx_sy_dyn_call_illegal_form DEFINITION PUBLIC INHERITING FROM cx_sy_dyn_call_error.

ENDCLASS.

CLASS cx_sy_dyn_call_illegal_form IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_DYN_CALL_ILLEGAL_FUNC             ', 'CLASS cx_sy_dyn_call_illegal_func DEFINITION PUBLIC INHERITING FROM cx_sy_dyn_call_error.

ENDCLASS.

CLASS cx_sy_dyn_call_illegal_func IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_DYN_CALL_ILLEGAL_METHOD           ', 'CLASS cx_sy_dyn_call_illegal_method DEFINITION PUBLIC INHERITING FROM cx_sy_dyn_call_error.

  PUBLIC SECTION.
    CONSTANTS private_method TYPE sotr_conc VALUE ''11111111111111111111111111111111''.

    METHODS constructor
      IMPORTING
        textid     LIKE textid OPTIONAL
        previous   LIKE previous OPTIONAL
        classname  TYPE string OPTIONAL
        methodname TYPE string OPTIONAL.

ENDCLASS.

CLASS cx_sy_dyn_call_illegal_method IMPLEMENTATION.

  METHOD constructor.
    super->constructor( previous = previous ).
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_DYN_CALL_PARAM_NOT_FOUND          ', 'CLASS cx_sy_dyn_call_param_not_found DEFINITION PUBLIC INHERITING FROM cx_sy_dyn_call_parameter_error.

ENDCLASS.

CLASS cx_sy_dyn_call_param_not_found IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_DYN_CALL_PARAMETER_ERROR          ', 'CLASS cx_sy_dyn_call_parameter_error DEFINITION PUBLIC INHERITING FROM cx_sy_dyn_call_error.
  PUBLIC SECTION.
    DATA parameter TYPE string.
ENDCLASS.

CLASS cx_sy_dyn_call_parameter_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_DYNAMIC_OSQL_ERROR                ', 'CLASS cx_sy_dynamic_osql_error DEFINITION PUBLIC INHERITING FROM cx_sy_open_sql_error.
  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        sqlmsg TYPE string OPTIONAL.
ENDCLASS.

CLASS cx_sy_dynamic_osql_error IMPLEMENTATION.
  METHOD constructor.
    super->constructor( sqlmsg = sqlmsg ).
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_DYNAMIC_OSQL_SEMANTICS            ', 'CLASS cx_sy_dynamic_osql_semantics DEFINITION PUBLIC INHERITING FROM cx_sy_dynamic_osql_error.
  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        sqlmsg TYPE string OPTIONAL.
ENDCLASS.

CLASS cx_sy_dynamic_osql_semantics IMPLEMENTATION.
  METHOD constructor.
    super->constructor( sqlmsg = sqlmsg ).
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_ITAB_DUPLICATE_KEY                ', 'CLASS cx_sy_itab_duplicate_key DEFINITION PUBLIC INHERITING FROM cx_sy_itab_error.

ENDCLASS.

CLASS cx_sy_itab_duplicate_key IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_ITAB_ERROR                        ', 'CLASS cx_sy_itab_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_sy_itab_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_ITAB_LINE_NOT_FOUND               ', 'CLASS cx_sy_itab_line_not_found DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_sy_itab_line_not_found IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_MESSAGE_ILLEGAL_TEXT              ', 'CLASS cx_sy_message_illegal_text DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.
  PUBLIC SECTION.
ENDCLASS.

CLASS cx_sy_message_illegal_text IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_MOVE_CAST_ERROR                   ', 'CLASS cx_sy_move_cast_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

  PUBLIC SECTION.
    METHODS if_message~get_text REDEFINITION.

ENDCLASS.

CLASS cx_sy_move_cast_error IMPLEMENTATION.

  METHOD if_message~get_text.
    result = ''Casting failed, types not compatible''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_OPEN_SQL_ERROR                    ', 'CLASS cx_sy_open_sql_error DEFINITION PUBLIC INHERITING FROM cx_sy_sql_error.
  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        sqlmsg TYPE string OPTIONAL.
ENDCLASS.

CLASS cx_sy_open_sql_error IMPLEMENTATION.
  METHOD constructor.
    super->constructor( sqlmsg = sqlmsg ).
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_RANGE_OUT_OF_BOUNDS               ', 'CLASS cx_sy_range_out_of_bounds DEFINITION PUBLIC INHERITING FROM cx_sy_data_access_error.

  PUBLIC SECTION.
    METHODS if_message~get_text REDEFINITION.

ENDCLASS.

CLASS cx_sy_range_out_of_bounds IMPLEMENTATION.

  METHOD if_message~get_text.
    result = ''Range out of bounds''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_REF_IS_INITIAL                    ', 'CLASS cx_sy_ref_is_initial DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_sy_ref_is_initial IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_SQL_ERROR                         ', 'CLASS cx_sy_sql_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.
  PUBLIC SECTION.
    DATA sqlmsg TYPE string.

    METHODS constructor
      IMPORTING
        sqlmsg TYPE string OPTIONAL.
ENDCLASS.

CLASS cx_sy_sql_error IMPLEMENTATION.
  METHOD constructor.
    super->constructor( ).
    me->sqlmsg = sqlmsg.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_STRG_PAR_VAL                      ', 'CLASS cx_sy_strg_par_val DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.
  PUBLIC SECTION.
ENDCLASS.

CLASS cx_sy_strg_par_val IMPLEMENTATION.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_STRUCT_ATTRIBUTES                 ', 'CLASS cx_sy_struct_attributes DEFINITION PUBLIC INHERITING FROM cx_sy_struct_creation.

ENDCLASS.

CLASS cx_sy_struct_attributes IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_STRUCT_COMP_NAME                  ', 'CLASS cx_sy_struct_comp_name DEFINITION PUBLIC INHERITING FROM cx_sy_struct_creation.

ENDCLASS.

CLASS cx_sy_struct_comp_name IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_STRUCT_COMP_TYPE                  ', 'CLASS cx_sy_struct_comp_type DEFINITION PUBLIC INHERITING FROM cx_sy_struct_creation.

ENDCLASS.

CLASS cx_sy_struct_comp_type IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_STRUCT_CREATION                   ', 'CLASS cx_sy_struct_creation DEFINITION PUBLIC INHERITING FROM cx_sy_type_creation.

ENDCLASS.

CLASS cx_sy_struct_creation IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_TYPE_CREATION                     ', 'CLASS cx_sy_type_creation DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_sy_type_creation IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_ZERODIVIDE                        ', 'CLASS cx_sy_zerodivide DEFINITION PUBLIC INHERITING FROM cx_sy_arithmetic_error.
  PUBLIC SECTION.
    METHODS if_message~get_text REDEFINITION.
ENDCLASS.

CLASS cx_sy_zerodivide IMPLEMENTATION.

  METHOD if_message~get_text.
    result = ''Division by zero.''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_TRANSFORMATION_ERROR                 ', 'CLASS cx_transformation_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_transformation_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_XSLT_EXCEPTION                       ', 'CLASS cx_xslt_exception DEFINITION PUBLIC INHERITING FROM cx_transformation_error.

ENDCLASS.

CLASS cx_xslt_exception IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_XSLT_FORMAT_ERROR                    ', 'CLASS cx_xslt_format_error DEFINITION PUBLIC INHERITING FROM cx_xslt_system_error.

ENDCLASS.

CLASS cx_xslt_format_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_XSLT_RUNTIME_ERROR                   ', 'CLASS cx_xslt_runtime_error DEFINITION PUBLIC INHERITING FROM cx_transformation_error.

ENDCLASS.

CLASS cx_xslt_runtime_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_XSLT_SERIALIZATION_ERROR             ', 'CLASS cx_xslt_serialization_error DEFINITION PUBLIC INHERITING FROM cx_xslt_system_error.

ENDCLASS.

CLASS cx_xslt_serialization_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_XSLT_SYSTEM_ERROR                    ', 'CLASS cx_xslt_system_error DEFINITION PUBLIC INHERITING FROM cx_xslt_exception.

ENDCLASS.

CLASS cx_xslt_system_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_MESSAGE                              ', 'INTERFACE if_message PUBLIC.

  METHODS get_text RETURNING VALUE(result) TYPE string.

  METHODS get_longtext
    IMPORTING preserve_newlines TYPE abap_bool OPTIONAL
    RETURNING VALUE(result) TYPE string.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_T100_DYN_MSG                         ', 'INTERFACE if_t100_dyn_msg PUBLIC.

  DATA msgty TYPE symsgty.

  DATA msgv1 TYPE symsgv.
  DATA msgv2 TYPE symsgv.
  DATA msgv3 TYPE symsgv.
  DATA msgv4 TYPE symsgv.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_T100_MESSAGE                         ', 'INTERFACE if_t100_message PUBLIC.

  DATA t100key TYPE scx_t100key.

  CONSTANTS:
    BEGIN OF default_textid,
      msgid TYPE symsgid VALUE ''AB'',
      msgno TYPE symsgno VALUE ''123'',
      attr1 TYPE scx_attrname VALUE '''',
      attr2 TYPE scx_attrname VALUE '''',
      attr3 TYPE scx_attrname VALUE '''',
      attr4 TYPE scx_attrname VALUE '''',
    END OF default_textid.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_FUGR_TEST                        ', 'CLASS kernel_fugr_test DEFINITION PUBLIC.
  PUBLIC SECTION.
ENDCLASS.

CLASS kernel_fugr_test IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_DEMO_OUTPUT                          ', 'CLASS cl_demo_output DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS write
      IMPORTING
        data TYPE any
        name TYPE string OPTIONAL.
    CLASS-METHODS clear.
    CLASS-METHODS display
      IMPORTING
      data TYPE any OPTIONAL
      name TYPE string OPTIONAL PREFERRED PARAMETER data.
ENDCLASS.

CLASS cl_demo_output IMPLEMENTATION.
  METHOD write.
    ASSERT 1 = ''not supported''.
  ENDMETHOD.

  METHOD clear.
    ASSERT 1 = ''not supported''.
  ENDMETHOD.

  METHOD display.
    ASSERT 1 = ''not supported''.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_GUI_CFW                              ', 'CLASS cl_gui_cfw DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS
      compute_pixel_from_metric
        IMPORTING
          x_or_y TYPE c
          in_     TYPE i
        RETURNING
          VALUE(val) TYPE i.

    CLASS-METHODS
      flush.

    CLASS-METHODS
      set_new_ok_code
        IMPORTING new_code
          TYPE clike.
ENDCLASS.

CLASS cl_gui_cfw IMPLEMENTATION.
  METHOD compute_pixel_from_metric.
    val = 1.
  ENDMETHOD.

  METHOD flush.
    RETURN.
  ENDMETHOD.

  METHOD set_new_ok_code.
    ASSERT 1 = ''not implemented''.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_GUI_CONTAINER                        ', 'CLASS cl_gui_container DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-DATA screen0 TYPE REF TO cl_gui_container.
    CLASS-DATA default_screen TYPE REF TO cl_gui_container.
    CONSTANTS visible_true TYPE c LENGTH 1 VALUE ''1''.
    CONSTANTS visible_false TYPE c LENGTH 1 VALUE ''0''.

    METHODS free.
ENDCLASS.

CLASS cl_gui_container IMPLEMENTATION.
  METHOD free.
    ASSERT 1 = ''not supported''.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_GUI_FRONTEND_SERVICES                ', 'CLASS cl_gui_frontend_services DEFINITION PUBLIC.
  PUBLIC SECTION.
    CONSTANTS filetype_all  TYPE string VALUE ''abc''.
    CONSTANTS filetype_xml  TYPE string VALUE ''xml''.
    CONSTANTS filetype_text TYPE string VALUE ''txt''.

    CONSTANTS action_cancel TYPE i VALUE 1.
    CONSTANTS action_ok     TYPE i VALUE 1.

    CONSTANTS platform_nt351 TYPE i VALUE 1.
    CONSTANTS platform_nt40 TYPE i VALUE 2.
    CONSTANTS platform_nt50 TYPE i VALUE 3.
    CONSTANTS platform_windows95 TYPE i VALUE 4.
    CONSTANTS platform_windows98 TYPE i VALUE 5.
    CONSTANTS platform_windowsxp TYPE i VALUE 6.

    CLASS-METHODS
      gui_download
        IMPORTING
          bin_filesize          TYPE i OPTIONAL
          filename              TYPE string
          filetype              TYPE string OPTIONAL
          write_lf              TYPE abap_bool OPTIONAL
          write_field_separator TYPE char1 OPTIONAL
          confirm_overwrite     TYPE abap_bool OPTIONAL
        CHANGING
          data_tab TYPE any.

    CLASS-METHODS file_exist
      IMPORTING
        file          TYPE string
      RETURNING
        VALUE(result) TYPE abap_bool.

    CLASS-METHODS
      directory_list_files
        IMPORTING
          directory  TYPE string
          files_only TYPE abap_bool OPTIONAL
        CHANGING
          file_table TYPE any
          count      TYPE i.

    CLASS-METHODS
      gui_upload
        IMPORTING
          filename     TYPE string
          filetype     TYPE char10 OPTIONAL
          codepage     TYPE abap_encoding DEFAULT space
          read_by_line TYPE abap_bool OPTIONAL
        EXPORTING
          filelength   TYPE i
        CHANGING
          data_tab     TYPE any.

    CLASS-METHODS
      file_open_dialog
        IMPORTING
          window_title      TYPE string OPTIONAL
          default_filename  TYPE string OPTIONAL
          default_extension TYPE string OPTIONAL
          multiselection    TYPE abap_bool OPTIONAL
          file_filter       TYPE string OPTIONAL
          initial_directory TYPE string OPTIONAL
        CHANGING
          file_table        TYPE filetable
          rc                TYPE i
          user_action       TYPE i OPTIONAL.

    CLASS-METHODS
      get_platform
        RETURNING
          VALUE(platform) TYPE i.

    CLASS-METHODS
      file_save_dialog
        IMPORTING
          window_title         TYPE string OPTIONAL
          default_extension    TYPE string OPTIONAL
          default_file_name    TYPE string OPTIONAL
          file_filter          TYPE string OPTIONAL
          initial_directory    TYPE string OPTIONAL
          prompt_on_overwrite  TYPE abap_bool OPTIONAL
        CHANGING
          filename             TYPE string
          path                 TYPE string
          fullpath             TYPE string
          user_action          TYPE i OPTIONAL.

    CLASS-METHODS
      directory_browse
        IMPORTING
          window_title    TYPE string OPTIONAL
          initial_folder  TYPE string OPTIONAL
        CHANGING
          selected_folder TYPE string.

    CLASS-METHODS
      execute
        IMPORTING
          document          TYPE string OPTIONAL
          application       TYPE string OPTIONAL
          parameter         TYPE string OPTIONAL
          default_directory TYPE string OPTIONAL
          maximized         TYPE string OPTIONAL
          minimized         TYPE string OPTIONAL
          synchronous       TYPE string OPTIONAL
          operation         TYPE string DEFAULT ''OPEN''.

    CLASS-METHODS
      get_file_separator
        CHANGING
          file_separator TYPE string.

    CLASS-METHODS
      directory_exist
        IMPORTING
          directory TYPE string
        RETURNING
          VALUE(result) TYPE abap_bool.

    CLASS-METHODS
      directory_create
        IMPORTING
          directory TYPE string
        CHANGING
          rc TYPE i.

    CLASS-METHODS
      clipboard_export
        IMPORTING
          no_auth_check TYPE abap_bool OPTIONAL
        EXPORTING
          data TYPE any
        CHANGING
          rc TYPE i.

    CLASS-METHODS
      get_system_directory
        CHANGING
          system_directory TYPE string.

    CLASS-METHODS
      get_gui_version
        CHANGING
          version_table TYPE filetable
          rc            TYPE i.

    CLASS-METHODS clipboard_import
      EXPORTING
        data   TYPE STANDARD TABLE
        length TYPE i.

    CLASS-METHODS file_delete
      IMPORTING
        filename TYPE string
      CHANGING
        rc       TYPE i.

    CLASS-METHODS get_sapgui_workdir
      CHANGING
        sapworkdir TYPE string.

ENDCLASS.

CLASS cl_gui_frontend_services IMPLEMENTATION.
  METHOD directory_exist.
    ASSERT 1 = ''directory_exist not supported''.
  ENDMETHOD.

  METHOD get_sapgui_workdir.
    ASSERT 1 = ''get_sapgui_workdir not supported''.
  ENDMETHOD.

  METHOD file_exist.
    ASSERT 1 = ''file_exist not supported''.
  ENDMETHOD.

  METHOD file_delete.
    ASSERT 1 = ''file_delete not supported''.
  ENDMETHOD.

  METHOD clipboard_import.
    ASSERT 1 = ''clipboard_import not supported''.
  ENDMETHOD.

  METHOD directory_list_files.
    ASSERT 1 = ''directory_list_files not supported''.
  ENDMETHOD.

  METHOD directory_create.
    ASSERT 1 = ''directory_create not supported''.
  ENDMETHOD.

  METHOD gui_download.
    ASSERT 1 = ''gui_download not supported''.
  ENDMETHOD.

  METHOD get_file_separator.
    ASSERT 1 = ''get_file_separator not supported''.
  ENDMETHOD.

  METHOD execute.
    ASSERT 1 = ''execute not supported''.
  ENDMETHOD.

  METHOD directory_browse.
    ASSERT 1 = ''directory_browse not supported''.
  ENDMETHOD.

  METHOD gui_upload.
    ASSERT 1 = ''gui_upload not supported''.
  ENDMETHOD.

  METHOD file_open_dialog.
    ASSERT 1 = ''file_open_dialog not supported''.
  ENDMETHOD.

  METHOD file_save_dialog.
    ASSERT 1 = ''file_save_dialog not supported''.
  ENDMETHOD.

  METHOD get_platform.
    platform = platform_windowsxp.
  ENDMETHOD.

  METHOD clipboard_export.
    ASSERT 1 = ''clipboard_export not supported''.
  ENDMETHOD.

  METHOD get_system_directory.
    ASSERT 1 = ''get_system_directory not supported''.
  ENDMETHOD.

  METHOD get_gui_version.
    ASSERT 1 = ''get_gui_verison not supported''.
  ENDMETHOD.
ENDCLASS.
');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_PROGRESS_INDICATOR                   ', 'CLASS cl_progress_indicator DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS progress_indicate
      IMPORTING
        i_text               TYPE any OPTIONAL
        i_processed          TYPE sy-tabix OPTIONAL
        i_total              TYPE sy-tabix OPTIONAL
        i_output_immediately TYPE abap_bool OPTIONAL
      EXPORTING
        e_progress_sent      TYPE abap_bool.
ENDCLASS.

CLASS cl_progress_indicator IMPLEMENTATION.
  METHOD progress_indicate.
* do nothing, gui is not supported, but background logic might indicatoe progress
    RETURN.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SALV_AGGREGATIONS                    ', 'CLASS cl_salv_aggregations DEFINITION PUBLIC.
  PUBLIC SECTION.
    METHODS add_aggregation
      IMPORTING
        columnname   TYPE any
        aggregation  TYPE i DEFAULT if_salv_c_aggregation=>total.
ENDCLASS.

CLASS cl_salv_aggregations IMPLEMENTATION.
  METHOD add_aggregation.
    ASSERT 1 = ''todo''.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SALV_COLUMN                          ', 'CLASS cl_salv_column DEFINITION PUBLIC.
  PUBLIC SECTION.
    METHODS set_technical IMPORTING value TYPE abap_bool DEFAULT abap_true.
    METHODS set_short_text IMPORTING value TYPE string.
    METHODS set_medium_text IMPORTING value TYPE string.
    METHODS set_long_text IMPORTING value TYPE string.
    METHODS set_output_length IMPORTING value TYPE any.
    METHODS set_sign IMPORTING value TYPE any OPTIONAL.
ENDCLASS.

CLASS cl_salv_column IMPLEMENTATION.
  METHOD set_technical.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD set_short_text.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD set_medium_text.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD set_long_text.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD set_output_length.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD set_sign.
    ASSERT 1 = ''todo''.
  ENDMETHOD.
ENDCLASS.
');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SALV_COLUMNS_TABLE                   ', 'CLASS cl_salv_columns_table DEFINITION PUBLIC.
  PUBLIC SECTION.
    METHODS set_cell_type_column
      IMPORTING value TYPE string.
    METHODS set_optimize
      IMPORTING value TYPE abap_bool DEFAULT abap_true.
    METHODS set_color_column
      IMPORTING value TYPE string.
    METHODS get_column
      IMPORTING columnname TYPE string
      RETURNING VALUE(value) TYPE REF TO cl_salv_column.
    METHODS get
      RETURNING VALUE(value) TYPE string.
    METHODS set_exception_column
      IMPORTING value TYPE any.
    METHODS set_hyperlink_entry_column
      IMPORTING
        value TYPE any.
ENDCLASS.

CLASS cl_salv_columns_table IMPLEMENTATION.
  METHOD set_hyperlink_entry_column.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get_column.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD set_exception_column.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD set_cell_type_column.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD set_optimize.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD set_color_column.
    ASSERT 1 = ''todo''.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SALV_EVENTS_TABLE                    ', 'CLASS cl_salv_events_table DEFINITION PUBLIC.
  PUBLIC SECTION.
    EVENTS double_click
      EXPORTING
        VALUE(row)    TYPE i
        VALUE(column) TYPE string.

    EVENTS added_function
      EXPORTING
        VALUE(e_salv_function) TYPE string OPTIONAL.

    EVENTS link_click
      EXPORTING
        VALUE(row) TYPE i
        VALUE(column) TYPE string.

ENDCLASS.

CLASS cl_salv_events_table IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SALV_FILTERS                         ', 'CLASS cl_salv_filters DEFINITION PUBLIC.
  PUBLIC SECTION.
ENDCLASS.

CLASS cl_salv_filters IMPLEMENTATION.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SALV_FUNCTIONAL_SETTINGS             ', 'CLASS cl_salv_functional_settings DEFINITION PUBLIC.
  PUBLIC SECTION.
    METHODS get_hyperlinks
      RETURNING
        VALUE(value) TYPE REF TO cl_salv_hyperlinks.
ENDCLASS.

CLASS cl_salv_functional_settings IMPLEMENTATION.
  METHOD get_hyperlinks.
    RETURN.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SALV_FUNCTIONS_LIST                  ', 'CLASS cl_salv_functions_list DEFINITION PUBLIC.
  PUBLIC SECTION.
    METHODS set_all
      IMPORTING flag
        TYPE abap_bool OPTIONAL.

    METHODS get_functions
      RETURNING
        VALUE(sdf) TYPE string.

    METHODS set_default
      IMPORTING
        value TYPE abap_bool DEFAULT abap_true.

    METHODS add_function
      IMPORTING
        name     TYPE any
        icon     TYPE string OPTIONAL
        text     TYPE string OPTIONAL
        tooltip  TYPE string
        position TYPE any.
ENDCLASS.

CLASS cl_salv_functions_list IMPLEMENTATION.
  METHOD set_all.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get_functions.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD set_default.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD add_function.
    ASSERT 1 = ''todo''.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SALV_HYPERLINKS                      ', 'CLASS cl_salv_hyperlinks DEFINITION PUBLIC.
  PUBLIC SECTION.
    METHODS add_hyperlink
      IMPORTING
        handle       TYPE any
        hyperlink    TYPE any OPTIONAL
      RAISING
        cx_salv_existing.

ENDCLASS.

CLASS cl_salv_hyperlinks IMPLEMENTATION.

  METHOD add_hyperlink.
    RETURN.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SALV_LAYOUT                          ', 'CLASS cl_salv_layout DEFINITION PUBLIC.
  PUBLIC SECTION.
    CONSTANTS restrict_none TYPE i VALUE 3.

    METHODS set_key
      IMPORTING
        value TYPE any.

    METHODS set_save_restriction
      IMPORTING
        value TYPE any OPTIONAL.

    METHODS set_default
      IMPORTING
        value TYPE abap_bool.

    METHODS has_default
      RETURNING
        VALUE(value) TYPE abap_bool.

    METHODS set_initial_layout
      IMPORTING
        value TYPE clike.
ENDCLASS.

CLASS cl_salv_layout IMPLEMENTATION.
  METHOD set_key.
    ASSERT 1 = ''not supported''.
  ENDMETHOD.

  METHOD set_initial_layout.
    ASSERT 1 = ''not supported''.
  ENDMETHOD.

  METHOD set_save_restriction.
    ASSERT 1 = ''not supported''.
  ENDMETHOD.

  METHOD set_default.
    ASSERT 1 = ''not supported''.
  ENDMETHOD.

  METHOD has_default.
    ASSERT 1 = ''not supported''.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SALV_SORTS                           ', 'CLASS cl_salv_sorts DEFINITION PUBLIC.
  PUBLIC SECTION.
    METHODS add_sort
      IMPORTING
        columnname TYPE clike
        subtotal   TYPE abap_bool DEFAULT abap_false
      RAISING
        cx_salv_not_found
        cx_salv_existing
        cx_salv_data_error.
ENDCLASS.

CLASS cl_salv_sorts IMPLEMENTATION.
  METHOD add_sort.
    ASSERT 1 = ''todo''.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SALV_TABLE                           ', 'CLASS cl_salv_table DEFINITION PUBLIC.
  PUBLIC SECTION.
    CONSTANTS c_functions_all TYPE i VALUE 1.
    TYPES ty_rows TYPE STANDARD TABLE OF i WITH DEFAULT KEY.

    CLASS-METHODS factory
      IMPORTING
        list_display TYPE any OPTIONAL
        r_container  TYPE any OPTIONAL
      EXPORTING
        r_salv_table TYPE any
      CHANGING
        t_table TYPE any.
    METHODS get_selections RETURNING VALUE(val) TYPE REF TO cl_salv_table.
    METHODS set_selected_rows IMPORTING val TYPE any.
    METHODS set_selection_mode IMPORTING val TYPE i.
    METHODS get_selected_rows RETURNING VALUE(rows) TYPE ty_rows.
    METHODS close_screen.
    METHODS refresh IMPORTING refresh_mode TYPE any OPTIONAL.
    METHODS display.
    METHODS is_offline RETURNING VALUE(value) TYPE abap_bool.
    METHODS get_metadata.
    METHODS get_layout
      RETURNING
        VALUE(value) TYPE REF TO cl_salv_layout.
    METHODS set_screen_status
      IMPORTING
        pfstatus      TYPE any
        set_functions TYPE any OPTIONAL
        report        TYPE any.
    METHODS set_screen_popup
      IMPORTING
        start_column TYPE i
        end_column   TYPE i
        start_line   TYPE i
        end_line     TYPE i.
    METHODS get_event
      RETURNING VALUE(val) TYPE REF TO cl_salv_events_table.
    METHODS get_display_settings
      RETURNING VALUE(val) TYPE REF TO cl_salv_table.
    METHODS set_striped_pattern IMPORTING val TYPE any.
    METHODS set_list_header IMPORTING val TYPE any.
    METHODS set_top_of_list IMPORTING val TYPE any.
    METHODS get_columns RETURNING VALUE(val) TYPE REF TO cl_salv_columns_table.
    METHODS get_functions RETURNING VALUE(val) TYPE REF TO cl_salv_functions_list.
    METHODS get_aggregations
      RETURNING
        VALUE(value) TYPE REF TO cl_salv_aggregations.
    METHODS get_filters
      RETURNING
        VALUE(foo) TYPE REF TO cl_salv_filters.

    METHODS to_xml
      IMPORTING
        xml_type   TYPE any
      RETURNING
        VALUE(xml) TYPE xstring.

    METHODS get_sorts
      RETURNING
        VALUE(value) TYPE REF TO cl_salv_sorts.

    METHODS get_functional_settings
      RETURNING
        VALUE(value) TYPE REF TO cl_salv_functional_settings.
ENDCLASS.

CLASS cl_salv_table IMPLEMENTATION.

  METHOD get_sorts.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get_functional_settings.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD set_selected_rows.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get_layout.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD to_xml.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get_filters.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get_aggregations.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get_functions.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get_selected_rows.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get_metadata.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD set_selection_mode.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD set_striped_pattern.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD set_list_header.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD factory.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD is_offline.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get_selections.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD close_screen.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD refresh.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD display.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD set_screen_status.
    ASSERT 1 = ''TODO''.
  ENDMETHOD.

  METHOD set_screen_popup.
    ASSERT 1 = ''TODO''.
  ENDMETHOD.

  METHOD get_event.
    ASSERT 1 = ''TODO''.
  ENDMETHOD.

  METHOD get_display_settings.
    ASSERT 1 = ''TODO''.
  ENDMETHOD.

  METHOD set_top_of_list.
    ASSERT 1 = ''TODO''.
  ENDMETHOD.

  METHOD get_columns.
    ASSERT 1 = ''TODO''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SALV_ACCESS_ERROR                    ', 'CLASS cx_salv_access_error DEFINITION PUBLIC INHERITING FROM cx_salv_static_check.

ENDCLASS.

CLASS cx_salv_access_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SALV_DATA_ERROR                      ', 'CLASS cx_salv_data_error DEFINITION PUBLIC INHERITING FROM cx_salv_static_check.

ENDCLASS.

CLASS cx_salv_data_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SALV_ERROR                           ', 'CLASS cx_salv_error DEFINITION PUBLIC INHERITING FROM cx_static_check.

ENDCLASS.

CLASS cx_salv_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SALV_EXISTING                        ', 'CLASS cx_salv_existing DEFINITION PUBLIC INHERITING FROM cx_salv_access_error.

ENDCLASS.

CLASS cx_salv_existing IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SALV_MSG                             ', 'CLASS cx_salv_msg DEFINITION PUBLIC INHERITING FROM cx_salv_error.

ENDCLASS.

CLASS cx_salv_msg IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SALV_NOT_FOUND                       ', 'CLASS cx_salv_not_found DEFINITION PUBLIC INHERITING FROM cx_salv_access_error.

ENDCLASS.

CLASS cx_salv_not_found IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SALV_STATIC_CHECK                    ', 'CLASS cx_salv_static_check DEFINITION PUBLIC INHERITING FROM cx_salv_error.

ENDCLASS.

CLASS cx_salv_static_check IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SALV_C_AGGREGATION                   ', 'INTERFACE if_salv_c_aggregation PUBLIC.
  CONSTANTS none    TYPE i VALUE 0.
  CONSTANTS total   TYPE i VALUE 1.
  CONSTANTS minimum TYPE i VALUE 2.
  CONSTANTS maximum TYPE i VALUE 3.
  CONSTANTS average TYPE i VALUE 4.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SALV_C_BOOL_SAP                      ', 'INTERFACE if_salv_c_bool_sap PUBLIC.
  CONSTANTS true_ TYPE abap_bool VALUE abap_true.
  CONSTANTS false_ TYPE abap_bool VALUE abap_false.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SALV_C_SELECTION_MODE                ', 'INTERFACE if_salv_c_selection_mode PUBLIC.
  CONSTANTS cell       TYPE i VALUE 1.
  CONSTANTS multiple   TYPE i VALUE 2.
  CONSTANTS none       TYPE i VALUE 3.
  CONSTANTS row_column TYPE i VALUE 4.
  CONSTANTS single     TYPE i VALUE 5.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_HTTP_CLIENT                          ', 'CLASS cl_http_client DEFINITION PUBLIC CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES if_http_client.

    CLASS-METHODS create_by_url
      IMPORTING
        url           TYPE string
        ssl_id        TYPE ssfapplssl OPTIONAL
        proxy_host    TYPE string OPTIONAL
        proxy_service TYPE string OPTIONAL
      EXPORTING
        VALUE(client) TYPE REF TO if_http_client.
* todo, add classic exceptions

    CLASS-METHODS create_by_destination
      IMPORTING
        destination   TYPE clike
      EXPORTING
        VALUE(client) TYPE REF TO if_http_client.
* todo, add classic exceptions

    CLASS-METHODS create_internal
      EXPORTING
        client TYPE REF TO if_http_client
      EXCEPTIONS
        plugin_not_active
        internal_error.

    METHODS constructor
      IMPORTING
        url TYPE string.

  PRIVATE SECTION.
    DATA mv_host TYPE string.

ENDCLASS.

CLASS cl_http_client IMPLEMENTATION.

  METHOD constructor.
* SSL_ID and proxies are currently ignored

    DATA lv_uri TYPE string.
    DATA lv_query TYPE string.

    CREATE OBJECT if_http_client~response TYPE cl_http_entity.

    FIND REGEX ''\\w(\\/[\\w\\d\\.\\-\\/]+)'' IN url SUBMATCHES lv_uri.
    mv_host = url.
*    WRITE ''@KERNEL console.dir(this.mv_host.get());''.
*    WRITE ''@KERNEL console.dir(lv_uri.get());''.
    REPLACE FIRST OCCURRENCE OF lv_uri IN mv_host WITH ''''.

    CREATE OBJECT if_http_client~request TYPE cl_http_entity.
    if_http_client~request->set_header_field(
      name = ''~request_uri''
      value = lv_uri ).

    FIND REGEX ''\\?(.*)'' IN url SUBMATCHES lv_query.
    IF sy-subrc = 0.
      cl_http_utility=>set_query(
        request = if_http_client~request
        query   = lv_query ).
    ENDIF.

  ENDMETHOD.

  METHOD if_http_client~escape_url.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD create_by_url.
    CREATE OBJECT client TYPE cl_http_client
      EXPORTING
        url = url.
    sy-subrc = 0. " todo
  ENDMETHOD.

  METHOD if_http_client~authenticate.
    DATA lv_base64 TYPE string.
    lv_base64 = cl_http_utility=>encode_base64( |{ username }:{ password }| ).
    if_http_client~request->set_header_field(
      name = ''authorization''
      value = |Basic { lv_base64 }| ).
  ENDMETHOD.

  METHOD if_http_client~close.
* todo
    RETURN.
  ENDMETHOD.

  METHOD create_by_destination.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD create_internal.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_client~create_abs_url.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_client~send.
    DATA lv_method        TYPE string.
    DATA lv_url           TYPE string.
    DATA lv_body          TYPE string.
    DATA lv_name          TYPE string.
    DATA lv_value         TYPE string.
    DATA lv_content_type  TYPE string.
    DATA lv_xstr          TYPE xstring.
    DATA lt_form_fields   TYPE tihttpnvp.
    DATA lt_header_fields TYPE tihttpnvp.
    DATA ls_field         LIKE LINE OF lt_header_fields.

    lv_method = if_http_client~request->get_method( ).
    IF lv_method IS INITIAL.
      lv_method = ''GET''.
    ENDIF.

* default user-agent if not set
    IF if_http_client~request->get_header_field( ''user-agent'' ) IS INITIAL.
      if_http_client~request->set_header_field(
        name  = ''user-agent''
        value = ''open-abap-http'' ).
    ENDIF.

* building URL
    lv_url = if_http_client~request->get_header_field( ''~request_uri'' ).
    REPLACE FIRST OCCURRENCE OF mv_host IN lv_url WITH ''''.
    lv_url = mv_host && lv_url.
    if_http_client~request->get_form_fields( CHANGING fields = lt_form_fields ).
    IF lines( lt_form_fields ) > 0.
      CASE lv_method.
        WHEN ''GET''.
          lv_url = lv_url && ''?'' && cl_http_utility=>fields_to_string( lt_form_fields ).
        WHEN ''POST''.
          if_http_client~request->set_cdata( cl_http_utility=>fields_to_string( lt_form_fields ) ).
      ENDCASE.
    ENDIF.
*    WRITE ''@KERNEL console.dir(lv_url.get());''.

* building headers
    if_http_client~request->get_header_fields( CHANGING fields = lt_header_fields ).
    WRITE ''@KERNEL let headers = {};''.
    LOOP AT lt_header_fields INTO ls_field WHERE name <> ''~request_uri''.
      WRITE ''@KERNEL headers[ls_field.get().name.get()] = ls_field.get().value.get();''.
    ENDLOOP.

    lv_content_type = if_http_client~request->get_content_type( ).
    IF lv_content_type IS NOT INITIAL.
      WRITE ''@KERNEL headers["content-type"] = lv_content_type.get();''.
    ENDIF.
    WRITE ''@KERNEL headers["accept-encoding"] = "gzip";''.

*    WRITE ''@KERNEL console.dir(headers);''.

    lv_body = if_http_client~request->get_cdata( ).
*    WRITE ''@KERNEL console.dir(lv_body);''.
    IF strlen( lv_body ) > 0.
      WRITE ''@KERNEL headers["content-length"] = lv_body.get().length;''.
    ENDIF.

    WRITE ''@KERNEL const https = await import("https");''.
    WRITE ''@KERNEL const http = await import("http");''.
    WRITE ''@KERNEL function postData(url, options, requestBody) {''.
    WRITE ''@KERNEL   return new Promise((resolve, reject) => {''.
    WRITE ''@KERNEL     const prot = url.startsWith("http://") ? http : https;''.
    WRITE ''@KERNEL     const req = prot.request(url, options,''.
    WRITE ''@KERNEL       (res) => {''.
    WRITE ''@KERNEL         let chunks = [];''.
    WRITE ''@KERNEL         res.on("data", (chunk) => {chunks.push(chunk);});''.
    WRITE ''@KERNEL         res.on("error", reject);''.
    WRITE ''@KERNEL         res.on("end", () => {''.
*    WRITE ''@KERNEL           console.dir(res.statusCode + " " + JSON.stringify(res.headers));''.
*    WRITE ''@KERNEL           if (res.statusCode >= 200 && res.statusCode <= 299) {''.
    WRITE ''@KERNEL             resolve({statusCode: res.statusCode, headers: res.headers, body: Buffer.concat(chunks)});''.
*    WRITE ''@KERNEL           } else {''.
*    WRITE ''@KERNEL             reject("Request failed. status: " + res.statusCode + ", body: " + Buffer.concat(chunks).toString());''.
*    WRITE ''@KERNEL           }''.
    WRITE ''@KERNEL         });''.
    WRITE ''@KERNEL       });''.
    WRITE ''@KERNEL     req.on("error", reject);''.
    WRITE ''@KERNEL     req.write(requestBody, "binary");''.
    WRITE ''@KERNEL     req.end();''.
    WRITE ''@KERNEL   });''.
    WRITE ''@KERNEL }''.

    WRITE ''@KERNEL const prot = lv_url.get().startsWith("http://") ? http : https;''.
    WRITE ''@KERNEL if (this.agent === undefined) {this.agent = new prot.Agent({keepAlive: true, maxSockets: 1});}''.
    WRITE ''@KERNEL let response = await postData(lv_url.get(), {method: lv_method.get(), headers: headers, agent: this.agent}, lv_body.get());''.

    " WRITE ''@KERNEL console.dir(response);''.
    " WRITE ''@KERNEL console.dir(response.headers);''.

    WRITE ''@KERNEL for (const h in response.headers) {''.
    WRITE ''@KERNEL   lv_name.set(h);''.
    WRITE ''@KERNEL   if (Array.isArray(response.headers[h])) continue;''.
    WRITE ''@KERNEL   lv_value.set(response.headers[h]);''.
    if_http_client~response->set_header_field(
      name  = lv_name
      value = lv_value ).
    WRITE ''@KERNEL }''.


    WRITE ''@KERNEL this.if_http_client$response.get().mv_content_type.set(response.headers["content-type"] || "");''.
    WRITE ''@KERNEL this.if_http_client$response.get().mv_status.set(response.statusCode);''.
    WRITE ''@KERNEL this.if_http_client$response.get().mv_data.set(response.body.toString("hex").toUpperCase());''.
*    WRITE ''@KERNEL console.dir(this.if_http_client$response.get().mv_data);''.

    lv_value = if_http_client~response->get_header_field( ''content-encoding'' ).
    IF lv_value = ''gzip''.
      cl_abap_gzip=>decompress_binary_with_header(
        EXPORTING
          gzip_in = if_http_client~response->get_data( )
        IMPORTING
          raw_out = lv_xstr ).
      if_http_client~response->set_data( lv_xstr ).
    ENDIF.

* workaround for classic exceptions, this should work sometime in the transpiler instead
    sy-subrc = 0.

  ENDMETHOD.

  METHOD if_http_client~receive.
* handled in send()

* workaround for classic exceptions, this should work sometime in the transpiler instead
    sy-subrc = 0.

  ENDMETHOD.

  METHOD if_http_client~get_last_error.
    if_http_client~response->get_status( IMPORTING code = code ).
    message = ''todo_open_abap''. " get from one of the response headers?
  ENDMETHOD.

  METHOD if_http_client~send_sap_logon_ticket.
* do nothing,
    RETURN.
  ENDMETHOD.

  METHOD if_http_client~refresh_request.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_HTTP_ENTITY                          ', 'CLASS cl_http_entity DEFINITION PUBLIC CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES if_http_response.
    INTERFACES if_http_request.

    ALIASES set_header_field FOR if_http_entity~set_header_field.
    ALIASES append_cdata FOR if_http_entity~append_cdata.
  PROTECTED SECTION.
    DATA m_last_error TYPE i.
  PRIVATE SECTION.
    DATA mv_status       TYPE i.
    DATA mv_reason       TYPE string.
    DATA mv_content_type TYPE string.
    DATA mv_method       TYPE string.
    DATA mv_data         TYPE xstring.
    DATA mt_headers      TYPE tihttpnvp.
    DATA mt_form_fields  TYPE tihttpnvp.
ENDCLASS.

CLASS cl_http_entity IMPLEMENTATION.

  METHOD if_http_response~server_cache_expire_rel.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_response~server_cache_expire_default.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_response~server_cache_expire_abs.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_response~server_cache_browser_dependent.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_response~get_raw_message.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_response~copy.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_request~get_user_agent.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_request~get_uri_parameter.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_request~get_raw_message.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_request~get_form_data.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_request~get_authorization.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_request~copy.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_request~set_authorization.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~add_multipart.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~get_cookie_field.
* todo
    CLEAR field_value.
  ENDMETHOD.

  METHOD if_http_entity~set_compression.
* todo
  ENDMETHOD.

  METHOD if_http_entity~append_cdata.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~append_cdata2.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~add_cookie_field.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~append_data.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~to_xstring.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~delete_cookie_secure.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~get_cookies.
* todo
    CLEAR cookies.
  ENDMETHOD.

  METHOD if_http_entity~delete_form_field.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~delete_form_field_secure.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~get_cookie.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~get_data_length.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~from_xstring.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~get_form_field_cs.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~get_last_error.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~delete_header_field.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~delete_header_field_secure.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~delete_cookie.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~set_header_fields.
* todo, does this method clear the existing fields?
    DATA ls_field LIKE LINE OF fields.
    LOOP AT fields INTO ls_field.
      if_http_entity~set_header_field(
        name  = ls_field-name
        value = ls_field-value ).
    ENDLOOP.
  ENDMETHOD.

  METHOD if_http_entity~suppress_content_type.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~set_formfield_encoding.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~set_cookie.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~get_version.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~get_serialized_message_length.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~get_header_field.
    DATA ls_header LIKE LINE OF mt_headers.
    READ TABLE mt_headers WITH KEY name = to_lower( name ) INTO ls_header.
    IF sy-subrc = 0.
      value = ls_header-value.
    ENDIF.
  ENDMETHOD.

  METHOD if_http_entity~get_header_fields.
    fields = mt_headers.
  ENDMETHOD.

  METHOD if_http_response~get_status.
    code = mv_status.
    reason = mv_reason.
  ENDMETHOD.

  METHOD if_http_entity~get_cdata.
    cl_abap_conv_in_ce=>create( encoding = ''UTF-8'' )->convert(
      EXPORTING input = mv_data
      IMPORTING data = data ).
  ENDMETHOD.

  METHOD if_http_response~set_status.
    mv_status = code.
    mv_reason = reason.
  ENDMETHOD.

  METHOD if_http_entity~set_cdata.
    cl_abap_conv_out_ce=>create( encoding = ''UTF-8'' )->convert(
      EXPORTING data = data
      IMPORTING buffer = mv_data ).
  ENDMETHOD.

  METHOD if_http_entity~get_content_type.
    content_type = if_http_entity~get_header_field( ''content-type'' ).
  ENDMETHOD.

  METHOD if_http_entity~set_content_type.
    if_http_entity~set_header_field(
      name  = ''content-type''
      value = content_type ).
  ENDMETHOD.

  METHOD if_http_entity~get_data.
    data = mv_data.
  ENDMETHOD.

  METHOD if_http_entity~set_data.
    mv_data = data.
  ENDMETHOD.

  METHOD if_http_response~delete_cookie_at_client.
    ASSERT 2 = ''todo''.
  ENDMETHOD.

  METHOD if_http_response~redirect.
    ASSERT 2 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~num_multiparts.
* todo
    num = 0.
  ENDMETHOD.

  METHOD if_http_entity~get_multipart.
    ASSERT 2 = ''todo''.
  ENDMETHOD.

  METHOD if_http_entity~get_form_fields_cs.
    fields = mt_form_fields.
  ENDMETHOD.

  METHOD if_http_entity~set_form_fields.
    mt_form_fields = fields.
  ENDMETHOD.

  METHOD if_http_entity~get_form_fields.
    DATA ls_field LIKE LINE OF mt_form_fields.
    LOOP AT mt_form_fields INTO ls_field.
      TRANSLATE ls_field-name TO LOWER CASE.
      APPEND ls_field TO fields.
    ENDLOOP.
  ENDMETHOD.

  METHOD if_http_entity~get_form_field.
    DATA ls_field LIKE LINE OF mt_form_fields.
    READ TABLE mt_form_fields INTO ls_field WITH KEY name = to_lower( name ).
    IF sy-subrc = 0.
      value = ls_field-value.
    ENDIF.
  ENDMETHOD.

  METHOD if_http_entity~set_header_field.
    DATA ls_header LIKE LINE OF mt_headers.
    FIELD-SYMBOLS <ls_header> LIKE LINE OF mt_headers.
    READ TABLE mt_headers WITH KEY name = to_lower( name ) ASSIGNING <ls_header>.
    IF sy-subrc = 0.
      <ls_header>-value = value.
    ELSE.
      ls_header-name = to_lower( name ).
      ls_header-value = value.
      APPEND ls_header TO mt_headers.
    ENDIF.
    IF name = ''~request_method''.
      if_http_request~set_method( value ).
    ENDIF.
  ENDMETHOD.

  METHOD if_http_request~set_method.
    mv_method = method.
  ENDMETHOD.

  METHOD if_http_request~get_method.
    meth = mv_method.
  ENDMETHOD.

  METHOD if_http_request~set_version.
* todo,
    RETURN.
  ENDMETHOD.

  METHOD if_http_entity~set_form_field.
    DATA ls_field LIKE LINE OF mt_form_fields.
    ls_field-name = name.
    ls_field-value = value.
    APPEND ls_field TO mt_form_fields.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_HTTP_SERVER                          ', 'CLASS cl_http_server DEFINITION PUBLIC CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES if_http_server.

    ALIASES co_enabled FOR if_http_server~co_enabled.
    ALIASES append_field_url FOR if_http_server~append_field_url.

    CLASS-DATA c_compression_supported TYPE i.
    DATA m_protocol_version TYPE string READ-ONLY.

    CLASS-METHODS get_location
      IMPORTING
        application TYPE csequence OPTIONAL
      EXPORTING
        port         TYPE string
        out_protocol TYPE string
        host         TYPE string.

ENDCLASS.

CLASS cl_http_server IMPLEMENTATION.
  METHOD if_http_server~logoff.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~set_session_stateful.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~append_field_url.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~create_abs_url.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~create_rel_url.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~decode_base64.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~enable_foreign_session_access.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~encode_base64.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~escape_html.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~escape_url.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~get_extension_info.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~get_extension_url.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~get_last_error.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~get_location.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~get_location_exception.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~get_xsrf_token.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~send_page.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~set_compression.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~set_page.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~set_session_stateful_via_url.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~unescape_url.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_server~validate_xsrf_token.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get_location.
    host = ''open-abap.org''.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_HTTP_UTILITY                         ', 'CLASS cl_http_utility DEFINITION PUBLIC.
  PUBLIC SECTION.
    INTERFACES if_http_utility.

    ALIASES decode_base64 FOR if_http_utility~decode_base64.
    ALIASES encode_base64 FOR if_http_utility~encode_base64.
    ALIASES escape_url FOR if_http_utility~escape_url.
    ALIASES fields_to_string FOR if_http_utility~fields_to_string.
    ALIASES get_last_error FOR if_http_utility~get_last_error.
    ALIASES string_to_fields FOR if_http_utility~string_to_fields.
    ALIASES unescape_url FOR if_http_utility~unescape_url.
    ALIASES normalize_url FOR if_http_utility~normalize_url.

    CLASS-METHODS decode_x_base64
      IMPORTING
        encoded TYPE string
      RETURNING
        VALUE(decoded) TYPE xstring.

    CLASS-METHODS encode_x_base64
      IMPORTING
        unencoded      TYPE xstring
      RETURNING
        VALUE(encoded) TYPE string.

    CLASS-METHODS set_query
      IMPORTING
        request TYPE REF TO if_http_request
        query   TYPE string.

    CLASS-METHODS set_request_uri
      IMPORTING
        request TYPE REF TO if_http_request
        uri     TYPE string.

    CLASS-METHODS escape_xml_attr_value
      IMPORTING
        unescaped      TYPE csequence
      RETURNING
        VALUE(escaped) TYPE string.

    CLASS-METHODS escape_html
      IMPORTING
        unescaped         TYPE string
        keep_num_char_ref TYPE abap_bool DEFAULT abap_undefined
      RETURNING
        VALUE(escaped)    TYPE string.

    CLASS-METHODS escape_javascript
      IMPORTING
        unescaped      TYPE string
        inside_html    TYPE abap_bool DEFAULT abap_false
      RETURNING
        VALUE(escaped) TYPE string.

ENDCLASS.

CLASS cl_http_utility IMPLEMENTATION.

  METHOD set_request_uri.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD escape_html.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD escape_javascript.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD escape_xml_attr_value.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_utility~get_last_error.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_utility~string_to_fields.
    DATA tab TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
    DATA str LIKE LINE OF tab.
    DATA ls_field LIKE LINE OF fields.

    ASSERT ignore_parenthesis = 0.

    SPLIT string AT ''&'' INTO TABLE tab.
    LOOP AT tab INTO str.
      SPLIT str AT ''='' INTO ls_field-name ls_field-value.
      APPEND ls_field TO fields.
    ENDLOOP.
  ENDMETHOD.

  METHOD set_query.
    request->set_form_fields( string_to_fields( query ) ).
  ENDMETHOD.

  METHOD if_http_utility~normalize_url.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_http_utility~fields_to_string.
    DATA tab TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
    DATA str TYPE string.
    DATA ls_field LIKE LINE OF fields.

    LOOP AT fields INTO ls_field.
      ls_field-value = if_http_utility~escape_url( ls_field-value ).
      str = ls_field-name && ''='' && ls_field-value.
      APPEND str TO tab.
    ENDLOOP.
    string = concat_lines_of( table = tab sep = ''&'' ).
  ENDMETHOD.

  METHOD encode_x_base64.
    WRITE ''@KERNEL let buffer = Buffer.from(unencoded.get(), "hex");''.
    WRITE ''@KERNEL encoded.set(buffer.toString("base64"));''.
  ENDMETHOD.

  METHOD decode_x_base64.
    WRITE ''@KERNEL let buffer = Buffer.from(encoded.get(), "base64");''.
    WRITE ''@KERNEL decoded.set(buffer.toString("hex").toUpperCase());''.
  ENDMETHOD.

  METHOD if_http_utility~unescape_url.
    WRITE ''@KERNEL let foo = escaped.get();''.
    WRITE ''@KERNEL unescaped.set(decodeURIComponent(foo));''.
  ENDMETHOD.

  METHOD if_http_utility~escape_url.
    DATA lv_index TYPE i.
    DATA lv_char  TYPE string.

    DO strlen( unescaped ) TIMES.
      lv_index = sy-index - 1.
      lv_char = unescaped+lv_index(1).
      IF to_upper( lv_char ) CA sy-abcde OR lv_char CA ''0123456789.-()''.
        escaped = escaped && lv_char.
      ELSE.
        escaped = escaped && ''%'' && to_lower( cl_abap_codepage=>convert_to( lv_char ) ).
      ENDIF.
    ENDDO.
  ENDMETHOD.

  METHOD if_http_utility~encode_base64.
    WRITE ''@KERNEL let buffer = Buffer.from(unencoded.get());''.
    WRITE ''@KERNEL encoded.set(buffer.toString("base64"));''.
  ENDMETHOD.

  METHOD if_http_utility~decode_base64.
    WRITE ''@KERNEL let buffer = Buffer.from(encoded.get(), "base64");''.
    WRITE ''@KERNEL decoded.set(buffer.toString());''.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_WEB_HTTP_UTILITY                     ', 'CLASS cl_web_http_utility DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS unescape_url
      IMPORTING
        escaped          TYPE string
        options          TYPE i OPTIONAL
      RETURNING
        VALUE(unescaped) TYPE string.

    CLASS-METHODS decode_x_base64
      IMPORTING
        encoded        TYPE string
      RETURNING
        VALUE(decoded) TYPE xstring.

    CLASS-METHODS encode_x_base64
      IMPORTING
        unencoded      TYPE xstring
      RETURNING
        VALUE(encoded) TYPE string.
ENDCLASS.

CLASS cl_web_http_utility IMPLEMENTATION.
  METHOD unescape_url.
    unescaped = cl_http_utility=>unescape_url(
      escaped = escaped
      options = options ).
  ENDMETHOD.

  METHOD decode_x_base64.
    decoded = cl_http_utility=>decode_x_base64( encoded ).
  ENDMETHOD.

  METHOD encode_x_base64.
    encoded = cl_http_utility=>encode_x_base64( unencoded ).
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_HTTP_CLIENT                          ', 'INTERFACE if_http_client PUBLIC.
  DATA request  TYPE REF TO if_http_request.
  DATA response TYPE REF TO if_http_response.

  DATA propertytype_logon_popup   TYPE i.
  DATA propertytype_accept_cookie TYPE i.
  DATA propertytype_redirect      TYPE i.

  CONSTANTS co_disabled TYPE i VALUE 0.
  CONSTANTS co_enabled  TYPE i VALUE 1.

  CONSTANTS co_timeout_default TYPE i VALUE 60.

  METHODS authenticate
    IMPORTING
      proxy_authentication TYPE abap_bool OPTIONAL
      username             TYPE string
      password             TYPE string.

  METHODS close.

  METHODS send
    IMPORTING
      timeout TYPE i DEFAULT 0
    EXCEPTIONS
      http_communication_failure
      http_invalid_state
      http_processing_failed
      http_invalid_timeout.

  METHODS receive
    EXCEPTIONS
      http_communication_failure
      http_invalid_state
      http_processing_failed.

  METHODS send_sap_logon_ticket.

  METHODS get_last_error
    EXPORTING
      code    TYPE i
      message TYPE string.

  METHODS refresh_request.

  METHODS create_abs_url
    IMPORTING
      path       TYPE string OPTIONAL
    RETURNING
      VALUE(url) TYPE string.

  CLASS-METHODS escape_url
    IMPORTING
      unescaped      TYPE string
    RETURNING
      VALUE(escaped) TYPE string.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_HTTP_ENTITY                          ', 'INTERFACE if_http_entity PUBLIC.

  CONSTANTS co_request_method_get TYPE string VALUE ''GET''.
  CONSTANTS co_request_method_post TYPE string VALUE ''POST''.
  CONSTANTS co_body_before_query_string TYPE i VALUE 3.
  CONSTANTS co_protocol_version_1_0 TYPE i VALUE 1000.
  CONSTANTS co_protocol_version_1_1 TYPE i VALUE 1001.
  CONSTANTS co_compress_based_on_mime_type TYPE i VALUE 2.

  METHODS set_cdata
    IMPORTING
      data   TYPE string
      offset TYPE i OPTIONAL
      length TYPE i OPTIONAL.

  METHODS set_data
    IMPORTING
      data TYPE xstring.

  METHODS get_header_field
    IMPORTING
      name TYPE string
    RETURNING
      VALUE(value) TYPE string.

  METHODS set_header_field
    IMPORTING
      name  TYPE string
      value TYPE string.

  METHODS get_form_fields
    CHANGING
      fields TYPE tihttpnvp.

  METHODS set_compression
    IMPORTING
      disable_extended_checks TYPE abap_bool DEFAULT abap_false
      options                 TYPE i DEFAULT co_compress_based_on_mime_type
      PREFERRED PARAMETER options.

  METHODS add_multipart
    IMPORTING
      suppress_content_length TYPE abap_bool DEFAULT abap_false
    RETURNING
      VALUE(entity) TYPE REF TO if_http_entity.

  METHODS append_cdata IMPORTING data TYPE clike.

  METHODS get_form_field IMPORTING name TYPE string RETURNING VALUE(value) TYPE string.

  METHODS get_cdata RETURNING VALUE(data) TYPE string.

  METHODS get_content_type
    RETURNING
      VALUE(content_type) TYPE string.

  METHODS get_serialized_message_length
    EXPORTING
      VALUE(body_length) TYPE i
      VALUE(header_length) TYPE i.

  METHODS set_content_type
    IMPORTING
      content_type TYPE string.

  METHODS get_data
    RETURNING
      VALUE(data) TYPE xstring.

  METHODS get_header_fields
    CHANGING
      fields TYPE tihttpnvp.

  METHODS to_xstring
    RETURNING
      VALUE(data) TYPE xstring.

  METHODS get_cookies
    CHANGING
      cookies TYPE any.

  METHODS add_cookie_field
    IMPORTING
      cookie_name TYPE string
      cookie_path TYPE string OPTIONAL
      field_name  TYPE string
      field_value TYPE string
      base64      TYPE i DEFAULT 1.

  METHODS append_cdata2
    IMPORTING
      data     TYPE string
      encoding TYPE i OPTIONAL
      offset   TYPE i OPTIONAL
      length   TYPE i OPTIONAL.

  METHODS append_data
    IMPORTING
      data   TYPE xstring
      offset TYPE i OPTIONAL
      length TYPE i OPTIONAL.

  METHODS delete_cookie_secure
    IMPORTING
      name TYPE string
      path TYPE string DEFAULT \`\`.

  METHODS delete_form_field
    IMPORTING
      name TYPE string.

  METHODS delete_form_field_secure
    IMPORTING
      name TYPE string.

  METHODS from_xstring
    IMPORTING
      data TYPE xstring.

  METHODS get_cookie
    IMPORTING
      name TYPE string
      path TYPE string DEFAULT \`\`
    EXPORTING
      value   TYPE string
      domain  TYPE string
      expires TYPE string
      secure  TYPE i.

  METHODS get_cookie_field
    IMPORTING
      cookie_name TYPE string
      cookie_path TYPE string OPTIONAL
      field_name  TYPE string
      base64      TYPE i DEFAULT 1
    RETURNING
      VALUE(field_value) TYPE string.

  METHODS get_data_length
    EXPORTING
      VALUE(data_length) TYPE i.

  METHODS get_form_fields_cs
    IMPORTING
      formfield_encoding TYPE i OPTIONAL
      search_option      TYPE i DEFAULT co_body_before_query_string
    CHANGING
      fields             TYPE tihttpnvp.

  METHODS get_form_field_cs
    IMPORTING
      name               TYPE string
      formfield_encoding TYPE i OPTIONAL
      search_option      TYPE i DEFAULT co_body_before_query_string
    RETURNING
      VALUE(value)       TYPE string.

  METHODS get_last_error
    RETURNING
      VALUE(rc) TYPE i.

  METHODS get_multipart
    IMPORTING
      index TYPE i
    RETURNING
      VALUE(entity) TYPE REF TO if_http_entity.

  METHODS get_version
    RETURNING
      VALUE(version) TYPE i.

  METHODS num_multiparts
    RETURNING
      VALUE(num) TYPE i.

  METHODS set_cookie
    IMPORTING
      name    TYPE string
      path    TYPE string OPTIONAL
      value   TYPE string
      domain  TYPE string OPTIONAL
      expires TYPE string OPTIONAL
      secure  TYPE i OPTIONAL.

  METHODS set_formfield_encoding
    IMPORTING
      formfield_encoding TYPE i.

  METHODS set_form_field
    IMPORTING
      name  TYPE string
      value TYPE string.

  METHODS set_form_fields
    IMPORTING
      fields     TYPE tihttpnvp
      multivalue TYPE int4 OPTIONAL.

  METHODS set_header_fields
    IMPORTING
      fields TYPE tihttpnvp.

  METHODS suppress_content_type
    IMPORTING
      suppress TYPE abap_bool DEFAULT abap_true.

  METHODS delete_cookie
    IMPORTING
      name TYPE string
      path TYPE string OPTIONAL.

  METHODS delete_header_field
    IMPORTING
      name TYPE string.

  METHODS delete_header_field_secure
    IMPORTING
      name TYPE string.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_HTTP_EXTENSION                       ', 'INTERFACE if_http_extension PUBLIC.

  DATA flow_rc TYPE i.

  CONSTANTS co_flow_ok             TYPE i VALUE 0.
  CONSTANTS co_flow_ok_others_mand TYPE i VALUE 2.

  METHODS handle_request IMPORTING server TYPE REF TO if_http_server.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_HTTP_REQUEST                         ', 'INTERFACE if_http_request PUBLIC.

  INTERFACES if_http_entity.

  ALIASES add_multipart FOR if_http_entity~add_multipart.
  ALIASES append_cdata FOR if_http_entity~append_cdata.
  ALIASES append_cdata2 FOR if_http_entity~append_cdata2.
  ALIASES append_data FOR if_http_entity~append_data.
  ALIASES co_protocol_version_1_0 FOR if_http_entity~co_protocol_version_1_0.
  ALIASES co_protocol_version_1_1 FOR if_http_entity~co_protocol_version_1_1.
  ALIASES co_request_method_get FOR if_http_entity~co_request_method_get.
  ALIASES co_request_method_post FOR if_http_entity~co_request_method_post.
  ALIASES get_cdata FOR if_http_entity~get_cdata.
  ALIASES get_content_type FOR if_http_entity~get_content_type.
  ALIASES get_cookie_field FOR if_http_entity~get_cookie_field.
  ALIASES get_cookies FOR if_http_entity~get_cookies.
  ALIASES get_data FOR if_http_entity~get_data.
  ALIASES get_form_field FOR if_http_entity~get_form_field.
  ALIASES get_form_fields FOR if_http_entity~get_form_fields.
  ALIASES get_form_fields_cs FOR if_http_entity~get_form_fields_cs.
  ALIASES get_header_field FOR if_http_entity~get_header_field.
  ALIASES get_header_fields FOR if_http_entity~get_header_fields.
  ALIASES get_last_error FOR if_http_entity~get_last_error.
  ALIASES get_multipart FOR if_http_entity~get_multipart.
  ALIASES num_multiparts FOR if_http_entity~num_multiparts.
  ALIASES set_cdata FOR if_http_entity~set_cdata.
  ALIASES set_compression FOR if_http_entity~set_compression.
  ALIASES set_content_type FOR if_http_entity~set_content_type.
  ALIASES set_cookie FOR if_http_entity~set_cookie.
  ALIASES set_data FOR if_http_entity~set_data.
  ALIASES set_form_field FOR if_http_entity~set_form_field.
  ALIASES set_form_fields FOR if_http_entity~set_form_fields.
  ALIASES set_header_field FOR if_http_entity~set_header_field.
  ALIASES set_header_fields FOR if_http_entity~set_header_fields.

  METHODS set_method
    IMPORTING
      method TYPE string.

  METHODS get_method
    RETURNING
      VALUE(meth) TYPE string.

  METHODS set_version
    IMPORTING
      version TYPE i.

  METHODS set_authorization
    IMPORTING
      auth_type TYPE i DEFAULT 1
      username  TYPE string
      password  TYPE string.

  METHODS copy
    RETURNING
      VALUE(request) TYPE REF TO if_http_request.

  METHODS get_authorization
    EXPORTING
      auth_type TYPE i
      username  TYPE string
      password  TYPE string.

  METHODS get_form_data
    IMPORTING
      name TYPE string
    CHANGING
      data TYPE data.

  METHODS get_raw_message
    RETURNING
      VALUE(data) TYPE xstring.

  METHODS get_uri_parameter
    IMPORTING
      name         TYPE string
    RETURNING
      VALUE(value) TYPE string.

  METHODS get_user_agent
    EXPORTING
      user_agent_type    TYPE i
      user_agent_version TYPE i.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_HTTP_RESPONSE                        ', 'INTERFACE if_http_response PUBLIC.

  INTERFACES if_http_entity.

  ALIASES get_header_field FOR if_http_entity~get_header_field.
  ALIASES get_cdata FOR if_http_entity~get_cdata.
  ALIASES get_content_type FOR if_http_entity~get_content_type.
  ALIASES set_content_type FOR if_http_entity~set_content_type.
  ALIASES get_data FOR if_http_entity~get_data.
  ALIASES set_data FOR if_http_entity~set_data.
  ALIASES get_header_fields FOR if_http_entity~get_header_fields.
  ALIASES set_header_field FOR if_http_entity~set_header_field.
  ALIASES set_cdata FOR if_http_entity~set_cdata.
  ALIASES append_cdata FOR if_http_entity~append_cdata.
  ALIASES set_cookie FOR if_http_entity~set_cookie.
  ALIASES delete_header_field FOR if_http_entity~delete_header_field.
  ALIASES set_compression FOR if_http_entity~set_compression.
  ALIASES get_cookies FOR if_http_entity~get_cookies.

  METHODS get_status
    EXPORTING
      code   TYPE i
      reason TYPE string.

  METHODS set_status
    IMPORTING
      code   TYPE i
      reason TYPE string.

  METHODS delete_cookie_at_client
    IMPORTING
      name   TYPE string
      path   TYPE string OPTIONAL
      domain TYPE string OPTIONAL.

  METHODS redirect
    IMPORTING
      url                TYPE string
      permanently        TYPE i OPTIONAL
      explanation        TYPE string OPTIONAL
      protocol_dependent TYPE i OPTIONAL.

  METHODS copy
    RETURNING
      VALUE(response) TYPE REF TO if_http_response.

  METHODS get_raw_message
    RETURNING
      VALUE(data) TYPE xstring.

  METHODS server_cache_browser_dependent
    IMPORTING
      dependent TYPE boolean DEFAULT abap_true.

  METHODS server_cache_expire_abs
    IMPORTING
      expires_abs_date  TYPE d OPTIONAL
      expires_abs_time  TYPE t OPTIONAL
      etag              TYPE char32 OPTIONAL
      browser_dependent TYPE boolean DEFAULT abap_false
      no_ufo_cache      TYPE boolean DEFAULT abap_false.

  METHODS server_cache_expire_default
    IMPORTING
      etag              TYPE char32 OPTIONAL
      browser_dependent TYPE boolean DEFAULT abap_false
      no_ufo_cache      TYPE boolean DEFAULT abap_false.

  METHODS server_cache_expire_rel
    IMPORTING
      expires_rel       TYPE i
      etag              TYPE char32 OPTIONAL
      browser_dependent TYPE boolean DEFAULT abap_false
      no_ufo_cache      TYPE boolean DEFAULT abap_false.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_HTTP_SERVER                          ', 'INTERFACE if_http_server PUBLIC.

  DATA response TYPE REF TO if_http_response.
  DATA request TYPE REF TO if_http_request.

  CONSTANTS authmethod_service             TYPE i VALUE 4.
  CONSTANTS co_compress_based_on_mime_type TYPE i VALUE 2.
  CONSTANTS co_disabled                    TYPE i VALUE 0.
  CONSTANTS co_enabled                     TYPE i VALUE 1.
  CONSTANTS co_page_error_type             TYPE c LENGTH 1 VALUE ''1''.
  CONSTANTS co_response_page_option        TYPE c LENGTH 1 VALUE '' ''.

  CLASS-DATA session_id TYPE string READ-ONLY.
  CLASS-DATA authentication_method TYPE i READ-ONLY.
  CLASS-DATA authenticated TYPE i READ-ONLY.

  METHODS logoff
    IMPORTING
      delete_mysapsso2_cookie TYPE abap_bool OPTIONAL
      propagate_logoff        TYPE abap_bool OPTIONAL
      redirect_url            TYPE string OPTIONAL.

  METHODS set_session_stateful
    IMPORTING
      stateful TYPE i DEFAULT co_enabled
      path     TYPE string OPTIONAL.

  CLASS-METHODS append_field_url
    IMPORTING
      name  TYPE string
      value TYPE string
    CHANGING
      url   TYPE string.

  METHODS create_abs_url
    IMPORTING
      protocol    TYPE string OPTIONAL
      post        TYPE string OPTIONAL
      port        TYPE string OPTIONAL
      path        TYPE string OPTIONAL
      querystring TYPE string OPTIONAL
    RETURNING
      VALUE(url) TYPE string.

  METHODS create_rel_url
    IMPORTING
      path        TYPE string OPTIONAL
      querystring TYPE string OPTIONAL
    RETURNING
      VALUE(url)  TYPE string.

  CLASS-METHODS decode_base64
    IMPORTING
      encoded        TYPE string
    RETURNING
      VALUE(decoded) TYPE string.

  METHODS enable_foreign_session_access
    IMPORTING
      url_path              TYPE string
      user_id               TYPE syuname OPTIONAL
      one_time_access_token TYPE abap_bool DEFAULT abap_true
    EXPORTING
      session_access_token  TYPE string
    EXCEPTIONS
      url_path_is_not_supported
      user_unknown
      session_is_not_stateful
      internal_error.

  CLASS-METHODS encode_base64
    IMPORTING
      unencoded TYPE string
    RETURNING
      VALUE(encoded) TYPE string.

  CLASS-METHODS escape_html
    IMPORTING
      unescaped TYPE string
    RETURNING
      VALUE(escaped) TYPE string.

  CLASS-METHODS escape_url
    IMPORTING
      unescaped TYPE string
    RETURNING
      VALUE(escaped) TYPE string.

  CLASS-METHODS get_extension_info
    IMPORTING
      extension_class TYPE string OPTIONAL
    EXPORTING
      urls TYPE string_table.

  CLASS-METHODS get_extension_url
    IMPORTING
      extension_class TYPE string
    EXPORTING
      urls TYPE string_table.

  METHODS get_last_error
    RETURNING
      VALUE(rc) TYPE i.

  CLASS-METHODS get_location
    IMPORTING
      protocol            TYPE csequence OPTIONAL
      application         TYPE csequence OPTIONAL
      for_domain          TYPE csequence OPTIONAL
      server              TYPE REF TO if_http_server OPTIONAL
      use_ticket_protocol TYPE abap_bool DEFAULT abap_true
    EXPORTING
      host TYPE string
      port TYPE string
      out_protocol TYPE string
      vh_switch TYPE abap_bool
    RETURNING
      VALUE(url_part) TYPE string.

  CLASS-METHODS get_location_exception
    IMPORTING
      protocol            TYPE csequence OPTIONAL
      application         TYPE csequence OPTIONAL
      for_domain          TYPE csequence OPTIONAL
      server              TYPE REF TO if_http_server OPTIONAL
      use_ticket_protocol TYPE abap_bool DEFAULT abap_true
    EXPORTING
      host                TYPE string
      port                TYPE string
      out_protocol        TYPE string
      vh_switch           TYPE abap_bool
    RETURNING
      VALUE(url_part)     TYPE string.

  METHODS get_xsrf_token
    EXPORTING
      token TYPE string
    EXCEPTIONS
      internal_error
      called_by_public_service.

  METHODS send_page.

  METHODS set_compression
    IMPORTING
      options TYPE i DEFAULT co_compress_based_on_mime_type
    EXCEPTIONS
      compression_not_possible.

  METHODS set_page
    IMPORTING
      response_page_type           TYPE char1 DEFAULT co_page_error_type
      response_option              TYPE char1 DEFAULT co_response_page_option
      response_option_page         TYPE any OPTIONAL
      response_option_redirect_url TYPE any OPTIONAL
    EXCEPTIONS
      invalid_parameter
      document_not_found.

  METHODS set_session_stateful_via_url
    IMPORTING
      stateful    TYPE i DEFAULT co_enabled
    CHANGING
      rewrite_url TYPE string OPTIONAL.

  CLASS-METHODS unescape_url
    IMPORTING
      escaped          TYPE string
    RETURNING
      VALUE(unescaped) TYPE string.

  METHODS validate_xsrf_token
    IMPORTING
      token      TYPE string OPTIONAL
    EXPORTING
      successful TYPE abap_bool
    EXCEPTIONS
      token_not_found
      cookie_not_found
      internal_error
      called_by_public_service.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_HTTP_UTILITY                         ', 'INTERFACE if_http_utility PUBLIC.

  CLASS-METHODS string_to_fields
    IMPORTING
      string             TYPE string
      ignore_parenthesis TYPE i DEFAULT 0
    RETURNING
      VALUE(fields)      TYPE tihttpnvp.

  CLASS-METHODS get_last_error
    RETURNING
      VALUE(rc) TYPE i.

  CLASS-METHODS unescape_url
    IMPORTING
      escaped          TYPE string
      options          TYPE i OPTIONAL
    RETURNING
      VALUE(unescaped) TYPE string.

  CLASS-METHODS escape_url
    IMPORTING
      unescaped      TYPE string
    RETURNING
      VALUE(escaped) TYPE string.

  CLASS-METHODS encode_base64
    IMPORTING
      unencoded TYPE string
    RETURNING
      VALUE(encoded) TYPE string.

  CLASS-METHODS fields_to_string
    IMPORTING
      fields TYPE tihttpnvp
    RETURNING
      VALUE(string) TYPE string.

  CLASS-METHODS decode_base64
    IMPORTING
      encoded        TYPE string
    RETURNING
      VALUE(decoded) TYPE string.

  CLASS-METHODS normalize_url
    IMPORTING
      unnormalized      TYPE string
    RETURNING
      VALUE(normalized) TYPE string.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_AMDP_MARKER_HDB                      ', 'INTERFACE if_amdp_marker_hdb PUBLIC.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SERIALIZABLE_OBJECT                  ', 'INTERFACE if_serializable_object PUBLIC.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_IXML                                 ', 'CLASS cl_ixml DEFINITION PUBLIC CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES if_ixml.
    CLASS-METHODS
      create
        RETURNING
          VALUE(xml) TYPE REF TO if_ixml.
ENDCLASS.

CLASS cl_ixml IMPLEMENTATION.
  METHOD create.
    CREATE OBJECT xml TYPE cl_ixml.
  ENDMETHOD.

  METHOD if_ixml~create_encoding.
    CREATE OBJECT rval TYPE lcl_encoding.
  ENDMETHOD.

  METHOD if_ixml~create_document.
    CREATE OBJECT doc TYPE lcl_document.
  ENDMETHOD.

  METHOD if_ixml~create_stream_factory.
    CREATE OBJECT stream TYPE lcl_stream_factory.
  ENDMETHOD.

  METHOD if_ixml~create_renderer.
    CREATE OBJECT renderer TYPE lcl_renderer
      EXPORTING
        ostream  = ostream
        document = document.
  ENDMETHOD.

  METHOD if_ixml~create_parser.
    CREATE OBJECT parser TYPE lcl_parser
      EXPORTING
        istream  = istream
        document = document.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML                                 ', 'INTERFACE if_ixml PUBLIC.
  METHODS create_document
    RETURNING
      VALUE(doc) TYPE REF TO if_ixml_document.
  METHODS create_stream_factory
    RETURNING
      VALUE(stream) TYPE REF TO if_ixml_stream_factory.
  METHODS create_renderer
    IMPORTING
      ostream  TYPE REF TO if_ixml_ostream
      document TYPE REF TO if_ixml_document
    RETURNING
      VALUE(renderer) TYPE REF TO if_ixml_renderer.
  METHODS create_parser
    IMPORTING
      stream_factory  TYPE REF TO if_ixml_stream_factory
      istream  TYPE REF TO if_ixml_istream
      document TYPE REF TO if_ixml_document
    RETURNING
      VALUE(parser) TYPE REF TO if_ixml_parser.
  METHODS create_encoding
    IMPORTING
      byte_order    TYPE i
      character_set TYPE string
    RETURNING
      VALUE(rval) TYPE REF TO if_ixml_encoding.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_ATTRIBUTE                       ', 'INTERFACE if_ixml_attribute PUBLIC.
  INTERFACES if_ixml_node.
  METHODS get_value RETURNING VALUE(val) TYPE string.
  METHODS set_value IMPORTING value TYPE string.
  METHODS get_name RETURNING VALUE(val) TYPE string.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_DOCUMENT                        ', 'INTERFACE if_ixml_document PUBLIC.
  INTERFACES if_ixml_node.

  ALIASES create_filter_name_ns FOR if_ixml_node~create_filter_name_ns.

  METHODS:
    set_encoding
      IMPORTING
        encoding TYPE REF TO object,
    set_standalone
      IMPORTING
        standalone TYPE abap_bool,
    get_standalone
      RETURNING
        VALUE(rval) TYPE abap_bool,
    set_namespace_prefix
      IMPORTING
        prefix TYPE string,
    append_child
      IMPORTING
        new_child TYPE REF TO if_ixml_node,
    get_first_child
      RETURNING
        VALUE(child) TYPE REF TO if_ixml_node,
    create_attribute_ns
      IMPORTING
        name TYPE string
        prefix TYPE string OPTIONAL
      RETURNING
        VALUE(element) TYPE REF TO if_ixml_attribute,
    create_element_ns
      IMPORTING
        name   TYPE string
        prefix TYPE string OPTIONAL
        uri    TYPE string OPTIONAL
      RETURNING
        VALUE(element) TYPE REF TO if_ixml_element,
    create_element
      IMPORTING
        name TYPE string
      RETURNING
        VALUE(element) TYPE REF TO if_ixml_element,
    create_iterator_filtered
      IMPORTING filter TYPE any
      RETURNING VALUE(val) TYPE REF TO if_ixml_node_iterator,
    create_filter_and
      IMPORTING
        filter1 TYPE any
        filter2 TYPE any
      RETURNING
        VALUE(val) TYPE REF TO if_ixml_node_filter,
    create_iterator
      RETURNING VALUE(rval) TYPE REF TO if_ixml_node_iterator,
    create_filter_node_type
      IMPORTING node_types TYPE i
      RETURNING VALUE(val) TYPE REF TO if_ixml_node_filter,
    create_simple_element_ns
      IMPORTING
        name       TYPE string
        parent     TYPE REF TO if_ixml_node
        prefix     TYPE string OPTIONAL
      RETURNING
        VALUE(val) TYPE REF TO if_ixml_element,
    create_filter_attribute
      IMPORTING
        name       TYPE string
      RETURNING
        VALUE(val) TYPE REF TO if_ixml_node_filter,
    create_simple_element
      IMPORTING
        name       TYPE string
        parent     TYPE REF TO if_ixml_node
        value      TYPE string OPTIONAL
      RETURNING
        VALUE(val) TYPE REF TO if_ixml_element,
    find_from_name
      IMPORTING
        name      TYPE string
        depth     TYPE i OPTIONAL
        namespace TYPE string OPTIONAL
      RETURNING
        VALUE(element) TYPE REF TO if_ixml_element,
    find_from_name_ns
      IMPORTING
        depth TYPE i OPTIONAL
        uri   TYPE string OPTIONAL
        name  TYPE string
      RETURNING
        VALUE(element) TYPE REF TO if_ixml_element,
    find_from_path
      IMPORTING
        path TYPE string
      RETURNING
        VALUE(val) TYPE REF TO if_ixml_element,
    get_elements_by_tag_name_ns
      IMPORTING
        name TYPE string
        namespace TYPE string OPTIONAL
        uri TYPE string OPTIONAL
      RETURNING VALUE(val) TYPE REF TO if_ixml_node_collection,
    get_elements_by_tag_name
      IMPORTING
        depth     TYPE i OPTIONAL
        name      TYPE string
        namespace TYPE string OPTIONAL
      RETURNING VALUE(val) TYPE REF TO if_ixml_node_collection,
    get_root RETURNING VALUE(node) TYPE REF TO if_ixml_node,
    get_root_element RETURNING VALUE(root) TYPE REF TO if_ixml_element.

  METHODS set_declaration
    IMPORTING
      declaration TYPE abap_bool.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_ELEMENT                         ', 'INTERFACE if_ixml_element PUBLIC.
  INTERFACES if_ixml_node.

  METHODS:
    remove_attribute_ns
      IMPORTING foo TYPE string,
    get_attributes
      RETURNING VALUE(attr) TYPE REF TO if_ixml_named_node_map,
    get_next
      RETURNING VALUE(next) TYPE REF TO if_ixml_element,
    get_name
      RETURNING VALUE(name) TYPE string,
    append_child
      IMPORTING
        new_child TYPE REF TO if_ixml_node
      RETURNING
        VALUE(rc) TYPE i,
    clone
      RETURNING VALUE(val) TYPE REF TO if_ixml_node,
    create_filter_node_type
      IMPORTING node_types TYPE i
      RETURNING VALUE(val) TYPE REF TO if_ixml_node_filter,
    create_iterator
      RETURNING VALUE(val) TYPE REF TO if_ixml_node_iterator,
    find_from_name_ns
      IMPORTING
        name      TYPE string
        namespace TYPE string OPTIONAL
        uri       TYPE string OPTIONAL
        depth     TYPE i OPTIONAL
      RETURNING VALUE(val) TYPE REF TO if_ixml_element,
    find_from_name
      IMPORTING
        name      TYPE string
        namespace TYPE string OPTIONAL
        depth     TYPE i OPTIONAL
      RETURNING VALUE(val) TYPE REF TO if_ixml_element,
    get_attribute_node
      IMPORTING name TYPE string
      RETURNING VALUE(val) TYPE REF TO if_ixml_attribute,
    get_attribute_ns
      IMPORTING
        name TYPE string
        uri TYPE string OPTIONAL
      RETURNING
        VALUE(val) TYPE string,
    get_attribute
      IMPORTING
        name TYPE string
        namespace TYPE string OPTIONAL
      RETURNING VALUE(val) TYPE string,
    get_children
      RETURNING VALUE(val) TYPE REF TO if_ixml_node_list,
    get_elements_by_tag_name
      IMPORTING
        name TYPE string
      RETURNING
        VALUE(val) TYPE REF TO if_ixml_node_collection,
    get_elements_by_tag_name_ns
      IMPORTING
        name TYPE string
        uri  TYPE string OPTIONAL
      RETURNING
        VALUE(val) TYPE REF TO if_ixml_node_collection,
    get_attribute_node_ns
        IMPORTING
        name TYPE string
        uri  TYPE string OPTIONAL
      RETURNING
        VALUE(val) TYPE REF TO if_ixml_attribute,
    get_first_child
      RETURNING VALUE(val) TYPE REF TO if_ixml_node,
    get_value
      RETURNING VALUE(val) TYPE string,
    remove_attribute
      IMPORTING name TYPE string,
    remove_node,
    render
      IMPORTING
        ostream TYPE REF TO if_ixml_ostream,
    set_attribute_node_ns
      IMPORTING
        attr TYPE any,
    set_attribute
      IMPORTING
        name        TYPE string
        namespace   TYPE string OPTIONAL
        value       TYPE string OPTIONAL
      RETURNING
        VALUE(rval) TYPE i,
    set_attribute_ns
      IMPORTING
        name   TYPE string
        prefix TYPE string OPTIONAL
        value  TYPE string OPTIONAL,
    set_value
      IMPORTING
        value TYPE string
      RETURNING
        VALUE(rc) TYPE i.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_ENCODING                        ', 'INTERFACE if_ixml_encoding PUBLIC.
  CONSTANTS co_none            TYPE i VALUE 0.
  CONSTANTS co_big_endian      TYPE i VALUE 1.
  CONSTANTS co_platform_endian TYPE i VALUE 4.

  METHODS get_byte_order
    RETURNING
      VALUE(rval) TYPE i.

  METHODS get_character_set
    RETURNING
      VALUE(rval) TYPE string.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_ISTREAM                         ', 'INTERFACE if_ixml_istream PUBLIC.
  CONSTANTS dtd_allowed    TYPE i VALUE 0.
  CONSTANTS dtd_restricted TYPE i VALUE 1.
  CONSTANTS dtd_prohibited TYPE i VALUE 2.

  METHODS close.

  METHODS get_dtd_restriction
    RETURNING
      VALUE(rval) TYPE i.

  METHODS set_dtd_restriction
    IMPORTING
      level TYPE i DEFAULT dtd_restricted.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_NAMED_NODE_MAP                  ', 'INTERFACE if_ixml_named_node_map PUBLIC.
  METHODS:
    create_iterator
      RETURNING VALUE(iterator) TYPE REF TO if_ixml_node_iterator,
    get_length
      RETURNING VALUE(val) TYPE i,
    get_named_item_ns
      IMPORTING name TYPE string
      RETURNING VALUE(val) TYPE REF TO if_ixml_node,
    get_named_item
      IMPORTING name TYPE string
      RETURNING VALUE(val) TYPE REF TO if_ixml_node,
    set_named_item_ns
      IMPORTING node TYPE REF TO if_ixml_node,
    remove_named_item
      IMPORTING name TYPE string.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_NODE                            ', 'INTERFACE if_ixml_node PUBLIC.
  CONSTANTS:
    co_node_document      TYPE i VALUE 1,
    co_node_element       TYPE i VALUE 4,
    co_node_text          TYPE i VALUE 16,
    co_node_cdata_section TYPE i VALUE 32.

  METHODS:
    append_child IMPORTING new_child TYPE REF TO if_ixml_node,
    get_attributes RETURNING VALUE(map) TYPE REF TO if_ixml_named_node_map,
    get_first_child RETURNING VALUE(node) TYPE REF TO if_ixml_node,
    get_children RETURNING VALUE(val) TYPE REF TO if_ixml_node_list,
    query_interface
      IMPORTING iid         TYPE i
      RETURNING VALUE(rval) TYPE REF TO if_ixml_unknown,
    remove_node,
    get_parent RETURNING VALUE(val) TYPE REF TO if_ixml_node,
    replace_child IMPORTING
      new_child TYPE string
      old_child TYPE string,
    get_name RETURNING VALUE(val) TYPE string,
    get_depth RETURNING VALUE(val) TYPE i,
    is_leaf RETURNING VALUE(val) TYPE abap_bool,
    get_namespace RETURNING VALUE(val) TYPE string,
    get_value RETURNING VALUE(val) TYPE string,
    get_type RETURNING VALUE(val) TYPE string,
    set_name IMPORTING name TYPE string,
    set_namespace_prefix IMPORTING val TYPE string,
    remove_child IMPORTING child TYPE REF TO if_ixml_node,
    set_value IMPORTING value TYPE string.

  METHODS get_gid
    RETURNING
      VALUE(rval) TYPE i.

  METHODS insert_child
    IMPORTING
      new_child   TYPE REF TO if_ixml_node
      ref_child   TYPE REF TO if_ixml_node
    RETURNING
      VALUE(rval) TYPE i.

  METHODS get_next
    RETURNING
      VALUE(rval) TYPE REF TO if_ixml_node.

  METHODS get_namespace_prefix
    RETURNING
      VALUE(rv_prefix) TYPE string.

  METHODS get_namespace_uri
    RETURNING
      VALUE(rval) TYPE string.

  METHODS get_height
    RETURNING
      VALUE(rval) TYPE i.

  METHODS create_filter_name_ns
    IMPORTING
      name        TYPE string
      namespace   TYPE string OPTIONAL
    RETURNING
      VALUE(rval) TYPE REF TO if_ixml_node_filter.

  METHODS get_column
    RETURNING
      VALUE(rval) TYPE i.

  METHODS create_iterator_filtered
    IMPORTING
      filter      TYPE REF TO if_ixml_node_filter
    RETURNING
      VALUE(rval) TYPE REF TO if_ixml_node_iterator.

  METHODS clone
    RETURNING
      VALUE(rval) TYPE REF TO if_ixml_node.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_NODE_COLLECTION                 ', 'INTERFACE if_ixml_node_collection PUBLIC.
  METHODS create_iterator
    RETURNING
      VALUE(rval) TYPE REF TO if_ixml_node_iterator.

  METHODS get_length
    RETURNING
      VALUE(rval) TYPE i.

  METHODS get_item
    IMPORTING
      index       TYPE i
    RETURNING
      VALUE(rval) TYPE REF TO if_ixml_node.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_NODE_FILTER                     ', 'INTERFACE if_ixml_node_filter PUBLIC.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_NODE_ITERATOR                   ', 'INTERFACE if_ixml_node_iterator PUBLIC.

  METHODS reset.

  METHODS get_next
    RETURNING
      VALUE(rval) TYPE REF TO if_ixml_node.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_NODE_LIST                       ', 'INTERFACE if_ixml_node_list PUBLIC.

  METHODS:
    get_length
      RETURNING
        VALUE(length) TYPE i,
    create_iterator
      RETURNING VALUE(rval) TYPE REF TO if_ixml_node_iterator,
    get_item
      IMPORTING
        index TYPE i
      RETURNING
        VALUE(val) TYPE REF TO if_ixml_node,
    create_rev_iterator_filtered
      IMPORTING
        filter TYPE any
      RETURNING
        VALUE(val) TYPE REF TO if_ixml_node_iterator.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_OSTREAM                         ', 'INTERFACE if_ixml_ostream PUBLIC.
  METHODS write_string
    IMPORTING
      string      TYPE string
    RETURNING
      VALUE(rval) TYPE i.

  METHODS get_num_written_raw
    RETURNING
      VALUE(rval) TYPE i.

  METHODS set_encoding
    IMPORTING
      encoding    TYPE REF TO if_ixml_encoding
    RETURNING
      VALUE(rval) TYPE boolean.

  METHODS set_pretty_print
    IMPORTING
      pretty_print TYPE abap_bool DEFAULT abap_true.

  METHODS get_pretty_print
    RETURNING
      VALUE(rval) TYPE boolean.

  METHODS get_indent
    RETURNING
      VALUE(rval) TYPE i.

  METHODS set_indent
    IMPORTING
      indent TYPE i.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_PARSE_ERROR                     ', 'INTERFACE if_ixml_parse_error PUBLIC.
  METHODS get_reason
    RETURNING
      VALUE(reason) TYPE string.
  METHODS get_line
    RETURNING
      VALUE(line) TYPE i.
  METHODS get_column
    RETURNING
      VALUE(column) TYPE i.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_PARSER                          ', 'INTERFACE if_ixml_parser PUBLIC.
  CONSTANTS co_no_validation   TYPE i VALUE 0.
  CONSTANTS co_validate_if_dtd TYPE i VALUE 2.

  METHODS parse
    RETURNING
      VALUE(subrc) TYPE i.
  METHODS set_normalizing
    IMPORTING
      normal TYPE abap_bool.
  METHODS num_errors
    RETURNING
      VALUE(errors) TYPE i.
  METHODS add_strip_space_element.
  METHODS get_error
    IMPORTING
      index TYPE i
    RETURNING
      VALUE(error) TYPE REF TO if_ixml_parse_error.
  METHODS set_validating
    IMPORTING
      mode TYPE i OPTIONAL
    RETURNING
      VALUE(rval) TYPE abap_bool.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_RENDERER                        ', 'INTERFACE if_ixml_renderer PUBLIC.
  METHODS render RETURNING VALUE(rval) TYPE i.
  METHODS set_normalizing IMPORTING normal TYPE abap_bool.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_STREAM_FACTORY                  ', 'INTERFACE if_ixml_stream_factory PUBLIC.
  METHODS create_ostream_cstring
    IMPORTING
      string        TYPE string
    RETURNING
      VALUE(stream) TYPE REF TO if_ixml_ostream.

  METHODS create_ostream_xstring
    IMPORTING
      string        TYPE xstring
    RETURNING
      VALUE(stream) TYPE REF TO if_ixml_ostream.

  METHODS create_istream_string
    IMPORTING
      string        TYPE string
    RETURNING
      VALUE(stream) TYPE REF TO if_ixml_istream.

  METHODS create_istream_xstring
    IMPORTING
      string        TYPE xstring
    RETURNING
      VALUE(stream) TYPE REF TO if_ixml_istream.

  METHODS create_ostream_itable
    IMPORTING
      table       TYPE table
    RETURNING
      VALUE(rval) TYPE REF TO if_ixml_ostream.

  METHODS create_istream_cstring
    IMPORTING
      string TYPE string
    RETURNING
      VALUE(rval) TYPE REF TO if_ixml_istream.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_UNKNOWN                         ', 'INTERFACE if_ixml_unknown PUBLIC.
  METHODS query_interface
    IMPORTING
      iid         TYPE i
    RETURNING
      VALUE(rval) TYPE REF TO if_ixml_unknown.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('/UI2/CL_JSON                            ', 'CLASS /ui2/cl_json DEFINITION PUBLIC.
  PUBLIC SECTION.

    TYPES pretty_name_mode TYPE string.

    CONSTANTS: BEGIN OF pretty_mode,
                 none       TYPE string VALUE '''',
                 low_case   TYPE string VALUE ''low_case'',
                 camel_case TYPE string VALUE ''camel_case'',
               END OF pretty_mode.

    TYPES tribool TYPE c LENGTH 1.

    CLASS-METHODS deserialize
      IMPORTING
        json             TYPE string OPTIONAL
        jsonx            TYPE xstring OPTIONAL
        pretty_name      TYPE string OPTIONAL
        assoc_arrays     TYPE abap_bool OPTIONAL
        assoc_arrays_opt TYPE abap_bool OPTIONAL
      CHANGING
        data             TYPE data.

    CLASS-METHODS serialize
      IMPORTING
        data          TYPE data
        compress      TYPE abap_bool OPTIONAL
        pretty_name   TYPE string OPTIONAL
        assoc_arrays  TYPE abap_bool OPTIONAL
        ts_as_iso8601 TYPE abap_bool OPTIONAL
        type_descr    TYPE REF TO cl_abap_typedescr OPTIONAL
        format_output TYPE abap_bool OPTIONAL
      RETURNING
        VALUE(r_json) TYPE string.

    CLASS-METHODS generate
      IMPORTING
        json        TYPE string
        pretty_name TYPE string OPTIONAL
      RETURNING
        VALUE(rr_data) TYPE REF TO data.

    METHODS serialize_int
      IMPORTING
        data          TYPE data
        type_descr    TYPE REF TO cl_abap_typedescr OPTIONAL
      RETURNING
        VALUE(r_json) TYPE string.

    METHODS constructor
      IMPORTING
        compress TYPE abap_bool DEFAULT abap_false
        pretty_name TYPE pretty_name_mode DEFAULT pretty_mode-none
        assoc_arrays TYPE abap_bool DEFAULT abap_false
        ts_as_iso8601 TYPE abap_bool DEFAULT abap_false.

  PROTECTED SECTION.

    DATA mv_compress TYPE abap_bool.
    DATA mv_pretty_name TYPE string.
    DATA mv_assoc_arrays TYPE abap_bool.
    DATA mv_ts_as_iso8601 TYPE abap_bool.
    DATA mv_extended TYPE abap_bool.

    METHODS is_compressable
      IMPORTING
        type_descr TYPE REF TO cl_abap_typedescr
        name       TYPE string
      RETURNING
      VALUE(rv_compress) TYPE abap_bool.

  PRIVATE SECTION.
    CLASS-DATA mo_parsed TYPE REF TO lcl_parser.
    CLASS-METHODS _deserialize
      IMPORTING
        VALUE(prefix) TYPE string
        pretty_name   TYPE string OPTIONAL
        io_type       TYPE REF TO cl_abap_typedescr
      CHANGING
        data          TYPE data.
ENDCLASS.

CLASS /ui2/cl_json IMPLEMENTATION.

  METHOD serialize_int.

    DATA lo_type       TYPE REF TO cl_abap_typedescr.
    DATA lo_struct     TYPE REF TO cl_abap_structdescr.
    DATA lo_table      TYPE REF TO cl_abap_tabledescr.
    DATA lt_components TYPE cl_abap_structdescr=>component_table.
    DATA ref           TYPE REF TO data.
    DATA lv_index      TYPE i.

    FIELD-SYMBOLS <ls_component> LIKE LINE OF lt_components.
    FIELD-SYMBOLS <any> TYPE any.
    FIELD-SYMBOLS <tab> TYPE ANY TABLE.

    IF type_descr IS INITIAL.
      lo_type = cl_abap_typedescr=>describe_by_data( data ).
    ELSE.
      lo_type = type_descr.
    ENDIF.

    CASE lo_type->kind.
      WHEN cl_abap_typedescr=>kind_elem.
*        WRITE ''@KERNEL console.dir(lo_type);''.
        CASE lo_type->type_kind.
          WHEN cl_abap_typedescr=>typekind_char.
            IF lo_type->absolute_name = \`\\TYPE-POOL=ABAP\\TYPE=ABAP_BOOL\`.
              IF data = abap_true.
                r_json = ''true''.
              ELSE.
                r_json = ''false''.
              ENDIF.
            ELSEIF data IS INITIAL.
              r_json = ''""''.
            ELSE.
              r_json = ''"'' && escape( val = |{ data }| format = cl_abap_format=>e_json_string )  && ''"''.
            ENDIF.
          WHEN cl_abap_typedescr=>typekind_string.
            r_json = ''"'' && escape( val = data format = cl_abap_format=>e_json_string ) && ''"''.
          WHEN cl_abap_typedescr=>typekind_int.
            r_json = |{ data }|.
          WHEN cl_abap_typedescr=>typekind_num.
            IF data = 0.
              r_json = |0|.
            ELSE.
              r_json = |{ data }|.
              SHIFT r_json LEFT DELETING LEADING ''0''.
            ENDIF.
          WHEN cl_abap_typedescr=>typekind_packed.
            IF mv_ts_as_iso8601 = abap_true
                AND ( lo_type->absolute_name = \`\\TYPE=TIMESTAMP\`
                OR lo_type->absolute_name = \`\\TYPE=TIMESTAMPL\` ).
              IF data IS INITIAL.
                r_json = |""|.
              ELSE.
                r_json = |"{ data TIMESTAMP = ISO }.0000000Z"|.
              ENDIF.
            ELSE.
              r_json = |{ data }|.
            ENDIF.
          WHEN cl_abap_typedescr=>typekind_date.
            r_json = |"{ data DATE = ISO }"|.
          WHEN cl_abap_typedescr=>typekind_time.
            r_json = |"{ data TIME = ISO }"|.
          WHEN OTHERS.
            r_json = data.
        ENDCASE.
      WHEN cl_abap_typedescr=>kind_table.
        r_json = ''[''.
        ASSIGN data TO <tab>.
        lo_table ?= lo_type.
        LOOP AT <tab> ASSIGNING <any>.
          lv_index = sy-tabix.
          r_json = r_json && serialize_int(
            data       = <any>
            type_descr = lo_table->get_table_line_type( ) ).

          IF lines( <tab> ) <> lv_index.
            r_json = r_json && '',''.
          ENDIF.
        ENDLOOP.
        r_json = r_json && '']''.
      WHEN cl_abap_typedescr=>kind_struct.
        lo_struct ?= lo_type.
        lt_components = lo_struct->get_components( ).
        r_json = ''{''.
        LOOP AT lt_components ASSIGNING <ls_component>.
          ASSIGN COMPONENT <ls_component>-name OF STRUCTURE data TO <any>.
          ASSERT sy-subrc = 0.
          IF mv_compress = abap_true AND <any> IS INITIAL.
            CONTINUE.
          ENDIF.
          IF mv_pretty_name = pretty_mode-camel_case.
            r_json = r_json && |"{ to_mixed( to_lower( <ls_component>-name ) ) }":|.
          ELSEIF mv_pretty_name = pretty_mode-low_case.
            r_json = r_json && |"{ to_lower( <ls_component>-name ) }":|.
          ELSE.
            r_json = r_json && |"{ <ls_component>-name }":|.
          ENDIF.
          r_json = r_json && serialize_int(
            data       = <any>
            type_descr = <ls_component>-type ).
          r_json = r_json && '',''.
        ENDLOOP.
        IF r_json CP ''*,''.
          r_json = substring( val = r_json off = 0 len = strlen( r_json ) - 1 ).
        ENDIF.
        r_json = r_json && ''}''.
      WHEN cl_abap_typedescr=>kind_ref.
        IF data IS INITIAL.
          r_json = ''null''.
          RETURN.
        ENDIF.
        ASSIGN data->* TO <any>.
        r_json = serialize_int( data = <any> ).
      WHEN OTHERS.
        ASSERT 1 = ''cl_json, unknown kind''.
    ENDCASE.
  ENDMETHOD.

  METHOD deserialize.

    DATA lo_type TYPE REF TO cl_abap_typedescr.

    CREATE OBJECT mo_parsed.

    IF jsonx IS NOT INITIAL.
      mo_parsed->parse( cl_abap_codepage=>convert_from( jsonx ) ).
    ELSEIF json IS INITIAL.
      RETURN.
    ELSE.
      mo_parsed->parse( json ).
    ENDIF.

* todo, this should take the "pretty_name" into account
    mo_parsed->adjust_names( ).

    lo_type = cl_abap_typedescr=>describe_by_data( data ).

    _deserialize(
      EXPORTING
        prefix      = ''''
        pretty_name = pretty_name
        io_type     = lo_type
      CHANGING
        data        = data ).

  ENDMETHOD.

  METHOD constructor.

    DATA rtti TYPE REF TO cl_abap_classdescr.

    mv_compress       = compress.
    mv_pretty_name    = pretty_name.
    mv_assoc_arrays   = assoc_arrays.
    mv_ts_as_iso8601  = ts_as_iso8601.

*  rtti ?= cl_abap_classdescr=>describe_by_object_ref( me ).
*  IF rtti->absolute_name NE mc_me_type.
*    mv_extended = abap_true.
*  ENDIF.

  ENDMETHOD.

  METHOD is_compressable.
    rv_compress = abap_true.
  ENDMETHOD.

  METHOD generate.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD serialize.

    DATA lo_json  TYPE REF TO /ui2/cl_json.

    ASSERT format_output IS INITIAL.

    CREATE OBJECT lo_json
      EXPORTING
        compress      = compress
        pretty_name   = pretty_name
        assoc_arrays  = assoc_arrays
        ts_as_iso8601 = ts_as_iso8601.

    r_json = lo_json->serialize_int(
      data       = data
      type_descr = type_descr ).

  ENDMETHOD.

  METHOD _deserialize.
    DATA lo_struct     TYPE REF TO cl_abap_structdescr.
    DATA lo_table      TYPE REF TO cl_abap_tabledescr.
    DATA lo_refdescr   TYPE REF TO cl_abap_refdescr.
    DATA lt_components TYPE cl_abap_structdescr=>component_table.
    DATA ls_component  LIKE LINE OF lt_components.
    DATA lt_members    TYPE string_table.
    DATA ref           TYPE REF TO data.
    DATA lv_name       TYPE string.
    DATA lv_type       TYPE string.
    DATA lv_value      TYPE string.
    DATA lv_member     LIKE LINE OF lt_members.

    FIELD-SYMBOLS <any> TYPE any.
    FIELD-SYMBOLS <at> TYPE ANY TABLE.
    FIELD-SYMBOLS <ls_component> LIKE LINE OF lt_components.

    prefix = mo_parsed->find_ignore_case( prefix ).

*    WRITE ''@KERNEL console.dir(lo_type.get());''.
    CASE io_type->kind.
      WHEN cl_abap_typedescr=>kind_elem.
*        WRITE ''@KERNEL console.dir(lo_type.get().absolute_name);''.
        IF io_type->absolute_name = ''\\TYPE-POOL=ABAP\\TYPE=ABAP_BOOL''
            OR io_type->absolute_name = ''\\TYPE=ABAP_BOOLEAN''
            OR io_type->absolute_name = ''\\TYPE=FLAG''.
          data = boolc( mo_parsed->value_string( prefix ) = ''true'' ).
        ELSEIF io_type->absolute_name = \`\\TYPE=TIMESTAMP\`
            OR io_type->absolute_name = \`\\TYPE=TIMESTAMPL\`.
          lv_value = mo_parsed->value_string( prefix ).
          REPLACE ALL OCCURRENCES OF ''-'' IN lv_value WITH ''''.
          REPLACE ALL OCCURRENCES OF ''T'' IN lv_value WITH ''''.
          REPLACE ALL OCCURRENCES OF '':'' IN lv_value WITH ''''.
          REPLACE ALL OCCURRENCES OF ''Z'' IN lv_value WITH ''''.
          data = lv_value.
        ELSEIF io_type->type_kind = cl_abap_typedescr=>typekind_date.
          lv_value = mo_parsed->value_string( prefix ).
          REPLACE ALL OCCURRENCES OF ''-'' IN lv_value WITH ''''.
          IF lv_value CO space.
            CLEAR data.
          ELSE.
            data = lv_value.
          ENDIF.
        ELSEIF io_type->type_kind = cl_abap_typedescr=>typekind_time.
          lv_value = mo_parsed->value_string( prefix ).
          REPLACE ALL OCCURRENCES OF '':'' IN lv_value WITH ''''.
          IF lv_value CO space.
            CLEAR data.
          ELSE.
            data = lv_value.
          ENDIF.
        ELSE.
          data = mo_parsed->value_string( prefix ).
        ENDIF.
      WHEN cl_abap_typedescr=>kind_table.
        lo_table ?= io_type.
        lt_members = mo_parsed->members( prefix && ''/'' ).
        ASSIGN data TO <at>.
        LOOP AT lt_members INTO lv_member.
*          WRITE ''@KERNEL console.dir(lv_member.get());''.
          CREATE DATA ref LIKE LINE OF data.
          ASSIGN ref->* TO <any>.
          _deserialize(
            EXPORTING
              prefix      = prefix && ''/'' && lv_member
              pretty_name = pretty_name
              io_type     = lo_table->get_table_line_type( )
            CHANGING
              data        = <any> ).
*          WRITE ''@KERNEL console.dir(fs_row_);''.
          INSERT <any> INTO TABLE <at>.
        ENDLOOP.
      WHEN cl_abap_typedescr=>kind_struct.
        lo_struct ?= io_type.
        lt_components = lo_struct->get_components( ).
        LOOP AT lt_components ASSIGNING <ls_component>.
          ASSIGN COMPONENT <ls_component>-name OF STRUCTURE data TO <any>.
          ASSERT sy-subrc = 0.
          CASE pretty_name.
            WHEN pretty_mode-camel_case.
              lv_name = to_mixed( to_lower( <ls_component>-name ) ).
            WHEN OTHERS.
              lv_name = to_lower( <ls_component>-name ).
          ENDCASE.
          " WRITE ''@KERNEL console.dir("structure: " + lv_name.get());''.
          _deserialize(
            EXPORTING
              prefix      = prefix && ''/'' && lv_name
              pretty_name = pretty_name
              io_type     = <ls_component>-type
            CHANGING
              data        = <any> ).
        ENDLOOP.
      WHEN cl_abap_typedescr=>kind_ref.
        lo_refdescr ?= io_type.
        IF data IS INITIAL.
          lt_members = mo_parsed->members( prefix && ''/'' ).

*          WRITE ''@KERNEL console.dir(prefix.get());''.
          IF lines( lt_members ) = 0 AND prefix = ''''.
            RETURN.
          ENDIF.

          lv_type = mo_parsed->get_type( prefix && ''/'' ).
          IF lv_type IS INITIAL.
            lv_type = mo_parsed->get_type( prefix ).
          ENDIF.
*          WRITE ''@KERNEL console.dir("type: " + lv_type.get());''.

          IF lines( lt_members ) > 0 AND lv_type = ''object''.
            CLEAR lt_components.
            LOOP AT lt_members INTO lv_member.
*              WRITE ''@KERNEL console.dir("component: " + lv_member.get());''.
              CLEAR ls_component.
              ls_component-name = to_upper( lv_member ).
              TRANSLATE ls_component-name USING ''-_''.
              ls_component-type = cl_abap_refdescr=>get_ref_to_data( ).
              ASSERT ls_component-name IS NOT INITIAL.
              APPEND ls_component TO lt_components.
            ENDLOOP.
            lo_struct = cl_abap_structdescr=>create( lt_components ).
            CREATE DATA data TYPE HANDLE lo_struct.
          ELSEIF lv_type = ''array''.
            lo_table = cl_abap_tabledescr=>create( cl_abap_refdescr=>get_ref_to_data( ) ).
            CREATE DATA data TYPE HANDLE lo_table.
          ELSE.
            CASE lv_type.
              WHEN ''num''.
                lv_value = mo_parsed->value_string( prefix ).
                IF lv_value CO ''-0123456789''.
                  CREATE DATA data TYPE i.
                ELSEIF lv_value CO ''-0123456789.''.
                  CREATE DATA data TYPE f.
                ELSE.
                  ASSERT 1 = ''todo''.
                ENDIF.
              WHEN ''bool''.
                CREATE DATA data TYPE HANDLE cl_abap_typedescr=>describe_by_name( ''ABAP_BOOL'' ).
              WHEN ''str''.
                CREATE DATA data TYPE HANDLE cl_abap_elemdescr=>get_string( ).
              " WHEN OTHERS.
              "   ASSERT 1 = ''todo''.
            ENDCASE.
          ENDIF.
        ENDIF.
        ASSIGN data->* TO <any>.
* todo: optimize, it should not be nessesary to call cl_abap_typedescr
        _deserialize(
          EXPORTING
            prefix      = prefix
            pretty_name = pretty_name
            io_type     = cl_abap_typedescr=>describe_by_data( <any> )
          CHANGING
            data        = <any> ).
      WHEN OTHERS.
        ASSERT 1 = ''cl_json, unknown kind''.
    ENDCASE.
  ENDMETHOD.

ENDCLASS.
');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_CALL_TRANSFORMATION              ', 'CLASS kernel_call_transformation DEFINITION PUBLIC.
* handling of ABAP statement CALL TRANSFORMATION
  PUBLIC SECTION.
    TYPES: BEGIN OF ty_options,
             initial_components TYPE string,
           END OF ty_options.

    CONSTANTS: BEGIN OF gc_options,
                 suppress TYPE string VALUE ''suppress'',
               END OF gc_options.

    CLASS-METHODS call
      IMPORTING
        name    TYPE any
        options TYPE any.
  PRIVATE SECTION.
    CLASS-DATA mi_doc     TYPE REF TO if_ixml_document.
    CLASS-DATA ms_options TYPE ty_options.

    CLASS-METHODS parse_xml
      IMPORTING
        iv_xml TYPE string.

    CLASS-METHODS parse_options
      IMPORTING options TYPE any.
ENDCLASS.

CLASS kernel_call_transformation IMPLEMENTATION.

  METHOD call.
* first convert SOURCE to internal format stored in "MI_DOC"?
* then output to RESULT

    DATA lv_name   TYPE string.
    DATA lv_source TYPE string.
    DATA lv_result TYPE string.
    DATA result    TYPE REF TO data.
    DATA lt_rtab   TYPE abap_trans_resbind_tab.
    DATA ls_rtab   LIKE LINE OF lt_rtab.
    DATA lv_type   TYPE string.
    DATA lv_dummy  TYPE string.
    DATA li_writer TYPE REF TO if_sxml_writer.
    DATA li_doc    TYPE REF TO if_ixml_document.


    CLEAR mi_doc.

*    WRITE ''@KERNEL console.dir(INPUT);''.

* only the ID transformation is implemented
    WRITE ''@KERNEL lv_name.set(INPUT.name.toUpperCase());''.
    ASSERT lv_name = ''ID''.

    parse_options( options ).

* Handle input SOURCE
    WRITE ''@KERNEL if (INPUT.sourceXML?.constructor.name === "ABAPObject") this.mi_doc.set(INPUT.sourceXML);''.
    WRITE ''@KERNEL if (INPUT.sourceXML?.constructor.name === "String") lv_source.set(INPUT.sourceXML);''.
    IF lv_source IS NOT INITIAL.
      IF lv_source(1) = ''<''.
        lv_type = ''XML''.
        parse_xml( lv_source ).
      ELSEIF lv_source(1) = ''{'' OR lv_source(1) = ''[''.
        lv_type = ''JSON''.
        mi_doc = kernel_json_to_ixml=>build( lv_source ).
      ELSE.
        RAISE EXCEPTION TYPE cx_xslt_format_error.
      ENDIF.
    ENDIF.

* input = object, output = ixml_document
    WRITE ''@KERNEL if (typeof INPUT.source === "object"''.
    WRITE ''@KERNEL     && INPUT.resultXML?.constructor.name === "ABAPObject"''.
    WRITE ''@KERNEL     && INPUT.resultXML?.qualifiedName === "IF_IXML_DOCUMENT") {''.
    WRITE ''@KERNEL   li_doc.set(INPUT.resultXML);''.
    WRITE ''@KERNEL   lv_dummy = INPUT.source;''.
    WRITE ''@KERNEL }''.
    IF li_doc IS NOT INITIAL.
      lcl_object_to_ixml=>run(
        ii_doc = li_doc
        source = lv_dummy ).
      RETURN.
    ENDIF.

* input = object, output = sxml_writer
    WRITE ''@KERNEL if (typeof INPUT.source === "object"''.
    WRITE ''@KERNEL     && INPUT.resultXML?.constructor.name === "ABAPObject") {''.
    WRITE ''@KERNEL   li_writer.set(INPUT.resultXML);''.
    WRITE ''@KERNEL   lv_dummy = INPUT.source;''.
    WRITE ''@KERNEL }''.
    IF li_writer IS NOT INITIAL.
      lcl_object_to_sxml=>run(
        ii_writer = li_writer
        source    = lv_dummy ).
      RETURN.
    ENDIF.

* input = object, output = string
    WRITE ''@KERNEL if (INPUT.resultXML && INPUT.resultXML.constructor.name === "String") {''.
    WRITE ''@KERNEL   lv_result.set("X");''.
    WRITE ''@KERNEL   lv_dummy = INPUT.source;''.
    WRITE ''@KERNEL }''.
    IF lv_result = abap_true.
      lv_result = lcl_object_to_string=>run(
        is_options = ms_options
        source     = lv_dummy ).
      WRITE ''@KERNEL   INPUT.resultXML.set(lv_result);''.
      RETURN.
    ENDIF.

    IF lv_source IS INITIAL AND mi_doc IS INITIAL.
      RAISE EXCEPTION TYPE cx_xslt_runtime_error.
    ENDIF.

* output = is an ABAP internal table, dynamic result parameter
    WRITE ''@KERNEL if (INPUT.result.constructor.name === "Table") {''.
    WRITE ''@KERNEL lt_rtab = INPUT.result;''.
    LOOP AT lt_rtab INTO ls_rtab.
      kernel_ixml_xml_to_data=>build(
        iv_name = ls_rtab-name
        iv_ref  = ls_rtab-value
        ii_doc  = mi_doc ).
    ENDLOOP.
    WRITE ''@KERNEL } else {''.
* INPUT.result is a javascript structure
    WRITE ''@KERNEL for (const name in INPUT.result) {''.
    WRITE ''@KERNEL   lv_name.set(name.toUpperCase());''.
    WRITE ''@KERNEL   if (INPUT.result[name].constructor.name === "FieldSymbol") {''.
    WRITE ''@KERNEL     result.assign(INPUT.result[name].getPointer());''.
    WRITE ''@KERNEL   } else {''.
    WRITE ''@KERNEL     result.assign(INPUT.result[name]);''.
    WRITE ''@KERNEL   }''.
    IF lv_type = ''JSON''.
      kernel_ixml_json_to_data=>build(
        iv_name = lv_name
        iv_ref  = result
        ii_doc  = mi_doc ).
    ELSE.
      kernel_ixml_xml_to_data=>build(
        iv_name = lv_name
        iv_ref  = result
        ii_doc  = mi_doc ).
    ENDIF.
    WRITE ''@KERNEL }''.
    WRITE ''@KERNEL }''.

  ENDMETHOD.

  METHOD parse_options.
* https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abapcall_transformation_options.htm

    DATA lv_name  TYPE string.
    DATA lv_value TYPE string.

    FIELD-SYMBOLS <lv_field> TYPE string.


    WRITE ''@KERNEL for (const name in INPUT.options || {}) {''.
    WRITE ''@KERNEL   lv_name.set(name);''.
    WRITE ''@KERNEL   lv_value.set(INPUT.options[name]);''.
    ASSIGN COMPONENT lv_name OF STRUCTURE ms_options TO <lv_field>.
    IF sy-subrc = 0.
      <lv_field> = lv_value.
    ENDIF.
    WRITE ''@KERNEL }''.

  ENDMETHOD.


  METHOD parse_xml.

    DATA li_factory TYPE REF TO if_ixml_stream_factory.
    DATA li_istream TYPE REF TO if_ixml_istream.
    DATA li_parser  TYPE REF TO if_ixml_parser.
    DATA li_ixml    TYPE REF TO if_ixml.
    DATA lv_subrc   TYPE i.

    li_ixml = cl_ixml=>create( ).
    mi_doc  = li_ixml->create_document( ).

    li_factory = li_ixml->create_stream_factory( ).
    li_istream = li_factory->create_istream_string( iv_xml ).
    li_parser = li_ixml->create_parser( stream_factory = li_factory
                                        istream        = li_istream
                                        document       = mi_doc ).
    li_parser->add_strip_space_element( ).
    lv_subrc = li_parser->parse( ).
    li_istream->close( ).

    ASSERT lv_subrc = 0.

  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_IXML_JSON_TO_DATA                ', 'CLASS kernel_ixml_json_to_data DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS build
      IMPORTING
        iv_name TYPE string
        iv_ref  TYPE REF TO data
        ii_doc  TYPE REF TO if_ixml_document.
  PRIVATE SECTION.
    CLASS-METHODS get_field_name
      IMPORTING ii_node TYPE REF TO if_ixml_node
      RETURNING VALUE(rv_name) TYPE string.
    CLASS-METHODS traverse
      IMPORTING
        ii_node TYPE REF TO if_ixml_node
        iv_ref  TYPE REF TO data.
ENDCLASS.

CLASS kernel_ixml_json_to_data IMPLEMENTATION.

  METHOD get_field_name.
    DATA li_aiterator TYPE REF TO if_ixml_node_iterator.
    DATA li_anode TYPE REF TO if_ixml_node.
    DATA attr TYPE REF TO if_ixml_named_node_map.

    attr = ii_node->get_attributes( ).
    IF attr IS NOT INITIAL.
      li_aiterator = attr->create_iterator( ).
      DO.
        li_anode = li_aiterator->get_next( ).
        IF li_anode IS INITIAL.
          EXIT. " current loop
        ENDIF.
* assume its the name,
        rv_name = li_anode->get_value( ).
        RETURN.
      ENDDO.
    ENDIF.
  ENDMETHOD.

  METHOD build.
* assumptions: the top level element is an object containing iv_name
    DATA li_first    TYPE REF TO if_ixml_node.
    DATA li_node     TYPE REF TO if_ixml_node.
    DATA lv_name     TYPE string.
    DATA li_iterator TYPE REF TO if_ixml_node_iterator.

    li_first = ii_doc->get_root( )->get_first_child( ).
    ASSERT li_first->get_name( ) = ''object''.

    li_iterator = li_first->get_children( )->create_iterator( ).
    DO.
      li_node = li_iterator->get_next( ).
      IF li_node IS INITIAL.
        EXIT. " current loop
      ENDIF.

      lv_name = get_field_name( li_node ).
      IF lv_name = iv_name.
*        WRITE ''@KERNEL console.dir("found");''.
        traverse(
          iv_ref  = iv_ref
          ii_node = li_node ).
        RETURN.
      ENDIF.
    ENDDO.
  ENDMETHOD.

  METHOD traverse.

    DATA lo_type     TYPE REF TO cl_abap_typedescr.
    DATA li_child    TYPE REF TO if_ixml_node.
    DATA lv_name     TYPE string.
    DATA li_iterator TYPE REF TO if_ixml_node_iterator.
    DATA lv_ref      TYPE REF TO data.

    FIELD-SYMBOLS <any>   TYPE any.
    FIELD-SYMBOLS <field> TYPE any.
    FIELD-SYMBOLS <tab>   TYPE ANY TABLE.

    lo_type = cl_abap_typedescr=>describe_by_data( iv_ref->* ).
    CASE lo_type->kind.
      WHEN cl_abap_typedescr=>kind_struct.
        ASSERT ii_node->get_name( ) = ''object''.
        ASSIGN iv_ref->* TO <any>.
        li_iterator = ii_node->get_children( )->create_iterator( ).
        DO.
          li_child = li_iterator->get_next( ).
          IF li_child IS INITIAL.
            EXIT. " current loop
          ENDIF.
          lv_name = get_field_name( li_child ).
          ASSIGN COMPONENT lv_name OF STRUCTURE <any> TO <field>.
          IF sy-subrc = 0.
            GET REFERENCE OF <field> INTO lv_ref.
            traverse( ii_node = li_child
                      iv_ref  = lv_ref ).
          ENDIF.
        ENDDO.
      WHEN cl_abap_typedescr=>kind_elem.
        li_child = ii_node->get_first_child( ).
        ASSERT li_child->get_name( ) = ''#text''.
        ASSIGN iv_ref->* TO <any>.
        <any> = li_child->get_value( ).

        IF lo_type->type_kind = cl_abap_typedescr=>typekind_char
            OR lo_type->type_kind = cl_abap_typedescr=>typekind_clike
            OR lo_type->type_kind = cl_abap_typedescr=>typekind_string.
          REPLACE ALL OCCURRENCES OF ''\\"'' IN <any> WITH ''"''.
        ENDIF.
      WHEN cl_abap_typedescr=>kind_table.
        ASSERT ii_node->get_name( ) = ''array''.
        ASSIGN iv_ref->* TO <tab>.
        li_iterator = ii_node->get_children( )->create_iterator( ).
        DO.
          li_child = li_iterator->get_next( ).
          IF li_child IS INITIAL.
            EXIT. " current loop
          ENDIF.
          CREATE DATA lv_ref LIKE LINE OF <tab>.
          ASSIGN lv_ref->* TO <any>.
          traverse( ii_node = li_child
                  iv_ref  = lv_ref ).
          INSERT <any> INTO TABLE <tab>.
        ENDDO.
      WHEN OTHERS.
        WRITE ''@KERNEL console.dir(lo_type.get().kind.get());''.
        ASSERT 1 = ''todo''.
    ENDCASE.

  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_IXML_XML_TO_DATA                 ', 'CLASS kernel_ixml_xml_to_data DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS build
      IMPORTING
        iv_name TYPE string
        iv_ref  TYPE REF TO data
        ii_doc  TYPE REF TO if_ixml_document.
  PRIVATE SECTION.
    CLASS-DATA mi_heap TYPE REF TO if_ixml_element.

    CLASS-METHODS traverse
      IMPORTING
        ii_node TYPE REF TO if_ixml_node
        iv_ref  TYPE REF TO data.

    CLASS-METHODS find_href_in_heap
      IMPORTING
        VALUE(iv_href) TYPE string
      RETURNING
        VALUE(ri_node) TYPE REF TO if_ixml_node.
ENDCLASS.

CLASS kernel_ixml_xml_to_data IMPLEMENTATION.

  METHOD build.

    DATA li_first    TYPE REF TO if_ixml_element.
    DATA li_node     TYPE REF TO if_ixml_node.
    DATA lv_name     TYPE string.
    DATA li_iterator TYPE REF TO if_ixml_node_iterator.

    mi_heap = ii_doc->find_from_name_ns( ''heap'' ).
*    WRITE ''@KERNEL console.dir(this.mi_heap);''.

    li_first ?= ii_doc->get_root( )->get_first_child( ).

    li_node = li_first->find_from_name_ns(
      name      = iv_name
      depth     = 0
      namespace = '''' ).
    IF li_node IS NOT INITIAL.
      traverse( ii_node = li_node
                iv_ref  = iv_ref ).
    ENDIF.
  ENDMETHOD.

  METHOD find_href_in_heap.

    DATA li_iterator TYPE REF TO if_ixml_node_iterator.
    DATA li_child    TYPE REF TO if_ixml_node.
    DATA lv_id       TYPE string.

    REPLACE FIRST OCCURRENCE OF ''#'' IN iv_href WITH ''''.
    ASSERT mi_heap IS NOT INITIAL.
    ASSERT iv_href IS NOT INITIAL.

    li_iterator = mi_heap->get_children( )->create_iterator( ).

    DO.
      li_child = li_iterator->get_next( ).
      IF li_child IS INITIAL.
        EXIT. " current loop
      ENDIF.
      lv_id = li_child->get_attributes( )->get_named_item_ns( ''id'' )->get_value( ).
      IF lv_id = iv_href.
        ri_node = li_child.
        RETURN.
      ENDIF.
    ENDDO.

    ASSERT 1 = ''not found in heap''.

  ENDMETHOD.

  METHOD traverse.

    DATA lo_type     TYPE REF TO cl_abap_typedescr.
    DATA li_child    TYPE REF TO if_ixml_node.
    DATA li_heap     TYPE REF TO if_ixml_node.
    DATA li_iname    TYPE REF TO if_ixml_node.
    DATA lv_name     TYPE string.
    DATA li_iterator TYPE REF TO if_ixml_node_iterator.
    DATA lv_ref      TYPE REF TO data.
    DATA lv_value    TYPE string.
    DATA li_href     TYPE REF TO if_ixml_node.

    FIELD-SYMBOLS <any>   TYPE any.
    FIELD-SYMBOLS <field> TYPE any.
    FIELD-SYMBOLS <tab>   TYPE ANY TABLE.

    lo_type = cl_abap_typedescr=>describe_by_data( iv_ref->* ).
    CASE lo_type->kind.
      WHEN cl_abap_typedescr=>kind_struct.
        ASSIGN iv_ref->* TO <any>.
        li_iterator = ii_node->get_children( )->create_iterator( ).
        DO.
          li_child = li_iterator->get_next( ).
          IF li_child IS INITIAL.
            EXIT. " current loop
          ENDIF.
          lv_name = li_child->get_name( ).
          ASSIGN COMPONENT lv_name OF STRUCTURE <any> TO <field>.
          IF sy-subrc = 0.
            GET REFERENCE OF <field> INTO lv_ref.
            traverse( ii_node = li_child
                      iv_ref  = lv_ref ).
          ENDIF.
        ENDDO.
      WHEN cl_abap_typedescr=>kind_elem.
        li_child = ii_node->get_first_child( ).
        IF li_child IS NOT INITIAL.
          ASSIGN iv_ref->* TO <any>.
          <any> = li_child->get_value( ).
        ENDIF.
      WHEN cl_abap_typedescr=>kind_table.
        ASSIGN iv_ref->* TO <tab>.
        li_iterator = ii_node->get_children( )->create_iterator( ).
        DO.
          li_child = li_iterator->get_next( ).
          IF li_child IS INITIAL.
            EXIT. " current loop
          ENDIF.
          CREATE DATA lv_ref LIKE LINE OF <tab>.
          ASSIGN lv_ref->* TO <any>.
          traverse( ii_node = li_child
                    iv_ref  = lv_ref ).
          INSERT <any> INTO TABLE <tab>.
        ENDDO.
      WHEN cl_abap_typedescr=>kind_ref.
        ASSIGN iv_ref->* TO <any>.
        IF <any> IS INITIAL.
          " WRITE ''@KERNEL lv_rtti_name.set(fs_any_.getPointer().RTTIName);''.
          " lv_internal = kernel_internal_name=>rtti_to_internal( lv_rtti_name ).
          " WRITE ''@KERNEL fs_any_.pointer.value = new abap.Classes[lv_internal.get()]();''.

          li_href = ii_node->get_attributes( )->get_named_item_ns( ''href'' ).
          IF li_href IS INITIAL.
            RETURN.
          ENDIF.
          lv_value = li_href->get_value( ).
          ASSERT lv_value IS NOT INITIAL.
          li_heap = find_href_in_heap( lv_value ).

          li_iname = li_heap->get_attributes( )->get_named_item_ns( ''internalName'' ).
          IF li_iname IS INITIAL AND lv_value(2) = ''#o''.
* then its a non serializable object, not to be instantiated
            RETURN.
          ENDIF.

          IF lv_value(2) = ''#o''.
            lv_value = li_iname->get_value( ).
            ASSERT lv_value IS NOT INITIAL.
*          WRITE ''@KERNEL console.dir(lv_value);''.
            WRITE ''@KERNEL fs_any_.pointer.value = new abap.Classes[lv_value.get()]();''.

          " li_child = ii_node->get_attributes( )->get_named_item_ns( ''href'' ).
          " WRITE ''@KERNEL console.dir(ii_node.get());''.

            li_iterator = li_heap->get_first_child( )->get_children( )->create_iterator( ).
            DO.
              li_child = li_iterator->get_next( ).
              IF li_child IS INITIAL.
                EXIT. " current loop
              ENDIF.
              lv_name = li_child->get_name( ).
              REPLACE FIRST OCCURRENCE OF ''.'' IN lv_name WITH ''~''.

              ASSIGN <any>->(lv_name) TO <field>.
              IF sy-subrc = 0.
                GET REFERENCE OF <field> INTO lv_ref.
                traverse( ii_node = li_child
                          iv_ref  = lv_ref ).
              ENDIF.
            ENDDO.
          ELSE.
* its a data reference
            " WRITE / lv_value.
            " WRITE ''@KERNEL console.dir(fs_any_);''.
            CREATE DATA <any>.
            " WRITE ''@KERNEL console.dir(fs_any_);''.

            li_child = li_heap->get_first_child( ).
            GET REFERENCE OF <any> INTO lv_ref.

            " WRITE ''@KERNEL console.dir(lv_ref);''.
            traverse( ii_node = li_child
                      iv_ref  = lv_ref->* ).
          ENDIF.
        ELSE.
          ASSERT 1 = ''todo_ref2''.
        ENDIF.
      WHEN OTHERS.
        WRITE ''@KERNEL console.dir(lo_type.get().kind.get());''.
        ASSERT 1 = ''todo''.
    ENDCASE.

  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_JSON_TO_IXML                     ', 'CLASS kernel_json_to_ixml DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS build
      IMPORTING iv_json TYPE string
      RETURNING VALUE(ri_doc) TYPE REF TO if_ixml_document.
ENDCLASS.

CLASS kernel_json_to_ixml IMPLEMENTATION.

  METHOD build.
* build IXML by calling SXML json parser and then converting :)

    DATA li_reader TYPE REF TO if_sxml_reader.
    DATA li_node TYPE REF TO if_sxml_node.
    DATA li_close TYPE REF TO if_sxml_close_element.
    DATA li_open TYPE REF TO if_sxml_open_element.
    DATA li_value TYPE REF TO if_sxml_value_node.
    DATA lt_attributes TYPE if_sxml_attribute=>attributes.
    DATA li_attribute TYPE REF TO if_sxml_attribute.
    DATA li_current TYPE REF TO if_ixml_node.
    DATA lv_name TYPE string.
    DATA li_map TYPE REF TO if_ixml_named_node_map.
    DATA li_new TYPE REF TO if_ixml_node.
    DATA li_element TYPE REF TO if_ixml_element.

    li_reader = cl_sxml_string_reader=>create( cl_abap_codepage=>convert_to( iv_json ) ).

    ri_doc = cl_ixml=>create( )->create_document( ).
    li_current = ri_doc->get_root( ).

    DO.
      li_node = li_reader->read_next_node( ).
      IF li_node IS INITIAL.
        EXIT.
      ENDIF.

      CASE li_node->type.
        WHEN if_sxml_node=>co_nt_element_open.
          li_open ?= li_node.
*          WRITE: / ''open: '', li_open->qname-name.

          CLEAR lv_name.
          lt_attributes = li_open->get_attributes( ).
          LOOP AT lt_attributes INTO li_attribute.
*            WRITE / li_attribute->get_value( ).
            lv_name = li_attribute->get_value( ).
          ENDLOOP.

          li_element = ri_doc->create_element_ns( li_open->qname-name ).
          li_new ?= li_element.
          li_current->append_child( li_new ).
          li_current = li_new.
*            WRITE ''@KERNEL console.dir(li_element);''.

          IF lv_name IS NOT INITIAL.
            li_element = ri_doc->create_element_ns( ''name'' ).
            li_new ?= li_element.
            li_new->set_value( lv_name ).

            li_map = li_current->get_attributes( ).
            li_map->set_named_item_ns( li_new ).
          ENDIF.

        WHEN if_sxml_node=>co_nt_element_close.
          li_close ?= li_node.
*          WRITE: / ''close: '', li_close->qname-name.
*          IF li_close->qname-name = ''object'' OR li_close->qname-name = ''array''.
          li_current = li_current->get_parent( ).
*          ENDIF.
        WHEN if_sxml_node=>co_nt_value.
          li_value ?= li_node.
*          WRITE / li_value->get_value( ).
*          li_current->set_value( li_value->get_value( ) ).

          li_element = ri_doc->create_element_ns( ''#text'' ).
          li_element->set_value( li_value->get_value( ) ).
          li_new ?= li_element.
          li_current->append_child( li_new ).

      ENDCASE.
    ENDDO.

  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_AUTHORITY_CHECK                  ', 'CLASS kernel_authority_check DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS call.
  PRIVATE SECTION.
ENDCLASS.

CLASS kernel_authority_check IMPLEMENTATION.

  METHOD call.
* add custom implementation here if needed
    sy-subrc = 0.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_CALL                             ', 'CLASS kernel_call DEFINITION PUBLIC.
* handling of ABAP statement CALL
  PUBLIC SECTION.
    CLASS-METHODS call
      IMPORTING
        input TYPE any.
  PRIVATE SECTION.
ENDCLASS.

CLASS kernel_call IMPLEMENTATION.

  METHOD call.

    DATA uuid TYPE sysuuid_x16.
    DATA name TYPE string.

    WRITE ''@KERNEL name.set(INPUT.name);''.

    IF name = ''RFCControl''.
      uuid = cl_system_uuid=>if_system_uuid_static~create_uuid_x16( ).
      WRITE ''@KERNEL INPUT.uuid.set(uuid);''.
    ENDIF.

  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_CREATE_DATA_HANDLE               ', 'CLASS kernel_create_data_handle DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS call
      IMPORTING
        handle TYPE REF TO cl_abap_datadescr
      CHANGING
        dref   TYPE REF TO any.
  PRIVATE SECTION.
    CLASS-METHODS elem
      IMPORTING
        handle TYPE REF TO cl_abap_datadescr
      CHANGING
        dref   TYPE REF TO any.
    CLASS-METHODS struct
      IMPORTING
        handle TYPE REF TO cl_abap_datadescr
      CHANGING
        dref   TYPE REF TO any.
    CLASS-METHODS table
      IMPORTING
        handle TYPE REF TO cl_abap_datadescr
      CHANGING
        dref   TYPE REF TO any.
    CLASS-METHODS ref
      IMPORTING
        handle TYPE REF TO cl_abap_datadescr
      CHANGING
        dref   TYPE REF TO any.
ENDCLASS.

CLASS kernel_create_data_handle IMPLEMENTATION.

  METHOD call.
    ASSERT handle IS BOUND.

    WRITE ''@KERNEL if (dref.constructor.name === "FieldSymbol") {''.
    WRITE ''@KERNEL   dref = dref.getPointer();''.
    WRITE ''@KERNEL }''.

    CASE handle->kind.
      WHEN cl_abap_typedescr=>kind_elem.
        elem( EXPORTING handle = handle
              CHANGING dref = dref ).
      WHEN cl_abap_typedescr=>kind_struct.
        struct( EXPORTING handle = handle
                CHANGING dref = dref ).
      WHEN cl_abap_typedescr=>kind_table.
        table( EXPORTING handle = handle
               CHANGING dref = dref ).
      WHEN cl_abap_typedescr=>kind_ref.
        ref( EXPORTING handle = handle
             CHANGING dref = dref ).
      WHEN OTHERS.
        WRITE ''@KERNEL console.dir(handle);''.
        ASSERT 1 = ''todo''.
    ENDCASE.
  ENDMETHOD.

  METHOD ref.
    DATA lo_ref  TYPE REF TO cl_abap_refdescr.
    DATA lo_data TYPE REF TO cl_abap_datadescr.
    DATA field   TYPE REF TO data.

    lo_ref ?= handle.
    lo_data ?= lo_ref->get_referenced_type( ).
    call(
      EXPORTING
        handle = lo_data
      CHANGING
        dref   = field ).

    WRITE ''@KERNEL dref.assign(new abap.types.DataReference(field.getPointer()));''.
  ENDMETHOD.

  METHOD struct.
    DATA lo_struct     TYPE REF TO cl_abap_structdescr.
    DATA lt_components TYPE cl_abap_structdescr=>component_table.
    DATA field         TYPE REF TO data.
    DATA lv_name       TYPE string.

    FIELD-SYMBOLS <ls_component> LIKE LINE OF lt_components.

    lo_struct ?= handle.
    lt_components = lo_struct->get_components( ).
    WRITE ''@KERNEL let obj = {};''.
    LOOP AT lt_components ASSIGNING <ls_component>.
*      WRITE ''@KERNEL console.dir(ls_component.get().name);''.
      call(
        EXPORTING
          handle = lo_struct->get_component_type( <ls_component>-name )
        CHANGING
          dref   = field ).
      lv_name = to_lower( <ls_component>-name ).
      WRITE ''@KERNEL obj[lv_name.get()] = field.getPointer();''.
    ENDLOOP.
    WRITE ''@KERNEL dref.assign(new abap.types.Structure(obj));''.
  ENDMETHOD.

  METHOD table.
    DATA lo_table     TYPE REF TO cl_abap_tabledescr.
    DATA lt_keys      TYPE abap_table_keydescr_tab.
    DATA lv_component TYPE string.
    DATA field        TYPE REF TO data.

    FIELD-SYMBOLS <ls_key> LIKE LINE OF lt_keys.

    lo_table ?= handle.

    call(
      EXPORTING
        handle = lo_table->get_table_line_type( )
      CHANGING
        dref   = field ).

    WRITE ''@KERNEL let options = {primaryKey: undefined, keyType: "DEFAULT", withHeader: false};''.
    WRITE ''@KERNEL options.primaryKey = {name: "primary_key", type: "STANDARD", keyFields: [], isUnique: false};''.

* todo, handle secondary keys,
    lt_keys = lo_table->get_keys( ).
    LOOP AT lt_keys ASSIGNING <ls_key> WHERE is_primary = abap_true.
      IF <ls_key>-access_kind = cl_abap_tabledescr=>tablekind_sorted.
        WRITE ''@KERNEL options.primaryKey.type = "SORTED";''.
      ELSEIF <ls_key>-access_kind = cl_abap_tabledescr=>tablekind_hashed.
        WRITE ''@KERNEL options.primaryKey.type = "HASHED";''.
      ENDIF.
      IF <ls_key>-is_unique = abap_true.
        WRITE ''@KERNEL options.primaryKey.isUnique = true;''.
      ENDIF.
      LOOP AT <ls_key>-components INTO lv_component.
        WRITE ''@KERNEL options.primaryKey.keyFields.push(lv_component.get().toLowerCase());''.
      ENDLOOP.
    ENDLOOP.

    WRITE ''@KERNEL dref.assign(abap.types.TableFactory.construct(field.getPointer(), options));''.
  ENDMETHOD.

  METHOD elem.
    DATA lv_half TYPE i.
    CASE handle->type_kind.
      WHEN cl_abap_typedescr=>typekind_float.
        CREATE DATA dref TYPE f.
      WHEN cl_abap_typedescr=>typekind_string.
        CREATE DATA dref TYPE string.
      WHEN cl_abap_typedescr=>typekind_xstring.
        CREATE DATA dref TYPE xstring.
      WHEN cl_abap_typedescr=>typekind_int.
        CREATE DATA dref TYPE i.
      WHEN cl_abap_typedescr=>typekind_date.
        CREATE DATA dref TYPE d.
      WHEN cl_abap_typedescr=>typekind_hex.
        CREATE DATA dref TYPE x LENGTH handle->length.
      WHEN cl_abap_typedescr=>typekind_packed.
        CREATE DATA dref TYPE p LENGTH handle->length DECIMALS handle->decimals.
      WHEN cl_abap_typedescr=>typekind_char.
        lv_half = handle->length / 2.
        CREATE DATA dref TYPE c LENGTH lv_half.
* todo, this needs some redesign to work properly,
        WRITE ''@KERNEL dref.getPointer().extra = {"qualifiedName": handle.get().relative_name};''.
      WHEN cl_abap_typedescr=>typekind_num.
        lv_half = handle->length / 2.
        CREATE DATA dref TYPE n LENGTH lv_half.
      WHEN cl_abap_typedescr=>typekind_time.
        CREATE DATA dref TYPE t.
      WHEN cl_abap_typedescr=>typekind_int8.
        CREATE DATA dref TYPE int8.
      WHEN OTHERS.
        WRITE ''@KERNEL console.dir(handle);''.
        ASSERT 1 = ''todo''.
    ENDCASE.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_INTERNAL_NAME                    ', 'CLASS kernel_internal_name DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS internal_to_rtti
      IMPORTING
        iv_internal TYPE string
      RETURNING
        VALUE(rv_rtti) TYPE string.

    CLASS-METHODS rtti_to_internal
      IMPORTING
        iv_rtti TYPE string
      RETURNING
        VALUE(rv_internal) TYPE string.
ENDCLASS.

CLASS kernel_internal_name IMPLEMENTATION.

  METHOD internal_to_rtti.
    rv_rtti = iv_internal.
    IF rv_rtti CP ''*CLAS-*''.
      REPLACE FIRST OCCURRENCE OF ''CLAS-'' IN rv_rtti WITH ''\\CLASS#POOL=''.
      REPLACE FIRST OCCURRENCE OF ''-'' IN rv_rtti WITH ''\\CLASS=''.
      REPLACE FIRST OCCURRENCE OF ''#'' IN rv_rtti WITH ''-''.
    ELSE.
      rv_rtti = ''\\CLASS='' && rv_rtti.
    ENDIF.
  ENDMETHOD.

  METHOD rtti_to_internal.
    rv_internal = iv_rtti.
    IF rv_internal CP ''\\CLASS=*''.
      REPLACE FIRST OCCURRENCE OF ''\\CLASS='' IN rv_internal WITH ''''.
    ELSEIF rv_internal CP ''\\CLASS-POOL=*''.
      REPLACE FIRST OCCURRENCE OF ''\\CLASS-POOL='' IN rv_internal WITH ''CLAS-''.
      REPLACE FIRST OCCURRENCE OF ''\\CLASS='' IN rv_internal WITH ''-''.
      REPLACE FIRST OCCURRENCE OF ''\\INTERFACE='' IN rv_internal WITH ''-''.
    ENDIF.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_LOCK                             ', 'CLASS kernel_lock DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS enqueue
      IMPORTING
        input TYPE any
      EXCEPTIONS
        foreign_lock
        system_failure.
    CLASS-METHODS dequeue
      IMPORTING
        input TYPE any.
  PRIVATE SECTION.
ENDCLASS.

CLASS kernel_lock IMPLEMENTATION.

  METHOD enqueue.
* add custom implementation here if needed
    sy-subrc = 0.
  ENDMETHOD.

  METHOD dequeue.
* add custom implementation here if needed
    sy-subrc = 0.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_PUSH_CHANNELS                    ', 'CLASS kernel_push_channels DEFINITION PUBLIC.
* handling of ABAP statement WAIT FOR PUSH CHANNELS
  PUBLIC SECTION.
    CLASS-METHODS wait
      IMPORTING
        seconds TYPE i
        cond    TYPE any.
  PRIVATE SECTION.
ENDCLASS.

CLASS kernel_push_channels IMPLEMENTATION.

  METHOD wait.
    DATA lv_seconds   TYPE i.
    DATA lv_condition TYPE abap_bool.

    lv_seconds = seconds * 1000.
    ASSERT lv_seconds > 0.

    WHILE lv_seconds > 0.
      WRITE ''@KERNEL await new Promise(resolve => setTimeout(resolve, 100));''.
      WRITE ''@KERNEL lv_condition = cond() ? "X" : " ";''.
      IF lv_condition = abap_true.
        sy-subrc = 0.
        RETURN.
      ENDIF.
      lv_seconds = lv_seconds - 100.
    ENDWHILE.

    sy-subrc = 4.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_SCAN_ABAP_SOURCE                 ', 'CLASS kernel_scan_abap_source DEFINITION PUBLIC.
* handling of ABAP statement SCAN ABAP-SOURCE
  PUBLIC SECTION.
    CLASS-METHODS call IMPORTING input TYPE any.
  PRIVATE SECTION.
    TYPES ty_stokesx TYPE STANDARD TABLE OF stokesx WITH DEFAULT KEY.
    TYPES ty_sstmnt TYPE STANDARD TABLE OF sstmnt WITH DEFAULT KEY.

    CLASS-METHODS call_internal
      IMPORTING
        source     TYPE string
      EXPORTING
        et_stokesx TYPE ty_stokesx
        et_sstmnt  TYPE ty_sstmnt.

    CONSTANTS: BEGIN OF gc_token,
                 comment    TYPE c LENGTH 1 VALUE ''C'',
                 identifier TYPE c LENGTH 1 VALUE ''I'',
                 list       TYPE c LENGTH 1 VALUE ''L'',
                 literal    TYPE c LENGTH 1 VALUE ''S'',
                 pragma     TYPE c LENGTH 1 VALUE ''P'',
               END OF gc_token.

    CONSTANTS: BEGIN OF gc_statement,
                 comment          TYPE c LENGTH 1 VALUE ''P'',
                 comment_in_stmnt TYPE c LENGTH 1 VALUE ''S'',
                 compute_direct   TYPE c LENGTH 1 VALUE ''C'',
                 empty            TYPE c LENGTH 1 VALUE ''N'',
                 macro_call       TYPE c LENGTH 1 VALUE ''D'',
                 macro_definition TYPE c LENGTH 1 VALUE ''M'',
                 method_direct    TYPE c LENGTH 1 VALUE ''A'',
                 native_sql       TYPE c LENGTH 1 VALUE ''E'',
                 pragma           TYPE c LENGTH 1 VALUE ''G'',
                 standard         TYPE c LENGTH 1 VALUE ''K'',
               END OF gc_statement.

    CLASS-METHODS pass1
      IMPORTING
        source        TYPE string
      EXPORTING
        et_tokens     TYPE ty_stokesx
        et_statements TYPE ty_sstmnt.

    CLASS-METHODS pass2
      CHANGING
        ct_tokens     TYPE ty_stokesx
        ct_statements TYPE ty_sstmnt.
ENDCLASS.

CLASS kernel_scan_abap_source IMPLEMENTATION.

  METHOD call.

* non-goal: good performance

    DATA lt_sstmnt  TYPE ty_sstmnt.
    DATA lt_stokes  TYPE stokes_tab.
    DATA ls_stokes  LIKE LINE OF lt_stokes.
    DATA lt_stokesx TYPE ty_stokesx.
    DATA ls_stokesx LIKE LINE OF lt_stokesx.
    DATA lv_source  TYPE string.

    WRITE ''@KERNEL lv_source.set(INPUT.scan_abap_source.array ? INPUT.scan_abap_source.array().map(e => e.get()).join("\\n") : INPUT.scan_abap_source.get());''.

    call_internal(
      EXPORTING
        source     = lv_source
      IMPORTING
        et_stokesx = lt_stokesx
        et_sstmnt  = lt_sstmnt ).

    LOOP AT lt_stokesx INTO ls_stokesx.
      CLEAR ls_stokes.
      MOVE-CORRESPONDING ls_stokesx TO ls_stokes.
      APPEND ls_stokes TO lt_stokes.
    ENDLOOP.

    WRITE ''@KERNEL const len = Object.keys(INPUT.tokens_into.getRowType().get()).length;''.
    WRITE ''@KERNEL INPUT.tokens_into.set(len == 4 ? lt_stokes : lt_stokesx);''.

    WRITE ''@KERNEL INPUT.statements_into.set(lt_sstmnt);''.

  ENDMETHOD.

  METHOD call_internal.

* build tokens in sequence of occurence in the source
* take care of chained statements
    pass1(
      EXPORTING
        source        = source
      IMPORTING
        et_tokens     = et_stokesx
        et_statements = et_sstmnt ).

* move comment tokens and add/change statements to comment type
    pass2(
      CHANGING
        ct_tokens     = et_stokesx
        ct_statements = et_sstmnt ).

  ENDMETHOD.

  METHOD pass1.
    CONSTANTS: BEGIN OF c_mode,
                 normal  TYPE i VALUE 1,
                 comment TYPE i VALUE 2,
               END OF c_mode.

    DATA character    TYPE c LENGTH 1.
    DATA row          TYPE i VALUE 1.
    DATA column       TYPE i.
    DATA index        TYPE i.
    DATA sfrom        TYPE i VALUE 1.
    DATA mode         TYPE i.
    DATA chain_tokens TYPE ty_stokesx.

    FIELD-SYMBOLS <trow> LIKE LINE OF et_tokens.
    FIELD-SYMBOLS <srow> LIKE LINE OF et_statements.

    mode = c_mode-normal.
    WHILE source IS NOT INITIAL.
      character = source(1).
      source = source+1.

      IF <trow> IS NOT ASSIGNED AND character <> '''' AND character <> |\\n|.
        APPEND INITIAL LINE TO et_tokens ASSIGNING <trow>.
        <trow>-row = row.
        <trow>-col = column.
        <trow>-type = gc_token-identifier.
      ELSEIF mode = c_mode-normal AND ( character = '''' OR character CA |.,| ).
        UNASSIGN <trow>.
"         IF character = '',''.
" *          WRITE ''@KERNEL console.dir("before");''.
"           APPEND LINES OF chain_tokens TO et_tokens.
" *          WRITE ''@KERNEL console.dir("after");''.
" *          WRITE lines( <tokens> ).
"         ENDIF.
      ELSEIF mode = c_mode-normal AND character = '':''.
        CLEAR chain_tokens.
        APPEND LINES OF et_tokens FROM sfrom TO chain_tokens.
        DELETE chain_tokens WHERE type = gc_token-comment.
*        WRITE ''@KERNEL console.dir(chain_tokens);''.
      ENDIF.

      IF ( mode = c_mode-normal AND character CA |.,| )
          OR source = ''''.
        APPEND INITIAL LINE TO et_statements ASSIGNING <srow>.
        <srow>-terminator = character.
        <srow>-from = sfrom.
        <srow>-to = lines( et_tokens ).
        sfrom = <srow>-to + 1.

        IF character = '',''.
*          WRITE ''@KERNEL console.dir("before");''.
          APPEND LINES OF chain_tokens TO et_tokens.
*          WRITE ''@KERNEL console.dir("after");''.
*          WRITE lines( <tokens> ).
        ENDIF.
      ENDIF.

      IF character = |\\n|.
        mode = c_mode-normal.
        UNASSIGN <trow>.
        row = row + 1.
        column = 0.
      ELSE.
        IF <trow> IS ASSIGNED.
          IF ( character = ''*'' AND column = 0 ) OR character = ''"''.
            mode = c_mode-comment.
            <trow>-type = gc_token-comment.
          ENDIF.
          IF mode = c_mode-comment.
            <trow>-type = gc_token-comment.
            CONCATENATE <trow>-str character INTO <trow>-str RESPECTING BLANKS.
          ELSEIF character <> '':''.
            <trow>-str = <trow>-str && to_upper( |{ character }| ).
          ENDIF.
        ENDIF.
        column = column + 1.
      ENDIF.

    ENDWHILE.

  ENDMETHOD.

  METHOD pass2.
    FIELD-SYMBOLS <ls_statement> LIKE LINE OF ct_statements.
    DATA ls_statement       LIKE LINE OF ct_statements.
    DATA ls_token           LIKE LINE OF ct_tokens.
    DATA contains_comment   TYPE abap_bool.
    DATA contains_normal    TYPE abap_bool.
    DATA lv_count           TYPE i.
    DATA lv_statement_index TYPE i.
    DATA lt_insert          LIKE ct_tokens.
    DATA lt_delete          TYPE STANDARD TABLE OF i WITH DEFAULT KEY.
    DATA lv_index           LIKE LINE OF lt_delete.

    LOOP AT ct_statements ASSIGNING <ls_statement>.
      lv_statement_index = sy-tabix.

*      WRITE ''@KERNEL console.dir("statement");''.
      contains_comment = abap_false.
      contains_normal = abap_false.
      LOOP AT ct_tokens INTO ls_token FROM <ls_statement>-from TO <ls_statement>-to.
        IF ls_token-type = gc_token-comment.
          contains_comment = abap_true.
        ELSE.
          contains_normal = abap_true.
        ENDIF.
*        WRITE ''@KERNEL console.dir(ls_token.get().str.get());''.
      ENDLOOP.

      IF contains_comment = abap_true AND contains_normal = abap_true.
* its a mix, move comments to the front as separate statement
*        WRITE ''@KERNEL console.dir("from: " + fs_ls_statement_.get().from.get());''.
*        WRITE ''@KERNEL console.dir("to: " + fs_ls_statement_.get().to.get());''.
        lv_count = 0.
        CLEAR lt_insert.
        CLEAR lt_delete.
        LOOP AT ct_tokens INTO ls_token FROM <ls_statement>-from TO <ls_statement>-to.
*          WRITE ''@KERNEL console.dir("token: " + ls_token.get().str.get() + " " + abap.builtin.sy.get().tabix.get());''.
          IF ls_token-type = gc_token-comment.
            INSERT sy-tabix INTO lt_delete INDEX 1.
            INSERT ls_token INTO lt_insert INDEX 1.
            lv_count = lv_count + 1.
          ENDIF.
        ENDLOOP.
        LOOP AT lt_delete INTO lv_index.
          DELETE ct_tokens INDEX lv_index.
        ENDLOOP.
        LOOP AT lt_insert INTO ls_token.
          INSERT ls_token INTO ct_tokens INDEX <ls_statement>-from.
        ENDLOOP.

        CLEAR ls_statement.
        ls_statement-from = <ls_statement>-from.
        ls_statement-to = <ls_statement>-from + lv_count - 1.
        ls_statement-type = gc_statement-comment.

        <ls_statement>-from = <ls_statement>-from + lv_count.

        INSERT ls_statement INTO ct_statements INDEX lv_statement_index.
      ELSEIF contains_comment = abap_true.
        <ls_statement>-type = gc_statement-comment.
      ELSE.
        <ls_statement>-type = gc_statement-standard.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_NUMBERRANGE_RUNTIME                  ', 'CLASS cl_numberrange_runtime DEFINITION PUBLIC.
  PUBLIC SECTION.

    TYPES nr_interval TYPE c LENGTH 2.
    TYPES nr_object   TYPE c LENGTH 10.
    TYPES nr_number   TYPE n LENGTH 20.

    CLASS-METHODS number_get
      IMPORTING
        nr_range_nr TYPE nr_interval
        object      TYPE nr_object
      EXPORTING
        number      TYPE nr_number
      RAISING
        cx_static_check.
ENDCLASS.

CLASS cl_numberrange_runtime IMPLEMENTATION.

  METHOD number_get.

    CALL FUNCTION ''NUMBER_GET_NEXT''
      EXPORTING
        nr_range_nr             = nr_range_nr
        object                  = object
      IMPORTING
        number                  = number
      EXCEPTIONS
        interval_not_found      = 1
        number_range_not_intern = 2
        object_not_found        = 3
        quantity_is_0           = 4
        quantity_is_not_1       = 5
        interval_overflow       = 6
        buffer_overflow         = 7
        OTHERS                  = 8.
    IF sy-subrc <> 0.
      RETURN. " todo
    ENDIF.

  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_NUMBERRANGE                      ', 'CLASS kernel_numberrange DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS number_get
      IMPORTING
        nr_range_nr TYPE cl_numberrange_runtime=>nr_interval
        object      TYPE cl_numberrange_runtime=>nr_object
      EXPORTING
        number      TYPE cl_numberrange_runtime=>nr_number
      RAISING
        cx_static_check.
  PRIVATE SECTION.
    TYPES: BEGIN OF ty_status,
             nr_range_nr TYPE cl_numberrange_runtime=>nr_interval,
             object      TYPE cl_numberrange_runtime=>nr_object,
             number      TYPE cl_numberrange_runtime=>nr_number,
           END OF ty_status.
    CLASS-DATA status TYPE STANDARD TABLE OF ty_status WITH DEFAULT KEY.
ENDCLASS.

CLASS kernel_numberrange IMPLEMENTATION.

  METHOD number_get.
* for now, only in memory for the current session
    FIELD-SYMBOLS <row> LIKE LINE OF status.
    READ TABLE status WITH KEY nr_range_nr = nr_range_nr object = object ASSIGNING <row>.
    IF sy-subrc = 0.
      <row>-number = <row>-number + 1.
    ELSE.
      APPEND INITIAL LINE TO status ASSIGNING <row>.
      <row>-nr_range_nr = nr_range_nr.
      <row>-object = object.
      <row>-number = 1.
    ENDIF.
    number = <row>-number.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_OAUTH2_CLIENT                        ', 'CLASS cl_oauth2_client DEFINITION PUBLIC.
  PUBLIC SECTION.
    INTERFACES if_oauth2_client.

    CLASS-METHODS create
      IMPORTING
        i_profile               TYPE clike
        i_configuration         TYPE clike OPTIONAL
      RETURNING
        VALUE(ro_oauth2_client) TYPE REF TO if_oauth2_client
      RAISING
        cx_static_check.
ENDCLASS.

CLASS cl_oauth2_client IMPLEMENTATION.

  METHOD create.
    WRITE / ''todo, cl_oauth2_client in open-abap-core, create()''.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_oauth2_client~execute_cc_flow.
    WRITE / ''todo, cl_oauth2_client in open-abap-core, execute_cc_flow()''.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_oauth2_client~set_token.
    WRITE / ''todo, cl_oauth2_client in open-abap-core, set_token()''.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_OAUTH2_CLIENT                        ', 'INTERFACE if_oauth2_client PUBLIC.

  METHODS execute_cc_flow
    RAISING
      cx_static_check.

  METHODS set_token
    IMPORTING
      ii_http_client TYPE REF TO if_http_client
    RAISING
      cx_static_check.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_OO_FACTORY                           ', 'CLASS cl_oo_factory DEFINITION PUBLIC CREATE PRIVATE.
  PUBLIC SECTION.
    INTERFACES if_oo_clif_source.

    CLASS-METHODS create_instance
      RETURNING
        VALUE(result) TYPE REF TO cl_oo_factory.

    METHODS create_clif_source
      IMPORTING
        clif_name     TYPE csequence
      RETURNING
        VALUE(result) TYPE REF TO if_oo_clif_source
      RAISING
        cx_oo_clif_not_exists.

  PRIVATE SECTION.
    DATA mv_name TYPE string.
ENDCLASS.

CLASS cl_oo_factory IMPLEMENTATION.
  METHOD create_instance.
    CREATE OBJECT result.
  ENDMETHOD.

  METHOD create_clif_source.
* todo, this not correct, should return a new instance, but will work for now
    result = me.
    mv_name = to_upper( clif_name ).
  ENDMETHOD.

  METHOD if_oo_clif_source~get_source.
    DATA ls_data TYPE reposrc.
    SELECT SINGLE * FROM reposrc INTO ls_data WHERE progname = mv_name.
    SPLIT ls_data-data AT |\\n| INTO TABLE source.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_OO_CLIF_NOT_EXISTS                   ', 'CLASS cx_oo_clif_not_exists DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_oo_clif_not_exists IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_OO_CLIF_SOURCE                       ', 'INTERFACE if_oo_clif_source PUBLIC.
  METHODS get_source
    EXPORTING
      source TYPE string_table.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_CLASSDESCR                      ', 'CLASS cl_abap_classdescr DEFINITION PUBLIC INHERITING FROM cl_abap_objectdescr.
  PUBLIC SECTION.
    CLASS-METHODS get_class_name
      IMPORTING
        p_object TYPE REF TO object
      RETURNING
        VALUE(p_name) TYPE abap_abstypename.

    METHODS get_super_class_type
      RETURNING
        VALUE(p_descr_ref) TYPE REF TO cl_abap_classdescr
      EXCEPTIONS
        super_class_not_found.

    METHODS constructor
      IMPORTING
        p_object TYPE any OPTIONAL.
ENDCLASS.

CLASS cl_abap_classdescr IMPLEMENTATION.
  METHOD constructor.
    super->constructor( p_object ).
  ENDMETHOD.

  METHOD get_class_name.
    DATA lv_name TYPE string.
    WRITE ''@KERNEL lv_name.set(p_object.get().constructor.INTERNAL_NAME);''.
    p_name = kernel_internal_name=>internal_to_rtti( lv_name ).
  ENDMETHOD.

  METHOD get_super_class_type.
    ASSERT 1 = ''todo''.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_COMPLEXDESCR                    ', 'CLASS cl_abap_complexdescr DEFINITION PUBLIC INHERITING FROM cl_abap_datadescr.
  PUBLIC SECTION.
ENDCLASS.

CLASS cl_abap_complexdescr IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_DATADESCR                       ', 'CLASS cl_abap_datadescr DEFINITION PUBLIC INHERITING FROM cl_abap_typedescr.
  PUBLIC SECTION.
    CLASS-METHODS get_data_type_kind
      IMPORTING
        p_data             TYPE data
      RETURNING
        VALUE(p_type_kind) TYPE abap_typekind.

    METHODS applies_to_data
      IMPORTING
        p_data TYPE data
      RETURNING
        VALUE(p_flag) TYPE abap_bool.
ENDCLASS.

CLASS cl_abap_datadescr IMPLEMENTATION.

  METHOD get_data_type_kind.
    DATA descr TYPE REF TO cl_abap_typedescr.
    descr = cl_abap_typedescr=>describe_by_data( p_data ).
    p_type_kind = descr->type_kind.
  ENDMETHOD.

  METHOD applies_to_data.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_ELEMDESCR                       ', 'CLASS cl_abap_elemdescr DEFINITION PUBLIC INHERITING FROM cl_abap_datadescr.
  PUBLIC SECTION.
    TYPES:
      BEGIN OF fixvalue,
        low        TYPE c LENGTH 10,
        high       TYPE c LENGTH 10,
        option     TYPE c LENGTH 2,
        ddlanguage TYPE c,
        ddtext     TYPE c LENGTH 60,
      END OF fixvalue.
    TYPES fixvalues TYPE STANDARD TABLE OF fixvalue WITH DEFAULT KEY.

    DATA output_length TYPE i READ-ONLY.
    DATA edit_mask TYPE abap_editmask READ-ONLY.
    DATA help_id TYPE abap_helpid READ-ONLY.

    METHODS get_ddic_fixed_values
      RETURNING
        VALUE(p_fixed_values) TYPE fixvalues.

    METHODS get_ddic_field
      IMPORTING
        p_langu TYPE sy-langu DEFAULT sy-langu
      RETURNING
        VALUE(p_flddescr) TYPE dfies
      EXCEPTIONS
        not_found
        no_ddic_type.

    CLASS-METHODS get_i RETURNING VALUE(r_result) TYPE REF TO cl_abap_elemdescr.
    CLASS-METHODS get_int8 RETURNING VALUE(r_result) TYPE REF TO cl_abap_elemdescr.
    CLASS-METHODS get_f RETURNING VALUE(r_result) TYPE REF TO cl_abap_elemdescr.
    CLASS-METHODS get_d RETURNING VALUE(r_result) TYPE REF TO cl_abap_elemdescr.
    CLASS-METHODS get_t RETURNING VALUE(r_result) TYPE REF TO cl_abap_elemdescr.
    CLASS-METHODS get_decfloat16 RETURNING VALUE(r_result) TYPE REF TO cl_abap_elemdescr.
    CLASS-METHODS get_decfloat34 RETURNING VALUE(r_result) TYPE REF TO cl_abap_elemdescr.
    CLASS-METHODS get_string RETURNING VALUE(p_result) TYPE REF TO cl_abap_elemdescr.
    CLASS-METHODS get_c
      IMPORTING
        p_length TYPE i
      RETURNING
        VALUE(p_result) TYPE REF TO cl_abap_elemdescr.
    CLASS-METHODS get_p
      IMPORTING
        p_length   TYPE i
        p_decimals TYPE i
      RETURNING
        VALUE(p_result) TYPE REF TO cl_abap_elemdescr.
    CLASS-METHODS get_n
      IMPORTING
        p_length TYPE i
      RETURNING
        VALUE(p_result) TYPE REF TO cl_abap_elemdescr.
    CLASS-METHODS get_x
      IMPORTING
        p_length TYPE i
      RETURNING
        VALUE(p_result) TYPE REF TO cl_abap_elemdescr.
    CLASS-METHODS get_xstring
      RETURNING
        VALUE(p_result) TYPE REF TO cl_abap_elemdescr.

ENDCLASS.

CLASS cl_abap_elemdescr IMPLEMENTATION.

  METHOD get_p.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get_decfloat16.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get_decfloat34.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get_n.
    DATA foo TYPE REF TO data.
    CREATE DATA foo TYPE n LENGTH p_length.
    p_result ?= cl_abap_typedescr=>describe_by_data_ref( foo ).
  ENDMETHOD.

  METHOD get_x.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get_xstring.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get_ddic_field.
    p_flddescr-tabname  = absolute_name.
    p_flddescr-inttype  = type_kind.
    p_flddescr-langu    = sy-langu.
    p_flddescr-position = 1.
    p_flddescr-leng     = length.
    p_flddescr-decimals = decimals.

    WRITE ''@KERNEL p_flddescr.get().domname.set(abap.DDIC[this.relative_name.get()]?.domain || "");''.

* todo, dfies-convexit
  ENDMETHOD.

  METHOD get_i.
    DATA foo TYPE i.
    r_result ?= cl_abap_typedescr=>describe_by_data( foo ).
  ENDMETHOD.

  METHOD get_int8.
    DATA foo TYPE int8.
    r_result ?= cl_abap_typedescr=>describe_by_data( foo ).
  ENDMETHOD.

  METHOD get_string.
    DATA foo TYPE string.
    p_result ?= cl_abap_typedescr=>describe_by_data( foo ).
  ENDMETHOD.

  METHOD get_f.
    DATA foo TYPE f.
    r_result ?= cl_abap_typedescr=>describe_by_data( foo ).
  ENDMETHOD.

  METHOD get_d.
    DATA foo TYPE d.
    r_result ?= cl_abap_typedescr=>describe_by_data( foo ).
  ENDMETHOD.

  METHOD get_t.
    DATA foo TYPE t.
    r_result ?= cl_abap_typedescr=>describe_by_data( foo ).
  ENDMETHOD.

  METHOD get_c.
    DATA foo TYPE REF TO data.
    CREATE DATA foo TYPE c LENGTH p_length.
    p_result ?= cl_abap_typedescr=>describe_by_data_ref( foo ).
  ENDMETHOD.

  METHOD get_ddic_fixed_values.

    DATA lv_dummy TYPE string.
    DATA lv_name  TYPE string.
    DATA ls_row   LIKE LINE OF p_fixed_values.

    SPLIT absolute_name AT ''='' INTO lv_dummy lv_name.

    WRITE ''@KERNEL for (const f of abap.DDIC[lv_name.get()]?.fixedValues || []) {''.
    CLEAR ls_row.
    WRITE ''@KERNEL   ls_row.get().low.set(f.low || "");''.
    WRITE ''@KERNEL   ls_row.get().high.set(f.high || "");''.
    WRITE ''@KERNEL   ls_row.get().option.set(f.option || "");''.
    WRITE ''@KERNEL   ls_row.get().ddlanguage.set(f.ddlanguage || "");''.
    WRITE ''@KERNEL   ls_row.get().ddtext.set(f.ddtext || "");''.
    APPEND ls_row TO p_fixed_values.
    WRITE ''@KERNEL }''.

  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_ENUMDESCR                       ', 'CLASS cl_abap_enumdescr DEFINITION PUBLIC INHERITING FROM cl_abap_elemdescr.
  PUBLIC SECTION.
    TYPES: BEGIN OF member,
             name  TYPE c LENGTH 30,
             value TYPE string,
           END OF member.
    TYPES member_table TYPE STANDARD TABLE OF member WITH KEY name.
    DATA members TYPE member_table READ-ONLY.
ENDCLASS.

CLASS cl_abap_enumdescr IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_INTFDESCR                       ', 'CLASS cl_abap_intfdescr DEFINITION PUBLIC INHERITING FROM cl_abap_objectdescr.
  PUBLIC SECTION.
ENDCLASS.

CLASS cl_abap_intfdescr IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_OBJECTDESCR                     ', 'CLASS cl_abap_objectdescr DEFINITION PUBLIC INHERITING FROM cl_abap_typedescr.
  PUBLIC SECTION.
    CONSTANTS changing  TYPE abap_parmkind VALUE ''C''.
    CONSTANTS exporting TYPE abap_parmkind VALUE ''E''.
    CONSTANTS importing TYPE abap_parmkind VALUE ''I''.
    CONSTANTS receiving TYPE abap_parmkind VALUE ''R''.
    CONSTANTS returning TYPE abap_parmkind VALUE ''R''.

    CONSTANTS private_   TYPE abap_visibility VALUE ''I''.
    CONSTANTS protected TYPE abap_visibility VALUE ''O''.
    CONSTANTS public_    TYPE abap_visibility VALUE ''U''.

    DATA attributes TYPE abap_attrdescr_tab READ-ONLY.
    DATA methods    TYPE abap_methdescr_tab READ-ONLY.
    DATA interfaces TYPE abap_intfdescr_tab READ-ONLY.

    METHODS constructor
      IMPORTING
        p_object TYPE any OPTIONAL.

    METHODS get_attribute_type
      IMPORTING
        p_name             TYPE any
      RETURNING
        VALUE(p_descr_ref) TYPE REF TO cl_abap_datadescr
      EXCEPTIONS
        attribute_not_found.

    METHODS get_method_parameter_type
      IMPORTING
        p_method_name      TYPE any
        p_parameter_name   TYPE any
      RETURNING
        VALUE(p_descr_ref) TYPE REF TO cl_abap_datadescr
      EXCEPTIONS
        parameter_not_found
        method_not_found.

    METHODS get_interface_type
      IMPORTING
        p_name             TYPE any
      RETURNING
        VALUE(p_descr_ref) TYPE REF TO cl_abap_intfdescr
      EXCEPTIONS
        interface_not_found.

  PROTECTED SECTION.
    DATA mv_object_name TYPE string.
    DATA mv_object_type TYPE string.

    TYPES: BEGIN OF ty_attribute_types,
             name TYPE abap_attrname,
             type TYPE REF TO cl_abap_datadescr,
           END OF ty_attribute_types.
    DATA mt_attribute_types TYPE STANDARD TABLE OF ty_attribute_types WITH DEFAULT KEY.

    TYPES: BEGIN OF ty_parameter_types,
             method    TYPE string,
             parameter TYPE string,
             type      TYPE REF TO data,
           END OF ty_parameter_types.
    DATA mt_parameter_types TYPE STANDARD TABLE OF ty_parameter_types WITH DEFAULT KEY.
ENDCLASS.

CLASS cl_abap_objectdescr IMPLEMENTATION.

  METHOD constructor.
    DATA lv_name  TYPE abap_attrname.
    DATA lv_char1 TYPE c LENGTH 1.
    DATA lv_any   TYPE string.

    FIELD-SYMBOLS <attr>      TYPE abap_attrdescr.
    FIELD-SYMBOLS <intf>      TYPE abap_intfdescr.
    FIELD-SYMBOLS <method>    TYPE abap_methdescr.
    FIELD-SYMBOLS <parameter> TYPE abap_parmdescr.
    FIELD-SYMBOLS <atype>     LIKE LINE OF mt_attribute_types.
    FIELD-SYMBOLS <ptype>     LIKE LINE OF mt_parameter_types.

* set attributes
    WRITE ''@KERNEL for (const a in p_object?.ATTRIBUTES || []) {''.
    WRITE ''@KERNEL   lv_name.set(a);''.
    APPEND INITIAL LINE TO attributes ASSIGNING <attr>.
    APPEND INITIAL LINE TO mt_attribute_types ASSIGNING <atype>.
    <attr>-name = lv_name.
    <atype>-name = lv_name.
    <attr>-is_interface = boolc( lv_name CA ''~'' ).
    WRITE ''@KERNEL   lv_char1.set(p_object.ATTRIBUTES[a].is_constant);''.
    <attr>-is_constant = lv_char1.
    WRITE ''@KERNEL   lv_char1.set(p_object.ATTRIBUTES[a].is_class || "");''.
    <attr>-is_class = lv_char1.
    WRITE ''@KERNEL   lv_char1.set(p_object.ATTRIBUTES[a].visibility);''.
    <attr>-visibility = lv_char1.
    WRITE ''@KERNEL   lv_any = p_object.ATTRIBUTES[a].type();''.
    <atype>-type ?= describe_by_data( lv_any ).
    <attr>-type_kind = <atype>-type->type_kind.
    <attr>-length = <atype>-type->length.
    <attr>-decimals = <atype>-type->decimals.
    WRITE ''@KERNEL }''.
    SORT attributes BY is_interface DESCENDING name ASCENDING.

* set interfaces
    WRITE ''@KERNEL for (const a of p_object?.IMPLEMENTED_INTERFACES || []) {''.
    WRITE ''@KERNEL   lv_name.set(a);''.
    APPEND INITIAL LINE TO interfaces ASSIGNING <intf>.
    <intf>-name = lv_name.
    WRITE ''@KERNEL }''.
    SORT interfaces BY name ASCENDING.

* set methods
    WRITE ''@KERNEL for (const a in p_object?.METHODS || []) {''.
    WRITE ''@KERNEL   lv_name.set(a);''.
    APPEND INITIAL LINE TO methods ASSIGNING <method>.
    <method>-name = lv_name.
    WRITE ''@KERNEL   lv_char1.set(p_object.METHODS[a].visibility);''.
    <method>-visibility = lv_char1.
* set parameters of methods
    WRITE ''@KERNEL for (const p in p_object.METHODS[a].parameters || []) {''.
    APPEND INITIAL LINE TO mt_parameter_types ASSIGNING <ptype>.
    APPEND INITIAL LINE TO <method>-parameters ASSIGNING <parameter>.
    <ptype>-method = <method>-name.
    WRITE ''@KERNEL   lv_name.set(p);''.
    <parameter>-name = lv_name.
    <ptype>-parameter = lv_name.
    WRITE ''@KERNEL   lv_any = p_object.METHODS[a].parameters[p].type();''.
* hmm, cannot call describe_by_data() here, as it can cause inifnite recursion
    GET REFERENCE OF lv_any INTO <ptype>-type.
"     <parameter>-type_kind = <ptype>-type->type_kind.
"     <parameter>-length = <ptype>-type->length.
"     <parameter>-decimals = <ptype>-type->decimals.
" * todo, set PARAM_KIND
    WRITE ''@KERNEL }''.
    WRITE ''@KERNEL }''.
    SORT methods BY name ASCENDING.

    super->constructor( ).
  ENDMETHOD.

  METHOD get_method_parameter_type.
    DATA ls_row LIKE LINE OF mt_parameter_types.
*    WRITE ''@KERNEL   this.mt_parameter_types.array().map(e => console.dir(e.get()));''.
    READ TABLE mt_parameter_types INTO ls_row WITH KEY method = p_method_name parameter = p_parameter_name.
    IF sy-subrc = 0.
      p_descr_ref ?= describe_by_data( ls_row-type->* ).
    ELSE.
      RAISE parameter_not_found.
    ENDIF.
  ENDMETHOD.

  METHOD get_interface_type.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get_attribute_type.
    DATA lv_name TYPE abap_attrname.
    DATA ls_type LIKE LINE OF mt_attribute_types.

    lv_name = to_upper( p_name ).
    READ TABLE mt_attribute_types INTO ls_type WITH KEY name = lv_name.
    IF sy-subrc <> 0.
      RAISE attribute_not_found.
    ENDIF.
    p_descr_ref = ls_type-type.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_REFDESCR                        ', 'CLASS cl_abap_refdescr DEFINITION PUBLIC INHERITING FROM cl_abap_datadescr.
  PUBLIC SECTION.
    METHODS get_referenced_type
      RETURNING VALUE(type) TYPE REF TO cl_abap_typedescr.

    CLASS-METHODS get_ref_to_data
      RETURNING
        VALUE(p_result) TYPE REF TO cl_abap_refdescr.

  PRIVATE SECTION.
    DATA referenced TYPE REF TO cl_abap_typedescr.
ENDCLASS.

CLASS cl_abap_refdescr IMPLEMENTATION.
  METHOD get_referenced_type.
    type = referenced.
  ENDMETHOD.

  METHOD get_ref_to_data.
    DATA foo TYPE REF TO data.
    p_result ?= cl_abap_typedescr=>describe_by_data( foo ).
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_STRUCTDESCR                     ', 'CLASS cl_abap_structdescr DEFINITION PUBLIC INHERITING FROM cl_abap_complexdescr.
  PUBLIC SECTION.
    CLASS-METHODS
      construct_from_data
        IMPORTING data TYPE any
        RETURNING VALUE(descr) TYPE REF TO cl_abap_structdescr.

    TYPES component       TYPE abap_componentdescr.
    TYPES component_table TYPE abap_component_tab.
    TYPES included_view   TYPE abap_component_view_tab.
    TYPES symbol_table    TYPE abap_component_symbol_tab.

    METHODS
      get_components
        RETURNING
          VALUE(rt_components) TYPE component_table.

    METHODS
      get_ddic_field_list
        IMPORTING
          p_langu                  TYPE syst-langu DEFAULT sy-langu
          p_including_substructres TYPE abap_bool DEFAULT abap_false
        RETURNING
          VALUE(rt_components)     TYPE ddfields
        EXCEPTIONS
          not_found
          no_ddic_type.

    METHODS get_component_type
      IMPORTING
        p_name             TYPE any
      RETURNING
        VALUE(p_descr_ref) TYPE REF TO cl_abap_datadescr
      EXCEPTIONS
        component_not_found
        unsupported_input_type.

    METHODS get_included_view
      IMPORTING
        p_level         TYPE i OPTIONAL
      RETURNING
        VALUE(p_result) TYPE included_view.

    CLASS-METHODS get
      IMPORTING
        p_components    TYPE component_table
      RETURNING
        VALUE(p_result) TYPE REF TO cl_abap_structdescr
      RAISING
        cx_sy_struct_creation.

    CLASS-METHODS create
      IMPORTING
        p_components TYPE component_table
        p_strict     TYPE abap_bool OPTIONAL
      RETURNING
        VALUE(ref)   TYPE REF TO cl_abap_structdescr.

    METHODS get_symbols
      RETURNING
        VALUE(p_result) TYPE symbol_table.

    DATA components  TYPE abap_compdescr_tab.
    DATA struct_kind TYPE abap_structkind READ-ONLY.

  PRIVATE SECTION.
    METHODS update_components.

    DATA mt_refs TYPE component_table.
ENDCLASS.

CLASS cl_abap_structdescr IMPLEMENTATION.

  METHOD get_symbols.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD create.
    DATA ls_component LIKE LINE OF p_components.
    DATA ls_ref       LIKE LINE OF mt_refs.

    IF lines( p_components ) = 0.
      RAISE EXCEPTION TYPE cx_sy_struct_attributes.
    ENDIF.

    LOOP AT p_components INTO ls_component.
      IF ls_component-name IS INITIAL.
        RAISE EXCEPTION TYPE cx_sy_struct_comp_name.
      ELSEIF ls_component-type IS INITIAL.
        RAISE EXCEPTION TYPE cx_sy_struct_comp_type.
      ELSEIF strlen( ls_component-name ) > 30. " todo, use abap_max_comp_name_ln
        RAISE EXCEPTION TYPE cx_sy_struct_comp_name.
      ENDIF.
    ENDLOOP.

    CREATE OBJECT ref.
    LOOP AT p_components INTO ls_component.
      CLEAR ls_ref.
      ls_ref-name = ls_component-name.
      ls_ref-type = ls_component-type.
      APPEND ls_ref TO ref->mt_refs.
    ENDLOOP.
    ref->update_components( ).

    ref->type_kind = typekind_struct2.
    ref->kind = kind_struct.
  ENDMETHOD.

  METHOD get_included_view.
    DATA ls_component LIKE LINE OF components.
    DATA ls_view      LIKE LINE OF p_result.
    DATA ls_ref       LIKE LINE OF mt_refs.

    LOOP AT components INTO ls_component.
      CLEAR ls_view.

      ls_view-name = ls_component-name.
      READ TABLE mt_refs WITH KEY name = ls_component-name INTO ls_ref.
      IF sy-subrc = 0.
        ls_view-type = ls_ref-type.
      ENDIF.
      IF ls_ref-as_include = abap_true.
        CONTINUE.
      ENDIF.

      INSERT ls_view INTO TABLE p_result.
    ENDLOOP.
  ENDMETHOD.

  METHOD get_ddic_field_list.

    DATA lt_components TYPE component_table.
    DATA ls_component  LIKE LINE OF lt_components.
    DATA ls_return     LIKE LINE OF rt_components.
    DATA lv_name       TYPE string.
    DATA lv_keyfield   TYPE string.
    DATA lo_elemdescr  TYPE REF TO cl_abap_elemdescr.
    FIELD-SYMBOLS <component> LIKE LINE OF rt_components.

    lt_components = get_components( ).

    ASSERT absolute_name CP ''+TYPE=*''.
    lv_name = absolute_name+6.

    LOOP AT lt_components INTO ls_component.
      CLEAR ls_return.
      ls_return-tabname = lv_name.
      ls_return-fieldname = ls_component-name.
      IF ls_component-type->kind = cl_abap_typedescr=>kind_elem.
        lo_elemdescr ?= ls_component-type.
        ls_return-leng = lo_elemdescr->output_length.
      ENDIF.
* todo, fill more fields in ls_return
      APPEND ls_return TO rt_components.
    ENDLOOP.

*    WRITE ''@KERNEL console.dir(abap.DDIC[lv_name.get()]?.keyFields);''.
    WRITE ''@KERNEL for (const keyfield of abap.DDIC[lv_name.get()]?.keyFields || [] ) {''.
    WRITE ''@KERNEL lv_keyfield.set(keyfield);''.
*    WRITE ''@KERNEL console.dir(rt_components.array()[0].get());''.
    READ TABLE rt_components ASSIGNING <component> WITH KEY fieldname = lv_keyfield.
    ASSERT sy-subrc = 0.
    <component>-keyflag = abap_true.
    WRITE ''@KERNEL }''.

  ENDMETHOD.

  METHOD construct_from_data.
* todo, this method should be private
    DATA lv_name       TYPE string.
    DATA ls_ref        LIKE LINE OF mt_refs.
    DATA lv_suffix     TYPE string.
    DATA lv_as_include TYPE abap_bool.
    DATA lo_datadescr  TYPE REF TO cl_abap_datadescr.

    FIELD-SYMBOLS <fs> TYPE any.

    CREATE OBJECT descr.

* todo, fail if input is not a structure?
    WRITE ''@KERNEL for (const name of Object.keys(INPUT.data.value)) {''.
    WRITE ''@KERNEL   lv_name.set(name.toUpperCase());''.
    ASSIGN COMPONENT lv_name OF STRUCTURE data TO <fs>.
    lo_datadescr ?= cl_abap_typedescr=>describe_by_data( <fs> ).
    ls_ref-name = lv_name.
    ls_ref-type = lo_datadescr.

    WRITE ''@KERNEL if (INPUT.data?.getAsInclude) {''.
    WRITE ''@KERNEL   lv_as_include.set(INPUT.data?.getAsInclude()?.[name.toLowerCase()] ? "X" : " ");''.
    WRITE ''@KERNEL }''.
    ls_ref-as_include = lv_as_include.

    WRITE ''@KERNEL if (INPUT.data?.getSuffix) {''.
    WRITE ''@KERNEL   lv_as_include.set(INPUT.data?.getSuffix()?.[name.toLowerCase()] || "");''.
    WRITE ''@KERNEL }''.
    ls_ref-suffix = lv_suffix.

    APPEND ls_ref TO descr->mt_refs.
    WRITE ''@KERNEL }''.

    descr->update_components( ).
  ENDMETHOD.

  METHOD update_components.
    DATA ls_component LIKE LINE OF components.
    FIELD-SYMBOLS <ls_ref> LIKE LINE OF mt_refs.

    CLEAR components.
    LOOP AT mt_refs ASSIGNING <ls_ref>.
      ls_component-name = <ls_ref>-name.
      ls_component-type_kind = <ls_ref>-type->type_kind.
      ls_component-length = <ls_ref>-type->length.
      ls_component-decimals = <ls_ref>-type->decimals.
      APPEND ls_component TO components.
    ENDLOOP.
  ENDMETHOD.

  METHOD get_components.
    rt_components = mt_refs.
  ENDMETHOD.

  METHOD get_component_type.
    FIELD-SYMBOLS <line> LIKE LINE OF mt_refs.
    READ TABLE mt_refs ASSIGNING <line> WITH KEY name = p_name.
    IF sy-subrc <> 0.
      RAISE component_not_found.
    ELSE.
      p_descr_ref = <line>-type.
    ENDIF.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_TABLEDESCR                      ', 'CLASS cl_abap_tabledescr DEFINITION PUBLIC INHERITING FROM cl_abap_datadescr.
  PUBLIC SECTION.
    DATA has_unique_key TYPE abap_bool READ-ONLY.
    DATA key            TYPE abap_keydescr_tab READ-ONLY.
    DATA key_defkind    TYPE abap_keydefkind READ-ONLY.
    DATA table_kind     TYPE abap_tablekind.

    CONSTANTS tablekind_any TYPE c LENGTH 1 VALUE ''A''.
    CONSTANTS tablekind_std TYPE c LENGTH 1 VALUE ''S''.
    CONSTANTS tablekind_index TYPE c LENGTH 1 VALUE ''I''.
    CONSTANTS tablekind_hashed TYPE c LENGTH 1 VALUE ''H''.
    CONSTANTS tablekind_sorted TYPE c LENGTH 1 VALUE ''O''.

    CONSTANTS keydefkind_default TYPE c LENGTH 1 VALUE ''D''.
    CONSTANTS keydefkind_tableline TYPE c LENGTH 1 VALUE ''L''.
    CONSTANTS keydefkind_user TYPE c LENGTH 1 VALUE ''U''.
    CONSTANTS keydefkind_empty TYPE c LENGTH 1 VALUE ''E''.

    CLASS-METHODS
      construct_from_data
        IMPORTING data TYPE any
        RETURNING VALUE(descr) TYPE REF TO cl_abap_tabledescr.

    METHODS get_table_line_type
      RETURNING
        VALUE(type) TYPE REF TO cl_abap_datadescr.

    CLASS-METHODS get
      IMPORTING type TYPE REF TO cl_abap_typedescr
      RETURNING VALUE(val) TYPE REF TO cl_abap_tabledescr.

    CLASS-METHODS get_with_keys
      IMPORTING
        p_line_type     TYPE REF TO cl_abap_datadescr
        p_keys          TYPE abap_table_keydescr_tab
      RETURNING
        VALUE(p_result) TYPE REF TO cl_abap_tabledescr.

    CLASS-METHODS create
      IMPORTING
        p_line_type  TYPE REF TO cl_abap_typedescr
        p_table_kind TYPE abap_tablekind DEFAULT tablekind_std
        p_unique     TYPE abap_bool DEFAULT abap_false
        p_key        TYPE abap_keydescr_tab OPTIONAL
        p_key_kind   TYPE abap_keydefkind DEFAULT keydefkind_default
      RETURNING
        VALUE(ref) TYPE REF TO cl_abap_tabledescr.

    METHODS get_keys
      RETURNING
        VALUE(p_keys) TYPE abap_table_keydescr_tab.

  PRIVATE SECTION.
    DATA mo_line_type TYPE REF TO cl_abap_typedescr.
    DATA mt_keys      TYPE abap_table_keydescr_tab.
ENDCLASS.

CLASS cl_abap_tabledescr IMPLEMENTATION.

  METHOD create.

    CREATE OBJECT ref.
    ref->has_unique_key = p_unique.
    ref->mo_line_type   = p_line_type.
    ref->key            = p_key.
    ref->key_defkind    = p_key_kind.
    ref->table_kind     = p_table_kind.

    " cl_abap_typedescr
    ref->type_kind      = typekind_table.
    ref->kind           = kind_table.

  ENDMETHOD.

  METHOD get_keys.
    p_keys = mt_keys.
  ENDMETHOD.

  METHOD get_with_keys.

    DATA ls_key LIKE LINE OF p_keys.

    IF lines( p_keys ) <> 1.
      ASSERT 1 = ''todo''.
    ENDIF.
    READ TABLE p_keys INDEX 1 INTO ls_key.
    ASSERT sy-subrc = 0.

    CREATE OBJECT p_result.
    p_result->has_unique_key = ls_key-is_unique.
    p_result->mo_line_type   = p_line_type.
    p_result->key_defkind    = ls_key-key_kind.
    p_result->table_kind     = ls_key-access_kind.
    p_result->mt_keys        = p_keys.

    " cl_abap_typedescr
    p_result->type_kind      = typekind_table.
    p_result->kind           = kind_table.

  ENDMETHOD.

  METHOD get.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD construct_from_data.
* todo, this method should be private
    DATA lv_dummy      TYPE i.
    DATA lv_flag       TYPE abap_bool.
    DATA lv_str        TYPE string.
    DATA lv_type       TYPE string.
    DATA lo_struct     TYPE REF TO cl_abap_structdescr.
    DATA lt_components TYPE cl_abap_structdescr=>component_table.
    DATA ls_component  LIKE LINE OF lt_components.
    DATA ls_key        TYPE LINE OF abap_keydescr_tab.

    CREATE OBJECT descr.

    WRITE ''@KERNEL lv_flag.set(data.getOptions()?.primaryKey?.isUnique === true ? "X" : "");''.
    descr->has_unique_key = lv_flag.

    WRITE ''@KERNEL lv_type.set(data.getOptions()?.primaryKey?.type || "");''.
    CASE lv_type.
      WHEN ''STANDARD''.
        descr->table_kind = tablekind_std.
      WHEN ''SORTED''.
        descr->table_kind = tablekind_sorted.
      WHEN ''HASHED''.
        descr->table_kind = tablekind_hashed.
      WHEN OTHERS.
        descr->table_kind = tablekind_std.
    ENDCASE.

    WRITE ''@KERNEL lv_dummy = data.getRowType();''.
    descr->mo_line_type = cl_abap_typedescr=>describe_by_data( lv_dummy ).

    WRITE ''@KERNEL lv_flag.set(data.getOptions()?.primaryKey?.keyFields.length > 0 ? "X" : "");''.
    IF lv_flag = abap_true.
      descr->key_defkind = keydefkind_user.

      WRITE ''@KERNEL for (const k of data.getOptions()?.primaryKey?.keyFields) {''.
      WRITE ''@KERNEL lv_str.set(k);''.
      ls_key-name = lv_str.
      APPEND ls_key TO descr->key.
      WRITE ''@KERNEL }''.

      IF lines( descr->key ) = 1 AND ls_key-name = ''TABLE_LINE''.
        descr->key_defkind = keydefkind_tableline.
      ENDIF.
    ELSE.
* EMPTY KEY currently not supported in open-abap
      descr->key_defkind = keydefkind_default.
      IF descr->mo_line_type->kind = kind_struct.
        lo_struct ?= descr->mo_line_type.
        lt_components = lo_struct->get_components( ).
        LOOP AT lt_components INTO ls_component.
          ls_key-name = ls_component-name.
          APPEND ls_key TO descr->key.
        ENDLOOP.
      ENDIF.
    ENDIF.

  ENDMETHOD.

  METHOD get_table_line_type.
    type ?= mo_line_type.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_TYPEDESCR                       ', 'CLASS cl_abap_typedescr DEFINITION PUBLIC.
* todo, this class should be ABSTRACT
  PUBLIC SECTION.
    CLASS-METHODS
      describe_by_data
        IMPORTING p_data TYPE any
        RETURNING VALUE(type) TYPE REF TO cl_abap_typedescr.

    CLASS-METHODS
      describe_by_name
        IMPORTING
          p_name TYPE clike
        RETURNING
          VALUE(type) TYPE REF TO cl_abap_typedescr
        EXCEPTIONS
          type_not_found.

    CLASS-METHODS
      describe_by_data_ref
        IMPORTING p_data_ref TYPE REF TO data
        RETURNING VALUE(type) TYPE REF TO cl_abap_typedescr.

    CLASS-METHODS
      describe_by_object_ref
        IMPORTING
          p_object_ref TYPE REF TO object
        RETURNING
          VALUE(p_descr_ref) TYPE REF TO cl_abap_typedescr
        EXCEPTIONS
          reference_is_initial.

    METHODS get_ddic_header
      RETURNING
        VALUE(p_header) TYPE abap_bool. " hmm, todo

    METHODS
      get_relative_name
        RETURNING
          VALUE(name) TYPE string.

    METHODS
      is_ddic_type
        RETURNING
          VALUE(p_abap_bool) TYPE abap_bool.

    METHODS is_instantiatable
      RETURNING
        VALUE(p_result) TYPE abap_bool.

    METHODS get_ddic_object
      RETURNING
        VALUE(p_object) TYPE string_table
      EXCEPTIONS
        not_found
        no_ddic_type.

    DATA type_kind     TYPE abap_typekind.
    DATA kind          TYPE c LENGTH 1.
    DATA ddic          TYPE abap_bool.
    DATA length        TYPE i.
    DATA decimals      TYPE i.
    DATA absolute_name TYPE abap_abstypename.
    DATA relative_name TYPE string.

    CONSTANTS typekind_any TYPE abap_typekind VALUE ''~''.
    CONSTANTS typekind_char TYPE abap_typekind VALUE ''C''.
    CONSTANTS typekind_class TYPE abap_typekind VALUE ''*''.
    CONSTANTS typekind_clike TYPE abap_typekind VALUE ''&''.
    CONSTANTS typekind_csequence TYPE abap_typekind VALUE ''?''.
    CONSTANTS typekind_data TYPE abap_typekind VALUE ''#''.
    CONSTANTS typekind_date TYPE abap_typekind VALUE ''D''.
    CONSTANTS typekind_decfloat TYPE abap_typekind VALUE ''/''.
    CONSTANTS typekind_decfloat16 TYPE abap_typekind VALUE ''a''.
    CONSTANTS typekind_decfloat34 TYPE abap_typekind VALUE ''e''.
    CONSTANTS typekind_dref TYPE abap_typekind VALUE ''l''.
    CONSTANTS typekind_enum TYPE abap_typekind VALUE ''k''.
    CONSTANTS typekind_float TYPE abap_typekind VALUE ''F''.
    CONSTANTS typekind_hex TYPE abap_typekind VALUE ''X''.
    CONSTANTS typekind_int TYPE abap_typekind VALUE ''I''.
    CONSTANTS typekind_int1 TYPE abap_typekind VALUE ''b''.
    CONSTANTS typekind_int2 TYPE abap_typekind VALUE ''s''.
    CONSTANTS typekind_int8 TYPE abap_typekind VALUE ''8''.
    CONSTANTS typekind_intf TYPE abap_typekind VALUE ''+''.
    CONSTANTS typekind_iref TYPE abap_typekind VALUE ''m''.
    CONSTANTS typekind_num TYPE abap_typekind VALUE ''N''.
    CONSTANTS typekind_numeric TYPE abap_typekind VALUE ''%''.
    CONSTANTS typekind_oref TYPE abap_typekind VALUE ''r''.
    CONSTANTS typekind_packed TYPE abap_typekind VALUE ''P''.
    CONSTANTS typekind_simple TYPE abap_typekind VALUE ''$''.
    CONSTANTS typekind_string TYPE abap_typekind VALUE ''g''.
    CONSTANTS typekind_struct1 TYPE abap_typekind VALUE ''u''.
    CONSTANTS typekind_struct2 TYPE abap_typekind VALUE ''v''.
    CONSTANTS typekind_table TYPE abap_typekind VALUE ''h''.
    CONSTANTS typekind_time TYPE abap_typekind VALUE ''T''.
    CONSTANTS typekind_utclong TYPE abap_typekind VALUE ''p''.
    CONSTANTS typekind_w TYPE abap_typekind VALUE ''w''.
    CONSTANTS typekind_xstring TYPE abap_typekind VALUE ''y''.

    CONSTANTS kind_elem   TYPE c LENGTH 1 VALUE ''E''.
    CONSTANTS kind_struct TYPE c LENGTH 1 VALUE ''S''.
    CONSTANTS kind_table  TYPE c LENGTH 1 VALUE ''T''.
    CONSTANTS kind_ref    TYPE c LENGTH 1 VALUE ''R''.
    CONSTANTS kind_class  TYPE c LENGTH 1 VALUE ''C''.
    CONSTANTS kind_intf   TYPE c LENGTH 1 VALUE ''I''.

  PRIVATE SECTION.
    CLASS-DATA gv_counter TYPE n LENGTH 10.

    CLASS-METHODS describe_by_dashes
      IMPORTING p_name TYPE clike
      RETURNING VALUE(type) TYPE REF TO cl_abap_typedescr.

    CLASS-METHODS is_deep
      IMPORTING  io_struct TYPE REF TO cl_abap_structdescr
      RETURNING VALUE(rv_deep) TYPE abap_bool.
ENDCLASS.

CLASS cl_abap_typedescr IMPLEMENTATION.

  METHOD get_ddic_object.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD is_instantiatable.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD describe_by_dashes.
    DATA lt_parts   TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
    DATA lv_part    LIKE LINE OF lt_parts.
    DATA lo_current TYPE REF TO cl_abap_typedescr.
    DATA lo_struct  TYPE REF TO cl_abap_structdescr.

    SPLIT p_name AT ''-'' INTO TABLE lt_parts.

    LOOP AT lt_parts INTO lv_part.
      IF lo_current IS INITIAL.
        lo_current = describe_by_name( lv_part ).
      ELSEIF lo_current->kind = kind_struct.
        lo_struct ?= lo_current.
        lo_current = lo_struct->get_component_type( lv_part ).
      ENDIF.
    ENDLOOP.

    type = lo_current.
  ENDMETHOD.

  METHOD describe_by_name.
    DATA ref         TYPE REF TO data.
    DATA objectdescr TYPE REF TO cl_abap_objectdescr.
    DATA oo_type     TYPE string.
    DATA lv_any      TYPE string.

* note, p_name might be internal name, so check and skip these,
    IF p_name CA ''-'' AND p_name NP ''CLAS-*'' AND p_name NP ''PROG-*''.
      type = describe_by_dashes( p_name ).
      RETURN.
    ENDIF.

    WRITE ''@KERNEL oo_type.set(abap.Classes[p_name.get().toUpperCase().trimEnd()]?.INTERNAL_TYPE || "");''.
    WRITE ''@KERNEL lv_any = abap.Classes[p_name.get().toUpperCase().trimEnd()];''.

    CASE oo_type.
      WHEN ''INTF''.
        CREATE OBJECT type TYPE cl_abap_intfdescr
          EXPORTING
            p_object = lv_any.
        type->type_kind = typekind_intf.
        type->kind = kind_intf.
        type->relative_name = to_upper( p_name ).
        type->absolute_name = ''\\CLASS='' && to_upper( p_name ).
        objectdescr ?= type.
        objectdescr->mv_object_name = to_upper( p_name ). " todo, this should give syntax error, as they are not friends
        objectdescr->mv_object_type = oo_type. " todo, this should give syntax error, as they are not friends
      WHEN ''CLAS''.
        CREATE OBJECT type TYPE cl_abap_classdescr.
        type->type_kind = typekind_class.
        type->kind = kind_class.
        type->relative_name = to_upper( p_name ).
        IF p_name CP ''CLAS-*''.
          type->absolute_name = kernel_internal_name=>internal_to_rtti( p_name ).
        ELSE.
          type->absolute_name = ''\\CLASS='' && to_upper( p_name ).
        ENDIF.
        objectdescr ?= type.
        objectdescr->mv_object_name = to_upper( p_name ). " todo, this should give syntax error, as they are not friends
        objectdescr->mv_object_type = oo_type. " todo, this should give syntax error, as they are not friends
      WHEN OTHERS.
        TRY.
            CREATE DATA ref TYPE (p_name).
          CATCH cx_sy_create_data_error.
            RAISE type_not_found.
        ENDTRY.
        type = describe_by_data_ref( ref ).
    ENDCASE.
  ENDMETHOD.

  METHOD get_relative_name.
    name = relative_name.
  ENDMETHOD.

  METHOD get_ddic_header.
    ASSERT 1 = 2.
  ENDMETHOD.

  METHOD is_ddic_type.
    p_abap_bool = ddic.
  ENDMETHOD.

  METHOD describe_by_data_ref.
    FIELD-SYMBOLS <ref> TYPE any.
    ASSIGN p_data_ref->* TO <ref>.
    type = describe_by_data( <ref> ).
  ENDMETHOD.

  METHOD describe_by_object_ref.
    DATA lv_name   TYPE string.
    DATA lo_cdescr TYPE REF TO cl_abap_classdescr.
    DATA lv_any    TYPE string.

    IF p_object_ref IS INITIAL.
      RAISE reference_is_initial.
    ENDIF.

    WRITE ''@KERNEL lv_any = p_object_ref.get().constructor;''.

    CREATE OBJECT lo_cdescr TYPE cl_abap_classdescr
      EXPORTING
        p_object = lv_any.
    lo_cdescr->type_kind = typekind_class.
    lo_cdescr->kind = kind_class.

    WRITE ''@KERNEL lv_name.set(p_object_ref.get().constructor.name.toUpperCase());''.

    lo_cdescr->relative_name = lv_name.
    lo_cdescr->absolute_name = ''\\CLASS='' && lv_name.

    p_descr_ref = lo_cdescr.
  ENDMETHOD.

  METHOD is_deep.

    DATA lt_components TYPE cl_abap_structdescr=>component_table.
    FIELD-SYMBOLS <ls_component> LIKE LINE OF lt_components.

    lt_components = io_struct->get_components( ).
    rv_deep = abap_false.

    LOOP AT lt_components ASSIGNING <ls_component>.
      IF <ls_component>-type->kind = kind_struct
          OR <ls_component>-type->type_kind = typekind_string
          OR <ls_component>-type->type_kind = typekind_xstring
          OR <ls_component>-type->kind = kind_table.
        rv_deep = abap_true.
        RETURN.
      ENDIF.
    ENDLOOP.

  ENDMETHOD.

  METHOD describe_by_data.

    DATA lo_elem      TYPE REF TO cl_abap_elemdescr.
    DATA lo_ref       TYPE REF TO cl_abap_refdescr.
    DATA lo_struct    TYPE REF TO cl_abap_structdescr.
    DATA lv_any       TYPE string.
    DATA lv_convexit  TYPE string.
    DATA lv_ddicname  TYPE string.
    DATA lv_decimals  TYPE i.
    DATA lv_length    TYPE i.
    DATA lv_name      TYPE string.
    DATA lv_prefix    TYPE string.
    DATA lv_qualified TYPE string.
    DATA lv_rtti_name TYPE string.

    WRITE ''@KERNEL lv_name.set(p_data.constructor.name);''.
    WRITE ''@KERNEL lv_length.set(p_data.getLength ? p_data.getLength() : 0);''.
    WRITE ''@KERNEL lv_decimals.set(p_data.getDecimals ? p_data.getDecimals() : 0);''.

* These are the constructor names from the js runtime
    CASE lv_name.
      WHEN ''Integer''.
        CREATE OBJECT type TYPE cl_abap_elemdescr.
        type->type_kind = typekind_int.
        type->kind = kind_elem.
        type->length = 4.
        lo_elem ?= type.
        lo_elem->output_length = 11.
        type->absolute_name = ''I''.
      WHEN ''Integer8''.
        CREATE OBJECT type TYPE cl_abap_elemdescr.
        type->type_kind = typekind_int8.
        type->kind = kind_elem.
        type->length = 8.
        lo_elem ?= type.
        lo_elem->output_length = 20.
        type->absolute_name = ''INT8''.
      WHEN ''Numc''.
        CREATE OBJECT type TYPE cl_abap_elemdescr.
        type->type_kind = typekind_num.
        type->kind = kind_elem.
        type->length = lv_length * 2.
        lo_elem ?= type.
        lo_elem->output_length = lv_length.
      WHEN ''Hex'' OR ''HexUInt8''.
        CREATE OBJECT type TYPE cl_abap_elemdescr.
        type->type_kind = typekind_hex.
        type->kind = kind_elem.
        type->length = lv_length.
        lo_elem ?= type.
        lo_elem->output_length = lv_length * 2.
      WHEN ''Date''.
        CREATE OBJECT type TYPE cl_abap_elemdescr.
        type->type_kind = typekind_date.
        type->kind = kind_elem.
        type->length = 16.
        lo_elem ?= type.
        lo_elem->output_length = 8.
        type->absolute_name = ''D''.
      WHEN ''Packed''.
        CREATE OBJECT type TYPE cl_abap_elemdescr.
        type->type_kind = typekind_packed.
        type->kind = kind_elem.
        type->length = lv_length.
        type->decimals = lv_decimals.
      WHEN ''Time''.
        CREATE OBJECT type TYPE cl_abap_elemdescr.
        type->type_kind = typekind_time.
        type->kind = kind_elem.
        type->length = 12.
        lo_elem ?= type.
        lo_elem->output_length = 6.
        type->absolute_name = ''T''.
      WHEN ''Float''.
        CREATE OBJECT type TYPE cl_abap_elemdescr.
        type->type_kind = typekind_float.
        type->kind = kind_elem.
        type->absolute_name = ''F''.
      WHEN ''DecFloat34''.
        CREATE OBJECT type TYPE cl_abap_elemdescr.
        type->type_kind = typekind_decfloat34.
        type->kind = kind_elem.
      WHEN ''Structure''.
        lo_struct = cl_abap_structdescr=>construct_from_data( p_data ).
        type ?= lo_struct.
        IF is_deep( lo_struct ) = abap_true.
          type->type_kind = typekind_struct2.
        ELSE.
          type->type_kind = typekind_struct1.
        ENDIF.
        type->kind = kind_struct.
      WHEN ''Table'' OR ''HashedTable''.
        type ?= cl_abap_tabledescr=>construct_from_data( p_data ).
        type->type_kind = typekind_table.
        type->kind = kind_table.
        type->length = 8. " yea, well, because it is. Pointer size?
      WHEN ''XString''.
        CREATE OBJECT type TYPE cl_abap_elemdescr.
        type->type_kind = typekind_xstring.
        type->kind = kind_elem.
        type->length = 8.
        type->absolute_name = ''XSTRING''.
      WHEN ''String''.
        CREATE OBJECT type TYPE cl_abap_elemdescr.
        type->type_kind = typekind_string.
        type->kind = kind_elem.
        type->length = 8.
        type->absolute_name = ''STRING''.
      WHEN ''Character''.
        CREATE OBJECT type TYPE cl_abap_elemdescr.
        type->type_kind = typekind_char.
        type->kind = kind_elem.
        type->length = lv_length * 2.
        lo_elem ?= type.
        lo_elem->output_length = lv_length.
      WHEN ''FieldSymbol''.
        WRITE ''@KERNEL lv_name = p_data.getPointer();''.
        type = describe_by_data( lv_name ).
        RETURN.
      WHEN ''ABAPObject''.
        CREATE OBJECT type TYPE cl_abap_refdescr.
        type->type_kind = typekind_oref.
        type->kind = kind_ref.

        lo_ref ?= type.
        IF p_data IS INITIAL.
* note: using the name doesnt work for local classes
          WRITE ''@KERNEL lv_rtti_name.set(p_data.RTTIName || "");''.
          IF lv_rtti_name CP ''\\CLASS-POOL=*''.
* convert to internal name,
            lv_rtti_name = kernel_internal_name=>rtti_to_internal( lv_rtti_name ).
            lo_ref->referenced = describe_by_name( lv_rtti_name ).
          ELSE.
            WRITE ''@KERNEL lv_name.set(p_data.qualifiedName || "");''.
            lo_ref->referenced = describe_by_name( lv_name ).
          ENDIF.
        ELSE.
          lo_ref->referenced = describe_by_object_ref( p_data ).
        ENDIF.
      WHEN ''UTCLong''.
        CREATE OBJECT type TYPE cl_abap_elemdescr.
        type->type_kind = typekind_utclong.
        type->kind = kind_elem.
      WHEN ''DataReference''.
        CREATE OBJECT type TYPE cl_abap_refdescr.
        type->type_kind = typekind_dref.
        type->kind = kind_ref.

        lo_ref ?= type.
        WRITE ''@KERNEL lv_any = p_data.type;''.
        lo_ref->referenced = describe_by_data( lv_any ).
      WHEN OTHERS.
        WRITE / lv_name.
        ASSERT 1 = ''todo_cl_abap_typedescr''.
    ENDCASE.

*    WRITE ''@KERNEL console.dir(p_data);''.

    WRITE ''@KERNEL lv_ddicname.set(p_data.getDDICName ? p_data.getDDICName() || "" : "");''.
    WRITE ''@KERNEL lv_convexit.set(p_data.getConversionExit ? p_data.getConversionExit() || "" : "");''.
    WRITE ''@KERNEL lv_qualified.set(p_data.getQualifiedName ? p_data.getQualifiedName() || "" : "");''.

    IF lv_qualified NA ''-''.
      type->absolute_name = lv_qualified.
    ELSEIF lv_ddicname <> ''''.
      type->absolute_name = lv_ddicname.
    ENDIF.

* this is not completely correct, local type names and ddic names might overlap, but will work for now,
* todo: use/check getDDICName() in the future,
    WRITE ''@KERNEL if(abap.DDIC[type.get().absolute_name.get().toUpperCase().trimEnd()]) { type.get().ddic.set("X"); }''.

    TRANSLATE type->absolute_name TO UPPER CASE.
    TRANSLATE type->relative_name TO UPPER CASE.

    IF type->absolute_name = ''ABAP_BOOL''.
      type->relative_name = ''ABAP_BOOL''.
      type->absolute_name = ''\\TYPE-POOL=ABAP\\TYPE=ABAP_BOOL''.
    ELSEIF type->absolute_name IS INITIAL.
      gv_counter = gv_counter + 1.
      type->absolute_name = ''\\TYPE=%_T000000000000000'' && gv_counter.
    ELSEIF type->absolute_name CS ''=>''.
      SPLIT type->absolute_name AT ''=>'' INTO lv_prefix type->absolute_name.
      type->relative_name = type->absolute_name.
      type->absolute_name = ''\\CLASS='' && lv_prefix && ''\\TYPE='' && type->absolute_name.
    ELSEIF type->type_kind = typekind_oref.
      type->relative_name = type->absolute_name.
      type->absolute_name = ''\\CLASS='' && type->absolute_name.
    ELSE.
      type->relative_name = type->absolute_name.
      type->absolute_name = ''\\TYPE='' && type->absolute_name.
    ENDIF.

    IF lv_convexit <> ''''.
      lo_elem->edit_mask = ''=='' && lv_convexit.
    ENDIF.

  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SHM_AREA                             ', 'CLASS cl_shm_area DEFINITION PUBLIC INHERITING FROM cx_shm_general_error ABSTRACT.
  PUBLIC SECTION.
    CONSTANTS default_instance TYPE shm_inst_name VALUE ''$DEFAULT_INSTANCE$''.
    CONSTANTS invocation_mode_explicit TYPE shm_constr_invocation_mode VALUE 319200300.
    CONSTANTS life_context_appserver TYPE shm_life_context VALUE 109200001.
    CONSTANTS attach_mode_default TYPE shm_attach_mode VALUE 1302197000.
    CONSTANTS attach_mode_wait TYPE shm_attach_mode VALUE 1302197002.
    CONSTANTS affect_local_server TYPE shm_affect_server VALUE 281119720.

    DATA properties TYPE shm_properties READ-ONLY.
    DATA inst_name  TYPE shm_inst_name READ-ONLY.
    DATA client     TYPE mandt READ-ONLY.

    METHODS detach_commit
      RAISING
        cx_shm_wrong_handle
        cx_shm_already_detached
        cx_shm_secondary_commit
        cx_shm_event_execution_failed
        cx_shm_completion_error.

    METHODS detach
      RAISING
        cx_shm_wrong_handle
        cx_shm_already_detached.

    METHODS get_root ABSTRACT
      RETURNING
        VALUE(root) TYPE REF TO object
      RAISING
        cx_shm_already_detached.

    METHODS is_valid
      RETURNING
        VALUE(valid) TYPE abap_bool.

  PROTECTED SECTION.
    DATA inst_trace_active TYPE abap_bool VALUE abap_false.
    DATA inst_trace_service TYPE REF TO if_shm_trace.
    DATA _lock TYPE %_c_pointer.
    CONSTANTS attach_mode_wait_2nd_try TYPE shm_attach_mode VALUE 1302197003.

    METHODS _attach_read71
      IMPORTING
        sneak_mode   TYPE abap_bool DEFAULT abap_false
        area_name    TYPE shm_area_name
        life_context TYPE shm_life_context
      EXPORTING
        root         TYPE REF TO object
      RAISING
        cx_shm_inconsistent
        cx_shm_no_active_version
        cx_shm_read_lock_active
        cx_shm_exclusive_lock_active
        cx_shm_parameter_error
        cx_shm_change_lock_active.

    METHODS _attach_update70
      IMPORTING
        area_name TYPE shm_area_name
        mode      TYPE shm_attach_mode
      EXPORTING
        root      TYPE REF TO object
      CHANGING
        wait_time TYPE i OPTIONAL
      RAISING
        cx_shm_inconsistent
        cx_shm_exclusive_lock_active
        cx_shm_change_lock_active
        cx_shm_version_limit_exceeded
        cx_shm_no_active_version
        cx_shm_parameter_error
        cx_shm_pending_lock_removed.

    METHODS _attach_write70
      IMPORTING
        area_name TYPE shm_area_name
        mode      TYPE shm_attach_mode
      EXPORTING
        root      TYPE REF TO object
      CHANGING
        wait_time TYPE i OPTIONAL
      RAISING
        cx_shm_version_limit_exceeded
        cx_shm_exclusive_lock_active
        cx_shm_change_lock_active
        cx_shm_parameter_error
        cx_shm_pending_lock_removed.

    CLASS-METHODS _invalidate_area71
      IMPORTING
        area_name TYPE shm_area_name
        client TYPE shm_client
        client_supplied TYPE abap_bool DEFAULT abap_false
        transactional TYPE abap_bool DEFAULT abap_false
        client_dependent TYPE abap_bool DEFAULT abap_false
        terminate_changer TYPE abap_bool
        affect_server TYPE shm_affect_server
        life_context TYPE shm_life_context DEFAULT life_context_appserver
      RETURNING
        VALUE(rc) TYPE shm_rc
      RAISING
        cx_shm_parameter_error.

    CLASS-METHODS _invalidate_instance71
      IMPORTING
        area_name TYPE shm_area_name
        inst_name TYPE shm_inst_name
        client TYPE shm_client
        client_supplied TYPE abap_bool DEFAULT abap_false
        transactional TYPE abap_bool DEFAULT abap_false
        client_dependent TYPE abap_bool DEFAULT abap_false
        terminate_changer TYPE abap_bool
        affect_server TYPE shm_affect_server
        life_context TYPE shm_life_context DEFAULT life_context_appserver
      RETURNING
        VALUE(rc) TYPE shm_rc
      RAISING
        cx_shm_parameter_error.

    METHODS _set_root
      IMPORTING
        root TYPE REF TO object
      RAISING
        cx_shm_wrong_handle
        cx_shm_initial_reference.

    CLASS-METHODS _detach_area71
      IMPORTING
        area_name        TYPE shm_area_name
        client           TYPE shm_client
        client_supplied  TYPE abap_bool
        client_dependent TYPE abap_bool DEFAULT abap_false
        life_context     TYPE shm_life_context
      RETURNING
        VALUE(rc)        TYPE shm_rc.

    CLASS-METHODS _free_area71
      IMPORTING
        area_name TYPE shm_area_name
        client TYPE shm_client
        client_supplied TYPE abap_bool DEFAULT abap_false
        transactional TYPE abap_bool DEFAULT abap_false
        client_dependent TYPE abap_bool DEFAULT abap_false
        terminate_changer TYPE abap_bool
        affect_server TYPE shm_affect_server
        life_context TYPE shm_life_context DEFAULT life_context_appserver
      RETURNING
        VALUE(rc) TYPE shm_rc
      RAISING
        cx_shm_parameter_error.

    CLASS-METHODS _get_instance_infos71
      IMPORTING
        area_name        TYPE shm_area_name
        client           TYPE shm_client
        client_supplied  TYPE abap_bool DEFAULT abap_false
        client_dependent TYPE abap_bool DEFAULT abap_false
        life_context     TYPE shm_life_context
      RETURNING
        VALUE(infos)     TYPE shm_inst_infos.

    CLASS-METHODS _free_instance71
      IMPORTING
        area_name         TYPE shm_area_name
        inst_name         TYPE shm_inst_name
        client            TYPE shm_client
        client_supplied   TYPE abap_bool DEFAULT abap_false
        transactional     TYPE abap_bool DEFAULT abap_false
        client_dependent  TYPE abap_bool DEFAULT abap_false
        terminate_changer TYPE abap_bool
        affect_server     TYPE shm_affect_server
        life_context      TYPE shm_life_context DEFAULT life_context_appserver
      RETURNING
        VALUE(rc)         TYPE shm_rc
      RAISING
        cx_shm_parameter_error.
  PRIVATE SECTION.
    CLASS-DATA mo_root TYPE REF TO object.
ENDCLASS.

CLASS cl_shm_area IMPLEMENTATION.

  METHOD is_valid.
    valid = abap_true.
  ENDMETHOD.

  METHOD _free_instance71.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD detach_commit.
    RETURN.
  ENDMETHOD.

  METHOD detach.
    RETURN.
  ENDMETHOD.

  METHOD _attach_read71.
    DATA created TYPE REF TO object.
    DATA lv_name TYPE string.

    IF sneak_mode = abap_false AND mo_root IS INITIAL.
      lv_name = area_name.
* todo, this is an evil workaround
      REPLACE FIRST OCCURRENCE OF ''_AREA'' IN lv_name WITH ''_ROOT''.
      CREATE OBJECT created TYPE (lv_name).

      _set_root( created ).
    ENDIF.

    root = mo_root.
  ENDMETHOD.

  METHOD _get_instance_infos71.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD _detach_area71.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD _free_area71.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD _set_root.
    mo_root = root.
  ENDMETHOD.

  METHOD _invalidate_instance71.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD _invalidate_area71.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD _attach_update70.
    DATA created TYPE REF TO object.
    DATA lv_name TYPE string.

    IF mo_root IS INITIAL.
* todo, this should respect the auto build flag configuration from the SHMA area
* todo, this is an evil workaround
      REPLACE FIRST OCCURRENCE OF ''_AREA'' IN lv_name WITH ''_ROOT''.
      CREATE OBJECT created TYPE (lv_name).

      _set_root( created ).
    ENDIF.
* open-abap is currently single threaded, so no lock conflicts
    root = mo_root.
  ENDMETHOD.

  METHOD _attach_write70.
* open-abap is currently single threaded, so no lock conflicts
    RETURN.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SHM_SERVICE                          ', 'CLASS cl_shm_service DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS initialize
      IMPORTING
        area_name  TYPE shm_area_name
        client     TYPE shma_client OPTIONAL
      EXPORTING
        attributes TYPE shma_attributes.

    CLASS-METHODS get_auto_build_class_name
      IMPORTING
        area_name TYPE shm_area_name
      RETURNING
        VALUE(auto_build_class_name) TYPE shm_auto_build_class_name
      RAISING
        cx_shma_not_configured
        cx_shma_inconsistent.

    CLASS-METHODS trace_get_service
      IMPORTING
        !area_name TYPE shm_area_name OPTIONAL
      RETURNING
        VALUE(trace_service) TYPE REF TO if_shm_trace.

    CLASS-METHODS trace_is_variant_active
      IMPORTING
        service_name     TYPE shmm_trc_variant_name
      RETURNING
        VALUE(is_active) TYPE abap_bool.

ENDCLASS.

CLASS cl_shm_service IMPLEMENTATION.

  METHOD initialize.
    RETURN.
  ENDMETHOD.

  METHOD get_auto_build_class_name.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD trace_get_service.
* dont dump, this method is called from area CLASS_CONSTRUCTORs
    RETURN.
  ENDMETHOD.

  METHOD trace_is_variant_active.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_ALREADY_DETACHED                 ', 'CLASS cx_shm_already_detached DEFINITION PUBLIC INHERITING FROM cx_shm_general_error.
  PUBLIC SECTION.
    METHODS constructor
      IMPORTING
        textid    LIKE textid OPTIONAL
        previous  LIKE previous OPTIONAL
        area_name TYPE string OPTIONAL
        inst_name TYPE string OPTIONAL
        client    TYPE string OPTIONAL.
ENDCLASS.

CLASS cx_shm_already_detached IMPLEMENTATION.

  METHOD constructor.
    RETURN.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_ATTACH_ERROR                     ', 'CLASS cx_shm_attach_error DEFINITION PUBLIC INHERITING FROM cx_shm_error.

ENDCLASS.

CLASS cx_shm_attach_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_BUILD_FAILED                     ', 'CLASS cx_shm_build_failed DEFINITION PUBLIC INHERITING FROM cx_shm_general_error.

ENDCLASS.

CLASS cx_shm_build_failed IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_CHANGE_LOCK_ACTIVE               ', 'CLASS cx_shm_change_lock_active DEFINITION PUBLIC INHERITING FROM cx_shm_attach_error.

ENDCLASS.

CLASS cx_shm_change_lock_active IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_COMPLETION_ERROR                 ', 'CLASS cx_shm_completion_error DEFINITION PUBLIC INHERITING FROM cx_shm_detach_error.

ENDCLASS.

CLASS cx_shm_completion_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_DETACH_ERROR                     ', 'CLASS cx_shm_detach_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_shm_detach_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_ERROR                            ', 'CLASS cx_shm_error DEFINITION PUBLIC INHERITING FROM cx_static_check.

ENDCLASS.

CLASS cx_shm_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_EVENT_EXECUTION_FAILED           ', 'CLASS cx_shm_event_execution_failed DEFINITION PUBLIC INHERITING FROM cx_shm_completion_error.

ENDCLASS.

CLASS cx_shm_event_execution_failed IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_EXCLUSIVE_LOCK_ACTIVE            ', 'CLASS cx_shm_exclusive_lock_active DEFINITION PUBLIC INHERITING FROM cx_shm_attach_error.

ENDCLASS.

CLASS cx_shm_exclusive_lock_active IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_GENERAL_ERROR                    ', 'CLASS cx_shm_general_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_shm_general_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_INCONSISTENT                     ', 'CLASS cx_shm_inconsistent DEFINITION PUBLIC INHERITING FROM cx_shm_attach_error.

ENDCLASS.

CLASS cx_shm_inconsistent IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_INITIAL_REFERENCE                ', 'CLASS cx_shm_initial_reference DEFINITION PUBLIC INHERITING FROM cx_shm_general_error.

ENDCLASS.

CLASS cx_shm_initial_reference IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_NO_ACTIVE_VERSION                ', 'CLASS cx_shm_no_active_version DEFINITION PUBLIC INHERITING FROM cx_shm_attach_error.

ENDCLASS.

CLASS cx_shm_no_active_version IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_PARAMETER_ERROR                  ', 'CLASS cx_shm_parameter_error DEFINITION PUBLIC INHERITING FROM cx_shm_general_error.

ENDCLASS.

CLASS cx_shm_parameter_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_PENDING_LOCK_REMOVED             ', 'CLASS cx_shm_pending_lock_removed DEFINITION PUBLIC INHERITING FROM cx_shm_attach_error.

ENDCLASS.

CLASS cx_shm_pending_lock_removed IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_READ_LOCK_ACTIVE                 ', 'CLASS cx_shm_read_lock_active DEFINITION PUBLIC INHERITING FROM cx_shm_attach_error.

ENDCLASS.

CLASS cx_shm_read_lock_active IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_SECONDARY_COMMIT                 ', 'CLASS cx_shm_secondary_commit DEFINITION PUBLIC INHERITING FROM cx_shm_detach_error.

ENDCLASS.

CLASS cx_shm_secondary_commit IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_VERSION_LIMIT_EXCEEDED           ', 'CLASS cx_shm_version_limit_exceeded DEFINITION PUBLIC INHERITING FROM cx_shm_attach_error.

ENDCLASS.

CLASS cx_shm_version_limit_exceeded IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_WRONG_HANDLE                     ', 'CLASS cx_shm_wrong_handle DEFINITION PUBLIC INHERITING FROM cx_shm_general_error.

ENDCLASS.

CLASS cx_shm_wrong_handle IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHMA_DYNAMIC                         ', 'CLASS cx_shma_dynamic DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_shma_dynamic IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHMA_INCONSISTENT                    ', 'CLASS cx_shma_inconsistent DEFINITION PUBLIC INHERITING FROM cx_shma_dynamic.

ENDCLASS.

CLASS cx_shma_inconsistent IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHMA_NOT_CONFIGURED                  ', 'CLASS cx_shma_not_configured DEFINITION PUBLIC INHERITING FROM cx_shma_dynamic.

ENDCLASS.

CLASS cx_shma_not_configured IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SHM_BUILD_INSTANCE                   ', 'INTERFACE if_shm_build_instance PUBLIC.
  CLASS-METHODS build
    IMPORTING
      inst_name       TYPE shm_inst_name              DEFAULT cl_shm_area=>default_instance
      invocation_mode TYPE shm_constr_invocation_mode DEFAULT cl_shm_area=>invocation_mode_explicit
    RAISING
      cx_shm_build_failed.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SHM_TRACE                            ', 'INTERFACE if_shm_trace PUBLIC.

  DATA: BEGIN OF variant,
          def_name         TYPE shmm_trc_variant_name,
          attach_for_upd   TYPE abap_bool,
          attach_for_read  TYPE abap_bool,
          free_area        TYPE abap_bool,
          detach_area      TYPE abap_bool,
          set_root         TYPE abap_bool,
          invalidate_inst  TYPE abap_bool,
          get_instance_inf TYPE abap_bool,
          free_instance    TYPE abap_bool,
          invalidate_area  TYPE abap_bool,
          build            TYPE abap_bool,
          attach_for_write TYPE abap_bool,
          get_root         TYPE abap_bool,
        END OF variant.

  METHODS trin_attach_for_write
    IMPORTING
      area_name TYPE shm_area_name
      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance
      client    TYPE shm_client DEFAULT sy-mandt
      mode      TYPE shm_attach_mode DEFAULT cl_shm_area=>attach_mode_default
      wait_time TYPE i DEFAULT 0.

  METHODS trcx_attach_for_write
    IMPORTING
      area_name TYPE shm_area_name
      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance
      client    TYPE shm_client DEFAULT sy-mandt
      mode      TYPE shm_attach_mode DEFAULT cl_shm_area=>attach_mode_default
      wait_time TYPE i DEFAULT 0
      cx        TYPE REF TO cx_root.

  METHODS trin_attach_for_update
    IMPORTING
      area_name TYPE shm_area_name
      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance
      client    TYPE shm_client DEFAULT sy-mandt
      mode      TYPE shm_attach_mode DEFAULT cl_shm_area=>attach_mode_default
      wait_time TYPE i DEFAULT 0.

  METHODS trcx_attach_for_update
    IMPORTING
      area_name TYPE shm_area_name
      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance
      client    TYPE shm_client DEFAULT sy-mandt
      mode      TYPE shm_attach_mode DEFAULT cl_shm_area=>attach_mode_default
      wait_time TYPE i DEFAULT 0
      cx        TYPE REF TO cx_root.

  METHODS trin_attach_for_read
    IMPORTING
      area_name TYPE shm_area_name
      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance
      client    TYPE shm_client DEFAULT sy-mandt.

  METHODS trcx_attach_for_read
    IMPORTING
      area_name TYPE shm_area_name
      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance
      client    TYPE shm_client DEFAULT sy-mandt
      cx        TYPE REF TO cx_root.

  METHODS trin_build
    IMPORTING
      area_name TYPE shm_area_name
      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance.

  METHODS trcx_build
    IMPORTING
      area_name TYPE shm_area_name
      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance
      cx TYPE REF TO cx_root.

  METHODS trin_set_root
    IMPORTING
      area_name TYPE shm_area_name
      inst_name TYPE shm_inst_name
      root TYPE REF TO object.

  METHODS trcx_set_root
    IMPORTING
      area_name TYPE shm_area_name
      inst_name TYPE shm_inst_name
      root TYPE REF TO object
      cx TYPE REF TO cx_root.

  METHODS trin_detach_area
    IMPORTING
      area_name TYPE shm_area_name
      client TYPE shm_client DEFAULT sy-mandt
      rc TYPE shm_rc.

  METHODS trin_free_area
    IMPORTING
      area_name         TYPE shm_area_name
      client            TYPE shm_client DEFAULT sy-mandt
      terminate_changer TYPE abap_bool DEFAULT abap_true
      affect_server     TYPE shm_affect_server OPTIONAL
      rc                TYPE shm_rc.

  METHODS trin_free_instance
    IMPORTING
      area_name TYPE shm_area_name
      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance
      client TYPE shm_client DEFAULT sy-mandt
      terminate_changer TYPE abap_bool DEFAULT abap_true
      affect_server TYPE shm_affect_server OPTIONAL
      rc TYPE shm_rc.

  METHODS trin_get_instance_infos
    IMPORTING
      area_name TYPE shm_area_name
      inst_name TYPE shm_inst_name OPTIONAL
      client TYPE shm_client DEFAULT sy-mandt
      infos TYPE shm_inst_infos.

  METHODS trin_invalidate_area
    IMPORTING
      area_name TYPE shm_area_name
      client TYPE shm_client DEFAULT sy-mandt
      rc TYPE shm_rc
      affect_server TYPE shm_affect_server OPTIONAL
      terminate_changer TYPE abap_bool DEFAULT abap_true.

  METHODS trin_invalidate_instance
    IMPORTING
      area_name TYPE shm_area_name
      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance
      client TYPE shm_client DEFAULT sy-mandt
      terminate_changer TYPE abap_bool DEFAULT abap_true
      affect_server TYPE shm_affect_server OPTIONAL
      rc TYPE shm_rc.

  METHODS trin_get_root
    IMPORTING
      area_name TYPE shm_area_name.

  METHODS trcx_get_root
    IMPORTING
      area_name TYPE shm_area_name
      cx        TYPE REF TO cx_root.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_MIME_REPOSITORY_API                  ', 'CLASS cl_mime_repository_api DEFINITION PUBLIC FINAL CREATE PRIVATE.

  PUBLIC SECTION.
    INTERFACES if_mr_api.
    ALIASES get_api FOR if_mr_api~get_api.
ENDCLASS.

CLASS cl_mime_repository_api IMPLEMENTATION.
  METHOD if_mr_api~get_api.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_mr_api~get.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_mr_api~create_folder.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_mr_api~put.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_mr_api~delete.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_mr_api~file_list.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_mr_api~properties.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_mr_api~get_io_for_url.
    ASSERT 1 = ''todo''.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_MR_API                               ', 'INTERFACE if_mr_api PUBLIC.

  CLASS-METHODS get_api
    IMPORTING
      i_prefix        TYPE csequence DEFAULT space
    RETURNING
      VALUE(r_mr_api) TYPE REF TO if_mr_api.

  METHODS get
    IMPORTING
      i_url             TYPE csequence
      i_check_authority TYPE abap_bool DEFAULT abap_true
    EXPORTING
      e_is_folder       TYPE abap_bool
      e_content         TYPE xstring
      e_mime_type       TYPE csequence
      e_loio            TYPE skwf_io
    CHANGING
      c_language        TYPE langu OPTIONAL
    EXCEPTIONS
      parameter_missing
      error_occured
      not_found
      permission_failure.

  METHODS create_folder
    IMPORTING
      i_url                     TYPE csequence
      i_language                TYPE langu DEFAULT sy-langu
      i_description             TYPE csequence OPTIONAL
      i_check_authority         TYPE abap_bool DEFAULT abap_true
      i_suppress_package_dialog TYPE abap_bool DEFAULT space
      i_dev_package             TYPE devclass OPTIONAL
      i_genflag                 TYPE abap_bool DEFAULT abap_false
      i_corr_number             TYPE trkorr OPTIONAL
      i_folder_loio             TYPE skwf_io OPTIONAL
      i_suppress_dialogs        TYPE abap_bool OPTIONAL
    EXPORTING
      e_folder_io               TYPE skwf_io
    EXCEPTIONS
      parameter_missing
      error_occured
      cancelled
      permission_failure
      folder_exists.

  METHODS put
    IMPORTING
      i_url                     TYPE csequence
      i_content                 TYPE xstring
      i_language                TYPE langu DEFAULT sy-langu
      i_description             TYPE csequence OPTIONAL
      i_check_authority         TYPE abap_bool DEFAULT abap_true
      i_suppress_package_dialog TYPE abap_bool DEFAULT space
      i_dev_package             TYPE devclass OPTIONAL
      i_genflag                 TYPE abap_bool DEFAULT abap_false
      i_corr_number             TYPE trkorr OPTIONAL
      i_new_loio                TYPE skwf_io OPTIONAL
      i_suppress_dialogs        TYPE abap_bool OPTIONAL
    EXCEPTIONS
      parameter_missing
      error_occured
      cancelled
      permission_failure
      data_inconsistency
      new_loio_already_exists
      is_folder.

  METHODS delete
    IMPORTING
      i_url              TYPE csequence
      i_delete_children  TYPE abap_bool DEFAULT abap_false
      i_check_authority  TYPE abap_bool DEFAULT abap_true
      i_corr_number      TYPE trkorr OPTIONAL
      i_suppress_dialogs TYPE abap_bool OPTIONAL
    EXCEPTIONS
      parameter_missing
      error_occured
      cancelled
      permission_failure
      not_found.

  METHODS file_list
    IMPORTING
      i_url             TYPE csequence
      i_recursive_call  TYPE abap_bool DEFAULT abap_false
      i_check_authority TYPE abap_bool DEFAULT abap_true
    EXPORTING
      e_files           TYPE string_table
    EXCEPTIONS
      parameter_missing
      error_occured
      not_found
      permission_failure
      is_not_folder.

  METHODS properties
    IMPORTING
      i_url               TYPE csequence
      i_check_authority   TYPE abap_bool DEFAULT abap_true
    EXPORTING
      e_is_folder         TYPE abap_bool
      e_mime_type         TYPE csequence
      e_name              TYPE string
      e_size              TYPE i
      e_bin_data          TYPE abap_bool
      e_loio              TYPE skwf_io
      e_phio              TYPE skwf_io
      e_language          TYPE langu
      e_phio_last_changed TYPE string " wrong, delete parameter?
    EXCEPTIONS
      parameter_missing
      error_occured
      not_found
      permission_failure.

  METHODS get_io_for_url
    IMPORTING
      i_url       TYPE csequence
    EXPORTING
      e_is_folder TYPE abap_bool
      e_loio      TYPE skwf_io
    EXCEPTIONS
      parameter_missing
      error_occured
      not_found.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SXML_STRING_READER                   ', 'CLASS cl_sxml_string_reader DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS create
      IMPORTING
        input         TYPE xstring
      RETURNING
        VALUE(reader) TYPE REF TO if_sxml_reader.
ENDCLASS.

CLASS cl_sxml_string_reader IMPLEMENTATION.
  METHOD create.
    CREATE OBJECT reader TYPE lcl_reader
      EXPORTING
        iv_json = cl_abap_codepage=>convert_from( input ).
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SXML_STRING_WRITER                   ', 'CLASS cl_sxml_string_writer DEFINITION PUBLIC FINAL CREATE PRIVATE.

  PUBLIC SECTION.
    INTERFACES if_sxml_writer.

    METHODS constructor
      IMPORTING
        type TYPE if_sxml=>xml_stream_type.

    METHODS get_output
      RETURNING
        VALUE(output) TYPE xstring.

    CLASS-METHODS create
      IMPORTING
        type                     TYPE if_sxml=>xml_stream_type DEFAULT if_sxml=>co_xt_xml10
        ignore_conversion_errors TYPE abap_bool DEFAULT abap_false
        normalizing              TYPE abap_bool DEFAULT abap_false
        no_empty_elements        TYPE abap_bool DEFAULT abap_false
        encoding                 TYPE string DEFAULT ''UTF-8''
        PREFERRED PARAMETER type
      RETURNING
        VALUE(writer)            TYPE REF TO cl_sxml_string_writer
      RAISING
        cx_sxml_illegal_argument_error.

  PRIVATE SECTION.
    DATA mv_output TYPE xstring.
    DATA mv_type TYPE if_sxml=>xml_stream_type.
    DATA mt_stack TYPE STANDARD TABLE OF string WITH DEFAULT KEY.

    METHODS append_text IMPORTING text TYPE string.
    METHODS get_text RETURNING VALUE(text) TYPE string.

* stack operations
    METHODS peek RETURNING VALUE(rv_name) TYPE string.
    METHODS remove RETURNING VALUE(rv_name) TYPE string.
ENDCLASS.

CLASS cl_sxml_string_writer IMPLEMENTATION.

  METHOD constructor.
    mv_type = type.
  ENDMETHOD.

  METHOD if_sxml_writer~new_close_element.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_sxml_writer~write_attribute_raw.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_sxml_writer~new_value.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_sxml_writer~new_open_element.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_sxml_writer~write_value_raw.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_sxml_writer~write_namespace_declaration.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD if_sxml_writer~write_node.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD create.
    CREATE OBJECT writer
      EXPORTING
        type = type.
  ENDMETHOD.

  METHOD if_sxml_writer~set_option.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD get_output.
    output = mv_output.
  ENDMETHOD.

  METHOD append_text.
    DATA append TYPE xstring.
    append = cl_abap_conv_codepage=>create_out( )->convert( text ).
    CONCATENATE mv_output append INTO mv_output IN BYTE MODE.
  ENDMETHOD.

  METHOD get_text.
    text = cl_abap_conv_codepage=>create_in( )->convert( mv_output ).
  ENDMETHOD.

  METHOD if_sxml_writer~open_element.
    DATA parent TYPE string.
    parent = peek( ).

    IF parent = ''array'' AND get_text( ) NP ''*[''.
      append_text( '','' ).
    ENDIF.
    IF parent = ''object'' AND get_text( ) NP ''*{''.
      append_text( '','' ).
    ENDIF.

    APPEND name TO mt_stack.
    CASE name.
      WHEN ''object''.
        append_text( ''{'' ).
      WHEN ''array''.
        append_text( ''['' ).
    ENDCASE.
  ENDMETHOD.

  METHOD remove.
    DATA index TYPE i.
    index = lines( mt_stack ).
    READ TABLE mt_stack INDEX index INTO rv_name.
    DELETE mt_stack INDEX index.
  ENDMETHOD.

  METHOD if_sxml_writer~close_element.
    DATA name TYPE string.
    name = remove( ).
    CASE name.
      WHEN ''object''.
        append_text( ''}'' ).
      WHEN ''array''.
        append_text( '']'' ).
    ENDCASE.
  ENDMETHOD.

  METHOD if_sxml_writer~write_attribute.
    append_text( ''"'' ).
    append_text( value ).
    append_text( ''":'' ).
  ENDMETHOD.

  METHOD peek.
    DATA index TYPE i.
    index = lines( mt_stack ).
    READ TABLE mt_stack INDEX index INTO rv_name.
  ENDMETHOD.

  METHOD if_sxml_writer~write_value.
    DATA name TYPE string.
    name = peek( ).
    CASE name.
      WHEN ''str''.
        append_text( ''"'' ).
        append_text( condense( value ) ).
        append_text( ''"'' ).
      WHEN ''num''.
        append_text( condense( value ) ).
      WHEN OTHERS.
        WRITE ''@KERNEL console.dir(name);''.
        ASSERT 1 = ''todo_if_sxml_writer_write_value''.
    ENDCASE.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SXML_ERROR                           ', 'CLASS cx_sxml_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.

ENDCLASS.

CLASS cx_sxml_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SXML_ILLEGAL_ARGUMENT_ERROR          ', 'CLASS cx_sxml_illegal_argument_error DEFINITION PUBLIC INHERITING FROM cx_sxml_error.
  PUBLIC SECTION.
ENDCLASS.

CLASS cx_sxml_illegal_argument_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SXML_NAME_ERROR                      ', 'CLASS cx_sxml_name_error DEFINITION PUBLIC INHERITING FROM cx_sxml_error.
  PUBLIC SECTION.
ENDCLASS.

CLASS cx_sxml_name_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SXML_PARSE_ERROR                     ', 'CLASS cx_sxml_parse_error DEFINITION PUBLIC INHERITING FROM cx_sxml_error.
  PUBLIC SECTION.
    METHODS constructor IMPORTING xml_offset TYPE i.
    CONSTANTS kernel_parser TYPE sotr_conc VALUE ''00000000000000000000000000000000''.

    DATA error_text TYPE string.
    DATA rawstring  TYPE string.
    DATA xml_offset TYPE i.
    DATA rc         TYPE i.
ENDCLASS.

CLASS cx_sxml_parse_error IMPLEMENTATION.
  METHOD constructor.
    super->constructor( ).
    me->xml_offset = xml_offset.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SXML_STATE_ERROR                     ', 'CLASS cx_sxml_state_error DEFINITION PUBLIC INHERITING FROM cx_sxml_error.
  PUBLIC SECTION.
ENDCLASS.

CLASS cx_sxml_state_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXML                                 ', 'INTERFACE if_sxml PUBLIC.

  TYPES xml_stream_type TYPE i.

  CONSTANTS co_xt_xml10 TYPE xml_stream_type VALUE 1.
  CONSTANTS co_xt_binary TYPE xml_stream_type VALUE 2.
  CONSTANTS co_xt_xop TYPE xml_stream_type VALUE 3.
  CONSTANTS co_xt_json TYPE xml_stream_type VALUE 4.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXML_ATTRIBUTE                       ', 'INTERFACE if_sxml_attribute PUBLIC.
  TYPES attributes TYPE STANDARD TABLE OF REF TO if_sxml_attribute WITH DEFAULT KEY.
  DATA: BEGIN OF qname,
          name      TYPE string,
          namespace TYPE string,
        END OF qname.
  DATA prefix TYPE string READ-ONLY.
  DATA value_type TYPE if_sxml_value=>value_type.
  METHODS get_value RETURNING VALUE(value) TYPE string.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXML_CLOSE_ELEMENT                   ', 'INTERFACE if_sxml_close_element PUBLIC.
  INTERFACES if_sxml_node.

  DATA: BEGIN OF qname,
          name      TYPE string,
          namespace TYPE string,
        END OF qname.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXML_NAMED                           ', 'INTERFACE if_sxml_named PUBLIC.

  TYPES: BEGIN OF pathnode,
           BEGIN OF qname,
             name      TYPE string,
             namespace TYPE string,
           END OF qname,
           prefix         TYPE string,
           child_position TYPE i,
         END OF pathnode.
  TYPES path TYPE STANDARD TABLE OF pathnode WITH DEFAULT KEY.

  TYPES: BEGIN OF nsbinding,
           prefix TYPE string,
           nsuri  TYPE string,
         END OF nsbinding.
  TYPES nsbindings TYPE HASHED TABLE OF nsbinding WITH UNIQUE KEY prefix.

  CONSTANTS co_use_default_xmlns TYPE string VALUE '':''.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXML_NODE                            ', 'INTERFACE if_sxml_node PUBLIC.
  TYPES node_type TYPE i.
  DATA type TYPE node_type READ-ONLY.

  CONSTANTS co_nt_initial TYPE node_type VALUE 0.
  CONSTANTS co_nt_element_open TYPE node_type VALUE 1.
  CONSTANTS co_nt_element_close TYPE node_type VALUE 2.
  CONSTANTS co_nt_value TYPE node_type VALUE 4.
  CONSTANTS co_nt_attribute TYPE node_type VALUE 32.
  CONSTANTS co_nt_final TYPE node_type VALUE 128.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXML_OPEN_ELEMENT                    ', 'INTERFACE if_sxml_open_element PUBLIC.
  INTERFACES if_sxml_node.

  DATA: BEGIN OF qname,
          name      TYPE string,
          namespace TYPE string,
        END OF qname.

  DATA prefix TYPE string READ-ONLY.

  METHODS get_attributes
    RETURNING
      VALUE(attr) TYPE if_sxml_attribute=>attributes.

  METHODS set_attribute
    IMPORTING
      name   TYPE string
      nsuri  TYPE string OPTIONAL
      prefix TYPE string OPTIONAL
      value  TYPE string OPTIONAL
    RETURNING
      VALUE(attribute) TYPE REF TO if_sxml_attribute
    RAISING
      cx_sxml_name_error.

  METHODS set_attributes
    IMPORTING
      attributes TYPE if_sxml_attribute=>attributes
    RAISING
      cx_sxml_name_error.

  METHODS set_prefix
    IMPORTING
      prefix TYPE string OPTIONAL.

  METHODS get_attribute_value
    IMPORTING
      !name TYPE string
      !nsuri TYPE string OPTIONAL
    RETURNING
      VALUE(value) TYPE REF TO if_sxml_value.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXML_READER                          ', 'INTERFACE if_sxml_reader PUBLIC.

  DATA node_type  TYPE if_sxml_node=>node_type READ-ONLY.
  DATA name       TYPE string READ-ONLY.
  DATA value_type TYPE if_sxml_value=>value_type READ-ONLY.
  DATA value      TYPE string READ-ONLY.
  DATA value_raw  TYPE xstring READ-ONLY.

  CONSTANTS co_opt_normalizing TYPE i VALUE 1.
  CONSTANTS co_opt_keep_whitespace TYPE i VALUE 2.
  CONSTANTS co_opt_asxml TYPE i VALUE 3.
  CONSTANTS co_opt_sep_member TYPE i VALUE 4.

  METHODS
    read_next_node
      RETURNING VALUE(node) TYPE REF TO if_sxml_node.

  METHODS next_node
    IMPORTING
      value_type TYPE if_sxml_value=>value_type DEFAULT if_sxml_value=>co_vt_text
    RAISING
      cx_sxml_parse_error.

  METHODS next_attribute
    IMPORTING
      value_type TYPE if_sxml_value=>value_type OPTIONAL.

  METHODS skip_node
    IMPORTING
      writer TYPE REF TO if_sxml_writer OPTIONAL
    RAISING
      cx_sxml_parse_error.

  METHODS set_option
    IMPORTING
      option TYPE i
      value  TYPE abap_bool DEFAULT abap_true.

  METHODS get_nsuri_by_prefix
    IMPORTING
      !prefix TYPE string
    RETURNING
      VALUE(nsuri) TYPE string.

  METHODS get_prefix_by_nsuri
    IMPORTING
      !nsuri TYPE string
    RETURNING
      VALUE(prefix) TYPE string.

  METHODS get_nsbindings
    RETURNING
      VALUE(nsbindings) TYPE if_sxml_named=>nsbindings.

  METHODS get_path
    RETURNING
      VALUE(path) TYPE if_sxml_named=>path.

  METHODS current_node.

  METHODS read_current_node
    RETURNING
      VALUE(node) TYPE REF TO if_sxml_node.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXML_VALUE                           ', 'INTERFACE if_sxml_value PUBLIC.

  TYPES value_type TYPE i.
  DATA type TYPE value_type.
  CONSTANTS co_vt_text TYPE value_type VALUE 2.

  METHODS get_value
    RETURNING
      VALUE(value) TYPE string.
  METHODS get_value_raw
    RETURNING
      VALUE(value) TYPE xstring.
  METHODS set_value
    IMPORTING
      value TYPE string.
  METHODS set_value_raw
    IMPORTING
      value TYPE xstring.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXML_VALUE_NODE                      ', 'INTERFACE if_sxml_value_node PUBLIC.
  INTERFACES if_sxml_node.

  METHODS get_value
    RETURNING
      VALUE(value) TYPE string.

  METHODS get_value_raw
    RETURNING
      VALUE(value) TYPE xstring.

  METHODS set_value
    IMPORTING
      value TYPE string.

  METHODS set_value_raw
    IMPORTING
      value TYPE xstring.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXML_WRITER                          ', 'INTERFACE if_sxml_writer PUBLIC.

  CONSTANTS co_opt_normalizing TYPE i VALUE 1.
  CONSTANTS co_opt_no_empty TYPE i VALUE 2.
  CONSTANTS co_opt_ignore_conv_errros TYPE i VALUE 3.
  CONSTANTS co_opt_linebreaks TYPE i VALUE 4.
  CONSTANTS co_opt_indent TYPE i VALUE 5.
  CONSTANTS co_opt_illegal_char_reject TYPE i VALUE 6.
  CONSTANTS co_opt_illegal_char_replace TYPE i VALUE 7.
  CONSTANTS co_opt_illegal_char_replace_by TYPE i VALUE 8.
  CONSTANTS co_opt_base64_no_lf TYPE i VALUE 9.

  METHODS open_element
    IMPORTING
      name   TYPE string
      nsuri  TYPE string OPTIONAL
      prefix TYPE string OPTIONAL
    RAISING
      cx_sxml_state_error
      cx_sxml_name_error.

  METHODS close_element
    RAISING
      cx_sxml_state_error.

  CLASS-METHODS new_close_element
    RETURNING
      VALUE(element) TYPE REF TO if_sxml_close_element.

  METHODS write_attribute
    IMPORTING
      name   TYPE string
      nsuri  TYPE string OPTIONAL
      prefix TYPE string OPTIONAL
      value  TYPE string OPTIONAL
    RAISING
      cx_sxml_state_error
      cx_sxml_name_error.

  METHODS write_attribute_raw
    IMPORTING
      name   TYPE string
      nsuri  TYPE string OPTIONAL
      prefix TYPE string OPTIONAL
      value  TYPE xstring OPTIONAL
    RAISING
      cx_sxml_state_error
      cx_sxml_name_error.

  METHODS write_value
    IMPORTING
      value TYPE string
    RAISING
      cx_sxml_state_error.

  METHODS set_option
    IMPORTING
      option TYPE i
      value  TYPE abap_bool DEFAULT abap_true.

  CLASS-METHODS new_open_element
    IMPORTING
      name   TYPE string
      nsuri  TYPE string OPTIONAL
      prefix TYPE string OPTIONAL
    RETURNING
      VALUE(element) TYPE REF TO if_sxml_open_element
    RAISING
      cx_sxml_name_error.

  CLASS-METHODS new_value
    RETURNING
      VALUE(value) TYPE REF TO if_sxml_value_node.

  METHODS write_namespace_declaration
    IMPORTING
      nsuri  TYPE string
      prefix TYPE string OPTIONAL
    RAISING
      cx_sxml_name_error.

  METHODS write_node
    IMPORTING
      node TYPE REF TO if_sxml_node
    RAISING
      cx_sxml_state_error.

  METHODS write_value_raw
    IMPORTING
      value TYPE xstring
    RAISING
      cx_sxml_state_error.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXMLP_FACTORY                        ', 'INTERFACE if_sxmlp_factory PUBLIC.
  CLASS-METHODS create_list
    IMPORTING
      name        TYPE string
      nsuri       TYPE string OPTIONAL
      prefix      TYPE string OPTIONAL
    RETURNING
      VALUE(rval) TYPE REF TO if_sxmlp_list.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXMLP_LIST                           ', 'INTERFACE if_sxmlp_list PUBLIC.
  INTERFACES if_sxmlp_part.

  METHODS add_part
    IMPORTING
      part TYPE REF TO if_sxmlp_part.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXMLP_PART                           ', 'INTERFACE if_sxmlp_part PUBLIC.
  METHODS serialize IMPORTING writer TYPE REF TO if_sxml_writer.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXMLP_SIMPLE                         ', 'INTERFACE if_sxmlp_simple PUBLIC.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_APC_TCP_CLIENT_MANAGER               ', 'CLASS cl_apc_tcp_client_manager DEFINITION PUBLIC.
  PUBLIC SECTION.
    CONSTANTS co_protocol_type_tcp  TYPE i VALUE 1.
    CONSTANTS co_protocol_type_tcps TYPE i VALUE 2.

    CLASS-METHODS create
      IMPORTING
        i_host          TYPE string
        i_port          TYPE string
        i_frame         TYPE if_abap_channel_types=>ty_apc_tcp_frame
        i_event_handler TYPE REF TO if_apc_wsp_event_handler
        i_protocol      TYPE i DEFAULT co_protocol_type_tcp
        i_ssl_id        TYPE ssfapplssl OPTIONAL
      RETURNING
        VALUE(ri_client) TYPE REF TO if_apc_wsp_client
      RAISING
        cx_apc_error.
ENDCLASS.

CLASS cl_apc_tcp_client_manager IMPLEMENTATION.
  METHOD create.
    DATA lv_port TYPE i.
    lv_port = i_port.
    CREATE OBJECT ri_client TYPE lcl_client
      EXPORTING
        iv_host     = i_host
        iv_port     = lv_port
        io_handler  = i_event_handler
        iv_protocol = i_protocol.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_APC_WSP_EXT_STATELESS_BASE           ', 'CLASS cl_apc_wsp_ext_stateless_base DEFINITION PUBLIC ABSTRACT.
  PUBLIC SECTION.
    INTERFACES if_apc_wsp_extension.
ENDCLASS.

CLASS cl_apc_wsp_ext_stateless_base IMPLEMENTATION.
  METHOD if_apc_wsp_extension~on_start.
    RETURN.
  ENDMETHOD.

  METHOD if_apc_wsp_extension~on_message.
    RETURN.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_APC_ERROR                            ', 'CLASS cx_apc_error DEFINITION PUBLIC INHERITING FROM cx_static_check.

ENDCLASS.

CLASS cx_apc_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_ABAP_CHANNEL_TYPES                   ', 'INTERFACE if_abap_channel_types PUBLIC.
  TYPES: BEGIN OF ty_apc_tcp_frame,
           frame_type          TYPE i,
           fixed_length        TYPE i,
           terminator          TYPE string,
           length_field_length TYPE i,
           length_field_offset TYPE i,
           length_field_header TYPE i,
         END OF ty_apc_tcp_frame.

  TYPES ty_tihttpnvp TYPE tihttpnvp.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_APC_TCP_FRAME_TYPES                  ', 'INTERFACE if_apc_tcp_frame_types PUBLIC.
  CONSTANTS co_frame_type_fixed_length TYPE i VALUE 1.
  CONSTANTS co_frame_type_terminator   TYPE i VALUE 2.
  CONSTANTS co_frame_type_length_field TYPE i VALUE 3.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_APC_WSP_BINDING_MANAGER              ', 'INTERFACE if_apc_wsp_binding_manager PUBLIC.
  METHODS bind_amc_message_consumer
    IMPORTING
      i_application_id TYPE clike
      i_channel_id     TYPE clike
    RAISING
      cx_apc_error.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_APC_WSP_CLIENT                       ', 'INTERFACE if_apc_wsp_client PUBLIC.
  METHODS connect
    RAISING
      cx_apc_error.

  METHODS close
    RAISING
      cx_apc_error.

  METHODS get_message_manager
    RETURNING
      VALUE(ri_manager) TYPE REF TO if_apc_wsp_message_manager
    RAISING
      cx_apc_error.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_APC_WSP_EVENT_HANDLER                ', 'INTERFACE if_apc_wsp_event_handler PUBLIC.
  METHODS on_open.

  METHODS on_message
    IMPORTING i_message TYPE REF TO if_apc_wsp_message.

  METHODS on_close.

  METHODS on_error
    IMPORTING
      i_reason TYPE string.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_APC_WSP_EXTENSION                    ', 'INTERFACE if_apc_wsp_extension PUBLIC.
  METHODS on_start
    IMPORTING
      i_context         TYPE REF TO if_apc_wsp_server_context
      i_message_manager TYPE REF TO if_apc_wsp_message_manager.

  METHODS on_message
    IMPORTING
      i_message         TYPE REF TO if_apc_wsp_message
      i_message_manager TYPE REF TO if_apc_wsp_message_manager
      i_context         TYPE REF TO if_apc_wsp_server_context.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_APC_WSP_INITIAL_REQUEST              ', 'INTERFACE if_apc_wsp_initial_request PUBLIC.
  METHODS get_form_fields
    IMPORTING
      i_formfield_encoding TYPE i DEFAULT 0
    CHANGING
      c_fields             TYPE if_abap_channel_types=>ty_tihttpnvp
    RAISING
      cx_apc_error.

  METHODS get_header_fields
    CHANGING
      c_fields TYPE if_abap_channel_types=>ty_tihttpnvp
    RAISING
      cx_apc_error.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_APC_WSP_MESSAGE                      ', 'INTERFACE if_apc_wsp_message PUBLIC.
  METHODS get_binary
    RETURNING VALUE(rv_binary) TYPE xstring
    RAISING cx_apc_error.

  METHODS set_binary
    IMPORTING iv_binary TYPE xsequence
    RAISING cx_apc_error.

  METHODS get_text
    RETURNING VALUE(r_message) TYPE string
    RAISING cx_apc_error.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_APC_WSP_MESSAGE_MANAGER              ', 'INTERFACE if_apc_wsp_message_manager PUBLIC.
  METHODS create_message
    RETURNING
      VALUE(ri_message) TYPE REF TO if_apc_wsp_message
    RAISING
      cx_apc_error.

  METHODS send
    IMPORTING
      ii_message TYPE REF TO if_apc_wsp_message
    RAISING
      cx_apc_error.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_APC_WSP_SERVER_CONTEXT               ', 'INTERFACE if_apc_wsp_server_context PUBLIC.
  METHODS get_initial_request
    RETURNING VALUE(r_initial_request) TYPE REF TO if_apc_wsp_initial_request
    RAISING cx_apc_error.
  METHODS get_binding_manager
    RETURNING VALUE(r_binding_manager) TYPE REF TO if_apc_wsp_binding_manager
    RAISING cx_apc_error.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_UNIT_ASSERT                     ', 'CLASS cl_abap_unit_assert DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS
      assert_equals
        IMPORTING
          act   TYPE any
          exp   TYPE any
          msg   TYPE csequence OPTIONAL
          tol   TYPE f OPTIONAL
          quit  TYPE i OPTIONAL
          level TYPE i OPTIONAL.

    CLASS-METHODS abort
      IMPORTING
        msg    TYPE csequence OPTIONAL
        detail TYPE csequence OPTIONAL
        quit   TYPE int1 DEFAULT 2 PREFERRED PARAMETER msg.

    CLASS-METHODS
      assert_differs
        IMPORTING
          act   TYPE simple
          exp   TYPE simple
          msg   TYPE csequence OPTIONAL
          quit  TYPE i OPTIONAL
          level TYPE i OPTIONAL.

    CLASS-METHODS
      assert_number_between
        IMPORTING
          lower  TYPE i
          upper  TYPE i
          number TYPE i
          msg    TYPE csequence OPTIONAL
          quit   TYPE i OPTIONAL
          level  TYPE i OPTIONAL.

    CLASS-METHODS
      assert_not_initial
        IMPORTING
          act   TYPE any
          msg   TYPE csequence OPTIONAL
          quit  TYPE i OPTIONAL
          level TYPE i OPTIONAL.

    CLASS-METHODS
      assert_initial
        IMPORTING
          act   TYPE any
          msg   TYPE csequence OPTIONAL
          quit  TYPE i OPTIONAL
          level TYPE i OPTIONAL.

    CLASS-METHODS
      skip
        IMPORTING
          msg    TYPE csequence
          detail TYPE csequence OPTIONAL.

    CLASS-METHODS
      fail
        IMPORTING
          msg    TYPE csequence OPTIONAL
          quit   TYPE i OPTIONAL
          level  TYPE i OPTIONAL
          detail TYPE csequence OPTIONAL
        PREFERRED PARAMETER msg.

    CLASS-METHODS
      assert_subrc
        IMPORTING
          exp   TYPE i DEFAULT 0
          act   TYPE i DEFAULT sy-subrc
          msg   TYPE csequence OPTIONAL
          quit  TYPE i OPTIONAL
          level TYPE i OPTIONAL
        PREFERRED PARAMETER act.

    CLASS-METHODS
      assert_true
        IMPORTING
          act   TYPE abap_bool
          msg   TYPE csequence OPTIONAL
          quit  TYPE i OPTIONAL
          level TYPE i OPTIONAL.

    CLASS-METHODS
      assert_false
        IMPORTING
          act TYPE abap_bool
          msg TYPE csequence OPTIONAL
          quit TYPE i OPTIONAL
          level TYPE i OPTIONAL.

    CLASS-METHODS
      assert_char_cp
        IMPORTING
          act   TYPE clike
          exp   TYPE clike
          msg   TYPE string OPTIONAL
          quit  TYPE i OPTIONAL
          level TYPE i OPTIONAL.

    CLASS-METHODS
      assert_char_np
        IMPORTING
          act   TYPE clike
          exp   TYPE clike
          msg   TYPE csequence OPTIONAL
          quit  TYPE i OPTIONAL
          level TYPE i OPTIONAL.

    CLASS-METHODS
      assert_bound
        IMPORTING
          act   TYPE any
          msg   TYPE csequence OPTIONAL
          quit  TYPE i OPTIONAL
          level TYPE i OPTIONAL.

    CLASS-METHODS
      assert_not_bound
        IMPORTING
          act   TYPE any
          msg   TYPE csequence OPTIONAL
          quit  TYPE i OPTIONAL
          level TYPE i OPTIONAL.

    CLASS-METHODS
      assert_text_matches
        IMPORTING
          pattern TYPE csequence
          text    TYPE csequence
          msg     TYPE csequence OPTIONAL
          quit    TYPE i OPTIONAL
          level   TYPE i OPTIONAL.

  PRIVATE SECTION.
    CLASS-METHODS
      compare_tables
        IMPORTING
          act TYPE any
          exp TYPE any.

ENDCLASS.

CLASS cl_abap_unit_assert IMPLEMENTATION.

  METHOD compare_tables.

    DATA index    TYPE i.
    DATA type1    TYPE REF TO cl_abap_tabledescr.
    DATA type2    TYPE REF TO cl_abap_tabledescr.
    DATA lv_match TYPE abap_bool.

    FIELD-SYMBOLS <tab1> TYPE INDEX TABLE.
    FIELD-SYMBOLS <row1> TYPE any.
    FIELD-SYMBOLS <tab2> TYPE INDEX TABLE.
    FIELD-SYMBOLS <row2> TYPE any.

    IF lines( act ) <> lines( exp ).
      RAISE EXCEPTION TYPE kernel_cx_assert
        EXPORTING
          msg = |Expected table to contain { lines( exp ) } rows, got { lines( act ) }|.
    ENDIF.

    ASSIGN act TO <tab1>.
    ASSIGN exp TO <tab2>.

    type1 ?= cl_abap_typedescr=>describe_by_data( act ).
    type2 ?= cl_abap_typedescr=>describe_by_data( exp ).
*    WRITE ''@KERNEL console.dir(type1);''.
    IF type1->table_kind = cl_abap_tabledescr=>tablekind_hashed
        OR type2->table_kind = cl_abap_tabledescr=>tablekind_hashed.
      LOOP AT <tab1> ASSIGNING <row1>.
        lv_match = abap_false.
        LOOP AT <tab2> ASSIGNING <row2>.
          TRY.
              assert_equals(
                act = <row1>
                exp = <row2> ).
              lv_match = abap_true.
              EXIT. " current loop
            CATCH kernel_cx_assert.
          ENDTRY.
        ENDLOOP.
        IF lv_match = abap_false.
          RAISE EXCEPTION TYPE kernel_cx_assert
            EXPORTING
              msg = |Hashed table contents differs|.
        ENDIF.
      ENDLOOP.
    ELSE.
      DO lines( act ) TIMES.
        index = sy-index.
        READ TABLE <tab1> INDEX index ASSIGNING <row1>.
        assert_subrc( ).
        READ TABLE <tab2> INDEX index ASSIGNING <row2>.
        assert_subrc( ).
        assert_equals(
          act = <row1>
          exp = <row2> ).
      ENDDO.
    ENDIF.

  ENDMETHOD.

  METHOD assert_text_matches.
    DATA lv_match TYPE abap_bool.
    lv_match = boolc( contains(
      val   = text
      regex = pattern ) ).
    IF lv_match = abap_false.
      RAISE EXCEPTION TYPE kernel_cx_assert
        EXPORTING
          expected = pattern
          actual   = text
          msg      = msg.
    ENDIF.
  ENDMETHOD.

  METHOD abort.
    ASSERT 1 = ''todo''.
  ENDMETHOD.

  METHOD assert_bound.
    IF act IS NOT BOUND.
      RAISE EXCEPTION TYPE kernel_cx_assert
        EXPORTING
          msg = |Expected value to be bound|.
    ENDIF.
  ENDMETHOD.

  METHOD assert_not_bound.
    IF act IS BOUND.
      RAISE EXCEPTION TYPE kernel_cx_assert
        EXPORTING
          msg = |Expected value to not be bound|.
    ENDIF.
  ENDMETHOD.

  METHOD assert_char_cp.
    IF act NP exp.
      RAISE EXCEPTION TYPE kernel_cx_assert
        EXPORTING
          expected = exp
          actual   = act
          msg      = msg.
    ENDIF.
  ENDMETHOD.

  METHOD assert_char_np.
    IF act CP exp.
      RAISE EXCEPTION TYPE kernel_cx_assert
        EXPORTING
          msg = |Actual: { act }|.
    ENDIF.
  ENDMETHOD.

  METHOD fail.
    RAISE EXCEPTION TYPE kernel_cx_assert
      EXPORTING
        msg = msg.
  ENDMETHOD.

  METHOD skip.
    RETURN.
  ENDMETHOD.

  METHOD assert_differs.
    TRY.
        assert_equals(
          act = act
          exp = exp ).
        RAISE EXCEPTION TYPE kernel_cx_assert
          EXPORTING
            msg      = |Expected different values|
            actual   = act
            expected = exp.
      CATCH kernel_cx_assert.
        RETURN.
    ENDTRY.
  ENDMETHOD.

  METHOD assert_true.
    IF act <> abap_true.
      RAISE EXCEPTION TYPE kernel_cx_assert
        EXPORTING
          msg = |Expected abap_true|.
    ENDIF.
  ENDMETHOD.

  METHOD assert_false.
    IF act <> abap_false.
      RAISE EXCEPTION TYPE kernel_cx_assert
        EXPORTING
          msg = |Expected abap_false|.
    ENDIF.
  ENDMETHOD.

  METHOD assert_equals.
    DATA type1  TYPE c LENGTH 1.
    DATA type2  TYPE c LENGTH 1.
    DATA diff   TYPE f.
    DATA lv_exp TYPE string.
    DATA lv_act TYPE string.
    DATA lv_msg TYPE string.

    DESCRIBE FIELD act TYPE type1.
    DESCRIBE FIELD exp TYPE type2.
    " WRITE ''@KERNEL console.dir(type1.get());''.
    " WRITE ''@KERNEL console.dir(type2.get());''.
    IF type1 CA ''CgyIFPDTXN8''. " basic types
      IF type2 IS NOT INITIAL.
        IF type2 NA ''CgyIFPDTXN8''.
          RAISE EXCEPTION TYPE kernel_cx_assert
            EXPORTING
              msg = |Unexpected types|.
        ENDIF.
      ENDIF.
    ELSEIF type1 IS NOT INITIAL AND type2 IS NOT INITIAL.
* else check the types are identical
      IF type1 <> type2.
        RAISE EXCEPTION TYPE kernel_cx_assert
          EXPORTING
            msg = |Unexpected types|.
      ENDIF.
    ENDIF.

    IF type1 = ''h''.
      compare_tables(
        act = act
        exp = exp ).
    ELSEIF tol IS SUPPLIED.
      diff = exp - act.
*      WRITE ''@KERNEL console.dir(tol);''.
*      WRITE ''@KERNEL console.dir(diff);''.
      IF diff >= tol.
        RAISE EXCEPTION TYPE kernel_cx_assert.
      ENDIF.
    ELSEIF type1 = ''l''.
      assert_equals(
        act = act->*
        exp = exp->* ).
    ELSEIF act <> exp.
      lv_act = lcl_dump=>to_string( act ).
      lv_exp = lcl_dump=>to_string( exp ).
      IF msg <> ''''.
        lv_msg = msg.
      ELSE.
        lv_msg = |Expected ''{ lv_exp }'', got ''{ lv_act }''|.
      ENDIF.
      RAISE EXCEPTION TYPE kernel_cx_assert
        EXPORTING
          msg      = lv_msg
          actual   = lv_act
          expected = lv_exp.
    ENDIF.
  ENDMETHOD.

  METHOD assert_not_initial.
    DATA lv_msg TYPE string.
    IF act IS INITIAL.
      lv_msg = msg.
      IF lv_msg IS INITIAL.
        lv_msg = |Expected non initial value|.
      ENDIF.
      RAISE EXCEPTION TYPE kernel_cx_assert
        EXPORTING
          msg = lv_msg.
    ENDIF.
  ENDMETHOD.

  METHOD assert_initial.
    DATA lv_msg TYPE string.
    IF act IS NOT INITIAL.
      lv_msg = msg.
      IF lv_msg IS INITIAL.
        lv_msg = |Expected initial value|.
      ENDIF.
      RAISE EXCEPTION TYPE kernel_cx_assert
        EXPORTING
          msg = lv_msg.
    ENDIF.
  ENDMETHOD.

  METHOD assert_subrc.
    DATA lv_msg TYPE string.
    IF act <> exp.
      lv_msg = msg.
      IF lv_msg IS INITIAL.
        lv_msg = |Expected sy-subrc to equal { exp }, got { act }|.
      ENDIF.
      RAISE EXCEPTION TYPE kernel_cx_assert
        EXPORTING
          msg = lv_msg.
    ENDIF.
  ENDMETHOD.

  METHOD assert_number_between.
    IF number < lower OR number > upper.
      RAISE EXCEPTION TYPE kernel_cx_assert.
    ENDIF.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_FUNCTION_TEST_ENVIRONMENT            ', 'CLASS cl_function_test_environment DEFINITION PUBLIC.
  PUBLIC SECTION.
    INTERFACES if_function_test_environment.

    "! Note: open-abap function module test doubles allows creating doubles for non-existing
    "! function modules
    CLASS-METHODS create
      IMPORTING
        function_modules                 TYPE if_function_test_environment=>tt_function_dependencies
      RETURNING
        VALUE(function_test_environment) TYPE REF TO if_function_test_environment.
  PRIVATE SECTION.
    TYPES: BEGIN OF ty_backup,
             name   TYPE sxco_fm_name,
             backup TYPE i,
             double_ TYPE REF TO if_function_testdouble,
           END OF ty_backup.
    CLASS-DATA gt_backup TYPE SORTED TABLE OF ty_backup WITH UNIQUE KEY name.
ENDCLASS.

CLASS cl_function_test_environment IMPLEMENTATION.

  METHOD create.
    DATA lv_module LIKE LINE OF function_modules.
    DATA ls_row    LIKE LINE OF gt_backup.

    ASSERT lines( function_modules ) > 0.

    LOOP AT function_modules INTO lv_module.
      ls_row-name = lv_module.
      CREATE OBJECT ls_row-double_ TYPE lcl_double
        EXPORTING
          iv_name = lv_module.
      WRITE ''@KERNEL ls_row.get().backup = abap.FunctionModules[lv_module.get().trimEnd()];''.
      INSERT ls_row INTO gt_backup.
    ENDLOOP.

    CREATE OBJECT function_test_environment TYPE cl_function_test_environment.
  ENDMETHOD.

  METHOD if_function_test_environment~get_double.
    FIELD-SYMBOLS <ls_row> LIKE LINE OF gt_backup.

    READ TABLE gt_backup ASSIGNING <ls_row> WITH KEY name = function_name.
    ASSERT sy-subrc = 0.

    result = <ls_row>-double_.
  ENDMETHOD.

  METHOD if_function_test_environment~clear_doubles.
    FIELD-SYMBOLS <ls_row> LIKE LINE OF gt_backup.

    LOOP AT gt_backup ASSIGNING <ls_row>.
      WRITE ''@KERNEL abap.FunctionModules[fs_ls_row_.get().name.get().trimEnd()] = fs_ls_row_.get().backup;''.
    ENDLOOP.
    CLEAR gt_backup.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_FTD_PARAMETER_NOT_FOUND              ', 'CLASS cx_ftd_parameter_not_found DEFINITION PUBLIC FINAL CREATE PUBLIC INHERITING FROM cx_no_check.

ENDCLASS.

CLASS cx_ftd_parameter_not_found IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_FTD_INPUT_ARGUMENTS                  ', 'INTERFACE if_ftd_input_arguments PUBLIC.

  METHODS get_importing_parameter
    IMPORTING
      name          TYPE abap_parmname
    RETURNING
      VALUE(result) TYPE REF TO data
    RAISING
      cx_ftd_parameter_not_found.

  METHODS get_table_parameter
    IMPORTING
      name          TYPE abap_parmname
    RETURNING
      VALUE(result) TYPE REF TO data
    RAISING
      cx_ftd_parameter_not_found.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_FTD_INPUT_CONFIG_SETTER              ', 'INTERFACE if_ftd_input_config_setter PUBLIC.

  METHODS ignore_all_parameters
    RETURNING
      VALUE(output_configuration_setter) TYPE REF TO if_ftd_output_config_setter.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_FTD_INVOCATION_ANSWER                ', 'INTERFACE if_ftd_invocation_answer PUBLIC.

  METHODS answer
    IMPORTING
      arguments_ TYPE REF TO if_ftd_input_arguments
    CHANGING
      result    TYPE REF TO if_ftd_invocation_result.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_FTD_INVOCATION_RESULT                ', 'INTERFACE if_ftd_invocation_result PUBLIC.

  METHODS get_output_configuration
    RETURNING
      VALUE(result) TYPE REF TO if_ftd_output_configuration.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_FTD_OUTPUT_CONFIG_SETTER             ', 'INTERFACE if_ftd_output_config_setter PUBLIC.

  METHODS then_answer
    IMPORTING
      answer      TYPE REF TO if_ftd_invocation_answer
    RETURNING
      VALUE(self) TYPE REF TO if_ftd_output_config_setter.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_FTD_OUTPUT_CONFIGURATION             ', 'INTERFACE if_ftd_output_configuration PUBLIC.

  METHODS set_exporting_parameter
    IMPORTING
      name        TYPE abap_parmname
      value       TYPE any
    RETURNING
      VALUE(self) TYPE REF TO if_ftd_output_configuration
    RAISING
      cx_ftd_parameter_not_found.

  METHODS set_table_parameter
    IMPORTING
      name  TYPE abap_parmname
      value TYPE any
    RETURNING
      VALUE(self) TYPE REF TO if_ftd_output_configuration
    RAISING
      cx_ftd_parameter_not_found.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_FUNCTION_TEST_ENVIRONMENT            ', 'INTERFACE if_function_test_environment PUBLIC.

  TYPES tt_function_dependencies TYPE STANDARD TABLE OF sxco_fm_name WITH KEY table_line.

  METHODS get_double
    IMPORTING
      function_name TYPE sxco_fm_name
    RETURNING
      VALUE(result) TYPE REF TO if_function_testdouble.

  METHODS clear_doubles.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_FUNCTION_TESTDOUBLE                  ', 'INTERFACE if_function_testdouble PUBLIC.

  METHODS configure_call
    RETURNING
      VALUE(input_configuration_setter) TYPE REF TO if_ftd_input_config_setter.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_ABAP_UNIT_CONSTANT                   ', 'INTERFACE if_abap_unit_constant PUBLIC.
  CONSTANTS:
    BEGIN OF severity,
      low               TYPE int1 VALUE 0,
      medium            TYPE int1 VALUE 1,
      high              TYPE int1 VALUE 2,
    END OF severity.
  CONSTANTS:
    BEGIN OF quit,
      test   TYPE int1 VALUE 1,
      no     TYPE int1 VALUE 5,
    END OF quit.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_AUNIT_CONSTANTS                      ', 'INTERFACE if_aunit_constants PUBLIC.
  CONSTANTS no        TYPE int1 VALUE 0.
  CONSTANTS critical  TYPE int1 VALUE 1.
  CONSTANTS fatal     TYPE int1 VALUE 1.
  CONSTANTS tolerable TYPE int1 VALUE 1.
  CONSTANTS method    TYPE int1 VALUE 1.
  CONSTANTS class_     TYPE int1 VALUE 2.

  CONSTANTS: BEGIN OF severity,
               low    TYPE int1 VALUE 0,
               medium TYPE int1 VALUE 1,
               high   TYPE int1 VALUE 2,
             END OF severity.

  CONSTANTS: BEGIN OF quit,
               no   TYPE int1 VALUE 0,
               test TYPE int1 VALUE 1,
             END OF quit.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_CX_ASSERT                        ', 'CLASS kernel_cx_assert DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.
  PUBLIC SECTION.
    DATA actual TYPE string.
    DATA expected TYPE string.
    DATA msg TYPE string.

    METHODS constructor
      IMPORTING
        msg      TYPE string
        previous LIKE previous OPTIONAL
        expected LIKE expected OPTIONAL
        actual   LIKE actual OPTIONAL.
ENDCLASS.

CLASS kernel_cx_assert IMPLEMENTATION.

  METHOD constructor.
    super->constructor( previous = previous ).
    me->expected = expected.
    me->actual = actual.
    me->msg = msg.
    IF me->msg IS INITIAL.
      me->msg = |Unit test assertion failed|.
    ENDIF.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_UNIT_RUNNER                      ', 'CLASS kernel_unit_runner DEFINITION PUBLIC.
  PUBLIC SECTION.
* as of now, only global classes with local testclasses are supported
    TYPES: BEGIN OF ty_input_item,
             class_name     TYPE c LENGTH 30,
             testclass_name TYPE c LENGTH 30,
             method_name    TYPE c LENGTH 30,
           END OF ty_input_item.
    TYPES ty_input TYPE STANDARD TABLE OF ty_input_item WITH DEFAULT KEY.

    TYPES ty_status TYPE string.
    CONSTANTS: BEGIN OF gc_status,
                success TYPE ty_status VALUE ''SUCCESS'',
                failed  TYPE ty_status VALUE ''FAILED'',
                skipped TYPE ty_status VALUE ''SKIPPED'',
               END OF gc_status.

    TYPES BEGIN OF ty_result_item.
    INCLUDE TYPE ty_input_item.
    TYPES: expected    TYPE string,
             actual      TYPE string,
             status      TYPE ty_status,
             runtime     TYPE i,
             message     TYPE string,
             js_location TYPE string,
             console     TYPE string,
           END OF ty_result_item.
    TYPES: BEGIN OF ty_result,
             list TYPE STANDARD TABLE OF ty_result_item WITH DEFAULT KEY,
             json TYPE string,
           END OF ty_result.

    CLASS-DATA mv_console TYPE string.

    CLASS-METHODS run
      IMPORTING
        it_input TYPE ty_input
      RETURNING
        VALUE(rs_result) TYPE ty_result.
  PRIVATE SECTION.
    TYPES: BEGIN OF ty_class_item,
             class_name     TYPE c LENGTH 30,
             testclass_name TYPE c LENGTH 30,
           END OF ty_class_item.
    TYPES ty_classes TYPE STANDARD TABLE OF ty_class_item WITH DEFAULT KEY.

    CLASS-METHODS unique_classes
      IMPORTING
       it_input TYPE ty_input
      RETURNING
        VALUE(rt_classes) TYPE ty_classes.

    CLASS-METHODS to_json
      IMPORTING it_list TYPE ty_result-list
      RETURNING VALUE(rv_json) TYPE string.

    CLASS-METHODS get_location
      IMPORTING ix_error TYPE REF TO cx_root
      RETURNING VALUE(rv_location) TYPE string.
ENDCLASS.

CLASS kernel_unit_runner IMPLEMENTATION.

  METHOD get_location.
    DATA lv_stack TYPE string.
    DATA lt_lines TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
    DATA lv_found TYPE abap_bool.
    WRITE ''@KERNEL lv_stack.set(INPUT.ix_error.get().stack);''.
    SPLIT lv_stack AT |\\n| INTO TABLE lt_lines.
* find whatever comes after "cl_abap_unit_assert"
    LOOP AT lt_lines INTO lv_stack.
      IF lv_stack CP ''*cl_abap_unit_assert*''.
        lv_found = abap_true.
        CONTINUE.
      ELSEIF lv_found = abap_true.
        REPLACE FIRST OCCURRENCE OF |at | IN lv_stack WITH ''''.
        rv_location = condense( lv_stack ).
        EXIT.
      ENDIF.
    ENDLOOP.
  ENDMETHOD.

  METHOD to_json.
* would like to keep the dependencies of this class minimal,
* so not using CALL TRANSFORMATION or any other ABAP classes

    DATA ls_list    LIKE LINE OF it_list.
    DATA lt_strings TYPE STANDARD TABLE OF string WITH DEFAULT KEY.
    DATA lv_string  LIKE LINE OF lt_strings.
    DATA lv_message TYPE string.


    LOOP AT it_list INTO ls_list.
      lv_message = ls_list-message.
      REPLACE ALL OCCURRENCES OF |"| IN lv_message WITH |\\"|.
      REPLACE ALL OCCURRENCES OF |\\n| IN lv_message WITH |\\\\n|.

      REPLACE ALL OCCURRENCES OF |"| IN ls_list-expected WITH |\\"|.
      REPLACE ALL OCCURRENCES OF |\\n| IN ls_list-expected WITH |\\\\n|.

      REPLACE ALL OCCURRENCES OF |"| IN ls_list-actual WITH |\\"|.
      REPLACE ALL OCCURRENCES OF |\\n| IN ls_list-actual WITH |\\\\n|.

      REPLACE ALL OCCURRENCES OF |"| IN ls_list-console WITH |\\"|.
      REPLACE ALL OCCURRENCES OF |\\n| IN ls_list-console WITH |\\\\n|.

      lv_string = |\\{"class_name": "{ ls_list-class_name
        }","testclass_name": "{ ls_list-testclass_name
        }","method_name": "{ ls_list-method_name
        }","expected": "{ ls_list-expected
        }","actual": "{ ls_list-actual
        }","status": "{ ls_list-status
        }","runtime": { ls_list-runtime
        },"console": "{ ls_list-console
        }","message": "{ lv_message
        }","js_location": "{ ls_list-js_location }"\\}|.
      APPEND lv_string TO lt_strings.
    ENDLOOP.
    CONCATENATE LINES OF lt_strings INTO rv_json SEPARATED BY '',''.
    rv_json = ''['' && rv_json && '']''.
  ENDMETHOD.

  METHOD unique_classes.
    DATA ls_input LIKE LINE OF it_input.
    DATA ls_class LIKE LINE OF rt_classes.
    LOOP AT it_input INTO ls_input.
      MOVE-CORRESPONDING ls_input TO ls_class.
      INSERT ls_class INTO TABLE rt_classes.
    ENDLOOP.
    SORT rt_classes.
    DELETE ADJACENT DUPLICATES FROM rt_classes.
  ENDMETHOD.

  METHOD run.

    DATA ls_input   LIKE LINE OF it_input.
    DATA lv_time    TYPE i.
    DATA lo_obj     TYPE REF TO object.
    DATA lv_name    TYPE string.
    DATA lt_classes TYPE ty_classes.
    DATA ls_class   LIKE LINE OF lt_classes.
    DATA lx_root    TYPE REF TO cx_root.
    DATA lx_assert  TYPE REF TO kernel_cx_assert.
    FIELD-SYMBOLS <ls_result> LIKE LINE OF rs_result-list.

* todo, respect quit level, default = method?

    lt_classes = unique_classes( it_input ).

    LOOP AT lt_classes INTO ls_class.
* this is special, and must match the runtime:
      lv_name = |CLAS-{ ls_class-class_name }-{ ls_class-testclass_name }|.
      CREATE OBJECT lo_obj TYPE (lv_name).

      TRY.
          CALL METHOD lo_obj->(''CLASS_SETUP'').
        CATCH cx_sy_dyn_call_illegal_method.
      ENDTRY.

      LOOP AT it_input INTO ls_input WHERE class_name = ls_class-class_name AND testclass_name = ls_class-testclass_name.
        APPEND INITIAL LINE TO rs_result-list ASSIGNING <ls_result>.
        MOVE-CORRESPONDING ls_input TO <ls_result>.

        TRY.
            CALL METHOD lo_obj->(''SETUP'').
          CATCH cx_sy_dyn_call_illegal_method.
        ENDTRY.

        GET RUN TIME FIELD lv_time.
        CLEAR mv_console.
        TRY.
            CALL METHOD lo_obj->(ls_input-method_name).
            <ls_result>-status  = gc_status-success.
            <ls_result>-console = mv_console.
          CATCH kernel_cx_assert INTO lx_assert.
            <ls_result>-status      = gc_status-failed.
            <ls_result>-actual      = lx_assert->actual.
            <ls_result>-expected    = lx_assert->expected.
            <ls_result>-message     = lx_assert->msg.
            <ls_result>-js_location = get_location( lx_assert ).
            <ls_result>-console     = mv_console.
          CATCH cx_root INTO lx_root.
            <ls_result>-status      = gc_status-failed.
            <ls_result>-message     = |Some exception raised|. " todo, use RTTI to find the class name?
            <ls_result>-js_location = get_location( lx_root ).
            <ls_result>-console     = mv_console.
        ENDTRY.
        GET RUN TIME FIELD lv_time.
        <ls_result>-runtime = lv_time.

        TRY.
            CALL METHOD lo_obj->(''TEARDOWN'').
          CATCH cx_sy_dyn_call_illegal_method.
        ENDTRY.
      ENDLOOP.

      TRY.
          CALL METHOD lo_obj->(''CLASS_TEARDOWN'').
        CATCH cx_sy_dyn_call_illegal_method.
      ENDTRY.

    ENDLOOP.

    rs_result-json = to_json( rs_result-list ).

  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_OSQL_TEST_ENVIRONMENT                ', 'CLASS cl_osql_test_environment DEFINITION PUBLIC.
  PUBLIC SECTION.
    INTERFACES if_osql_test_environment.

    CLASS-METHODS create
      IMPORTING
        i_dependency_list TYPE if_osql_test_environment=>ty_t_sobjnames
      RETURNING
        VALUE(r_result)   TYPE REF TO if_osql_test_environment.

  PRIVATE SECTION.
    CONSTANTS mv_schema TYPE string VALUE ''double''.

    DATA mt_tables TYPE if_osql_test_environment=>ty_t_sobjnames.
    DATA mo_sql    TYPE REF TO cl_sql_statement.

    METHODS initialize.
    METHODS validate.
    METHODS set_runtime_prefix.
ENDCLASS.

CLASS cl_osql_test_environment IMPLEMENTATION.

  METHOD create.
    DATA lo_env TYPE REF TO cl_osql_test_environment.

    ASSERT sy-dbsys = ''sqlite''.

    CREATE OBJECT lo_env.
    lo_env->mt_tables = i_dependency_list.
    CREATE OBJECT lo_env->mo_sql.
    lo_env->initialize( ).

    r_result = lo_env.

  ENDMETHOD.

  METHOD validate.

    DATA ref           TYPE REF TO data.
    DATA lv_table      LIKE LINE OF mt_tables.
    FIELD-SYMBOLS <fs> TYPE any.

    LOOP AT mt_tables INTO lv_table.
      TRY.
          CREATE DATA ref TYPE (lv_table).
          ASSIGN ref->* TO <fs>.
          SELECT SINGLE * FROM (lv_table) INTO <fs>.
        CATCH cx_sy_create_data_error cx_sy_dynamic_osql_semantics.
          WRITE ''@KERNEL throw new Error(\`table \${lv_table.get().trimEnd()} invalid or does not exist\`);''.
      ENDTRY.
    ENDLOOP.
  ENDMETHOD.

  METHOD initialize.

    DATA lv_table  LIKE LINE OF mt_tables.
    DATA lv_sql    TYPE string.
    DATA lo_result TYPE REF TO cl_sql_result_set.
    DATA lr_ref    TYPE REF TO data.

    WRITE ''@KERNEL if (abap.dbo.schemaPrefix !== "") throw new Error("already prefixed");''.

* validate that the tables to be doubled exists
    validate( ).

* https://www.sqlite.org/lang_attach.html
    mo_sql->execute_update( |ATTACH DATABASE '':memory:'' AS { mv_schema };| ).

    LOOP AT mt_tables INTO lv_table.
      lv_table = to_lower( lv_table ).

      lo_result = mo_sql->execute_query( |SELECT sql FROM main.sqlite_master WHERE type=''table'' AND name=''{ lv_table }'';| ).
      GET REFERENCE OF lv_sql INTO lr_ref.
      lo_result->set_param( lr_ref ).
      lo_result->next( ).
      lo_result->close( ).

      REPLACE FIRST OCCURRENCE OF lv_table IN lv_sql WITH |{ mv_schema }''.''{ lv_table }|.
      ASSERT sy-subrc = 0.

      mo_sql->execute_update( lv_sql ).
    ENDLOOP.

    set_runtime_prefix( ).

  ENDMETHOD.

  METHOD set_runtime_prefix.

    WRITE ''@KERNEL abap.dbo.schemaPrefix = this.mv_schema.get();''.

  ENDMETHOD.

  METHOD if_osql_test_environment~clear_doubles.
    DATA lv_table LIKE LINE OF mt_tables.

    LOOP AT mt_tables INTO lv_table.
      lv_table = to_lower( lv_table ).
      mo_sql->execute_update( |DELETE FROM { mv_schema }."{ lv_table }";| ).
    ENDLOOP.
  ENDMETHOD.

  METHOD if_osql_test_environment~destroy.

* https://www.sqlite.org/lang_detach.html
    mo_sql->execute_update( |DETACH DATABASE { mv_schema };| ).

    WRITE ''@KERNEL abap.dbo.schemaPrefix = "";''.

  ENDMETHOD.

  METHOD if_osql_test_environment~insert_test_data.
    DATA lo_table_descr  TYPE REF TO cl_abap_tabledescr.
    DATA lo_struct_descr TYPE REF TO cl_abap_structdescr.
    DATA lv_table        TYPE string.

    lo_table_descr ?= cl_abap_typedescr=>describe_by_data( i_data ).
    lo_struct_descr ?= lo_table_descr->get_table_line_type( ).
    lv_table = lo_struct_descr->get_relative_name( ).

* sanity checks,
    ASSERT lv_table IS NOT INITIAL.
    READ TABLE mt_tables WITH KEY table_line = lv_table TRANSPORTING NO FIELDS.
    ASSERT sy-subrc = 0.

    INSERT (lv_table) FROM TABLE i_data.
    ASSERT sy-subrc = 0.

  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_OSQL_TEST_ENVIRONMENT                ', 'INTERFACE if_osql_test_environment PUBLIC.

  TYPES ty_s_sobjname  TYPE abap_compname.
  TYPES ty_t_sobjnames TYPE STANDARD TABLE OF ty_s_sobjname WITH DEFAULT KEY.

  METHODS clear_doubles.
  METHODS destroy.

  METHODS insert_test_data
    IMPORTING
      i_data TYPE ANY TABLE.

ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SYSTEM_UUID                          ', 'CLASS cl_system_uuid DEFINITION PUBLIC.
  PUBLIC SECTION.
    INTERFACES if_system_uuid_rfc4122_static.
    INTERFACES if_system_uuid_static.

    ALIASES create_uuid_c32_static FOR if_system_uuid_static~create_uuid_c32.
    ALIASES create_uuid_x16_static FOR if_system_uuid_static~create_uuid_x16.
ENDCLASS.

CLASS cl_system_uuid IMPLEMENTATION.

  METHOD if_system_uuid_static~create_uuid_x16.
    WRITE ''@KERNEL if (cl_system_uuid.CRYPTO === undefined) cl_system_uuid.CRYPTO = await import("crypto");''.
    WRITE ''@KERNEL uuid.set(cl_system_uuid.CRYPTO.randomBytes(16).toString("hex").toUpperCase());''.
  ENDMETHOD.

  METHOD if_system_uuid_static~create_uuid_c32.
    WRITE ''@KERNEL if (cl_system_uuid.CRYPTO === undefined) cl_system_uuid.CRYPTO = await import("crypto");''.
    WRITE ''@KERNEL uuid.set(cl_system_uuid.CRYPTO.randomBytes(16).toString("hex").toUpperCase());''.
  ENDMETHOD.

  METHOD if_system_uuid_rfc4122_static~create_uuid_c36_by_version.
    ASSERT version = 4.
    WRITE ''@KERNEL if (cl_system_uuid.CRYPTO === undefined) cl_system_uuid.CRYPTO = await import("crypto");''.
    WRITE ''@KERNEL uuid.set(cl_system_uuid.CRYPTO.randomUUID());''.
  ENDMETHOD.

  METHOD if_system_uuid_static~create_uuid_c22.
    WRITE ''@KERNEL if (cl_system_uuid.CRYPTO === undefined) cl_system_uuid.CRYPTO = await import("crypto");''.
* yea, well, hmm,
    WRITE ''@KERNEL uuid.set(cl_system_uuid.CRYPTO.randomBytes(11).toString("hex"));''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_UUID_ERROR                           ', 'CLASS cx_uuid_error DEFINITION PUBLIC INHERITING FROM cx_static_check.

ENDCLASS.

CLASS cx_uuid_error IMPLEMENTATION.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SYSTEM_UUID_RFC4122_STATIC           ', 'INTERFACE if_system_uuid_rfc4122_static PUBLIC.
  CLASS-METHODS create_uuid_c36_by_version
    IMPORTING
      version TYPE i
    RETURNING
      VALUE(uuid) TYPE sysuuid_c36
    RAISING
      cx_uuid_error.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SYSTEM_UUID_STATIC                   ', 'INTERFACE if_system_uuid_static PUBLIC.
  CLASS-METHODS create_uuid_x16
    RETURNING
      VALUE(uuid) TYPE sysuuid_x16
    RAISING
      cx_uuid_error.

  CLASS-METHODS create_uuid_c32
    RETURNING
      VALUE(uuid) TYPE sysuuid_c32
    RAISING
      cx_uuid_error.

  CLASS-METHODS create_uuid_c22
    RETURNING
      VALUE(uuid) TYPE sysuuid_c22
    RAISING
      cx_uuid_error.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_EXPRESS_ICF_SHIM                     ', 'CLASS cl_express_icf_shim DEFINITION PUBLIC.
  PUBLIC SECTION.
    CLASS-METHODS run
      IMPORTING
        res   TYPE any
        req   TYPE any
        base  TYPE string OPTIONAL.
  PRIVATE SECTION.
    CLASS-DATA mi_server TYPE REF TO if_http_server.
    CLASS-METHODS response
      IMPORTING
        res     TYPE any ##NEEDED.
    CLASS-METHODS request
      IMPORTING
        req  TYPE any
        base TYPE string ##NEEDED.
ENDCLASS.

CLASS cl_express_icf_shim IMPLEMENTATION.

  METHOD run.
    DATA lv_classname TYPE string.
    DATA li_handler   TYPE REF TO if_http_extension.

    WRITE ''@KERNEL lv_classname.set(INPUT.class);''.
    TRANSLATE lv_classname TO UPPER CASE.
    CREATE OBJECT li_handler TYPE (lv_classname).

    IF mi_server IS INITIAL.
      CREATE OBJECT mi_server TYPE lcl_server.
    ENDIF.

    CREATE OBJECT mi_server->request TYPE cl_http_entity.
    request(
      req  = req
      base = base ).

********************************************************

    CREATE OBJECT mi_server->response TYPE cl_http_entity.
    li_handler->handle_request( mi_server ).

********************************************************

    response( res ).
  ENDMETHOD.

  METHOD request.
    DATA lv_xstr   TYPE xstring.
    DATA lv_str    TYPE string.
    DATA lv_name   TYPE string.
    DATA lv_value  TYPE string.
    DATA lt_fields TYPE tihttpnvp.

    WRITE ''@KERNEL lv_xstr.set(INPUT.req.body.toString("hex").toUpperCase());''.
    mi_server->request->set_data( lv_xstr ).
    WRITE ''@KERNEL lv_str.set(INPUT.req.method);''.
    mi_server->request->set_method( lv_str ).
    WRITE ''@KERNEL for (const h in INPUT.req.headers) {''.
    WRITE ''@KERNEL   lv_name.set(h);''.
    WRITE ''@KERNEL   lv_value.set(INPUT.req.headers[h]);''.
    mi_server->request->set_header_field(
      name  = lv_name
      value = lv_value ).
    WRITE ''@KERNEL }''.

    WRITE ''@KERNEL lv_value.set(INPUT.req.url);''.
    mi_server->request->set_header_field(
      name  = ''~request_uri''
      value = lv_value ).

    SPLIT lv_value AT ''?'' INTO lv_value lv_value.
    mi_server->request->set_header_field(
      name  = ''~query_string''
      value = lv_value ).

    lt_fields = cl_http_utility=>string_to_fields( lv_value ).
    mi_server->request->set_form_fields( lt_fields ).


    WRITE ''@KERNEL lv_value.set(INPUT.req.path);''.
    mi_server->request->set_header_field(
      name  = ''~path''
      value = lv_value ).
    mi_server->request->set_header_field(
      name  = ''~path_translated_expanded''
      value = lv_value ).

    REPLACE FIRST OCCURRENCE OF base IN lv_value WITH ''''.
    mi_server->request->set_header_field(
      name  = ''~path_info''
      value = lv_value ).
* path_info_expanded is without alias
    mi_server->request->set_header_field(
      name  = ''~path_info_expanded''
      value = lv_value ).

  ENDMETHOD.

  METHOD response.
    DATA lv_code          TYPE i.
    DATA lv_xstr          TYPE xstring.
    DATA lv_content_type  TYPE string.
    DATA lt_header_fields TYPE tihttpnvp.
    DATA ls_field         LIKE LINE OF lt_header_fields.

    mi_server->response->get_status( IMPORTING code = lv_code ).
    IF lv_code IS INITIAL.
      lv_code = 200.
    ENDIF.

    lv_content_type = mi_server->response->get_content_type( ).
    IF lv_content_type IS INITIAL.
      mi_server->response->set_content_type( ''text/html'' ).
    ENDIF.

    mi_server->response->get_header_fields( CHANGING fields = lt_header_fields ).
    LOOP AT lt_header_fields INTO ls_field.
      WRITE ''@KERNEL INPUT.res.append(ls_field.get().name.get(), ls_field.get().value.get());''.
    ENDLOOP.

    lv_xstr = mi_server->response->get_data( ).
    WRITE ''@KERNEL INPUT.res.status(lv_code.get()).send(Buffer.from(lv_xstr.get(), "hex"));''.
  ENDMETHOD.

ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ICF_TREE                             ', 'CLASS cl_icf_tree DEFINITION PUBLIC.
  PUBLIC SECTION.
    INTERFACES if_icf_tree.
ENDCLASS.

CLASS cl_icf_tree IMPLEMENTATION.
  METHOD if_icf_tree~service_from_url.
* todo
    RETURN.
  ENDMETHOD.
ENDCLASS.');`);
  insert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_ICF_TREE                             ', 'INTERFACE if_icf_tree PUBLIC.
  CLASS-METHODS service_from_url
    IMPORTING
      url             TYPE string DEFAULT ''/''
      hostnumber      TYPE i
      authority_check TYPE c DEFAULT ''X''
    EXPORTING
      urlsuffix       TYPE string
      icfnodguid      TYPE char25
      icf_name        TYPE char15
      icfactive       TYPE abap_bool
      icfaltnme       TYPE string
    EXCEPTIONS
      wrong_application
      no_application
      not_allow_application
      wrong_url
      no_authority.
ENDINTERFACE.');`);
  insert.push(`INSERT INTO t000 ('mandt', 'cccategory', 'ccnocliind') VALUES ('123', '', '');`);

  const {setup} = await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_crypto-browserify_index_js"), __webpack_require__.e("vendors-node_modules_path-browserify_index_js"), __webpack_require__.e("vendors-node_modules_abaplint_database-sqlite_build_index_js"), __webpack_require__.e("test_setup_mjs")]).then(__webpack_require__.bind(__webpack_require__, /*! ../test/setup.mjs */ "./test/setup.mjs"));
  await setup(globalThis.abap, schemas, insert);
}
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "./output/_top.mjs":
/*!*************************!*\
  !*** ./output/_top.mjs ***!
  \*************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _abaplint_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @abaplint/runtime */ "./node_modules/@abaplint/runtime/build/src/index.js");

globalThis.abap = new _abaplint_runtime__WEBPACK_IMPORTED_MODULE_0__.ABAP();

/***/ }),

/***/ "./output/abap.type.mjs":
/*!******************************!*\
  !*** ./output/abap.type.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
const pool = {};
pool['abap_max_comp_name_ln'] = new abap.types.Integer({qualifiedName: "I"});
pool['abap_max_comp_name_ln'].set(30);
pool['abap_func_exporting'] = new abap.types.Integer({qualifiedName: "KIND"});
pool['abap_func_exporting'].set(10);
pool['abap_func_importing'] = new abap.types.Integer({qualifiedName: "KIND"});
pool['abap_func_importing'].set(20);
pool['abap_func_tables'] = new abap.types.Integer({qualifiedName: "KIND"});
pool['abap_func_tables'].set(30);
pool['abap_func_changing'] = new abap.types.Integer({qualifiedName: "KIND"});
pool['abap_func_changing'].set(40);
pool['abap_trans_srcbind'] = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "value": new abap.types.DataReference(new abap.types.Character(4))}, "abap_trans_srcbind", undefined, {}, {});
pool['abap_encoding'] = new abap.types.Character(20, {"qualifiedName":"abap_encoding"});
pool['abap_trans_srcbind_tab'] = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "value": new abap.types.DataReference(new abap.types.Character(4))}, "abap_trans_srcbind", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_trans_srcbind_tab");
pool['abap_trans_resbind_tab'] = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "value": new abap.types.DataReference(new abap.types.Character(4))}, "abap_trans_srcbind", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_trans_srcbind_tab");
pool['abap_abstypename'] = new abap.types.Character(200, {"qualifiedName":"abap_abstypename"});
pool['abap_attrname'] = new abap.types.Character(61, {"qualifiedName":"abap_attrname"});
pool['abap_classname'] = new abap.types.Character(30, {"qualifiedName":"abap_classname"});
pool['abap_compname'] = new abap.types.Character(30, {"qualifiedName":"abap_compname"});
pool['abap_editmask'] = new abap.types.Character(7, {"qualifiedName":"abap_editmask"});
pool['abap_evntname'] = new abap.types.Character(61, {"qualifiedName":"abap_evntname"});
pool['abap_excpname'] = new abap.types.Character(30, {"qualifiedName":"abap_excpname"});
pool['abap_helpid'] = new abap.types.Character(62, {"qualifiedName":"abap_helpid"});
pool['abap_intfname'] = new abap.types.Character(30, {"qualifiedName":"abap_intfname"});
pool['abap_keydefkind'] = new abap.types.Character(1, {"qualifiedName":"abap_keydefkind"});
pool['abap_keyname'] = new abap.types.Character(255, {"qualifiedName":"abap_keyname"});
pool['abap_methname'] = new abap.types.Character(61, {"qualifiedName":"abap_methname"});
pool['abap_parmkind'] = new abap.types.Character(1, {"qualifiedName":"abap_parmkind"});
pool['abap_parmname'] = new abap.types.Character(30, {"qualifiedName":"abap_parmname"});
pool['abap_structkind'] = new abap.types.Character(1, {"qualifiedName":"abap_structkind"});
pool['abap_typekind'] = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
pool['abap_visibility'] = new abap.types.Character(1, {"qualifiedName":"abap_visibility"});
pool['abap_tablekind'] = new abap.types.Character(1, {"qualifiedName":"abap_tablekind"});
pool['abap_char1'] = new abap.types.Character(1, {"qualifiedName":"abap_char1"});
pool['abap_cr_lf'] = new abap.types.Character(2, {"qualifiedName":"abap_cr_lf"});
pool['abap_byte_order_mark'] = new abap.types.Hex({length: 2});
pool['abap_byte_order_utf8'] = new abap.types.Hex({length: 3});
pool['abap_endian'] = new abap.types.Character(1, {"qualifiedName":"abap_endian"});
pool['abap_componentdescr'] = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {});
pool['abap_component_tab'] = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_component_tab");
pool['abap_compdescr'] = new abap.types.Structure({"length": new abap.types.Integer({qualifiedName: "LENGTH"}), "decimals": new abap.types.Integer({qualifiedName: "DECIMALS"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "name": new abap.types.Character(30, {"qualifiedName":"abap_compname"})}, "abap_compdescr", undefined, {}, {});
pool['abap_compdescr_tab'] = abap.types.TableFactory.construct(new abap.types.Structure({"length": new abap.types.Integer({qualifiedName: "LENGTH"}), "decimals": new abap.types.Integer({qualifiedName: "DECIMALS"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "name": new abap.types.Character(30, {"qualifiedName":"abap_compname"})}, "abap_compdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_compdescr_tab");
pool['abap_table_keycompdescr'] = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"})}, "abap_table_keycompdescr", undefined, {}, {});
pool['abap_table_keydescr'] = new abap.types.Structure({"components": abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"})}, "abap_table_keycompdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_table_keydescr-components"), "name": new abap.types.String({qualifiedName: "NAME"}), "is_primary": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "access_kind": new abap.types.String({qualifiedName: "ACCESS_KIND"}), "is_unique": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "key_kind": new abap.types.String({qualifiedName: "KEY_KIND"})}, "abap_table_keydescr", undefined, {}, {});
pool['abap_table_keydescr_tab'] = abap.types.TableFactory.construct(new abap.types.Structure({"components": abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"})}, "abap_table_keycompdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_table_keydescr-components"), "name": new abap.types.String({qualifiedName: "NAME"}), "is_primary": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "access_kind": new abap.types.String({qualifiedName: "ACCESS_KIND"}), "is_unique": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "key_kind": new abap.types.String({qualifiedName: "KEY_KIND"})}, "abap_table_keydescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_table_keydescr_tab");
pool['abap_simple_componentdescr'] = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"})}, "abap_simple_componentdescr", undefined, {}, {});
pool['abap_component_view_tab'] = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"})}, "abap_simple_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_component_view_tab");
pool['abap_parmbind'] = new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_parmname"}), "kind": new abap.types.Character(1, {"qualifiedName":"abap_parmkind"}), "value": new abap.types.DataReference(new abap.types.Character(4))}, "abap_parmbind", undefined, {}, {});
pool['abap_parmbind_tab'] = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_parmname"}), "kind": new abap.types.Character(1, {"qualifiedName":"abap_parmkind"}), "value": new abap.types.DataReference(new abap.types.Character(4))}, "abap_parmbind", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"HASHED","isUnique":true,"keyFields":["NAME"]},"secondary":[]}, "abap_parmbind_tab");
pool['abap_parmdescr'] = new abap.types.Structure({"length": new abap.types.Integer({qualifiedName: "LENGTH"}), "decimals": new abap.types.Integer({qualifiedName: "DECIMALS"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "name": new abap.types.Character(30, {"qualifiedName":"abap_parmname"}), "parm_kind": new abap.types.Character(1, {"qualifiedName":"abap_parmkind"}), "by_value": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_optional": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_parmdescr", undefined, {}, {});
pool['abap_parmdescr_tab'] = abap.types.TableFactory.construct(new abap.types.Structure({"length": new abap.types.Integer({qualifiedName: "LENGTH"}), "decimals": new abap.types.Integer({qualifiedName: "DECIMALS"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "name": new abap.types.Character(30, {"qualifiedName":"abap_parmname"}), "parm_kind": new abap.types.Character(1, {"qualifiedName":"abap_parmkind"}), "by_value": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_optional": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_parmdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_parmdescr_tab");
pool['abap_component_symbol_tab'] = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"})}, "abap_simple_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"HASHED","isUnique":true,"keyFields":["NAME"]},"secondary":[]}, "abap_component_symbol_tab");
pool['abap_func_parmbind'] = new abap.types.Structure({"value": new abap.types.DataReference(new abap.types.Character(4)), "tables_wa": new abap.types.DataReference(new abap.types.Character(4)), "kind": new abap.types.Integer({qualifiedName: "KIND"}), "name": new abap.types.Character(30, {"qualifiedName":"abap_parmname"})}, "abap_func_parmbind", undefined, {}, {});
pool['abap_func_parmbind_tab'] = abap.types.TableFactory.construct(new abap.types.Structure({"value": new abap.types.DataReference(new abap.types.Character(4)), "tables_wa": new abap.types.DataReference(new abap.types.Character(4)), "kind": new abap.types.Integer({qualifiedName: "KIND"}), "name": new abap.types.Character(30, {"qualifiedName":"abap_parmname"})}, "abap_func_parmbind", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"SORTED","isUnique":true,"keyFields":["KIND","NAME"]},"secondary":[]}, "abap_func_parmbind_tab");
pool['abap_func_excpbind'] = new abap.types.Structure({"message": new abap.types.DataReference(new abap.types.Character(4)), "value": new abap.types.Integer({qualifiedName: "VALUE"}), "name": new abap.types.Character(30, {"qualifiedName":"abap_excpname"})}, "abap_func_excpbind", undefined, {}, {});
pool['abap_func_excpbind_tab'] = abap.types.TableFactory.construct(new abap.types.Structure({"message": new abap.types.DataReference(new abap.types.Character(4)), "value": new abap.types.Integer({qualifiedName: "VALUE"}), "name": new abap.types.Character(30, {"qualifiedName":"abap_excpname"})}, "abap_func_excpbind", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"HASHED","isUnique":true,"keyFields":["NAME"]},"secondary":[]}, "abap_func_excpbind_tab");
pool['abap_excpdescr'] = new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_excpname"}), "is_resumable": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_excpdescr", undefined, {}, {});
pool['abap_excpdescr_tab'] = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_excpname"}), "is_resumable": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_excpdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_excpdescr_tab");
pool['abap_methdescr'] = new abap.types.Structure({"parameters": abap.types.TableFactory.construct(new abap.types.Structure({"length": new abap.types.Integer({qualifiedName: "LENGTH"}), "decimals": new abap.types.Integer({qualifiedName: "DECIMALS"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "name": new abap.types.Character(30, {"qualifiedName":"abap_parmname"}), "parm_kind": new abap.types.Character(1, {"qualifiedName":"abap_parmkind"}), "by_value": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_optional": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_parmdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_parmdescr_tab"), "exceptions": abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_excpname"}), "is_resumable": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_excpdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_excpdescr_tab"), "name": new abap.types.Character(61, {"qualifiedName":"abap_methname"}), "for_event": new abap.types.Character(61, {"qualifiedName":"abap_evntname"}), "of_class": new abap.types.Character(30, {"qualifiedName":"abap_classname"}), "visibility": new abap.types.Character(1, {"qualifiedName":"abap_visibility"}), "is_interface": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_inherited": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_redefined": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_abstract": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_final": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_class": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "alias_for": new abap.types.Character(61, {"qualifiedName":"abap_methname"}), "is_raising_excps": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_methdescr", undefined, {}, {});
pool['abap_methdescr_tab'] = abap.types.TableFactory.construct(new abap.types.Structure({"parameters": abap.types.TableFactory.construct(new abap.types.Structure({"length": new abap.types.Integer({qualifiedName: "LENGTH"}), "decimals": new abap.types.Integer({qualifiedName: "DECIMALS"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "name": new abap.types.Character(30, {"qualifiedName":"abap_parmname"}), "parm_kind": new abap.types.Character(1, {"qualifiedName":"abap_parmkind"}), "by_value": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_optional": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_parmdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_parmdescr_tab"), "exceptions": abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_excpname"}), "is_resumable": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_excpdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_excpdescr_tab"), "name": new abap.types.Character(61, {"qualifiedName":"abap_methname"}), "for_event": new abap.types.Character(61, {"qualifiedName":"abap_evntname"}), "of_class": new abap.types.Character(30, {"qualifiedName":"abap_classname"}), "visibility": new abap.types.Character(1, {"qualifiedName":"abap_visibility"}), "is_interface": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_inherited": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_redefined": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_abstract": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_final": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_class": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "alias_for": new abap.types.Character(61, {"qualifiedName":"abap_methname"}), "is_raising_excps": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_methdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_methdescr_tab");
pool['abap_attrdescr'] = new abap.types.Structure({"length": new abap.types.Integer({qualifiedName: "LENGTH"}), "decimals": new abap.types.Integer({qualifiedName: "DECIMALS"}), "name": new abap.types.Character(61, {"qualifiedName":"abap_attrname"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "visibility": new abap.types.Character(1, {"qualifiedName":"abap_visibility"}), "is_interface": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_inherited": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_class": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_constant": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_virtual": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_read_only": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "alias_for": new abap.types.Character(61, {"qualifiedName":"abap_attrname"})}, "abap_attrdescr", undefined, {}, {});
pool['abap_attrdescr_tab'] = abap.types.TableFactory.construct(new abap.types.Structure({"length": new abap.types.Integer({qualifiedName: "LENGTH"}), "decimals": new abap.types.Integer({qualifiedName: "DECIMALS"}), "name": new abap.types.Character(61, {"qualifiedName":"abap_attrname"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "visibility": new abap.types.Character(1, {"qualifiedName":"abap_visibility"}), "is_interface": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_inherited": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_class": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_constant": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_virtual": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_read_only": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "alias_for": new abap.types.Character(61, {"qualifiedName":"abap_attrname"})}, "abap_attrdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_attrdescr_tab");
pool['abap_intfdescr'] = new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_intfname"}), "is_inherited": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_intfdescr", undefined, {}, {});
pool['abap_intfdescr_tab'] = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_intfname"}), "is_inherited": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_intfdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_intfdescr_tab");
pool['abap_excpbind'] = new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_excpname"}), "value": new abap.types.Integer({qualifiedName: "VALUE"})}, "abap_excpbind", undefined, {}, {});
pool['abap_excpbind_tab'] = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_excpname"}), "value": new abap.types.Integer({qualifiedName: "VALUE"})}, "abap_excpbind", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"HASHED","isUnique":true,"keyFields":["NAME"]},"secondary":[]}, "abap_excpbind_tab");
pool['abap_keydescr'] = new abap.types.Structure({"name": new abap.types.Character(255, {"qualifiedName":"abap_keyname"})}, "abap_keydescr", undefined, {}, {});
pool['abap_keydescr_tab'] = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(255, {"qualifiedName":"abap_keyname"})}, "abap_keydescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_keydescr_tab");
abap.TypePools['ABAP'] = pool;
//# sourceMappingURL=abap.type.mjs.map

/***/ }),

/***/ "./output/abap_boolean.dtel.mjs":
/*!**************************************!*\
  !*** ./output/abap_boolean.dtel.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["ABAP_BOOLEAN"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOLEAN","ddicName":"ABAP_BOOLEAN"}),
  "domain": "ABAP_BOOLEAN",
  "fixedValues": [{"description":"False","language":"E"},{"description":"True","low":"X","language":"E"}],
};

/***/ }),

/***/ "./output/abap_callstack.ttyp.mjs":
/*!****************************************!*\
  !*** ./output/abap_callstack.ttyp.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["ABAP_CALLSTACK"] = {
  "objectType": "TTYP",
  "type": abap.types.TableFactory.construct(new abap.types.Structure({"mainprogram": new abap.types.Character(40, {}), "include": new abap.types.Character(40, {}), "line": new abap.types.Integer({qualifiedName: "I"}), "blocktype": new abap.types.Character(12, {}), "blockname": new abap.types.String({qualifiedName: "STRING"})}, "ABAP_CALLSTACK_LINE", "ABAP_CALLSTACK_LINE", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "ABAP_CALLSTACK"),
};

/***/ }),

/***/ "./output/abap_callstack_line.tabl.mjs":
/*!*********************************************!*\
  !*** ./output/abap_callstack_line.tabl.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["ABAP_CALLSTACK_LINE"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"mainprogram": new abap.types.Character(40, {}), "include": new abap.types.Character(40, {}), "line": new abap.types.Integer({qualifiedName: "I"}), "blocktype": new abap.types.Character(12, {}), "blockname": new abap.types.String({qualifiedName: "STRING"})}, "ABAP_CALLSTACK_LINE", "ABAP_CALLSTACK_LINE", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/abap_encod.dtel.mjs":
/*!************************************!*\
  !*** ./output/abap_encod.dtel.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["ABAP_ENCOD"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(20, {"qualifiedName":"ABAP_ENCOD","ddicName":"ABAP_ENCOD"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/abap_sortorder.tabl.mjs":
/*!****************************************!*\
  !*** ./output/abap_sortorder.tabl.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["ABAP_SORTORDER"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "descending": new abap.types.Character(1, {}), "astext": new abap.types.Character(1, {})}, "ABAP_SORTORDER", "ABAP_SORTORDER", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/abap_sortorder_tab.ttyp.mjs":
/*!********************************************!*\
  !*** ./output/abap_sortorder_tab.ttyp.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["ABAP_SORTORDER_TAB"] = {
  "objectType": "TTYP",
  "type": abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "descending": new abap.types.Character(1, {}), "astext": new abap.types.Character(1, {})}, "ABAP_SORTORDER", "ABAP_SORTORDER", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "ABAP_SORTORDER_TAB"),
};

/***/ }),

/***/ "./output/balmnr.dtel.mjs":
/*!********************************!*\
  !*** ./output/balmnr.dtel.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["BALMNR"] = {
  "objectType": "DTEL",
  "type": new abap.types.Numc({length: 6, qualifiedName: "BALMNR"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/balognr.dtel.mjs":
/*!*********************************!*\
  !*** ./output/balognr.dtel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["BALOGNR"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(20, {"qualifiedName":"BALOGNR","ddicName":"BALOGNR"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/bapi_fld.dtel.mjs":
/*!**********************************!*\
  !*** ./output/bapi_fld.dtel.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["BAPI_FLD"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(30, {"qualifiedName":"BAPI_FLD","ddicName":"BAPI_FLD"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/bapi_line.dtel.mjs":
/*!***********************************!*\
  !*** ./output/bapi_line.dtel.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["BAPI_LINE"] = {
  "objectType": "DTEL",
  "type": new abap.types.Integer({qualifiedName: "BAPI_LINE"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/bapi_msg.dtel.mjs":
/*!**********************************!*\
  !*** ./output/bapi_msg.dtel.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["BAPI_MSG"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(220, {"qualifiedName":"BAPI_MSG","ddicName":"BAPI_MSG"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/bapi_mtype.dtel.mjs":
/*!************************************!*\
  !*** ./output/bapi_mtype.dtel.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["BAPI_MTYPE"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(1, {"qualifiedName":"BAPI_MTYPE","ddicName":"BAPI_MTYPE"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/bapi_param.dtel.mjs":
/*!************************************!*\
  !*** ./output/bapi_param.dtel.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["BAPI_PARAM"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(32, {"qualifiedName":"BAPI_PARAM","ddicName":"BAPI_PARAM"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/bapi_rcode.dtel.mjs":
/*!************************************!*\
  !*** ./output/bapi_rcode.dtel.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["BAPI_RCODE"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(5, {"qualifiedName":"BAPI_RCODE","ddicName":"BAPI_RCODE"}),
  "domain": "CHAR5",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/bapilogsys.dtel.mjs":
/*!************************************!*\
  !*** ./output/bapilogsys.dtel.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["BAPILOGSYS"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(10, {"qualifiedName":"BAPILOGSYS","ddicName":"BAPILOGSYS"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/bapioption.dtel.mjs":
/*!************************************!*\
  !*** ./output/bapioption.dtel.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["BAPIOPTION"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(2, {"qualifiedName":"BAPIOPTION","ddicName":"BAPIOPTION"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/bapiret2.tabl.mjs":
/*!**********************************!*\
  !*** ./output/bapiret2.tabl.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["BAPIRET2"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"type": new abap.types.Character(1, {"qualifiedName":"BAPI_MTYPE","ddicName":"BAPI_MTYPE"}), "id": new abap.types.Character(20, {"qualifiedName":"SYMSGID","ddicName":"SYMSGID"}), "number": new abap.types.Numc({length: 3, qualifiedName: "SYMSGNO"}), "message": new abap.types.Character(220, {"qualifiedName":"BAPI_MSG","ddicName":"BAPI_MSG"}), "log_no": new abap.types.Character(20, {"qualifiedName":"BALOGNR","ddicName":"BALOGNR"}), "log_msg_no": new abap.types.Numc({length: 6, qualifiedName: "BALMNR"}), "message_v1": new abap.types.Character(50, {"qualifiedName":"SYMSGV","ddicName":"SYMSGV"}), "message_v2": new abap.types.Character(50, {"qualifiedName":"SYMSGV","ddicName":"SYMSGV"}), "message_v3": new abap.types.Character(50, {"qualifiedName":"SYMSGV","ddicName":"SYMSGV"}), "message_v4": new abap.types.Character(50, {"qualifiedName":"SYMSGV","ddicName":"SYMSGV"}), "parameter": new abap.types.Character(32, {"qualifiedName":"BAPI_PARAM","ddicName":"BAPI_PARAM"}), "row": new abap.types.Integer({qualifiedName: "BAPI_LINE"}), "field": new abap.types.Character(30, {"qualifiedName":"BAPI_FLD","ddicName":"BAPI_FLD"}), "system": new abap.types.Character(10, {"qualifiedName":"BAPILOGSYS","ddicName":"BAPILOGSYS"})}, "BAPIRET2", "BAPIRET2", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/bapirettab.ttyp.mjs":
/*!************************************!*\
  !*** ./output/bapirettab.ttyp.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["BAPIRETTAB"] = {
  "objectType": "TTYP",
  "type": abap.types.TableFactory.construct(new abap.types.Structure({"type": new abap.types.Character(1, {"qualifiedName":"BAPI_MTYPE","ddicName":"BAPI_MTYPE"}), "id": new abap.types.Character(20, {"qualifiedName":"SYMSGID","ddicName":"SYMSGID"}), "number": new abap.types.Numc({length: 3, qualifiedName: "SYMSGNO"}), "message": new abap.types.Character(220, {"qualifiedName":"BAPI_MSG","ddicName":"BAPI_MSG"}), "log_no": new abap.types.Character(20, {"qualifiedName":"BALOGNR","ddicName":"BALOGNR"}), "log_msg_no": new abap.types.Numc({length: 6, qualifiedName: "BALMNR"}), "message_v1": new abap.types.Character(50, {"qualifiedName":"SYMSGV","ddicName":"SYMSGV"}), "message_v2": new abap.types.Character(50, {"qualifiedName":"SYMSGV","ddicName":"SYMSGV"}), "message_v3": new abap.types.Character(50, {"qualifiedName":"SYMSGV","ddicName":"SYMSGV"}), "message_v4": new abap.types.Character(50, {"qualifiedName":"SYMSGV","ddicName":"SYMSGV"}), "parameter": new abap.types.Character(32, {"qualifiedName":"BAPI_PARAM","ddicName":"BAPI_PARAM"}), "row": new abap.types.Integer({qualifiedName: "BAPI_LINE"}), "field": new abap.types.Character(30, {"qualifiedName":"BAPI_FLD","ddicName":"BAPI_FLD"}), "system": new abap.types.Character(10, {"qualifiedName":"BAPILOGSYS","ddicName":"BAPILOGSYS"})}, "BAPIRET2", "BAPIRET2", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "BAPIRETTAB"),
};

/***/ }),

/***/ "./output/bapireturn.tabl.mjs":
/*!************************************!*\
  !*** ./output/bapireturn.tabl.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["BAPIRETURN"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"type": new abap.types.Character(1, {"qualifiedName":"BAPI_MTYPE","ddicName":"BAPI_MTYPE"}), "code": new abap.types.Character(5, {"qualifiedName":"BAPI_RCODE","ddicName":"BAPI_RCODE"}), "message": new abap.types.Character(220, {"qualifiedName":"BAPI_MSG","ddicName":"BAPI_MSG"}), "log_no": new abap.types.Character(20, {"qualifiedName":"BALOGNR","ddicName":"BALOGNR"}), "log_msg_no": new abap.types.Numc({length: 6, qualifiedName: "BALMNR"}), "message_v1": new abap.types.Character(50, {"qualifiedName":"SYMSGV","ddicName":"SYMSGV"}), "message_v2": new abap.types.Character(50, {"qualifiedName":"SYMSGV","ddicName":"SYMSGV"}), "message_v3": new abap.types.Character(50, {"qualifiedName":"SYMSGV","ddicName":"SYMSGV"}), "message_v4": new abap.types.Character(50, {"qualifiedName":"SYMSGV","ddicName":"SYMSGV"})}, "BAPIRETURN", "BAPIRETURN", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/bapisign.dtel.mjs":
/*!**********************************!*\
  !*** ./output/bapisign.dtel.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["BAPISIGN"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(1, {"qualifiedName":"BAPISIGN","ddicName":"BAPISIGN"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/boole_d.dtel.mjs":
/*!*********************************!*\
  !*** ./output/boole_d.dtel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["BOOLE_D"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(1, {"qualifiedName":"BOOLE_D","ddicName":"BOOLE_D"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/boolean.dtel.mjs":
/*!*********************************!*\
  !*** ./output/boolean.dtel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["BOOLEAN"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(1, {"qualifiedName":"BOOLEAN","ddicName":"BOOLEAN"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/char1.dtel.mjs":
/*!*******************************!*\
  !*** ./output/char1.dtel.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["CHAR1"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(1, {"qualifiedName":"CHAR1","ddicName":"CHAR1"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/char10.dtel.mjs":
/*!********************************!*\
  !*** ./output/char10.dtel.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["CHAR10"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(10, {"qualifiedName":"CHAR10","ddicName":"CHAR10"}),
  "domain": "CHAR10",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/char120.dtel.mjs":
/*!*********************************!*\
  !*** ./output/char120.dtel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["CHAR120"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(120, {"qualifiedName":"CHAR120","ddicName":"CHAR120"}),
  "domain": "CHAR120",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/char15.dtel.mjs":
/*!********************************!*\
  !*** ./output/char15.dtel.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["CHAR15"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(15, {"qualifiedName":"CHAR15","ddicName":"CHAR15"}),
  "domain": "CHAR15",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/char2.dtel.mjs":
/*!*******************************!*\
  !*** ./output/char2.dtel.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["CHAR2"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(2, {"qualifiedName":"CHAR2","ddicName":"CHAR2"}),
  "domain": "CHAR2",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/char20.dtel.mjs":
/*!********************************!*\
  !*** ./output/char20.dtel.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["CHAR20"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(20, {"qualifiedName":"CHAR20","ddicName":"CHAR20"}),
  "domain": "CHAR20",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/char25.dtel.mjs":
/*!********************************!*\
  !*** ./output/char25.dtel.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["CHAR25"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(25, {"qualifiedName":"CHAR25","ddicName":"CHAR25"}),
  "domain": "CHAR25",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/char255.dtel.mjs":
/*!*********************************!*\
  !*** ./output/char255.dtel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["CHAR255"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(255, {"qualifiedName":"CHAR255","ddicName":"CHAR255"}),
  "domain": "CHAR255",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/char3.dtel.mjs":
/*!*******************************!*\
  !*** ./output/char3.dtel.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["CHAR3"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(3, {"qualifiedName":"CHAR3","ddicName":"CHAR3"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/char30.dtel.mjs":
/*!********************************!*\
  !*** ./output/char30.dtel.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["CHAR30"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(30, {"qualifiedName":"CHAR30","ddicName":"CHAR30"}),
  "domain": "CHAR30",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/char32.dtel.mjs":
/*!********************************!*\
  !*** ./output/char32.dtel.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["CHAR32"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(32, {"qualifiedName":"CHAR32","ddicName":"CHAR32"}),
  "domain": "CHAR32",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/char4.dtel.mjs":
/*!*******************************!*\
  !*** ./output/char4.dtel.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["CHAR4"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(4, {"qualifiedName":"CHAR4","ddicName":"CHAR4"}),
  "domain": "CHAR4",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/char6.dtel.mjs":
/*!*******************************!*\
  !*** ./output/char6.dtel.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["CHAR6"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(6, {"qualifiedName":"CHAR6","ddicName":"CHAR6"}),
  "domain": "CHAR6",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/char70.dtel.mjs":
/*!********************************!*\
  !*** ./output/char70.dtel.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["CHAR70"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(70, {"qualifiedName":"CHAR70","ddicName":"CHAR70"}),
  "domain": "CHAR70",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/char8.dtel.mjs":
/*!*******************************!*\
  !*** ./output/char8.dtel.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["CHAR8"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(8, {"qualifiedName":"CHAR8","ddicName":"CHAR8"}),
  "domain": "CHAR8",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/char80.dtel.mjs":
/*!********************************!*\
  !*** ./output/char80.dtel.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["CHAR80"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(80, {"qualifiedName":"CHAR80","ddicName":"CHAR80"}),
  "domain": "CHAR80",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/cl_abap_char_utilities.clas.mjs":
/*!************************************************!*\
  !*** ./output/cl_abap_char_utilities.clas.mjs ***!
  \************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_char_utilities": () => (/* binding */ cl_abap_char_utilities)
/* harmony export */ });
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_char_utilities.clas.abap
class cl_abap_char_utilities {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_CHAR_UTILITIES';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"BYTE_ORDER_MARK_UTF8": {"type": () => {return new abap.types.Hex({length: 3});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "BYTE_ORDER_MARK_BIG": {"type": () => {return new abap.types.Hex({length: 2});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "BYTE_ORDER_MARK_LITTLE": {"type": () => {return new abap.types.Hex({length: 2});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CHARSIZE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "ENDIAN": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_endian"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "BACKSPACE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_char1"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CR_LF": {"type": () => {return new abap.types.Character(2, {"qualifiedName":"abap_cr_lf"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "FORM_FEED": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_char1"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "HORIZONTAL_TAB": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_char1"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "NEWLINE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_char1"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "VERTICAL_TAB": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_char1"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "MAXCHAR": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_char1"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "MINCHAR": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_char1"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"CLASS_CONSTRUCTOR": {"visibility": "U", "parameters": {}},
  "GET_SIMPLE_SPACES_FOR_CUR_CP": {"visibility": "U", "parameters": {"S_STR": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.byte_order_mark_utf8 = cl_abap_char_utilities.byte_order_mark_utf8;
    this.byte_order_mark_big = cl_abap_char_utilities.byte_order_mark_big;
    this.byte_order_mark_little = cl_abap_char_utilities.byte_order_mark_little;
    this.charsize = cl_abap_char_utilities.charsize;
    this.endian = cl_abap_char_utilities.endian;
    this.backspace = cl_abap_char_utilities.backspace;
    this.cr_lf = cl_abap_char_utilities.cr_lf;
    this.form_feed = cl_abap_char_utilities.form_feed;
    this.horizontal_tab = cl_abap_char_utilities.horizontal_tab;
    this.newline = cl_abap_char_utilities.newline;
    this.vertical_tab = cl_abap_char_utilities.vertical_tab;
    this.maxchar = cl_abap_char_utilities.maxchar;
    this.minchar = cl_abap_char_utilities.minchar;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async class_constructor() {
    return cl_abap_char_utilities.class_constructor();
  }
  static async class_constructor() {
    cl_abap_char_utilities.maxchar.set(Buffer.from("FDFF", "hex").toString());
    cl_abap_char_utilities.minchar.set(Buffer.from("0000", "hex").toString());
  }
  async get_simple_spaces_for_cur_cp() {
    return cl_abap_char_utilities.get_simple_spaces_for_cur_cp();
  }
  static async get_simple_spaces_for_cur_cp() {
    let s_str = new abap.types.String({qualifiedName: "STRING"});
    abap.statements.concatenate({source: [new abap.types.String().set(` `), cl_abap_char_utilities.horizontal_tab, cl_abap_char_utilities.vertical_tab, cl_abap_char_utilities.newline, cl_abap_char_utilities.cr_lf.getOffset({length: 1}), cl_abap_char_utilities.form_feed], target: s_str});
    return s_str;
  }
}
abap.Classes['CL_ABAP_CHAR_UTILITIES'] = cl_abap_char_utilities;
cl_abap_char_utilities.byte_order_mark_utf8 = new abap.types.Hex({length: 3});
cl_abap_char_utilities.byte_order_mark_utf8.set('EFBBBF');
cl_abap_char_utilities.byte_order_mark_big = new abap.types.Hex({length: 2});
cl_abap_char_utilities.byte_order_mark_big.set('FEFF');
cl_abap_char_utilities.byte_order_mark_little = new abap.types.Hex({length: 2});
cl_abap_char_utilities.byte_order_mark_little.set('FFFE');
cl_abap_char_utilities.charsize = new abap.types.Integer({qualifiedName: "I"});
cl_abap_char_utilities.charsize.set(2);
cl_abap_char_utilities.endian = new abap.types.Character(1, {"qualifiedName":"abap_endian"});
cl_abap_char_utilities.endian.set('L');
cl_abap_char_utilities.backspace = new abap.types.Character(1, {"qualifiedName":"abap_char1"});
cl_abap_char_utilities.backspace.set("\b");
cl_abap_char_utilities.cr_lf = new abap.types.Character(2, {"qualifiedName":"abap_cr_lf"});
cl_abap_char_utilities.cr_lf.set("\r\n");
cl_abap_char_utilities.form_feed = new abap.types.Character(1, {"qualifiedName":"abap_char1"});
cl_abap_char_utilities.form_feed.set("\f");
cl_abap_char_utilities.horizontal_tab = new abap.types.Character(1, {"qualifiedName":"abap_char1"});
cl_abap_char_utilities.horizontal_tab.set("\t");
cl_abap_char_utilities.newline = new abap.types.Character(1, {"qualifiedName":"abap_char1"});
cl_abap_char_utilities.newline.set("\n");
cl_abap_char_utilities.vertical_tab = new abap.types.Character(1, {"qualifiedName":"abap_char1"});
cl_abap_char_utilities.vertical_tab.set("\u000b");
cl_abap_char_utilities.maxchar = new abap.types.Character(1, {"qualifiedName":"abap_char1"});
cl_abap_char_utilities.maxchar.set('_');
cl_abap_char_utilities.minchar = new abap.types.Character(1, {"qualifiedName":"abap_char1"});
cl_abap_char_utilities.minchar.set('_');
await abap.Classes['CL_ABAP_CHAR_UTILITIES'].class_constructor();

//# sourceMappingURL=cl_abap_char_utilities.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_classdescr.clas.mjs":
/*!********************************************!*\
  !*** ./output/cl_abap_classdescr.clas.mjs ***!
  \********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_classdescr": () => (/* binding */ cl_abap_classdescr)
/* harmony export */ });
const {cl_abap_objectdescr} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_objectdescr.clas.mjs */ "./output/cl_abap_objectdescr.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_classdescr.clas.abap
class cl_abap_classdescr extends cl_abap_objectdescr {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_CLASSDESCR';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"GET_CLASS_NAME": {"visibility": "U", "parameters": {"P_NAME": {"type": () => {return new abap.types.Character(200, {"qualifiedName":"abap_abstypename"});}, "is_optional": " "}, "P_OBJECT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});}, "is_optional": " "}}},
  "GET_SUPER_CLASS_TYPE": {"visibility": "U", "parameters": {"P_DESCR_REF": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_CLASSDESCR", RTTIName: "\\CLASS=CL_ABAP_CLASSDESCR"});}, "is_optional": " "}}},
  "CONSTRUCTOR": {"visibility": "U", "parameters": {"P_OBJECT": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    let p_object = INPUT?.p_object || new abap.types.Character(4);
    await super.constructor_({p_object: p_object});
    return this;
  }
  async get_class_name(INPUT) {
    return cl_abap_classdescr.get_class_name(INPUT);
  }
  static async get_class_name(INPUT) {
    let p_name = new abap.types.Character(200, {"qualifiedName":"abap_abstypename"});
    let p_object = INPUT?.p_object;
    if (p_object === undefined) { p_object = new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined}).set(INPUT.p_object); }
    let lv_name = new abap.types.String({qualifiedName: "STRING"});
    lv_name.set(p_object.get().constructor.INTERNAL_NAME);
    p_name.set((await abap.Classes['KERNEL_INTERNAL_NAME'].internal_to_rtti({iv_internal: lv_name})));
    return p_name;
  }
  async get_super_class_type() {
    let p_descr_ref = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_CLASSDESCR", RTTIName: "\\CLASS=CL_ABAP_CLASSDESCR"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return p_descr_ref;
  }
}
abap.Classes['CL_ABAP_CLASSDESCR'] = cl_abap_classdescr;

//# sourceMappingURL=cl_abap_classdescr.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_codepage.clas.mjs":
/*!******************************************!*\
  !*** ./output/cl_abap_codepage.clas.mjs ***!
  \******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_codepage": () => (/* binding */ cl_abap_codepage)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_codepage.clas.abap
class cl_abap_codepage {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_CODEPAGE';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"CONVERT_TO": {"visibility": "U", "parameters": {"OUTPUT": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "CODEPAGE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "SOURCE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "CONVERT_FROM": {"visibility": "U", "parameters": {"OUTPUT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "CODEPAGE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "SOURCE": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "SAP_CODEPAGE": {"visibility": "U", "parameters": {"CODEPAGE": {"type": () => {return new abap.types.Character(20, {"qualifiedName":"abap_encoding"});}, "is_optional": " "}, "ENCODING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async convert_to(INPUT) {
    return cl_abap_codepage.convert_to(INPUT);
  }
  static async convert_to(INPUT) {
    let output = new abap.types.XString({qualifiedName: "XSTRING"});
    let codepage = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.codepage) {codepage.set(INPUT.codepage);}
    let source = INPUT?.source;
    if (source?.getQualifiedName === undefined || source.getQualifiedName() !== "STRING") { source = undefined; }
    if (source === undefined) { source = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.source); }
    let conv = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_CONV_OUT_CE", RTTIName: "\\CLASS=CL_ABAP_CONV_OUT_CE"});
    conv.set((await abap.Classes['CL_ABAP_CONV_OUT_CE'].create({encoding: new abap.types.Character(5).set('UTF-8')})));
    await conv.get().convert({data: source, buffer: output});
    return output;
  }
  async convert_from(INPUT) {
    return cl_abap_codepage.convert_from(INPUT);
  }
  static async convert_from(INPUT) {
    let output = new abap.types.String({qualifiedName: "STRING"});
    let codepage = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.codepage) {codepage.set(INPUT.codepage);}
    let source = INPUT?.source;
    if (source?.getQualifiedName === undefined || source.getQualifiedName() !== "XSTRING") { source = undefined; }
    if (source === undefined) { source = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.source); }
    let conv = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_CONV_IN_CE", RTTIName: "\\CLASS=CL_ABAP_CONV_IN_CE"});
    let data = new abap.types.String({qualifiedName: "STRING"});
    conv.set((await abap.Classes['CL_ABAP_CONV_IN_CE'].create({encoding: new abap.types.Character(5).set('UTF-8')})));
    await conv.get().convert({input: source, data: output});
    return output;
  }
  async sap_codepage(INPUT) {
    return cl_abap_codepage.sap_codepage(INPUT);
  }
  static async sap_codepage(INPUT) {
    let codepage = new abap.types.Character(20, {"qualifiedName":"abap_encoding"});
    let encoding = INPUT?.encoding;
    if (encoding?.getQualifiedName === undefined || encoding.getQualifiedName() !== "STRING") { encoding = undefined; }
    if (encoding === undefined) { encoding = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.encoding); }
    abap.statements.assert(abap.compare.eq(encoding, new abap.types.Character(8).set('UTF-16LE')));
    codepage.set(new abap.types.Character(4).set('4103'));
    return codepage;
  }
}
abap.Classes['CL_ABAP_CODEPAGE'] = cl_abap_codepage;

//# sourceMappingURL=cl_abap_codepage.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_complexdescr.clas.mjs":
/*!**********************************************!*\
  !*** ./output/cl_abap_complexdescr.clas.mjs ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_complexdescr": () => (/* binding */ cl_abap_complexdescr)
/* harmony export */ });
const {cl_abap_datadescr} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_datadescr.clas.mjs */ "./output/cl_abap_datadescr.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_complexdescr.clas.abap
class cl_abap_complexdescr extends cl_abap_datadescr {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_COMPLEXDESCR';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CL_ABAP_COMPLEXDESCR'] = cl_abap_complexdescr;

//# sourceMappingURL=cl_abap_complexdescr.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_conv_codepage.clas.mjs":
/*!***********************************************!*\
  !*** ./output/cl_abap_conv_codepage.clas.mjs ***!
  \***********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_conv_codepage": () => (/* binding */ cl_abap_conv_codepage)
/* harmony export */ });
await __webpack_require__.e(/*! import() */ "output_cl_abap_conv_codepage_clas_locals_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_conv_codepage.clas.locals.mjs */ "./output/cl_abap_conv_codepage.clas.locals.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_conv_codepage.clas.abap
class cl_abap_conv_codepage {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_CONV_CODEPAGE';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"CREATE_IN": {"visibility": "U", "parameters": {"INSTANCE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_ABAP_CONV_IN", RTTIName: "\\INTERFACE=IF_ABAP_CONV_IN"});}, "is_optional": " "}}},
  "CREATE_OUT": {"visibility": "U", "parameters": {"INSTANCE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_ABAP_CONV_OUT", RTTIName: "\\INTERFACE=IF_ABAP_CONV_OUT"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async create_in() {
    return cl_abap_conv_codepage.create_in();
  }
  static async create_in() {
    let instance = new abap.types.ABAPObject({qualifiedName: "IF_ABAP_CONV_IN", RTTIName: "\\INTERFACE=IF_ABAP_CONV_IN"});
    instance.set(await (new abap.Classes['CLAS-CL_ABAP_CONV_CODEPAGE-LCL_IN']()).constructor_());
    return instance;
  }
  async create_out() {
    return cl_abap_conv_codepage.create_out();
  }
  static async create_out() {
    let instance = new abap.types.ABAPObject({qualifiedName: "IF_ABAP_CONV_OUT", RTTIName: "\\INTERFACE=IF_ABAP_CONV_OUT"});
    instance.set(await (new abap.Classes['CLAS-CL_ABAP_CONV_CODEPAGE-LCL_OUT']()).constructor_());
    return instance;
  }
}
abap.Classes['CL_ABAP_CONV_CODEPAGE'] = cl_abap_conv_codepage;

//# sourceMappingURL=cl_abap_conv_codepage.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_conv_in_ce.clas.mjs":
/*!********************************************!*\
  !*** ./output/cl_abap_conv_in_ce.clas.mjs ***!
  \********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_conv_in_ce": () => (/* binding */ cl_abap_conv_in_ce)
/* harmony export */ });
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_conv_in_ce.clas.abap
class cl_abap_conv_in_ce {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_CONV_IN_CE';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"MV_INPUT": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MV_JS_ENCODING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MV_IGNORE_CERR": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "visibility": "I", "is_constant": " ", "is_class": " "}};
  static METHODS = {"CREATE": {"visibility": "U", "parameters": {"RET": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_CONV_IN_CE", RTTIName: "\\CLASS=CL_ABAP_CONV_IN_CE"});}, "is_optional": " "}, "ENCODING": {"type": () => {return new abap.types.Character(20, {"qualifiedName":"abap_encoding"});}, "is_optional": " "}, "INPUT": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "REPLACEMENT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"CHAR1","ddicName":"CHAR1"});}, "is_optional": " "}, "IGNORE_CERR": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "ENDIAN": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"CHAR1","ddicName":"CHAR1"});}, "is_optional": " "}}},
  "UCCPI": {"visibility": "U", "parameters": {"RET": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VALUE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "UCCP": {"visibility": "U", "parameters": {"CHAR_": {"type": () => {return new abap.types.Character(2, {"qualifiedName":"cl_abap_conv_in_ce=>ty_char2"});}, "is_optional": " "}, "UCCP": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "CONVERT": {"visibility": "U", "parameters": {"INPUT": {"type": () => {return new abap.types.Hex();}, "is_optional": " "}, "N": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "DATA": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "READ": {"visibility": "U", "parameters": {"N": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "DATA": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.mv_input = new abap.types.XString({qualifiedName: "XSTRING"});
    this.mv_js_encoding = new abap.types.String({qualifiedName: "STRING"});
    this.mv_ignore_cerr = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async create(INPUT) {
    return cl_abap_conv_in_ce.create(INPUT);
  }
  static async create(INPUT) {
    let ret = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_CONV_IN_CE", RTTIName: "\\CLASS=CL_ABAP_CONV_IN_CE"});
    let encoding = new abap.types.Character(20, {"qualifiedName":"abap_encoding"});
    if (INPUT && INPUT.encoding) {encoding.set(INPUT.encoding);}
    if (INPUT === undefined || INPUT.encoding === undefined) {encoding = new abap.types.Character(5).set('UTF-8');}
    let input = new abap.types.XString({qualifiedName: "XSTRING"});
    if (INPUT && INPUT.input) {input.set(INPUT.input);}
    let replacement = new abap.types.Character(1, {"qualifiedName":"CHAR1","ddicName":"CHAR1"});
    if (INPUT && INPUT.replacement) {replacement.set(INPUT.replacement);}
    if (INPUT === undefined || INPUT.replacement === undefined) {replacement = new abap.types.Character(1).set('#');}
    let ignore_cerr = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.ignore_cerr) {ignore_cerr.set(INPUT.ignore_cerr);}
    if (INPUT === undefined || INPUT.ignore_cerr === undefined) {ignore_cerr = abap.builtin.abap_false;}
    let endian = new abap.types.Character(1, {"qualifiedName":"CHAR1","ddicName":"CHAR1"});
    if (INPUT && INPUT.endian) {endian.set(INPUT.endian);}
    abap.statements.assert(abap.compare.eq(replacement, new abap.types.Character(1).set('#')));
    abap.statements.assert(abap.compare.initial(endian));
    ret.set(await (new abap.Classes['CL_ABAP_CONV_IN_CE']()).constructor_());
    let unique20 = encoding;
    if (abap.compare.eq(unique20, new abap.types.Character(5).set('UTF-8'))) {
      ret.get().mv_js_encoding.set(new abap.types.Character(4).set('utf8'));
    } else if (abap.compare.eq(unique20, new abap.types.Character(4).set('4103'))) {
      ret.get().mv_js_encoding.set(new abap.types.Character(8).set('utf-16le'));
    } else {
      abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(13).set('not supported')));
    }
    ret.get().mv_input.set(input);
    ret.get().mv_ignore_cerr.set(ignore_cerr);
    return ret;
  }
  async uccp(INPUT) {
    return cl_abap_conv_in_ce.uccp(INPUT);
  }
  static async uccp(INPUT) {
    let char_ = new abap.types.Character(2, {"qualifiedName":"cl_abap_conv_in_ce=>ty_char2"});
    let uccp = INPUT?.uccp;
    let int = new abap.types.Integer({qualifiedName: "I"});
    let hex = new abap.types.Hex({length: 2});
    hex.set(uccp);
    int.set(hex);
    try {
      char_.set((await this.uccpi({value: int})));
    } catch (e) {
      if ((abap.Classes['CX_SY_CONVERSION_CODEPAGE'] && e instanceof abap.Classes['CX_SY_CONVERSION_CODEPAGE'])) {
      } else {
        throw e;
      }
    }
    return char_;
  }
  async uccpi(INPUT) {
    return cl_abap_conv_in_ce.uccpi(INPUT);
  }
  static async uccpi(INPUT) {
    let ret = new abap.types.String({qualifiedName: "STRING"});
    let value = INPUT?.value;
    if (value?.getQualifiedName === undefined || value.getQualifiedName() !== "I") { value = undefined; }
    if (value === undefined) { value = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.value); }
    let lv_hex = new abap.types.Hex({length: 2});
    let lo_in = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_CONV_IN_CE", RTTIName: "\\CLASS=CL_ABAP_CONV_IN_CE"});
    lv_hex.set(value);
    abap.statements.concatenate({source: [lv_hex.getOffset({offset: 1, length: 1}), lv_hex.getOffset({length: 1})], target: lv_hex});
    lo_in.set((await this.create({encoding: new abap.types.Character(4).set('4103')})));
    await lo_in.get().convert({input: lv_hex, data: ret});
    return ret;
  }
  async convert(INPUT) {
    let input = INPUT?.input;
    let n = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.n) {n.set(INPUT.n);}
    let data = INPUT?.data || new abap.types.String({qualifiedName: "STRING"});
    let lv_error = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    abap.statements.assert(abap.compare.initial(this.mv_js_encoding) === false);
    let buf = Buffer.from(input.get(), "hex");
    const decoder = TextDecoder || await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_util_util_js"), __webpack_require__.e("_d679")]).then(__webpack_require__.t.bind(__webpack_require__, /*! util */ "./node_modules/util/util.js", 19)).TextDecoder;
    const td = new decoder(this.mv_js_encoding.get(), {fatal: this.mv_ignore_cerr.get() !== "X"});
    try {
        data.set(td.decode(buf));
    } catch {
      lv_error.set(abap.builtin.abap_true);
    }
    if (abap.compare.eq(lv_error, abap.builtin.abap_true)) {
      const unique21 = await (new abap.Classes['CX_SY_CONVERSION_CODEPAGE']()).constructor_();
      unique21.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_conv_in_ce.clas.abap","INTERNAL_LINE": 111};
      throw unique21;
    }
  }
  async read(INPUT) {
    let n = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.n) {n.set(INPUT.n);}
    let data = INPUT?.data || new abap.types.String({qualifiedName: "STRING"});
    await this.convert({input: this.mv_input, n: n, data: data});
  }
}
abap.Classes['CL_ABAP_CONV_IN_CE'] = cl_abap_conv_in_ce;
cl_abap_conv_in_ce.ty_char2 = new abap.types.Character(2, {"qualifiedName":"cl_abap_conv_in_ce=>ty_char2"});

//# sourceMappingURL=cl_abap_conv_in_ce.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_conv_out_ce.clas.mjs":
/*!*********************************************!*\
  !*** ./output/cl_abap_conv_out_ce.clas.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_conv_out_ce": () => (/* binding */ cl_abap_conv_out_ce)
/* harmony export */ });
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_conv_out_ce.clas.abap
class cl_abap_conv_out_ce {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_CONV_OUT_CE';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"MV_JS_ENCODING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MV_BUFFER": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "visibility": "I", "is_constant": " ", "is_class": " "}};
  static METHODS = {"CREATE": {"visibility": "U", "parameters": {"RET": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_CONV_OUT_CE", RTTIName: "\\CLASS=CL_ABAP_CONV_OUT_CE"});}, "is_optional": " "}, "ENCODING": {"type": () => {return new abap.types.Character(20, {"qualifiedName":"abap_encoding"});}, "is_optional": " "}, "IGNORE_CERR": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "ENDIAN": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "REPLACEMENT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "UCCPI": {"visibility": "U", "parameters": {"RET": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "CHAR_": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "UCCP": {"visibility": "U", "parameters": {"UCCP": {"type": () => {return new abap.types.Hex({length: 2});}, "is_optional": " "}, "CHAR_": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "CONVERT": {"visibility": "U", "parameters": {"DATA": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "N": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "BUFFER": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "WRITE": {"visibility": "U", "parameters": {"DATA": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "GET_BUFFER": {"visibility": "U", "parameters": {"BUFFER": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "RESET": {"visibility": "U", "parameters": {}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.mv_js_encoding = new abap.types.String({qualifiedName: "STRING"});
    this.mv_buffer = new abap.types.XString({qualifiedName: "XSTRING"});
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async create(INPUT) {
    return cl_abap_conv_out_ce.create(INPUT);
  }
  static async create(INPUT) {
    let ret = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_CONV_OUT_CE", RTTIName: "\\CLASS=CL_ABAP_CONV_OUT_CE"});
    let encoding = new abap.types.Character(20, {"qualifiedName":"abap_encoding"});
    if (INPUT && INPUT.encoding) {encoding.set(INPUT.encoding);}
    let ignore_cerr = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.ignore_cerr) {ignore_cerr.set(INPUT.ignore_cerr);}
    if (INPUT === undefined || INPUT.ignore_cerr === undefined) {ignore_cerr = abap.builtin.abap_false;}
    let endian = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.endian) {endian.set(INPUT.endian);}
    let replacement = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.replacement) {replacement.set(INPUT.replacement);}
    ret.set(await (new abap.Classes['CL_ABAP_CONV_OUT_CE']()).constructor_());
    let unique22 = encoding;
    if (abap.compare.eq(unique22, new abap.types.Character(5).set('UTF-8')) || abap.compare.eq(unique22, new abap.types.Character(1).set(''))) {
      ret.get().mv_js_encoding.set(new abap.types.Character(4).set('utf8'));
    } else if (abap.compare.eq(unique22, new abap.types.Character(4).set('4103'))) {
      ret.get().mv_js_encoding.set(new abap.types.Character(7).set('utf16le'));
    } else {
      abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(13).set('not supported')));
    }
    return ret;
  }
  async uccpi(INPUT) {
    return cl_abap_conv_out_ce.uccpi(INPUT);
  }
  static async uccpi(INPUT) {
    let ret = new abap.types.Integer({qualifiedName: "I"});
    let char_ = INPUT?.char_;
    let lo_out = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_CONV_OUT_CE", RTTIName: "\\CLASS=CL_ABAP_CONV_OUT_CE"});
    let lv_hex = new abap.types.XString({qualifiedName: "XSTRING"});
    lo_out.set((await this.create({encoding: new abap.types.Character(4).set('4103')})));
    await lo_out.get().convert({data: char_, buffer: lv_hex});
    abap.statements.assert(abap.compare.eq(abap.builtin.xstrlen({val: lv_hex}), abap.IntegerFactory.get(2)));
    ret.set(lv_hex.getOffset({length: 1}));
    ret.set(abap.operators.add(ret,abap.operators.multiply(lv_hex.getOffset({offset: 1, length: 1}),new abap.types.Integer().set(255))));
    return ret;
  }
  async write(INPUT) {
    let data = INPUT?.data;
    let res = new abap.types.XString({qualifiedName: "XSTRING"});
    await this.convert({data: data, buffer: res});
    abap.statements.concatenate({source: [this.mv_buffer, res], target: this.mv_buffer});
  }
  async get_buffer() {
    let buffer = new abap.types.XString({qualifiedName: "XSTRING"});
    buffer.set(this.mv_buffer);
    return buffer;
  }
  async uccp(INPUT) {
    return cl_abap_conv_out_ce.uccp(INPUT);
  }
  static async uccp(INPUT) {
    let uccp = new abap.types.Hex({length: 2});
    let char_ = INPUT?.char_;
    let lv_char = new abap.types.Character(1, {});
    let lo_obj = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_CONV_OUT_CE", RTTIName: "\\CLASS=CL_ABAP_CONV_OUT_CE"});
    lv_char.set(char_.getOffset({length: 1}));
    lo_obj.set((await this.create({encoding: new abap.types.Character(4).set('4103')})));
    await lo_obj.get().convert({data: lv_char, buffer: uccp});
    abap.statements.shift(uccp, {direction: 'LEFT',circular: true,mode: 'BYTE'});
    return uccp;
  }
  async reset() {
    abap.statements.clear(this.mv_buffer);
  }
  async convert(INPUT) {
    let data = INPUT?.data;
    let n = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.n) {n.set(INPUT.n);}
    let buffer = INPUT?.buffer || new abap.types.XString({qualifiedName: "XSTRING"});
    let lv_str = new abap.types.String({qualifiedName: "STRING"});
    let result = "";
    if (INPUT && INPUT.n) {
      lv_str.set(data);
      lv_str.set(lv_str.getOffset({length: n}));
      result = Buffer.from(lv_str.get(), this.mv_js_encoding.get()).toString("hex");
    } else {
      result = Buffer.from(data.get(), this.mv_js_encoding.get()).toString("hex");
    }
    buffer.set(result.toUpperCase());
  }
}
abap.Classes['CL_ABAP_CONV_OUT_CE'] = cl_abap_conv_out_ce;
cl_abap_conv_out_ce.hex02 = new abap.types.Hex({length: 2});

//# sourceMappingURL=cl_abap_conv_out_ce.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_datadescr.clas.mjs":
/*!*******************************************!*\
  !*** ./output/cl_abap_datadescr.clas.mjs ***!
  \*******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_datadescr": () => (/* binding */ cl_abap_datadescr)
/* harmony export */ });
const {cl_abap_typedescr} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_typedescr.clas.mjs */ "./output/cl_abap_typedescr.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_datadescr.clas.abap
class cl_abap_datadescr extends cl_abap_typedescr {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_DATADESCR';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"GET_DATA_TYPE_KIND": {"visibility": "U", "parameters": {"P_TYPE_KIND": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "is_optional": " "}, "P_DATA": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "APPLIES_TO_DATA": {"visibility": "U", "parameters": {"P_FLAG": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "P_DATA": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async get_data_type_kind(INPUT) {
    return cl_abap_datadescr.get_data_type_kind(INPUT);
  }
  static async get_data_type_kind(INPUT) {
    let p_type_kind = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
    let p_data = INPUT?.p_data;
    let descr = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});
    descr.set((await abap.Classes['CL_ABAP_TYPEDESCR'].describe_by_data({p_data: p_data})));
    p_type_kind.set(descr.get().type_kind);
    return p_type_kind;
  }
  async applies_to_data(INPUT) {
    let p_flag = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    let p_data = INPUT?.p_data;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return p_flag;
  }
}
abap.Classes['CL_ABAP_DATADESCR'] = cl_abap_datadescr;

//# sourceMappingURL=cl_abap_datadescr.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_datfm.clas.mjs":
/*!***************************************!*\
  !*** ./output/cl_abap_datfm.clas.mjs ***!
  \***************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_datfm": () => (/* binding */ cl_abap_datfm)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_datfm.clas.abap
class cl_abap_datfm {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_DATFM';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"DDMMYYYY_DOT_SEPERATED": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "I", "is_constant": "X", "is_class": "X"},
  "YYYYMMDD_DOT_SEPERATED": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "I", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"CONV_DATE_EXT_TO_INT": {"visibility": "U", "parameters": {"IM_DATEXT": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "IM_DATFMDES": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"CHAR1","ddicName":"CHAR1"});}, "is_optional": " "}, "EX_DATINT": {"type": () => {return new abap.types.Date({qualifiedName: "D"});}, "is_optional": " "}, "EX_DATFMUSED": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"CHAR1","ddicName":"CHAR1"});}, "is_optional": " "}}},
  "GET_DATE_FORMAT_DES": {"visibility": "U", "parameters": {"IM_DATFM": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"CHAR1","ddicName":"CHAR1"});}, "is_optional": " "}, "IM_LANGU": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"SPRAS","ddicName":"SPRAS"});}, "is_optional": " "}, "IM_PLAIN": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "IM_LONG": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "EX_DATEFORMAT": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "CONV_PERIOD_EXT_TO_INT": {"visibility": "U", "parameters": {"IM_PERIODEXT": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "EX_PERIODINT": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.ddmmyyyy_dot_seperated = cl_abap_datfm.ddmmyyyy_dot_seperated;
    this.yyyymmdd_dot_seperated = cl_abap_datfm.yyyymmdd_dot_seperated;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async conv_period_ext_to_int(INPUT) {
    return cl_abap_datfm.conv_period_ext_to_int(INPUT);
  }
  static async conv_period_ext_to_int(INPUT) {
    let im_periodext = INPUT?.im_periodext;
    let ex_periodint = INPUT?.ex_periodint || new abap.types.Character();
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async conv_date_ext_to_int(INPUT) {
    return cl_abap_datfm.conv_date_ext_to_int(INPUT);
  }
  static async conv_date_ext_to_int(INPUT) {
    let im_datext = INPUT?.im_datext;
    let im_datfmdes = new abap.types.Character(1, {"qualifiedName":"CHAR1","ddicName":"CHAR1"});
    if (INPUT && INPUT.im_datfmdes) {im_datfmdes.set(INPUT.im_datfmdes);}
    let ex_datint = INPUT?.ex_datint || new abap.types.Date({qualifiedName: "D"});
    let ex_datfmused = INPUT?.ex_datfmused || new abap.types.Character(1, {"qualifiedName":"CHAR1","ddicName":"CHAR1"});
    let regex_ddmmyyyy_dot_seperated = new abap.types.String({qualifiedName: "STRING"});
    regex_ddmmyyyy_dot_seperated.set('^(0[0-9]|[12][0-9]|3[01])[- \\..](0[0-9]|1[012])[- \\..]\\d\\d\\d\\d$');
    let regex_yyyymmdd_dot_seperated = new abap.types.String({qualifiedName: "STRING"});
    regex_yyyymmdd_dot_seperated.set('^\\d\\d\\d\\d[- \\..](0[0-9]|1[012])[- \\..](0[0-9]|[12][0-9]|3[01])$');
    let regex_yyyymmdd_no_dot = new abap.types.String({qualifiedName: "STRING"});
    regex_yyyymmdd_no_dot.set('^(\\d{4})(0[0-9]|1[012])(0[0-9]|[12][0-9]|3[01])$');
    if (abap.compare.ne(im_datfmdes, cl_abap_datfm.ddmmyyyy_dot_seperated) && abap.compare.ne(im_datfmdes, cl_abap_datfm.yyyymmdd_dot_seperated)) {
      const unique28 = await (new abap.Classes['CX_ABAP_DATFM']()).constructor_();
      unique28.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_datfm.clas.abap","INTERNAL_LINE": 50};
      throw unique28;
    }
    abap.statements.find(im_datext, {regex: regex_ddmmyyyy_dot_seperated, first: false});
    if (abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
      ex_datint.set(abap.operators.concat(im_datext.getOffset({offset: 6, length: 4}),abap.operators.concat(im_datext.getOffset({offset: 3, length: 2}),im_datext.getOffset({length: 2}))));
      ex_datfmused.set(cl_abap_datfm.ddmmyyyy_dot_seperated);
      return;
    }
    abap.statements.find(im_datext, {regex: regex_yyyymmdd_dot_seperated, first: false});
    if (abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
      ex_datint.set(abap.operators.concat(im_datext.getOffset({length: 4}),abap.operators.concat(im_datext.getOffset({offset: 5, length: 2}),im_datext.getOffset({offset: 8, length: 2}))));
      ex_datfmused.set(cl_abap_datfm.yyyymmdd_dot_seperated);
      return;
    }
    abap.statements.find(im_datext, {regex: regex_yyyymmdd_no_dot, first: false});
    if (abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
      ex_datint.set(im_datext);
      ex_datfmused.set(cl_abap_datfm.yyyymmdd_dot_seperated);
      return;
    }
    const unique29 = await (new abap.Classes['CX_ABAP_DATFM']()).constructor_();
    unique29.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_datfm.clas.abap","INTERNAL_LINE": 74};
    throw unique29;
  }
  async get_date_format_des(INPUT) {
    return cl_abap_datfm.get_date_format_des(INPUT);
  }
  static async get_date_format_des(INPUT) {
    let im_datfm = new abap.types.Character(1, {"qualifiedName":"CHAR1","ddicName":"CHAR1"});
    if (INPUT && INPUT.im_datfm) {im_datfm.set(INPUT.im_datfm);}
    let im_langu = new abap.types.Character(1, {"qualifiedName":"SPRAS","ddicName":"SPRAS"});
    if (INPUT && INPUT.im_langu) {im_langu.set(INPUT.im_langu);}
    if (INPUT === undefined || INPUT.im_langu === undefined) {im_langu = abap.builtin.sy.get().langu;}
    let im_plain = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.im_plain) {im_plain.set(INPUT.im_plain);}
    if (INPUT === undefined || INPUT.im_plain === undefined) {im_plain = abap.builtin.abap_false;}
    let im_long = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.im_long) {im_long.set(INPUT.im_long);}
    if (INPUT === undefined || INPUT.im_long === undefined) {im_long = abap.builtin.abap_false;}
    let ex_dateformat = INPUT?.ex_dateformat || new abap.types.Character();
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
}
abap.Classes['CL_ABAP_DATFM'] = cl_abap_datfm;
cl_abap_datfm.ddmmyyyy_dot_seperated = new abap.types.Character(1, {});
cl_abap_datfm.ddmmyyyy_dot_seperated.set('1');
cl_abap_datfm.yyyymmdd_dot_seperated = new abap.types.Character(1, {});
cl_abap_datfm.yyyymmdd_dot_seperated.set('4');

//# sourceMappingURL=cl_abap_datfm.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_dyn_prg.clas.mjs":
/*!*****************************************!*\
  !*** ./output/cl_abap_dyn_prg.clas.mjs ***!
  \*****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_dyn_prg": () => (/* binding */ cl_abap_dyn_prg)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_dyn_prg.clas.abap
class cl_abap_dyn_prg {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_DYN_PRG';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"CHECK_TABLE_NAME_STR": {"visibility": "U", "parameters": {"VAL_STR": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VAL": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "PACKAGES": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "CHECK_WHITELIST_STR": {"visibility": "U", "parameters": {"VAL_STR": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VAL": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "WHITELIST": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "QUOTE": {"visibility": "U", "parameters": {"OUT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VAL": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "ESCAPE_QUOTES": {"visibility": "U", "parameters": {"OUT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VAL": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "ESCAPE_XSS_XML_HTML": {"visibility": "U", "parameters": {"OUT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VAL": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "ESCAPE_XSS_URL": {"visibility": "U", "parameters": {"OUT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VAL": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async check_table_name_str(INPUT) {
    return cl_abap_dyn_prg.check_table_name_str(INPUT);
  }
  static async check_table_name_str(INPUT) {
    let val_str = new abap.types.String({qualifiedName: "STRING"});
    let val = INPUT?.val;
    let packages = INPUT?.packages;
    val_str.set(val);
    return val_str;
  }
  async check_whitelist_str(INPUT) {
    return cl_abap_dyn_prg.check_whitelist_str(INPUT);
  }
  static async check_whitelist_str(INPUT) {
    let val_str = new abap.types.String({qualifiedName: "STRING"});
    let val = INPUT?.val;
    let whitelist = INPUT?.whitelist;
    val_str.set(val);
    return val_str;
  }
  async quote(INPUT) {
    return cl_abap_dyn_prg.quote(INPUT);
  }
  static async quote(INPUT) {
    let out = new abap.types.String({qualifiedName: "STRING"});
    let val = INPUT?.val;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return out;
  }
  async escape_xss_url(INPUT) {
    return cl_abap_dyn_prg.escape_xss_url(INPUT);
  }
  static async escape_xss_url(INPUT) {
    let out = new abap.types.String({qualifiedName: "STRING"});
    let val = INPUT?.val;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return out;
  }
  async escape_quotes(INPUT) {
    return cl_abap_dyn_prg.escape_quotes(INPUT);
  }
  static async escape_quotes(INPUT) {
    let out = new abap.types.String({qualifiedName: "STRING"});
    let val = INPUT?.val;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return out;
  }
  async escape_xss_xml_html(INPUT) {
    return cl_abap_dyn_prg.escape_xss_xml_html(INPUT);
  }
  static async escape_xss_xml_html(INPUT) {
    let out = new abap.types.String({qualifiedName: "STRING"});
    let val = INPUT?.val;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return out;
  }
}
abap.Classes['CL_ABAP_DYN_PRG'] = cl_abap_dyn_prg;

//# sourceMappingURL=cl_abap_dyn_prg.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_elemdescr.clas.mjs":
/*!*******************************************!*\
  !*** ./output/cl_abap_elemdescr.clas.mjs ***!
  \*******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_elemdescr": () => (/* binding */ cl_abap_elemdescr)
/* harmony export */ });
const {cl_abap_datadescr} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_datadescr.clas.mjs */ "./output/cl_abap_datadescr.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_elemdescr.clas.abap
class cl_abap_elemdescr extends cl_abap_datadescr {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_ELEMDESCR';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"OUTPUT_LENGTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "EDIT_MASK": {"type": () => {return new abap.types.Character(7, {"qualifiedName":"abap_editmask"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "HELP_ID": {"type": () => {return new abap.types.Character(62, {"qualifiedName":"abap_helpid"});}, "visibility": "U", "is_constant": " ", "is_class": " "}};
  static METHODS = {"GET_DDIC_FIXED_VALUES": {"visibility": "U", "parameters": {"P_FIXED_VALUES": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"low": new abap.types.Character(10, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-low"}), "high": new abap.types.Character(10, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-high"}), "option": new abap.types.Character(2, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-option"}), "ddlanguage": new abap.types.Character(1, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-ddlanguage"}), "ddtext": new abap.types.Character(60, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-ddtext"})}, "cl_abap_elemdescr=>fixvalue", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "cl_abap_elemdescr=>fixvalues");}, "is_optional": " "}}},
  "GET_DDIC_FIELD": {"visibility": "U", "parameters": {"P_FLDDESCR": {"type": () => {return new abap.types.Structure({"tabname": new abap.types.Character(30, {}), "fieldname": new abap.types.Character(30, {}), "langu": new abap.types.Character(1, {}), "position": new abap.types.Numc({length: 4}), "offset": new abap.types.Numc({length: 6}), "domname": new abap.types.Character(30, {}), "rollname": new abap.types.Character(30, {}), "checktable": new abap.types.Character(1, {}), "leng": new abap.types.Numc({length: 6}), "intlen": new abap.types.Numc({length: 6}), "outputlen": new abap.types.Numc({length: 6}), "decimals": new abap.types.Numc({length: 6}), "datatype": new abap.types.Character(1, {}), "inttype": new abap.types.Character(1, {}), "reftable": new abap.types.Character(1, {}), "reffield": new abap.types.Character(1, {}), "precfield": new abap.types.Character(1, {}), "authorid": new abap.types.Character(1, {}), "memoryid": new abap.types.Character(1, {}), "logflag": new abap.types.Character(1, {}), "mask": new abap.types.Character(20, {}), "masklen": new abap.types.Character(1, {}), "convexit": new abap.types.Character(1, {}), "headlen": new abap.types.Character(1, {}), "scrlen1": new abap.types.Character(1, {}), "scrlen2": new abap.types.Character(1, {}), "scrlen3": new abap.types.Character(1, {}), "fieldtext": new abap.types.Character(1, {}), "reptext": new abap.types.Character(1, {}), "scrtext_s": new abap.types.Character(1, {}), "scrtext_m": new abap.types.Character(1, {}), "scrtext_l": new abap.types.Character(1, {}), "keyflag": new abap.types.Character(1, {}), "lowercase": new abap.types.Character(1, {}), "mac": new abap.types.Character(1, {}), "genkey": new abap.types.Character(1, {}), "noforkey": new abap.types.Character(1, {}), "valexi": new abap.types.Character(1, {}), "noauthch": new abap.types.Character(1, {}), "sign": new abap.types.Character(1, {}), "dynpfld": new abap.types.Character(1, {}), "f4availabl": new abap.types.Character(1, {}), "comptype": new abap.types.Character(1, {}), "outputstyle": new abap.types.Character(1, {}), "lfieldname": new abap.types.Character(132, {})}, "DFIES", "DFIES", {}, {});}, "is_optional": " "}, "P_LANGU": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"sy-langu","conversionExit":"ISOLA"});}, "is_optional": " "}}},
  "GET_I": {"visibility": "U", "parameters": {"R_RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});}, "is_optional": " "}}},
  "GET_INT8": {"visibility": "U", "parameters": {"R_RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});}, "is_optional": " "}}},
  "GET_F": {"visibility": "U", "parameters": {"R_RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});}, "is_optional": " "}}},
  "GET_D": {"visibility": "U", "parameters": {"R_RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});}, "is_optional": " "}}},
  "GET_T": {"visibility": "U", "parameters": {"R_RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});}, "is_optional": " "}}},
  "GET_DECFLOAT16": {"visibility": "U", "parameters": {"R_RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});}, "is_optional": " "}}},
  "GET_DECFLOAT34": {"visibility": "U", "parameters": {"R_RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});}, "is_optional": " "}}},
  "GET_STRING": {"visibility": "U", "parameters": {"P_RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});}, "is_optional": " "}}},
  "GET_C": {"visibility": "U", "parameters": {"P_RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});}, "is_optional": " "}, "P_LENGTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_P": {"visibility": "U", "parameters": {"P_RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});}, "is_optional": " "}, "P_LENGTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "P_DECIMALS": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_N": {"visibility": "U", "parameters": {"P_RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});}, "is_optional": " "}, "P_LENGTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_X": {"visibility": "U", "parameters": {"P_RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});}, "is_optional": " "}, "P_LENGTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_XSTRING": {"visibility": "U", "parameters": {"P_RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.output_length = new abap.types.Integer({qualifiedName: "I"});
    this.edit_mask = new abap.types.Character(7, {"qualifiedName":"abap_editmask"});
    this.help_id = new abap.types.Character(62, {"qualifiedName":"abap_helpid"});
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async get_p(INPUT) {
    return cl_abap_elemdescr.get_p(INPUT);
  }
  static async get_p(INPUT) {
    let p_result = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});
    let p_length = INPUT?.p_length;
    if (p_length?.getQualifiedName === undefined || p_length.getQualifiedName() !== "I") { p_length = undefined; }
    if (p_length === undefined) { p_length = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.p_length); }
    let p_decimals = INPUT?.p_decimals;
    if (p_decimals?.getQualifiedName === undefined || p_decimals.getQualifiedName() !== "I") { p_decimals = undefined; }
    if (p_decimals === undefined) { p_decimals = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.p_decimals); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return p_result;
  }
  async get_decfloat16() {
    return cl_abap_elemdescr.get_decfloat16();
  }
  static async get_decfloat16() {
    let r_result = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return r_result;
  }
  async get_decfloat34() {
    return cl_abap_elemdescr.get_decfloat34();
  }
  static async get_decfloat34() {
    let r_result = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return r_result;
  }
  async get_n(INPUT) {
    return cl_abap_elemdescr.get_n(INPUT);
  }
  static async get_n(INPUT) {
    let p_result = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});
    let p_length = INPUT?.p_length;
    if (p_length?.getQualifiedName === undefined || p_length.getQualifiedName() !== "I") { p_length = undefined; }
    if (p_length === undefined) { p_length = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.p_length); }
    let foo = new abap.types.DataReference(new abap.types.Character(4));
    abap.statements.createData(foo,{"typeName": "N","length": p_length});
    await abap.statements.cast(p_result, (await abap.Classes['CL_ABAP_TYPEDESCR'].describe_by_data_ref({p_data_ref: foo})));
    return p_result;
  }
  async get_x(INPUT) {
    return cl_abap_elemdescr.get_x(INPUT);
  }
  static async get_x(INPUT) {
    let p_result = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});
    let p_length = INPUT?.p_length;
    if (p_length?.getQualifiedName === undefined || p_length.getQualifiedName() !== "I") { p_length = undefined; }
    if (p_length === undefined) { p_length = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.p_length); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return p_result;
  }
  async get_xstring() {
    return cl_abap_elemdescr.get_xstring();
  }
  static async get_xstring() {
    let p_result = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return p_result;
  }
  async get_ddic_field(INPUT) {
    let p_flddescr = new abap.types.Structure({"tabname": new abap.types.Character(30, {}), "fieldname": new abap.types.Character(30, {}), "langu": new abap.types.Character(1, {}), "position": new abap.types.Numc({length: 4}), "offset": new abap.types.Numc({length: 6}), "domname": new abap.types.Character(30, {}), "rollname": new abap.types.Character(30, {}), "checktable": new abap.types.Character(1, {}), "leng": new abap.types.Numc({length: 6}), "intlen": new abap.types.Numc({length: 6}), "outputlen": new abap.types.Numc({length: 6}), "decimals": new abap.types.Numc({length: 6}), "datatype": new abap.types.Character(1, {}), "inttype": new abap.types.Character(1, {}), "reftable": new abap.types.Character(1, {}), "reffield": new abap.types.Character(1, {}), "precfield": new abap.types.Character(1, {}), "authorid": new abap.types.Character(1, {}), "memoryid": new abap.types.Character(1, {}), "logflag": new abap.types.Character(1, {}), "mask": new abap.types.Character(20, {}), "masklen": new abap.types.Character(1, {}), "convexit": new abap.types.Character(1, {}), "headlen": new abap.types.Character(1, {}), "scrlen1": new abap.types.Character(1, {}), "scrlen2": new abap.types.Character(1, {}), "scrlen3": new abap.types.Character(1, {}), "fieldtext": new abap.types.Character(1, {}), "reptext": new abap.types.Character(1, {}), "scrtext_s": new abap.types.Character(1, {}), "scrtext_m": new abap.types.Character(1, {}), "scrtext_l": new abap.types.Character(1, {}), "keyflag": new abap.types.Character(1, {}), "lowercase": new abap.types.Character(1, {}), "mac": new abap.types.Character(1, {}), "genkey": new abap.types.Character(1, {}), "noforkey": new abap.types.Character(1, {}), "valexi": new abap.types.Character(1, {}), "noauthch": new abap.types.Character(1, {}), "sign": new abap.types.Character(1, {}), "dynpfld": new abap.types.Character(1, {}), "f4availabl": new abap.types.Character(1, {}), "comptype": new abap.types.Character(1, {}), "outputstyle": new abap.types.Character(1, {}), "lfieldname": new abap.types.Character(132, {})}, "DFIES", "DFIES", {}, {});
    let p_langu = new abap.types.Character(1, {"qualifiedName":"sy-langu","conversionExit":"ISOLA"});
    if (INPUT && INPUT.p_langu) {p_langu.set(INPUT.p_langu);}
    if (INPUT === undefined || INPUT.p_langu === undefined) {p_langu = abap.builtin.sy.get().langu;}
    p_flddescr.get().tabname.set(this.absolute_name);
    p_flddescr.get().inttype.set(this.type_kind);
    p_flddescr.get().langu.set(abap.builtin.sy.get().langu);
    p_flddescr.get().position.set(abap.IntegerFactory.get(1));
    p_flddescr.get().leng.set(this.length);
    p_flddescr.get().decimals.set(this.decimals);
    p_flddescr.get().domname.set(abap.DDIC[this.relative_name.get()]?.domain || "");
    return p_flddescr;
  }
  async get_i() {
    return cl_abap_elemdescr.get_i();
  }
  static async get_i() {
    let r_result = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});
    let foo = new abap.types.Integer({qualifiedName: "I"});
    await abap.statements.cast(r_result, (await abap.Classes['CL_ABAP_TYPEDESCR'].describe_by_data({p_data: foo})));
    return r_result;
  }
  async get_int8() {
    return cl_abap_elemdescr.get_int8();
  }
  static async get_int8() {
    let r_result = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});
    let foo = new abap.types.Integer8({qualifiedName: "INT8"});
    await abap.statements.cast(r_result, (await abap.Classes['CL_ABAP_TYPEDESCR'].describe_by_data({p_data: foo})));
    return r_result;
  }
  async get_string() {
    return cl_abap_elemdescr.get_string();
  }
  static async get_string() {
    let p_result = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});
    let foo = new abap.types.String({qualifiedName: "STRING"});
    await abap.statements.cast(p_result, (await abap.Classes['CL_ABAP_TYPEDESCR'].describe_by_data({p_data: foo})));
    return p_result;
  }
  async get_f() {
    return cl_abap_elemdescr.get_f();
  }
  static async get_f() {
    let r_result = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});
    let foo = new abap.types.Float({qualifiedName: "F"});
    await abap.statements.cast(r_result, (await abap.Classes['CL_ABAP_TYPEDESCR'].describe_by_data({p_data: foo})));
    return r_result;
  }
  async get_d() {
    return cl_abap_elemdescr.get_d();
  }
  static async get_d() {
    let r_result = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});
    let foo = new abap.types.Date({qualifiedName: "D"});
    await abap.statements.cast(r_result, (await abap.Classes['CL_ABAP_TYPEDESCR'].describe_by_data({p_data: foo})));
    return r_result;
  }
  async get_t() {
    return cl_abap_elemdescr.get_t();
  }
  static async get_t() {
    let r_result = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});
    let foo = new abap.types.Time({qualifiedName: "T"});
    await abap.statements.cast(r_result, (await abap.Classes['CL_ABAP_TYPEDESCR'].describe_by_data({p_data: foo})));
    return r_result;
  }
  async get_c(INPUT) {
    return cl_abap_elemdescr.get_c(INPUT);
  }
  static async get_c(INPUT) {
    let p_result = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});
    let p_length = INPUT?.p_length;
    if (p_length?.getQualifiedName === undefined || p_length.getQualifiedName() !== "I") { p_length = undefined; }
    if (p_length === undefined) { p_length = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.p_length); }
    let foo = new abap.types.DataReference(new abap.types.Character(4));
    abap.statements.createData(foo,{"typeName": "C","length": p_length});
    await abap.statements.cast(p_result, (await abap.Classes['CL_ABAP_TYPEDESCR'].describe_by_data_ref({p_data_ref: foo})));
    return p_result;
  }
  async get_ddic_fixed_values() {
    let p_fixed_values = abap.types.TableFactory.construct(new abap.types.Structure({"low": new abap.types.Character(10, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-low"}), "high": new abap.types.Character(10, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-high"}), "option": new abap.types.Character(2, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-option"}), "ddlanguage": new abap.types.Character(1, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-ddlanguage"}), "ddtext": new abap.types.Character(60, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-ddtext"})}, "cl_abap_elemdescr=>fixvalue", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "cl_abap_elemdescr=>fixvalues");
    let lv_dummy = new abap.types.String({qualifiedName: "STRING"});
    let lv_name = new abap.types.String({qualifiedName: "STRING"});
    let ls_row = new abap.types.Structure({"low": new abap.types.Character(10, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-low"}), "high": new abap.types.Character(10, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-high"}), "option": new abap.types.Character(2, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-option"}), "ddlanguage": new abap.types.Character(1, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-ddlanguage"}), "ddtext": new abap.types.Character(60, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-ddtext"})}, "cl_abap_elemdescr=>fixvalue", undefined, {}, {});
    abap.statements.split({source: this.absolute_name, at: new abap.types.Character(1).set('='), targets: [lv_dummy,lv_name]});
    for (const f of abap.DDIC[lv_name.get()]?.fixedValues || []) {
      abap.statements.clear(ls_row);
        ls_row.get().low.set(f.low || "");
        ls_row.get().high.set(f.high || "");
        ls_row.get().option.set(f.option || "");
        ls_row.get().ddlanguage.set(f.ddlanguage || "");
        ls_row.get().ddtext.set(f.ddtext || "");
      abap.statements.append({source: ls_row, target: p_fixed_values});
    }
    return p_fixed_values;
  }
}
abap.Classes['CL_ABAP_ELEMDESCR'] = cl_abap_elemdescr;
cl_abap_elemdescr.fixvalue = new abap.types.Structure({"low": new abap.types.Character(10, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-low"}), "high": new abap.types.Character(10, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-high"}), "option": new abap.types.Character(2, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-option"}), "ddlanguage": new abap.types.Character(1, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-ddlanguage"}), "ddtext": new abap.types.Character(60, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-ddtext"})}, "cl_abap_elemdescr=>fixvalue", undefined, {}, {});
cl_abap_elemdescr.fixvalues = abap.types.TableFactory.construct(new abap.types.Structure({"low": new abap.types.Character(10, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-low"}), "high": new abap.types.Character(10, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-high"}), "option": new abap.types.Character(2, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-option"}), "ddlanguage": new abap.types.Character(1, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-ddlanguage"}), "ddtext": new abap.types.Character(60, {"qualifiedName":"cl_abap_elemdescr=>fixvalue-ddtext"})}, "cl_abap_elemdescr=>fixvalue", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "cl_abap_elemdescr=>fixvalues");

//# sourceMappingURL=cl_abap_elemdescr.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_enumdescr.clas.mjs":
/*!*******************************************!*\
  !*** ./output/cl_abap_enumdescr.clas.mjs ***!
  \*******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_enumdescr": () => (/* binding */ cl_abap_enumdescr)
/* harmony export */ });
const {cl_abap_elemdescr} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_elemdescr.clas.mjs */ "./output/cl_abap_elemdescr.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_enumdescr.clas.abap
class cl_abap_enumdescr extends cl_abap_elemdescr {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_ENUMDESCR';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"MEMBERS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"cl_abap_enumdescr=>member-name"}), "value": new abap.types.String({qualifiedName: "CL_ABAP_ENUMDESCR=>MEMBER-VALUE"})}, "cl_abap_enumdescr=>member", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "cl_abap_enumdescr=>member_table");}, "visibility": "U", "is_constant": " ", "is_class": " "}};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.members = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"cl_abap_enumdescr=>member-name"}), "value": new abap.types.String({qualifiedName: "CL_ABAP_ENUMDESCR=>MEMBER-VALUE"})}, "cl_abap_enumdescr=>member", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "cl_abap_enumdescr=>member_table");
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CL_ABAP_ENUMDESCR'] = cl_abap_enumdescr;
cl_abap_enumdescr.member = new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"cl_abap_enumdescr=>member-name"}), "value": new abap.types.String({qualifiedName: "CL_ABAP_ENUMDESCR=>MEMBER-VALUE"})}, "cl_abap_enumdescr=>member", undefined, {}, {});
cl_abap_enumdescr.member_table = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"cl_abap_enumdescr=>member-name"}), "value": new abap.types.String({qualifiedName: "CL_ABAP_ENUMDESCR=>MEMBER-VALUE"})}, "cl_abap_enumdescr=>member", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "cl_abap_enumdescr=>member_table");

//# sourceMappingURL=cl_abap_enumdescr.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_exceptional_values.clas.mjs":
/*!****************************************************!*\
  !*** ./output/cl_abap_exceptional_values.clas.mjs ***!
  \****************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_exceptional_values": () => (/* binding */ cl_abap_exceptional_values)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_exceptional_values.clas.abap
class cl_abap_exceptional_values {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_EXCEPTIONAL_VALUES';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"GET_MAX_VALUE": {"visibility": "U", "parameters": {"OUT": {"type": () => {return new abap.types.DataReference(new abap.types.Character(4));}, "is_optional": " "}, "IN_": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "GET_MIN_VALUE": {"visibility": "U", "parameters": {"OUT": {"type": () => {return new abap.types.DataReference(new abap.types.Character(4));}, "is_optional": " "}, "IN_": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async get_max_value(INPUT) {
    return cl_abap_exceptional_values.get_max_value(INPUT);
  }
  static async get_max_value(INPUT) {
    let out = new abap.types.DataReference(new abap.types.Character(4));
    let in_ = INPUT?.in_;
    let lv_type = new abap.types.Character(1, {});
    let lv_length = new abap.types.Integer({qualifiedName: "I"});
    let lv_decimals = new abap.types.Integer({qualifiedName: "I"});
    let fs_out_ = new abap.types.FieldSymbol(new abap.types.Character(4));
    abap.statements.describe({field: in_, type: lv_type});
    let unique3 = lv_type;
    if (abap.compare.eq(unique3, abap.Classes['CL_ABAP_TYPEDESCR'].typekind_int)) {
      out.assign(abap.Classes['CL_ABAP_MATH'].max_int4);
    } else if (abap.compare.eq(unique3, abap.Classes['CL_ABAP_TYPEDESCR'].typekind_packed)) {
      abap.statements.describe({field: in_, length: lv_length, decimals: lv_decimals, mode: 'BYTE'});
      abap.statements.createData(out,{"typeName": "P","length": lv_length,"decimals": lv_decimals});
      abap.statements.assign({target: fs_out_, source: (out).dereference()});
      if (abap.compare.eq(lv_length, abap.IntegerFactory.get(3)) && abap.compare.eq(lv_decimals, abap.IntegerFactory.get(1))) {
        fs_out_.set(new abap.types.Character(6).set('9999.9'));
      } else if (abap.compare.eq(lv_length, abap.IntegerFactory.get(4)) && abap.compare.eq(lv_decimals, abap.IntegerFactory.get(1))) {
        fs_out_.set(new abap.types.Character(8).set('999999.9'));
      } else if (abap.compare.eq(lv_length, abap.IntegerFactory.get(7)) && abap.compare.eq(lv_decimals, abap.IntegerFactory.get(3))) {
        fs_out_.set(new abap.types.Character(14).set('9999999999.999'));
      } else {
        abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
      }
    } else {
      console.dir(INPUT);
      abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    }
    return out;
  }
  async get_min_value(INPUT) {
    return cl_abap_exceptional_values.get_min_value(INPUT);
  }
  static async get_min_value(INPUT) {
    let out = new abap.types.DataReference(new abap.types.Character(4));
    let in_ = INPUT?.in_;
    let lv_type = new abap.types.Character(1, {});
    let fs_out_ = new abap.types.FieldSymbol(new abap.types.Character(4));
    abap.statements.describe({field: in_, type: lv_type});
    let unique4 = lv_type;
    if (abap.compare.eq(unique4, abap.Classes['CL_ABAP_TYPEDESCR'].typekind_int)) {
      out.assign(abap.Classes['CL_ABAP_MATH'].min_int4);
    } else if (abap.compare.eq(unique4, abap.Classes['CL_ABAP_TYPEDESCR'].typekind_packed)) {
      out.set((await this.get_max_value({in_: in_})));
      abap.statements.assign({target: fs_out_, source: (out).dereference()});
      fs_out_.set(abap.operators.multiply(fs_out_,abap.IntegerFactory.get(-1)));
    } else {
      console.dir(INPUT);
      abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    }
    return out;
  }
}
abap.Classes['CL_ABAP_EXCEPTIONAL_VALUES'] = cl_abap_exceptional_values;

//# sourceMappingURL=cl_abap_exceptional_values.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_format.clas.mjs":
/*!****************************************!*\
  !*** ./output/cl_abap_format.clas.mjs ***!
  \****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_format": () => (/* binding */ cl_abap_format)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_format.clas.abap
class cl_abap_format {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_FORMAT';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"E_HTML_ATTR": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "E_HTML_JS": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "E_HTML_JS_HTML": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "E_HTML_TEXT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "E_JSON_STRING": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "E_URL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "E_XML_ATTR": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "E_XSS_ML": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.e_html_attr = cl_abap_format.e_html_attr;
    this.e_html_js = cl_abap_format.e_html_js;
    this.e_html_js_html = cl_abap_format.e_html_js_html;
    this.e_html_text = cl_abap_format.e_html_text;
    this.e_json_string = cl_abap_format.e_json_string;
    this.e_url = cl_abap_format.e_url;
    this.e_xml_attr = cl_abap_format.e_xml_attr;
    this.e_xss_ml = cl_abap_format.e_xss_ml;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CL_ABAP_FORMAT'] = cl_abap_format;
cl_abap_format.e_html_attr = new abap.types.Integer({qualifiedName: "I"});
cl_abap_format.e_html_attr.set(5);
cl_abap_format.e_html_js = new abap.types.Integer({qualifiedName: "I"});
cl_abap_format.e_html_js.set(8);
cl_abap_format.e_html_js_html = new abap.types.Integer({qualifiedName: "I"});
cl_abap_format.e_html_js_html.set(10);
cl_abap_format.e_html_text = new abap.types.Integer({qualifiedName: "I"});
cl_abap_format.e_html_text.set(4);
cl_abap_format.e_json_string = new abap.types.Integer({qualifiedName: "I"});
cl_abap_format.e_json_string.set(24);
cl_abap_format.e_url = new abap.types.Integer({qualifiedName: "I"});
cl_abap_format.e_url.set(12);
cl_abap_format.e_xml_attr = new abap.types.Integer({qualifiedName: "I"});
cl_abap_format.e_xml_attr.set(1);
cl_abap_format.e_xss_ml = new abap.types.Integer({qualifiedName: "I"});
cl_abap_format.e_xss_ml.set(26);

//# sourceMappingURL=cl_abap_format.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_gzip.clas.mjs":
/*!**************************************!*\
  !*** ./output/cl_abap_gzip.clas.mjs ***!
  \**************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_gzip": () => (/* binding */ cl_abap_gzip)
/* harmony export */ });
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_gzip.clas.abap
class cl_abap_gzip {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_GZIP';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"DECOMPRESS_BINARY": {"visibility": "U", "parameters": {"GZIP_IN": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "RAW_OUT": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "RAW_OUT_LEN": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "COMPRESS_BINARY": {"visibility": "U", "parameters": {"COMPRESS_LEVEL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "RAW_IN": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "GZIP_OUT": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "GZIP_OUT_LEN": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "DECOMPRESS_TEXT": {"visibility": "U", "parameters": {"GZIP_IN": {"type": () => {return new abap.types.Hex();}, "is_optional": " "}, "GZIP_IN_LEN": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "CONVERSION": {"type": () => {return new abap.types.Character(20, {"qualifiedName":"ABAP_ENCOD","ddicName":"ABAP_ENCOD"});}, "is_optional": " "}, "TEXT_OUT": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "TEXT_OUT_LEN": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "COMPRESS_TEXT": {"visibility": "U", "parameters": {"TEXT_IN": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "TEXT_IN_LEN": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "COMPRESS_LEVEL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "CONVERSION": {"type": () => {return new abap.types.Character(20, {"qualifiedName":"ABAP_ENCOD","ddicName":"ABAP_ENCOD"});}, "is_optional": " "}, "GZIP_OUT": {"type": () => {return new abap.types.Hex();}, "is_optional": " "}, "GZIP_OUT_LEN": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "DECOMPRESS_BINARY_WITH_HEADER": {"visibility": "U", "parameters": {"GZIP_IN": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "RAW_OUT": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async decompress_binary_with_header(INPUT) {
    return cl_abap_gzip.decompress_binary_with_header(INPUT);
  }
  static async decompress_binary_with_header(INPUT) {
    let gzip_in = INPUT?.gzip_in;
    if (gzip_in?.getQualifiedName === undefined || gzip_in.getQualifiedName() !== "XSTRING") { gzip_in = undefined; }
    if (gzip_in === undefined) { gzip_in = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.gzip_in); }
    let raw_out = INPUT?.raw_out || new abap.types.XString({qualifiedName: "XSTRING"});
    const zlib = await __webpack_require__.e(/*! import() */ "_7c68").then(__webpack_require__.t.bind(__webpack_require__, /*! zlib */ "?7c68", 19));
    const buf = Buffer.from(gzip_in.get(), "hex");
    const decompress = zlib.gunzipSync(buf).toString("hex").toUpperCase();
    raw_out.set(decompress);
  }
  async decompress_text(INPUT) {
    return cl_abap_gzip.decompress_text(INPUT);
  }
  static async decompress_text(INPUT) {
    let gzip_in = INPUT?.gzip_in;
    let gzip_in_len = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.gzip_in_len) {gzip_in_len.set(INPUT.gzip_in_len);}
    if (INPUT === undefined || INPUT.gzip_in_len === undefined) {gzip_in_len = abap.IntegerFactory.get(-1);}
    let conversion = new abap.types.Character(20, {"qualifiedName":"ABAP_ENCOD","ddicName":"ABAP_ENCOD"});
    if (INPUT && INPUT.conversion) {conversion.set(INPUT.conversion);}
    if (INPUT === undefined || INPUT.conversion === undefined) {conversion = new abap.types.Character(7).set('DEFAULT');}
    let text_out = INPUT?.text_out || new abap.types.Character();
    let text_out_len = INPUT?.text_out_len || new abap.types.Integer({qualifiedName: "I"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async compress_text(INPUT) {
    return cl_abap_gzip.compress_text(INPUT);
  }
  static async compress_text(INPUT) {
    let text_in = INPUT?.text_in;
    let text_in_len = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.text_in_len) {text_in_len.set(INPUT.text_in_len);}
    if (INPUT === undefined || INPUT.text_in_len === undefined) {text_in_len = abap.IntegerFactory.get(-1);}
    let compress_level = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.compress_level) {compress_level.set(INPUT.compress_level);}
    if (INPUT === undefined || INPUT.compress_level === undefined) {compress_level = abap.IntegerFactory.get(6);}
    let conversion = new abap.types.Character(20, {"qualifiedName":"ABAP_ENCOD","ddicName":"ABAP_ENCOD"});
    if (INPUT && INPUT.conversion) {conversion.set(INPUT.conversion);}
    if (INPUT === undefined || INPUT.conversion === undefined) {conversion = new abap.types.Character(7).set('DEFAULT');}
    let gzip_out = INPUT?.gzip_out || new abap.types.Hex();
    let gzip_out_len = INPUT?.gzip_out_len || new abap.types.Integer({qualifiedName: "I"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async decompress_binary(INPUT) {
    return cl_abap_gzip.decompress_binary(INPUT);
  }
  static async decompress_binary(INPUT) {
    let gzip_in = INPUT?.gzip_in;
    if (gzip_in?.getQualifiedName === undefined || gzip_in.getQualifiedName() !== "XSTRING") { gzip_in = undefined; }
    if (gzip_in === undefined) { gzip_in = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.gzip_in); }
    let raw_out = INPUT?.raw_out || new abap.types.XString({qualifiedName: "XSTRING"});
    let raw_out_len = INPUT?.raw_out_len || new abap.types.Integer({qualifiedName: "I"});
    const zlib = await __webpack_require__.e(/*! import() */ "_7c68").then(__webpack_require__.t.bind(__webpack_require__, /*! zlib */ "?7c68", 19));
    const buf = Buffer.from(gzip_in.get(), "hex");
    const decompress = zlib.inflateRawSync(buf, {finishFlush: zlib.constants.Z_SYNC_FLUSH}).toString("hex").toUpperCase();
    raw_out.set(decompress);
    raw_out_len.set(abap.builtin.xstrlen({val: raw_out}));
  }
  async compress_binary(INPUT) {
    return cl_abap_gzip.compress_binary(INPUT);
  }
  static async compress_binary(INPUT) {
    let compress_level = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.compress_level) {compress_level.set(INPUT.compress_level);}
    let raw_in = INPUT?.raw_in;
    if (raw_in?.getQualifiedName === undefined || raw_in.getQualifiedName() !== "XSTRING") { raw_in = undefined; }
    if (raw_in === undefined) { raw_in = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.raw_in); }
    let gzip_out = INPUT?.gzip_out || new abap.types.XString({qualifiedName: "XSTRING"});
    let gzip_out_len = INPUT?.gzip_out_len || new abap.types.Integer({qualifiedName: "I"});
    const zlib = await __webpack_require__.e(/*! import() */ "_7c68").then(__webpack_require__.t.bind(__webpack_require__, /*! zlib */ "?7c68", 19));
    const buf = Buffer.from(raw_in.get(), "hex");
    const gzi = zlib.deflateRawSync(buf).toString("hex").toUpperCase();
    gzip_out.set(gzi);
    gzip_out_len.set(abap.builtin.xstrlen({val: gzip_out}));
  }
}
abap.Classes['CL_ABAP_GZIP'] = cl_abap_gzip;

//# sourceMappingURL=cl_abap_gzip.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_hmac.clas.mjs":
/*!**************************************!*\
  !*** ./output/cl_abap_hmac.clas.mjs ***!
  \**************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_hmac": () => (/* binding */ cl_abap_hmac)
/* harmony export */ });
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_hmac.clas.abap
class cl_abap_hmac {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_HMAC';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"CALCULATE_HMAC_FOR_RAW": {"visibility": "U", "parameters": {"IF_ALGORITHM": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "IF_KEY": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "IF_DATA": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "IF_LENGTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "EF_HMACSTRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "EF_HMACXSTRING": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "EF_HMACB64STRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "CALCULATE_HMAC_FOR_CHAR": {"visibility": "U", "parameters": {"IF_ALGORITHM": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "IF_KEY": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "IF_DATA": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "EF_HMACSTRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "EF_HMACXSTRING": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "EF_HMACB64STRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "STRING_TO_XSTRING": {"visibility": "U", "parameters": {"ER_OUTPUT": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "IF_INPUT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async calculate_hmac_for_raw(INPUT) {
    return cl_abap_hmac.calculate_hmac_for_raw(INPUT);
  }
  static async calculate_hmac_for_raw(INPUT) {
    let if_algorithm = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.if_algorithm) {if_algorithm.set(INPUT.if_algorithm);}
    if (INPUT === undefined || INPUT.if_algorithm === undefined) {if_algorithm = new abap.types.Character(4).set('SHA1');}
    let if_key = INPUT?.if_key;
    if (if_key?.getQualifiedName === undefined || if_key.getQualifiedName() !== "XSTRING") { if_key = undefined; }
    if (if_key === undefined) { if_key = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.if_key); }
    let if_data = INPUT?.if_data;
    if (if_data?.getQualifiedName === undefined || if_data.getQualifiedName() !== "XSTRING") { if_data = undefined; }
    if (if_data === undefined) { if_data = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.if_data); }
    let if_length = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.if_length) {if_length.set(INPUT.if_length);}
    let ef_hmacstring = INPUT?.ef_hmacstring || new abap.types.String({qualifiedName: "STRING"});
    let ef_hmacxstring = INPUT?.ef_hmacxstring || new abap.types.XString({qualifiedName: "XSTRING"});
    let ef_hmacb64string = INPUT?.ef_hmacb64string || new abap.types.String({qualifiedName: "STRING"});
    let lv_algorithm = new abap.types.String({qualifiedName: "STRING"});
    abap.statements.clear(ef_hmacstring);
    abap.statements.clear(ef_hmacxstring);
    abap.statements.assert(abap.compare.eq(if_length, abap.IntegerFactory.get(0)));
    lv_algorithm.set(abap.builtin.to_lower({val: if_algorithm}));
    abap.statements.assert(abap.compare.eq(lv_algorithm, new abap.types.Character(4).set('sha1')) || abap.compare.eq(lv_algorithm, new abap.types.Character(3).set('md5')) || abap.compare.eq(lv_algorithm, new abap.types.Character(6).set('sha256')));
    const crypto = await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_crypto-browserify_index_js"), __webpack_require__.e("_d546-_8131-_3fc0-_cd53-_4068-_e7e4-_7bec-_0aec-_dbd9-_fbf1-_75ad-_6552-_1dfd-_ed1b-_b483-_d1-da8ac5")]).then(__webpack_require__.t.bind(__webpack_require__, /*! crypto */ "./node_modules/crypto-browserify/index.js", 19));
    if (abap.compare.initial(if_key)) {
      var shasum = crypto.createHash(lv_algorithm.get());
      shasum.update(if_data.get(), "hex");
      ef_hmacstring.set(shasum.digest("hex").toUpperCase());
    } else {
      let hmac = crypto.createHmac(lv_algorithm.get(), Buffer.from(if_key.get(), "hex")).update(if_data.get(), "hex").digest("hex").toUpperCase();
      ef_hmacstring.set(hmac);
    }
    ef_hmacb64string.set(Buffer.from(ef_hmacstring.get(), "hex").toString("base64"));
    ef_hmacxstring.set(ef_hmacstring);
  }
  async calculate_hmac_for_char(INPUT) {
    return cl_abap_hmac.calculate_hmac_for_char(INPUT);
  }
  static async calculate_hmac_for_char(INPUT) {
    let if_algorithm = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.if_algorithm) {if_algorithm.set(INPUT.if_algorithm);}
    if (INPUT === undefined || INPUT.if_algorithm === undefined) {if_algorithm = new abap.types.Character(4).set('SHA1');}
    let if_key = INPUT?.if_key;
    if (if_key?.getQualifiedName === undefined || if_key.getQualifiedName() !== "XSTRING") { if_key = undefined; }
    if (if_key === undefined) { if_key = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.if_key); }
    let if_data = INPUT?.if_data;
    if (if_data?.getQualifiedName === undefined || if_data.getQualifiedName() !== "STRING") { if_data = undefined; }
    if (if_data === undefined) { if_data = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.if_data); }
    let ef_hmacstring = INPUT?.ef_hmacstring || new abap.types.String({qualifiedName: "STRING"});
    let ef_hmacxstring = INPUT?.ef_hmacxstring || new abap.types.XString({qualifiedName: "XSTRING"});
    let ef_hmacb64string = INPUT?.ef_hmacb64string || new abap.types.String({qualifiedName: "STRING"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async string_to_xstring(INPUT) {
    return cl_abap_hmac.string_to_xstring(INPUT);
  }
  static async string_to_xstring(INPUT) {
    let er_output = new abap.types.XString({qualifiedName: "XSTRING"});
    let if_input = INPUT?.if_input;
    if (if_input?.getQualifiedName === undefined || if_input.getQualifiedName() !== "STRING") { if_input = undefined; }
    if (if_input === undefined) { if_input = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.if_input); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return er_output;
  }
}
abap.Classes['CL_ABAP_HMAC'] = cl_abap_hmac;

//# sourceMappingURL=cl_abap_hmac.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_intfdescr.clas.mjs":
/*!*******************************************!*\
  !*** ./output/cl_abap_intfdescr.clas.mjs ***!
  \*******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_intfdescr": () => (/* binding */ cl_abap_intfdescr)
/* harmony export */ });
const {cl_abap_objectdescr} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_objectdescr.clas.mjs */ "./output/cl_abap_objectdescr.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_intfdescr.clas.abap
class cl_abap_intfdescr extends cl_abap_objectdescr {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_INTFDESCR';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CL_ABAP_INTFDESCR'] = cl_abap_intfdescr;

//# sourceMappingURL=cl_abap_intfdescr.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_matcher.clas.mjs":
/*!*****************************************!*\
  !*** ./output/cl_abap_matcher.clas.mjs ***!
  \*****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_matcher": () => (/* binding */ cl_abap_matcher)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_matcher.clas.abap
class cl_abap_matcher {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_MATCHER';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"MT_MATCHES": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"line": new abap.types.Integer({qualifiedName: "I"}), "offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"}), "submatches": abap.types.TableFactory.construct(new abap.types.Structure({"offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"})}, "SUBMATCH_RESULT", "SUBMATCH_RESULT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SUBMATCH_RESULT_TAB")}, "MATCH_RESULT", "MATCH_RESULT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "MATCH_RESULT_TAB");}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MV_INDEX": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MV_TEXT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MV_PATTERN": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "I", "is_constant": " ", "is_class": " "}};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"PATTERN": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "IGNORE_CASE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "TEXT": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "FIND_ALL": {"visibility": "U", "parameters": {"RT_MATCHES": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"line": new abap.types.Integer({qualifiedName: "I"}), "offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"}), "submatches": abap.types.TableFactory.construct(new abap.types.Structure({"offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"})}, "SUBMATCH_RESULT", "SUBMATCH_RESULT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SUBMATCH_RESULT_TAB")}, "MATCH_RESULT", "MATCH_RESULT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "MATCH_RESULT_TAB");}, "is_optional": " "}}},
  "FIND_NEXT": {"visibility": "U", "parameters": {"FOUND": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "GET_SUBMATCH": {"visibility": "U", "parameters": {"MATCH": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "INDEX": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_OFFSET": {"visibility": "U", "parameters": {"OFFSET": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "MATCH": {"visibility": "U", "parameters": {"SUCCESS": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "GET_LENGTH": {"visibility": "U", "parameters": {"LENGTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.mt_matches = abap.types.TableFactory.construct(new abap.types.Structure({"line": new abap.types.Integer({qualifiedName: "I"}), "offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"}), "submatches": abap.types.TableFactory.construct(new abap.types.Structure({"offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"})}, "SUBMATCH_RESULT", "SUBMATCH_RESULT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SUBMATCH_RESULT_TAB")}, "MATCH_RESULT", "MATCH_RESULT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "MATCH_RESULT_TAB");
    this.mv_index = new abap.types.Integer({qualifiedName: "I"});
    this.mv_text = new abap.types.String({qualifiedName: "STRING"});
    this.mv_pattern = new abap.types.String({qualifiedName: "STRING"});
  }
  async constructor_(INPUT) {
    let pattern = INPUT?.pattern;
    let ignore_case = INPUT?.ignore_case;
    if (ignore_case?.getQualifiedName === undefined || ignore_case.getQualifiedName() !== "ABAP_BOOL") { ignore_case = undefined; }
    if (ignore_case === undefined) { ignore_case = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}).set(INPUT.ignore_case); }
    let text = INPUT?.text;
    if (abap.compare.eq(ignore_case, abap.builtin.abap_true)) {
      abap.statements.find(text, {regex: pattern, first: false, ignoringCase: true, results: this.mt_matches});
    } else {
      abap.statements.find(text, {regex: pattern, first: false, results: this.mt_matches});
    }
    this.mv_pattern.set(pattern);
    this.mv_text.set(text);
    return this;
  }
  async match() {
    let success = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    abap.statements.find(this.mv_text, {regex: new abap.types.String().set(`^${abap.templateFormatting(this.mv_pattern)}$`), first: false});
    success.set(abap.builtin.boolc(abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))));
    return success;
  }
  async find_all() {
    let rt_matches = abap.types.TableFactory.construct(new abap.types.Structure({"line": new abap.types.Integer({qualifiedName: "I"}), "offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"}), "submatches": abap.types.TableFactory.construct(new abap.types.Structure({"offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"})}, "SUBMATCH_RESULT", "SUBMATCH_RESULT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SUBMATCH_RESULT_TAB")}, "MATCH_RESULT", "MATCH_RESULT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "MATCH_RESULT_TAB");
    rt_matches.set(this.mt_matches);
    return rt_matches;
  }
  async find_next() {
    let found = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    this.mv_index.set(abap.operators.add(this.mv_index,abap.IntegerFactory.get(1)));
    abap.statements.readTable(this.mt_matches,{index: this.mv_index});
    found.set(abap.builtin.boolc(abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))));
    return found;
  }
  async get_submatch(INPUT) {
    let match = new abap.types.String({qualifiedName: "STRING"});
    let index = INPUT?.index;
    if (index?.getQualifiedName === undefined || index.getQualifiedName() !== "I") { index = undefined; }
    if (index === undefined) { index = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.index); }
    let ls_match = new abap.types.Structure({"line": new abap.types.Integer({qualifiedName: "I"}), "offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"}), "submatches": abap.types.TableFactory.construct(new abap.types.Structure({"offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"})}, "SUBMATCH_RESULT", "SUBMATCH_RESULT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SUBMATCH_RESULT_TAB")}, "MATCH_RESULT", "MATCH_RESULT", {}, {});
    let ls_submatch = new abap.types.Structure({"offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"})}, "SUBMATCH_RESULT", "SUBMATCH_RESULT", {}, {});
    abap.statements.readTable(this.mt_matches,{index: this.mv_index,
      into: ls_match});
    abap.statements.readTable(ls_match.get().submatches,{index: index,
      into: ls_submatch});
    if (abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
      match.set(this.mv_text.getOffset({offset: ls_submatch.get().offset, length: ls_submatch.get().length}));
    }
    return match;
  }
  async get_offset() {
    let offset = new abap.types.Integer({qualifiedName: "I"});
    let ls_match = new abap.types.Structure({"line": new abap.types.Integer({qualifiedName: "I"}), "offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"}), "submatches": abap.types.TableFactory.construct(new abap.types.Structure({"offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"})}, "SUBMATCH_RESULT", "SUBMATCH_RESULT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SUBMATCH_RESULT_TAB")}, "MATCH_RESULT", "MATCH_RESULT", {}, {});
    abap.statements.readTable(this.mt_matches,{index: this.mv_index,
      into: ls_match});
    offset.set(ls_match.get().offset);
    return offset;
  }
  async get_length() {
    let length = new abap.types.Integer({qualifiedName: "I"});
    let ls_match = new abap.types.Structure({"line": new abap.types.Integer({qualifiedName: "I"}), "offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"}), "submatches": abap.types.TableFactory.construct(new abap.types.Structure({"offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"})}, "SUBMATCH_RESULT", "SUBMATCH_RESULT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SUBMATCH_RESULT_TAB")}, "MATCH_RESULT", "MATCH_RESULT", {}, {});
    abap.statements.readTable(this.mt_matches,{index: this.mv_index,
      into: ls_match});
    length.set(ls_match.get().length);
    return length;
  }
}
abap.Classes['CL_ABAP_MATCHER'] = cl_abap_matcher;

//# sourceMappingURL=cl_abap_matcher.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_math.clas.mjs":
/*!**************************************!*\
  !*** ./output/cl_abap_math.clas.mjs ***!
  \**************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_math": () => (/* binding */ cl_abap_math)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_math.clas.abap
class cl_abap_math {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_MATH';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"MIN_INT4": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "MAX_INT4": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "MAX_INT8": {"type": () => {return new abap.types.Integer8({qualifiedName: "INT8"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "MIN_INT8": {"type": () => {return new abap.types.Integer8({qualifiedName: "INT8"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "ROUND_CEILING": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "ROUND_UP": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "ROUND_HALF_UP": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "ROUND_HALF_EVEN": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "ROUND_HALF_DOWN": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "ROUND_DOWN": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "ROUND_FLOOR": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.min_int4 = cl_abap_math.min_int4;
    this.max_int4 = cl_abap_math.max_int4;
    this.max_int8 = cl_abap_math.max_int8;
    this.min_int8 = cl_abap_math.min_int8;
    this.round_ceiling = cl_abap_math.round_ceiling;
    this.round_up = cl_abap_math.round_up;
    this.round_half_up = cl_abap_math.round_half_up;
    this.round_half_even = cl_abap_math.round_half_even;
    this.round_half_down = cl_abap_math.round_half_down;
    this.round_down = cl_abap_math.round_down;
    this.round_floor = cl_abap_math.round_floor;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CL_ABAP_MATH'] = cl_abap_math;
cl_abap_math.min_int4 = new abap.types.Integer({qualifiedName: "I"});
cl_abap_math.min_int4.set(-2147483648);
cl_abap_math.max_int4 = new abap.types.Integer({qualifiedName: "I"});
cl_abap_math.max_int4.set(2147483647);
cl_abap_math.max_int8 = new abap.types.Integer8({qualifiedName: "INT8"});
cl_abap_math.max_int8.set(9223372036854775807);
cl_abap_math.min_int8 = new abap.types.Integer8({qualifiedName: "INT8"});
cl_abap_math.min_int8.set(-9223372036854775808);
cl_abap_math.round_ceiling = new abap.types.Integer({qualifiedName: "I"});
cl_abap_math.round_ceiling.set(0);
cl_abap_math.round_up = new abap.types.Integer({qualifiedName: "I"});
cl_abap_math.round_up.set(1);
cl_abap_math.round_half_up = new abap.types.Integer({qualifiedName: "I"});
cl_abap_math.round_half_up.set(2);
cl_abap_math.round_half_even = new abap.types.Integer({qualifiedName: "I"});
cl_abap_math.round_half_even.set(3);
cl_abap_math.round_half_down = new abap.types.Integer({qualifiedName: "I"});
cl_abap_math.round_half_down.set(4);
cl_abap_math.round_down = new abap.types.Integer({qualifiedName: "I"});
cl_abap_math.round_down.set(5);
cl_abap_math.round_floor = new abap.types.Integer({qualifiedName: "I"});
cl_abap_math.round_floor.set(6);

//# sourceMappingURL=cl_abap_math.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_message_digest.clas.mjs":
/*!************************************************!*\
  !*** ./output/cl_abap_message_digest.clas.mjs ***!
  \************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_message_digest": () => (/* binding */ cl_abap_message_digest)
/* harmony export */ });
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_message_digest.clas.abap
class cl_abap_message_digest {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_MESSAGE_DIGEST';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"CALCULATE_HASH_FOR_RAW": {"visibility": "U", "parameters": {"IF_ALGORITHM": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "IF_DATA": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "EF_HASHXSTRING": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "CALCULATE_HASH_FOR_CHAR": {"visibility": "U", "parameters": {"IF_ALGORITHM": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "IF_DATA": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "EF_HASHXSTRING": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "EF_HASHSTRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "EF_HASHB64STRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async calculate_hash_for_raw(INPUT) {
    return cl_abap_message_digest.calculate_hash_for_raw(INPUT);
  }
  static async calculate_hash_for_raw(INPUT) {
    let if_algorithm = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.if_algorithm) {if_algorithm.set(INPUT.if_algorithm);}
    if (INPUT === undefined || INPUT.if_algorithm === undefined) {if_algorithm = new abap.types.Character(4).set('SHA1');}
    let if_data = INPUT?.if_data;
    if (if_data?.getQualifiedName === undefined || if_data.getQualifiedName() !== "XSTRING") { if_data = undefined; }
    if (if_data === undefined) { if_data = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.if_data); }
    let ef_hashxstring = INPUT?.ef_hashxstring || new abap.types.XString({qualifiedName: "XSTRING"});
    let lv_algorithm = new abap.types.String({qualifiedName: "STRING"});
    lv_algorithm.set(abap.builtin.to_lower({val: if_algorithm}));
    abap.statements.assert(abap.compare.eq(lv_algorithm, new abap.types.Character(4).set('sha1')) || abap.compare.eq(lv_algorithm, new abap.types.Character(3).set('md5')) || abap.compare.eq(lv_algorithm, new abap.types.Character(6).set('sha256')));
    const crypto = await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_crypto-browserify_index_js"), __webpack_require__.e("_d546-_8131-_3fc0-_cd53-_4068-_e7e4-_7bec-_0aec-_dbd9-_fbf1-_75ad-_6552-_1dfd-_ed1b-_b483-_d1-da8ac5")]).then(__webpack_require__.t.bind(__webpack_require__, /*! crypto */ "./node_modules/crypto-browserify/index.js", 19));
    var shasum = crypto.createHash(lv_algorithm.get());
    shasum.update(if_data.get(), "hex");
    ef_hashxstring.set(shasum.digest("hex").toUpperCase());
  }
  async calculate_hash_for_char(INPUT) {
    return cl_abap_message_digest.calculate_hash_for_char(INPUT);
  }
  static async calculate_hash_for_char(INPUT) {
    let if_algorithm = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.if_algorithm) {if_algorithm.set(INPUT.if_algorithm);}
    if (INPUT === undefined || INPUT.if_algorithm === undefined) {if_algorithm = new abap.types.Character(4).set('SHA1');}
    let if_data = INPUT?.if_data;
    if (if_data?.getQualifiedName === undefined || if_data.getQualifiedName() !== "STRING") { if_data = undefined; }
    if (if_data === undefined) { if_data = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.if_data); }
    let ef_hashxstring = INPUT?.ef_hashxstring || new abap.types.XString({qualifiedName: "XSTRING"});
    let ef_hashstring = INPUT?.ef_hashstring || new abap.types.String({qualifiedName: "STRING"});
    let ef_hashb64string = INPUT?.ef_hashb64string || new abap.types.String({qualifiedName: "STRING"});
    let lv_algorithm = new abap.types.String({qualifiedName: "STRING"});
    lv_algorithm.set(abap.builtin.to_lower({val: if_algorithm}));
    abap.statements.assert(abap.compare.eq(lv_algorithm, new abap.types.Character(4).set('sha1')) || abap.compare.eq(lv_algorithm, new abap.types.Character(3).set('md5')) || abap.compare.eq(lv_algorithm, new abap.types.Character(6).set('sha256')));
    const crypto = await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_crypto-browserify_index_js"), __webpack_require__.e("_d546-_8131-_3fc0-_cd53-_4068-_e7e4-_7bec-_0aec-_dbd9-_fbf1-_75ad-_6552-_1dfd-_ed1b-_b483-_d1-da8ac5")]).then(__webpack_require__.t.bind(__webpack_require__, /*! crypto */ "./node_modules/crypto-browserify/index.js", 19));
    var shasum = crypto.createHash(lv_algorithm.get());
    shasum.update(if_data.get());
    ef_hashxstring.set(shasum.digest("hex").toUpperCase());
    ef_hashb64string.set(Buffer.from(ef_hashxstring.get(), "hex").toString("base64"));
    ef_hashstring.set(ef_hashxstring);
  }
}
abap.Classes['CL_ABAP_MESSAGE_DIGEST'] = cl_abap_message_digest;

//# sourceMappingURL=cl_abap_message_digest.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_objectdescr.clas.mjs":
/*!*********************************************!*\
  !*** ./output/cl_abap_objectdescr.clas.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_objectdescr": () => (/* binding */ cl_abap_objectdescr)
/* harmony export */ });
const {cl_abap_typedescr} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_typedescr.clas.mjs */ "./output/cl_abap_typedescr.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_objectdescr.clas.abap
class cl_abap_objectdescr extends cl_abap_typedescr {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_OBJECTDESCR';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"ATTRIBUTES": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"length": new abap.types.Integer({qualifiedName: "LENGTH"}), "decimals": new abap.types.Integer({qualifiedName: "DECIMALS"}), "name": new abap.types.Character(61, {"qualifiedName":"abap_attrname"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "visibility": new abap.types.Character(1, {"qualifiedName":"abap_visibility"}), "is_interface": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_inherited": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_class": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_constant": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_virtual": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_read_only": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "alias_for": new abap.types.Character(61, {"qualifiedName":"abap_attrname"})}, "abap_attrdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_attrdescr_tab");}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "METHODS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"parameters": abap.types.TableFactory.construct(new abap.types.Structure({"length": new abap.types.Integer({qualifiedName: "LENGTH"}), "decimals": new abap.types.Integer({qualifiedName: "DECIMALS"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "name": new abap.types.Character(30, {"qualifiedName":"abap_parmname"}), "parm_kind": new abap.types.Character(1, {"qualifiedName":"abap_parmkind"}), "by_value": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_optional": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_parmdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_parmdescr_tab"), "exceptions": abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_excpname"}), "is_resumable": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_excpdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_excpdescr_tab"), "name": new abap.types.Character(61, {"qualifiedName":"abap_methname"}), "for_event": new abap.types.Character(61, {"qualifiedName":"abap_evntname"}), "of_class": new abap.types.Character(30, {"qualifiedName":"abap_classname"}), "visibility": new abap.types.Character(1, {"qualifiedName":"abap_visibility"}), "is_interface": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_inherited": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_redefined": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_abstract": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_final": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_class": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "alias_for": new abap.types.Character(61, {"qualifiedName":"abap_methname"}), "is_raising_excps": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_methdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_methdescr_tab");}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "INTERFACES": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_intfname"}), "is_inherited": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_intfdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_intfdescr_tab");}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "MV_OBJECT_NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "O", "is_constant": " ", "is_class": " "},
  "MV_OBJECT_TYPE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "O", "is_constant": " ", "is_class": " "},
  "MT_ATTRIBUTE_TYPES": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(61, {"qualifiedName":"abap_attrname"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"})}, "cl_abap_objectdescr=>ty_attribute_types", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "");}, "visibility": "O", "is_constant": " ", "is_class": " "},
  "MT_PARAMETER_TYPES": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"method": new abap.types.String({qualifiedName: "CL_ABAP_OBJECTDESCR=>TY_PARAMETER_TYPES-METHOD"}), "parameter": new abap.types.String({qualifiedName: "CL_ABAP_OBJECTDESCR=>TY_PARAMETER_TYPES-PARAMETER"}), "type": new abap.types.DataReference(new abap.types.Character(4))}, "cl_abap_objectdescr=>ty_parameter_types", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "");}, "visibility": "O", "is_constant": " ", "is_class": " "},
  "CHANGING": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_parmkind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "EXPORTING": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_parmkind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IMPORTING": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_parmkind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "RECEIVING": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_parmkind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "RETURNING": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_parmkind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "PRIVATE_": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_visibility"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "PROTECTED": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_visibility"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "PUBLIC_": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_visibility"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"P_OBJECT": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "GET_ATTRIBUTE_TYPE": {"visibility": "U", "parameters": {"P_DESCR_REF": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"});}, "is_optional": " "}, "P_NAME": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "GET_METHOD_PARAMETER_TYPE": {"visibility": "U", "parameters": {"P_DESCR_REF": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"});}, "is_optional": " "}, "P_METHOD_NAME": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "P_PARAMETER_NAME": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "GET_INTERFACE_TYPE": {"visibility": "U", "parameters": {"P_DESCR_REF": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_INTFDESCR", RTTIName: "\\CLASS=CL_ABAP_INTFDESCR"});}, "is_optional": " "}, "P_NAME": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.attributes = abap.types.TableFactory.construct(new abap.types.Structure({"length": new abap.types.Integer({qualifiedName: "LENGTH"}), "decimals": new abap.types.Integer({qualifiedName: "DECIMALS"}), "name": new abap.types.Character(61, {"qualifiedName":"abap_attrname"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "visibility": new abap.types.Character(1, {"qualifiedName":"abap_visibility"}), "is_interface": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_inherited": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_class": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_constant": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_virtual": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_read_only": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "alias_for": new abap.types.Character(61, {"qualifiedName":"abap_attrname"})}, "abap_attrdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_attrdescr_tab");
    this.methods = abap.types.TableFactory.construct(new abap.types.Structure({"parameters": abap.types.TableFactory.construct(new abap.types.Structure({"length": new abap.types.Integer({qualifiedName: "LENGTH"}), "decimals": new abap.types.Integer({qualifiedName: "DECIMALS"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "name": new abap.types.Character(30, {"qualifiedName":"abap_parmname"}), "parm_kind": new abap.types.Character(1, {"qualifiedName":"abap_parmkind"}), "by_value": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_optional": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_parmdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_parmdescr_tab"), "exceptions": abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_excpname"}), "is_resumable": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_excpdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_excpdescr_tab"), "name": new abap.types.Character(61, {"qualifiedName":"abap_methname"}), "for_event": new abap.types.Character(61, {"qualifiedName":"abap_evntname"}), "of_class": new abap.types.Character(30, {"qualifiedName":"abap_classname"}), "visibility": new abap.types.Character(1, {"qualifiedName":"abap_visibility"}), "is_interface": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_inherited": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_redefined": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_abstract": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_final": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_class": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "alias_for": new abap.types.Character(61, {"qualifiedName":"abap_methname"}), "is_raising_excps": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_methdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_methdescr_tab");
    this.interfaces = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_intfname"}), "is_inherited": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_intfdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_intfdescr_tab");
    this.mv_object_name = new abap.types.String({qualifiedName: "STRING"});
    this.mv_object_type = new abap.types.String({qualifiedName: "STRING"});
    this.mt_attribute_types = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(61, {"qualifiedName":"abap_attrname"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"})}, "cl_abap_objectdescr=>ty_attribute_types", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "");
    this.mt_parameter_types = abap.types.TableFactory.construct(new abap.types.Structure({"method": new abap.types.String({qualifiedName: "CL_ABAP_OBJECTDESCR=>TY_PARAMETER_TYPES-METHOD"}), "parameter": new abap.types.String({qualifiedName: "CL_ABAP_OBJECTDESCR=>TY_PARAMETER_TYPES-PARAMETER"}), "type": new abap.types.DataReference(new abap.types.Character(4))}, "cl_abap_objectdescr=>ty_parameter_types", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "");
    this.changing = cl_abap_objectdescr.changing;
    this.exporting = cl_abap_objectdescr.exporting;
    this.importing = cl_abap_objectdescr.importing;
    this.receiving = cl_abap_objectdescr.receiving;
    this.returning = cl_abap_objectdescr.returning;
    this.private_ = cl_abap_objectdescr.private_;
    this.protected = cl_abap_objectdescr.protected;
    this.public_ = cl_abap_objectdescr.public_;
  }
  async constructor_(INPUT) {
    let p_object = INPUT?.p_object || new abap.types.Character(4);
    let lv_name = new abap.types.Character(61, {"qualifiedName":"abap_attrname"});
    let lv_char1 = new abap.types.Character(1, {});
    let lv_any = new abap.types.String({qualifiedName: "STRING"});
    let fs_attr_ = new abap.types.FieldSymbol(new abap.types.Structure({"length": new abap.types.Integer({qualifiedName: "LENGTH"}), "decimals": new abap.types.Integer({qualifiedName: "DECIMALS"}), "name": new abap.types.Character(61, {"qualifiedName":"abap_attrname"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "visibility": new abap.types.Character(1, {"qualifiedName":"abap_visibility"}), "is_interface": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_inherited": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_class": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_constant": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_virtual": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_read_only": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "alias_for": new abap.types.Character(61, {"qualifiedName":"abap_attrname"})}, "abap_attrdescr", undefined, {}, {}));
    let fs_intf_ = new abap.types.FieldSymbol(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_intfname"}), "is_inherited": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_intfdescr", undefined, {}, {}));
    let fs_method_ = new abap.types.FieldSymbol(new abap.types.Structure({"parameters": abap.types.TableFactory.construct(new abap.types.Structure({"length": new abap.types.Integer({qualifiedName: "LENGTH"}), "decimals": new abap.types.Integer({qualifiedName: "DECIMALS"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "name": new abap.types.Character(30, {"qualifiedName":"abap_parmname"}), "parm_kind": new abap.types.Character(1, {"qualifiedName":"abap_parmkind"}), "by_value": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_optional": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_parmdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_parmdescr_tab"), "exceptions": abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_excpname"}), "is_resumable": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_excpdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_excpdescr_tab"), "name": new abap.types.Character(61, {"qualifiedName":"abap_methname"}), "for_event": new abap.types.Character(61, {"qualifiedName":"abap_evntname"}), "of_class": new abap.types.Character(30, {"qualifiedName":"abap_classname"}), "visibility": new abap.types.Character(1, {"qualifiedName":"abap_visibility"}), "is_interface": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_inherited": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_redefined": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_abstract": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_final": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_class": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "alias_for": new abap.types.Character(61, {"qualifiedName":"abap_methname"}), "is_raising_excps": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_methdescr", undefined, {}, {}));
    let fs_parameter_ = new abap.types.FieldSymbol(new abap.types.Structure({"length": new abap.types.Integer({qualifiedName: "LENGTH"}), "decimals": new abap.types.Integer({qualifiedName: "DECIMALS"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "name": new abap.types.Character(30, {"qualifiedName":"abap_parmname"}), "parm_kind": new abap.types.Character(1, {"qualifiedName":"abap_parmkind"}), "by_value": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "is_optional": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, "abap_parmdescr", undefined, {}, {}));
    let fs_atype_ = new abap.types.FieldSymbol(new abap.types.Structure({"name": new abap.types.Character(61, {"qualifiedName":"abap_attrname"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"})}, "cl_abap_objectdescr=>ty_attribute_types", undefined, {}, {}));
    let fs_ptype_ = new abap.types.FieldSymbol(new abap.types.Structure({"method": new abap.types.String({qualifiedName: "CL_ABAP_OBJECTDESCR=>TY_PARAMETER_TYPES-METHOD"}), "parameter": new abap.types.String({qualifiedName: "CL_ABAP_OBJECTDESCR=>TY_PARAMETER_TYPES-PARAMETER"}), "type": new abap.types.DataReference(new abap.types.Character(4))}, "cl_abap_objectdescr=>ty_parameter_types", undefined, {}, {}));
    for (const a in p_object?.ATTRIBUTES || []) {
        lv_name.set(a);
      fs_attr_.assign(this.attributes.appendInitial());
      fs_atype_.assign(this.mt_attribute_types.appendInitial());
      fs_attr_.get().name.set(lv_name);
      fs_atype_.get().name.set(lv_name);
      fs_attr_.get().is_interface.set(abap.builtin.boolc(abap.compare.ca(lv_name, new abap.types.Character(1).set('~'))));
        lv_char1.set(p_object.ATTRIBUTES[a].is_constant);
      fs_attr_.get().is_constant.set(lv_char1);
        lv_char1.set(p_object.ATTRIBUTES[a].is_class || "");
      fs_attr_.get().is_class.set(lv_char1);
        lv_char1.set(p_object.ATTRIBUTES[a].visibility);
      fs_attr_.get().visibility.set(lv_char1);
        lv_any = p_object.ATTRIBUTES[a].type();
      await abap.statements.cast(fs_atype_.get().type, (await this.describe_by_data({p_data: lv_any})));
      fs_attr_.get().type_kind.set(fs_atype_.get().type.get().type_kind);
      fs_attr_.get().length.set(fs_atype_.get().type.get().length);
      fs_attr_.get().decimals.set(fs_atype_.get().type.get().decimals);
    }
    abap.statements.sort(this.attributes,{by: [{component: "is_interface", descending: true},{component: "name"}]});
    for (const a of p_object?.IMPLEMENTED_INTERFACES || []) {
        lv_name.set(a);
      fs_intf_.assign(this.interfaces.appendInitial());
      fs_intf_.get().name.set(lv_name);
    }
    abap.statements.sort(this.interfaces,{by: [{component: "name"}]});
    for (const a in p_object?.METHODS || []) {
        lv_name.set(a);
      fs_method_.assign(this.methods.appendInitial());
      fs_method_.get().name.set(lv_name);
        lv_char1.set(p_object.METHODS[a].visibility);
      fs_method_.get().visibility.set(lv_char1);
      for (const p in p_object.METHODS[a].parameters || []) {
        fs_ptype_.assign(this.mt_parameter_types.appendInitial());
        fs_parameter_.assign(fs_method_.get().parameters.appendInitial());
        fs_ptype_.get().method.set(fs_method_.get().name);
          lv_name.set(p);
        fs_parameter_.get().name.set(lv_name);
        fs_ptype_.get().parameter.set(lv_name);
          lv_any = p_object.METHODS[a].parameters[p].type();
        fs_ptype_.get().type.assign(lv_any);
      }
    }
    abap.statements.sort(this.methods,{by: [{component: "name"}]});
    await super.constructor_();
    return this;
  }
  async get_method_parameter_type(INPUT) {
    let p_descr_ref = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"});
    let p_method_name = INPUT?.p_method_name;
    let p_parameter_name = INPUT?.p_parameter_name;
    let ls_row = new abap.types.Structure({"method": new abap.types.String({qualifiedName: "CL_ABAP_OBJECTDESCR=>TY_PARAMETER_TYPES-METHOD"}), "parameter": new abap.types.String({qualifiedName: "CL_ABAP_OBJECTDESCR=>TY_PARAMETER_TYPES-PARAMETER"}), "type": new abap.types.DataReference(new abap.types.Character(4))}, "cl_abap_objectdescr=>ty_parameter_types", undefined, {}, {});
    abap.statements.readTable(this.mt_parameter_types,{into: ls_row,
      withKey: (i) => {return abap.compare.eq(i.method, p_method_name) && abap.compare.eq(i.parameter, p_parameter_name);},
      withKeyValue: [{key: (i) => {return i.method}, value: p_method_name},{key: (i) => {return i.parameter}, value: p_parameter_name}],
      usesTableLine: false,
      withKeySimple: {"method": p_method_name,"parameter": p_parameter_name}});
    if (abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
      await abap.statements.cast(p_descr_ref, (await this.describe_by_data({p_data: (ls_row.get().type).dereference()})));
    } else {
      throw new abap.ClassicError({classic: "parameter_not_found"});
    }
    return p_descr_ref;
  }
  async get_interface_type(INPUT) {
    let p_descr_ref = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_INTFDESCR", RTTIName: "\\CLASS=CL_ABAP_INTFDESCR"});
    let p_name = INPUT?.p_name;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return p_descr_ref;
  }
  async get_attribute_type(INPUT) {
    let p_descr_ref = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"});
    let p_name = INPUT?.p_name;
    let lv_name = new abap.types.Character(61, {"qualifiedName":"abap_attrname"});
    let ls_type = new abap.types.Structure({"name": new abap.types.Character(61, {"qualifiedName":"abap_attrname"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"})}, "cl_abap_objectdescr=>ty_attribute_types", undefined, {}, {});
    lv_name.set(abap.builtin.to_upper({val: p_name}));
    abap.statements.readTable(this.mt_attribute_types,{into: ls_type,
      withKey: (i) => {return abap.compare.eq(i.name, lv_name);},
      withKeyValue: [{key: (i) => {return i.name}, value: lv_name}],
      usesTableLine: false,
      withKeySimple: {"name": lv_name}});
    if (abap.compare.ne(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
      throw new abap.ClassicError({classic: "attribute_not_found"});
    }
    p_descr_ref.set(ls_type.get().type);
    return p_descr_ref;
  }
}
abap.Classes['CL_ABAP_OBJECTDESCR'] = cl_abap_objectdescr;
cl_abap_objectdescr.changing = new abap.types.Character(1, {"qualifiedName":"abap_parmkind"});
cl_abap_objectdescr.changing.set('C');
cl_abap_objectdescr.exporting = new abap.types.Character(1, {"qualifiedName":"abap_parmkind"});
cl_abap_objectdescr.exporting.set('E');
cl_abap_objectdescr.importing = new abap.types.Character(1, {"qualifiedName":"abap_parmkind"});
cl_abap_objectdescr.importing.set('I');
cl_abap_objectdescr.receiving = new abap.types.Character(1, {"qualifiedName":"abap_parmkind"});
cl_abap_objectdescr.receiving.set('R');
cl_abap_objectdescr.returning = new abap.types.Character(1, {"qualifiedName":"abap_parmkind"});
cl_abap_objectdescr.returning.set('R');
cl_abap_objectdescr.private_ = new abap.types.Character(1, {"qualifiedName":"abap_visibility"});
cl_abap_objectdescr.private_.set('I');
cl_abap_objectdescr.protected = new abap.types.Character(1, {"qualifiedName":"abap_visibility"});
cl_abap_objectdescr.protected.set('O');
cl_abap_objectdescr.public_ = new abap.types.Character(1, {"qualifiedName":"abap_visibility"});
cl_abap_objectdescr.public_.set('U');
cl_abap_objectdescr.ty_attribute_types = new abap.types.Structure({"name": new abap.types.Character(61, {"qualifiedName":"abap_attrname"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"})}, "cl_abap_objectdescr=>ty_attribute_types", undefined, {}, {});
cl_abap_objectdescr.ty_parameter_types = new abap.types.Structure({"method": new abap.types.String({qualifiedName: "CL_ABAP_OBJECTDESCR=>TY_PARAMETER_TYPES-METHOD"}), "parameter": new abap.types.String({qualifiedName: "CL_ABAP_OBJECTDESCR=>TY_PARAMETER_TYPES-PARAMETER"}), "type": new abap.types.DataReference(new abap.types.Character(4))}, "cl_abap_objectdescr=>ty_parameter_types", undefined, {}, {});

//# sourceMappingURL=cl_abap_objectdescr.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_random.clas.mjs":
/*!****************************************!*\
  !*** ./output/cl_abap_random.clas.mjs ***!
  \****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_random": () => (/* binding */ cl_abap_random)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_random.clas.abap
class cl_abap_random {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_RANDOM';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"CREATE": {"visibility": "U", "parameters": {"RO_RANDOM": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_RANDOM", RTTIName: "\\CLASS=CL_ABAP_RANDOM"});}, "is_optional": " "}, "SEED": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "INT": {"visibility": "U", "parameters": {"RV_INTEGER": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "INTINRANGE": {"visibility": "U", "parameters": {"RV_INTEGER": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "LOW": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "HIGH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "SEED": {"visibility": "U", "parameters": {"RV_SEED": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async create(INPUT) {
    return cl_abap_random.create(INPUT);
  }
  static async create(INPUT) {
    let ro_random = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_RANDOM", RTTIName: "\\CLASS=CL_ABAP_RANDOM"});
    let seed = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.seed) {seed.set(INPUT.seed);}
    ro_random.set(await (new abap.Classes['CL_ABAP_RANDOM']()).constructor_());
    return ro_random;
  }
  async int() {
    let rv_integer = new abap.types.Integer({qualifiedName: "I"});
    rv_integer.set(Math.floor(Math.random() * 2147483647));
    return rv_integer;
  }
  async seed() {
    return cl_abap_random.seed();
  }
  static async seed() {
    let rv_seed = new abap.types.Integer({qualifiedName: "I"});
    rv_seed.set(Math.floor(Math.random() * 2147483647));
    return rv_seed;
  }
  async intinrange(INPUT) {
    let rv_integer = new abap.types.Integer({qualifiedName: "I"});
    let low = INPUT?.low;
    if (low?.getQualifiedName === undefined || low.getQualifiedName() !== "I") { low = undefined; }
    if (low === undefined) { low = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.low); }
    let high = INPUT?.high;
    if (high?.getQualifiedName === undefined || high.getQualifiedName() !== "I") { high = undefined; }
    if (high === undefined) { high = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.high); }
    let lv_interval = new abap.types.Integer({qualifiedName: "I"});
    abap.statements.assert(abap.compare.gt(high, low));
    abap.statements.assert(abap.compare.ge(low, abap.IntegerFactory.get(0)));
    lv_interval.set(abap.operators.add(abap.operators.minus(high,low),abap.IntegerFactory.get(1)));
    rv_integer.set((abap.builtin.abs({val: (await this.int())})));
    rv_integer.set(abap.operators.mod(rv_integer,lv_interval));
    rv_integer.set(abap.operators.add(rv_integer,low));
    return rv_integer;
  }
}
abap.Classes['CL_ABAP_RANDOM'] = cl_abap_random;

//# sourceMappingURL=cl_abap_random.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_random_int.clas.mjs":
/*!********************************************!*\
  !*** ./output/cl_abap_random_int.clas.mjs ***!
  \********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_random_int": () => (/* binding */ cl_abap_random_int)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_random_int.clas.abap
class cl_abap_random_int {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_RANDOM_INT';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"MV_MIN": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MV_MAX": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "I", "is_constant": " ", "is_class": " "}};
  static METHODS = {"CREATE": {"visibility": "U", "parameters": {"PRNG": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_RANDOM_INT", RTTIName: "\\CLASS=CL_ABAP_RANDOM_INT"});}, "is_optional": " "}, "SEED": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "MIN": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "MAX": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_NEXT": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.mv_min = new abap.types.Integer({qualifiedName: "I"});
    this.mv_max = new abap.types.Integer({qualifiedName: "I"});
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async create(INPUT) {
    return cl_abap_random_int.create(INPUT);
  }
  static async create(INPUT) {
    let prng = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_RANDOM_INT", RTTIName: "\\CLASS=CL_ABAP_RANDOM_INT"});
    let seed = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.seed) {seed.set(INPUT.seed);}
    let min = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.min) {min.set(INPUT.min);}
    if (INPUT === undefined || INPUT.min === undefined) {min = new abap.types.Integer().set(-2147483648);}
    let max = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.max) {max.set(INPUT.max);}
    if (INPUT === undefined || INPUT.max === undefined) {max = new abap.types.Integer().set(2147483647);}
    prng.set(await (new abap.Classes['CL_ABAP_RANDOM_INT']()).constructor_());
    prng.get().mv_min.set(min);
    prng.get().mv_max.set(max);
    return prng;
  }
  async get_next() {
    let value = new abap.types.Integer({qualifiedName: "I"});
    value.set((await (await abap.Classes['CL_ABAP_RANDOM'].create()).get().intinrange({low: this.mv_min, high: this.mv_max})));
    return value;
  }
}
abap.Classes['CL_ABAP_RANDOM_INT'] = cl_abap_random_int;

//# sourceMappingURL=cl_abap_random_int.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_refdescr.clas.mjs":
/*!******************************************!*\
  !*** ./output/cl_abap_refdescr.clas.mjs ***!
  \******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_refdescr": () => (/* binding */ cl_abap_refdescr)
/* harmony export */ });
const {cl_abap_datadescr} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_datadescr.clas.mjs */ "./output/cl_abap_datadescr.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_refdescr.clas.abap
class cl_abap_refdescr extends cl_abap_datadescr {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_REFDESCR';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"REFERENCED": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});}, "visibility": "I", "is_constant": " ", "is_class": " "}};
  static METHODS = {"GET_REFERENCED_TYPE": {"visibility": "U", "parameters": {"TYPE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});}, "is_optional": " "}}},
  "GET_REF_TO_DATA": {"visibility": "U", "parameters": {"P_RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_REFDESCR", RTTIName: "\\CLASS=CL_ABAP_REFDESCR"});}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.referenced = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async get_referenced_type() {
    let type = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});
    type.set(this.referenced);
    return type;
  }
  async get_ref_to_data() {
    return cl_abap_refdescr.get_ref_to_data();
  }
  static async get_ref_to_data() {
    let p_result = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_REFDESCR", RTTIName: "\\CLASS=CL_ABAP_REFDESCR"});
    let foo = new abap.types.DataReference(new abap.types.Character(4));
    await abap.statements.cast(p_result, (await abap.Classes['CL_ABAP_TYPEDESCR'].describe_by_data({p_data: foo})));
    return p_result;
  }
}
abap.Classes['CL_ABAP_REFDESCR'] = cl_abap_refdescr;

//# sourceMappingURL=cl_abap_refdescr.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_regex.clas.mjs":
/*!***************************************!*\
  !*** ./output/cl_abap_regex.clas.mjs ***!
  \***************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_regex": () => (/* binding */ cl_abap_regex)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_regex.clas.abap
class cl_abap_regex {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_REGEX';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"MV_PATTERN": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MV_IGNORE_CASE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "visibility": "I", "is_constant": " ", "is_class": " "}};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"PATTERN": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "IGNORE_CASE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "CREATE_MATCHER": {"visibility": "U", "parameters": {"RO_MATCHER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_MATCHER", RTTIName: "\\CLASS=CL_ABAP_MATCHER"});}, "is_optional": " "}, "TEXT": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "CREATE_PCRE": {"visibility": "U", "parameters": {"REGEX": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_REGEX", RTTIName: "\\CLASS=CL_ABAP_REGEX"});}, "is_optional": " "}, "PATTERN": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "IGNORE_CASE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.mv_pattern = new abap.types.String({qualifiedName: "STRING"});
    this.mv_ignore_case = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
  }
  async constructor_(INPUT) {
    let pattern = INPUT?.pattern;
    let ignore_case = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.ignore_case) {ignore_case.set(INPUT.ignore_case);}
    if (INPUT === undefined || INPUT.ignore_case === undefined) {ignore_case = abap.builtin.abap_false;}
    this.mv_pattern.set(pattern);
    this.mv_ignore_case.set(ignore_case);
    return this;
  }
  async create_pcre(INPUT) {
    return cl_abap_regex.create_pcre(INPUT);
  }
  static async create_pcre(INPUT) {
    let regex = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_REGEX", RTTIName: "\\CLASS=CL_ABAP_REGEX"});
    let pattern = INPUT?.pattern;
    let ignore_case = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.ignore_case) {ignore_case.set(INPUT.ignore_case);}
    if (INPUT === undefined || INPUT.ignore_case === undefined) {ignore_case = abap.builtin.abap_false;}
    regex.set(await (new abap.Classes['CL_ABAP_REGEX']()).constructor_({pattern: pattern, ignore_case: ignore_case}));
    return regex;
  }
  async create_matcher(INPUT) {
    let ro_matcher = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_MATCHER", RTTIName: "\\CLASS=CL_ABAP_MATCHER"});
    let text = INPUT?.text;
    ro_matcher.set(await (new abap.Classes['CL_ABAP_MATCHER']()).constructor_({pattern: this.mv_pattern, ignore_case: this.mv_ignore_case, text: text}));
    return ro_matcher;
  }
}
abap.Classes['CL_ABAP_REGEX'] = cl_abap_regex;

//# sourceMappingURL=cl_abap_regex.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_structdescr.clas.mjs":
/*!*********************************************!*\
  !*** ./output/cl_abap_structdescr.clas.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_structdescr": () => (/* binding */ cl_abap_structdescr)
/* harmony export */ });
const {cl_abap_complexdescr} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_complexdescr.clas.mjs */ "./output/cl_abap_complexdescr.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_structdescr.clas.abap
class cl_abap_structdescr extends cl_abap_complexdescr {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_STRUCTDESCR';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"COMPONENTS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"length": new abap.types.Integer({qualifiedName: "LENGTH"}), "decimals": new abap.types.Integer({qualifiedName: "DECIMALS"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "name": new abap.types.Character(30, {"qualifiedName":"abap_compname"})}, "abap_compdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_compdescr_tab");}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "STRUCT_KIND": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_structkind"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "MT_REFS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_component_tab");}, "visibility": "I", "is_constant": " ", "is_class": " "}};
  static METHODS = {"UPDATE_COMPONENTS": {"visibility": "I", "parameters": {}},
  "CONSTRUCT_FROM_DATA": {"visibility": "U", "parameters": {"DESCR": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_STRUCTDESCR", RTTIName: "\\CLASS=CL_ABAP_STRUCTDESCR"});}, "is_optional": " "}, "DATA": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "GET_COMPONENTS": {"visibility": "U", "parameters": {"RT_COMPONENTS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_component_tab");}, "is_optional": " "}}},
  "GET_DDIC_FIELD_LIST": {"visibility": "U", "parameters": {"RT_COMPONENTS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"tabname": new abap.types.Character(30, {}), "fieldname": new abap.types.Character(30, {}), "langu": new abap.types.Character(1, {}), "position": new abap.types.Numc({length: 4}), "offset": new abap.types.Numc({length: 6}), "domname": new abap.types.Character(30, {}), "rollname": new abap.types.Character(30, {}), "checktable": new abap.types.Character(1, {}), "leng": new abap.types.Numc({length: 6}), "intlen": new abap.types.Numc({length: 6}), "outputlen": new abap.types.Numc({length: 6}), "decimals": new abap.types.Numc({length: 6}), "datatype": new abap.types.Character(1, {}), "inttype": new abap.types.Character(1, {}), "reftable": new abap.types.Character(1, {}), "reffield": new abap.types.Character(1, {}), "precfield": new abap.types.Character(1, {}), "authorid": new abap.types.Character(1, {}), "memoryid": new abap.types.Character(1, {}), "logflag": new abap.types.Character(1, {}), "mask": new abap.types.Character(20, {}), "masklen": new abap.types.Character(1, {}), "convexit": new abap.types.Character(1, {}), "headlen": new abap.types.Character(1, {}), "scrlen1": new abap.types.Character(1, {}), "scrlen2": new abap.types.Character(1, {}), "scrlen3": new abap.types.Character(1, {}), "fieldtext": new abap.types.Character(1, {}), "reptext": new abap.types.Character(1, {}), "scrtext_s": new abap.types.Character(1, {}), "scrtext_m": new abap.types.Character(1, {}), "scrtext_l": new abap.types.Character(1, {}), "keyflag": new abap.types.Character(1, {}), "lowercase": new abap.types.Character(1, {}), "mac": new abap.types.Character(1, {}), "genkey": new abap.types.Character(1, {}), "noforkey": new abap.types.Character(1, {}), "valexi": new abap.types.Character(1, {}), "noauthch": new abap.types.Character(1, {}), "sign": new abap.types.Character(1, {}), "dynpfld": new abap.types.Character(1, {}), "f4availabl": new abap.types.Character(1, {}), "comptype": new abap.types.Character(1, {}), "outputstyle": new abap.types.Character(1, {}), "lfieldname": new abap.types.Character(132, {})}, "DFIES", "DFIES", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "DDFIELDS");}, "is_optional": " "}, "P_LANGU": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"sy-langu","conversionExit":"ISOLA"});}, "is_optional": " "}, "P_INCLUDING_SUBSTRUCTRES": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "GET_COMPONENT_TYPE": {"visibility": "U", "parameters": {"P_DESCR_REF": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"});}, "is_optional": " "}, "P_NAME": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "GET_INCLUDED_VIEW": {"visibility": "U", "parameters": {"P_RESULT": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"})}, "abap_simple_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_component_view_tab");}, "is_optional": " "}, "P_LEVEL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET": {"visibility": "U", "parameters": {"P_RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_STRUCTDESCR", RTTIName: "\\CLASS=CL_ABAP_STRUCTDESCR"});}, "is_optional": " "}, "P_COMPONENTS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_component_tab");}, "is_optional": " "}}},
  "CREATE": {"visibility": "U", "parameters": {"REF": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_STRUCTDESCR", RTTIName: "\\CLASS=CL_ABAP_STRUCTDESCR"});}, "is_optional": " "}, "P_COMPONENTS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_component_tab");}, "is_optional": " "}, "P_STRICT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "GET_SYMBOLS": {"visibility": "U", "parameters": {"P_RESULT": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"})}, "abap_simple_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"HASHED","isUnique":true,"keyFields":["NAME"]},"secondary":[]}, "abap_component_symbol_tab");}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.components = abap.types.TableFactory.construct(new abap.types.Structure({"length": new abap.types.Integer({qualifiedName: "LENGTH"}), "decimals": new abap.types.Integer({qualifiedName: "DECIMALS"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "name": new abap.types.Character(30, {"qualifiedName":"abap_compname"})}, "abap_compdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_compdescr_tab");
    this.struct_kind = new abap.types.Character(1, {"qualifiedName":"abap_structkind"});
    this.mt_refs = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_component_tab");
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async get_symbols() {
    let p_result = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"})}, "abap_simple_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"HASHED","isUnique":true,"keyFields":["NAME"]},"secondary":[]}, "abap_component_symbol_tab");
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return p_result;
  }
  async get(INPUT) {
    return cl_abap_structdescr.get(INPUT);
  }
  static async get(INPUT) {
    let p_result = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_STRUCTDESCR", RTTIName: "\\CLASS=CL_ABAP_STRUCTDESCR"});
    let p_components = INPUT?.p_components;
    if (p_components?.getQualifiedName === undefined || p_components.getQualifiedName() !== "ABAP_COMPONENT_TAB") { p_components = undefined; }
    if (p_components === undefined) { p_components = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_component_tab").set(INPUT.p_components); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return p_result;
  }
  async create(INPUT) {
    return cl_abap_structdescr.create(INPUT);
  }
  static async create(INPUT) {
    let ref = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_STRUCTDESCR", RTTIName: "\\CLASS=CL_ABAP_STRUCTDESCR"});
    let p_components = INPUT?.p_components;
    if (p_components?.getQualifiedName === undefined || p_components.getQualifiedName() !== "ABAP_COMPONENT_TAB") { p_components = undefined; }
    if (p_components === undefined) { p_components = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_component_tab").set(INPUT.p_components); }
    let p_strict = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.p_strict) {p_strict.set(INPUT.p_strict);}
    let ls_component = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {});
    let ls_ref = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {});
    if (abap.compare.eq(abap.builtin.lines({val: p_components}), abap.IntegerFactory.get(0))) {
      const unique112 = await (new abap.Classes['CX_SY_STRUCT_ATTRIBUTES']()).constructor_();
      unique112.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_structdescr.clas.abap","INTERNAL_LINE": 87};
      throw unique112;
    }
    for await (const unique113 of abap.statements.loop(p_components)) {
      ls_component.set(unique113);
      if (abap.compare.initial(ls_component.get().name)) {
        const unique114 = await (new abap.Classes['CX_SY_STRUCT_COMP_NAME']()).constructor_();
        unique114.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_structdescr.clas.abap","INTERNAL_LINE": 92};
        throw unique114;
      } else if (abap.compare.initial(ls_component.get().type)) {
        const unique115 = await (new abap.Classes['CX_SY_STRUCT_COMP_TYPE']()).constructor_();
        unique115.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_structdescr.clas.abap","INTERNAL_LINE": 94};
        throw unique115;
      } else if (abap.compare.gt(abap.builtin.strlen({val: ls_component.get().name}), abap.IntegerFactory.get(30))) {
        const unique116 = await (new abap.Classes['CX_SY_STRUCT_COMP_NAME']()).constructor_();
        unique116.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_structdescr.clas.abap","INTERNAL_LINE": 96};
        throw unique116;
      }
    }
    ref.set(await (new abap.Classes['CL_ABAP_STRUCTDESCR']()).constructor_());
    for await (const unique117 of abap.statements.loop(p_components)) {
      ls_component.set(unique117);
      abap.statements.clear(ls_ref);
      ls_ref.get().name.set(ls_component.get().name);
      ls_ref.get().type.set(ls_component.get().type);
      abap.statements.append({source: ls_ref, target: ref.get().mt_refs});
    }
    await ref.get().update_components();
    ref.get().type_kind.set(cl_abap_structdescr.typekind_struct2);
    ref.get().kind.set(cl_abap_structdescr.kind_struct);
    return ref;
  }
  async get_included_view(INPUT) {
    let p_result = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"})}, "abap_simple_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_component_view_tab");
    let p_level = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.p_level) {p_level.set(INPUT.p_level);}
    let ls_component = new abap.types.Structure({"length": new abap.types.Integer({qualifiedName: "LENGTH"}), "decimals": new abap.types.Integer({qualifiedName: "DECIMALS"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "name": new abap.types.Character(30, {"qualifiedName":"abap_compname"})}, "abap_compdescr", undefined, {}, {});
    let ls_view = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"})}, "abap_simple_componentdescr", undefined, {}, {});
    let ls_ref = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {});
    for await (const unique118 of abap.statements.loop(this.components)) {
      ls_component.set(unique118);
      abap.statements.clear(ls_view);
      ls_view.get().name.set(ls_component.get().name);
      abap.statements.readTable(this.mt_refs,{into: ls_ref,
        withKey: (i) => {return abap.compare.eq(i.name, ls_component.get().name);},
        withKeyValue: [{key: (i) => {return i.name}, value: ls_component.get().name}],
        usesTableLine: false,
        withKeySimple: {"name": ls_component.get().name}});
      if (abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
        ls_view.get().type.set(ls_ref.get().type);
      }
      if (abap.compare.eq(ls_ref.get().as_include, abap.builtin.abap_true)) {
        continue;
      }
      abap.statements.insertInternal({data: ls_view, table: p_result});
    }
    return p_result;
  }
  async get_ddic_field_list(INPUT) {
    let rt_components = abap.types.TableFactory.construct(new abap.types.Structure({"tabname": new abap.types.Character(30, {}), "fieldname": new abap.types.Character(30, {}), "langu": new abap.types.Character(1, {}), "position": new abap.types.Numc({length: 4}), "offset": new abap.types.Numc({length: 6}), "domname": new abap.types.Character(30, {}), "rollname": new abap.types.Character(30, {}), "checktable": new abap.types.Character(1, {}), "leng": new abap.types.Numc({length: 6}), "intlen": new abap.types.Numc({length: 6}), "outputlen": new abap.types.Numc({length: 6}), "decimals": new abap.types.Numc({length: 6}), "datatype": new abap.types.Character(1, {}), "inttype": new abap.types.Character(1, {}), "reftable": new abap.types.Character(1, {}), "reffield": new abap.types.Character(1, {}), "precfield": new abap.types.Character(1, {}), "authorid": new abap.types.Character(1, {}), "memoryid": new abap.types.Character(1, {}), "logflag": new abap.types.Character(1, {}), "mask": new abap.types.Character(20, {}), "masklen": new abap.types.Character(1, {}), "convexit": new abap.types.Character(1, {}), "headlen": new abap.types.Character(1, {}), "scrlen1": new abap.types.Character(1, {}), "scrlen2": new abap.types.Character(1, {}), "scrlen3": new abap.types.Character(1, {}), "fieldtext": new abap.types.Character(1, {}), "reptext": new abap.types.Character(1, {}), "scrtext_s": new abap.types.Character(1, {}), "scrtext_m": new abap.types.Character(1, {}), "scrtext_l": new abap.types.Character(1, {}), "keyflag": new abap.types.Character(1, {}), "lowercase": new abap.types.Character(1, {}), "mac": new abap.types.Character(1, {}), "genkey": new abap.types.Character(1, {}), "noforkey": new abap.types.Character(1, {}), "valexi": new abap.types.Character(1, {}), "noauthch": new abap.types.Character(1, {}), "sign": new abap.types.Character(1, {}), "dynpfld": new abap.types.Character(1, {}), "f4availabl": new abap.types.Character(1, {}), "comptype": new abap.types.Character(1, {}), "outputstyle": new abap.types.Character(1, {}), "lfieldname": new abap.types.Character(132, {})}, "DFIES", "DFIES", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "DDFIELDS");
    let p_langu = new abap.types.Character(1, {"qualifiedName":"sy-langu","conversionExit":"ISOLA"});
    if (INPUT && INPUT.p_langu) {p_langu.set(INPUT.p_langu);}
    if (INPUT === undefined || INPUT.p_langu === undefined) {p_langu = abap.builtin.sy.get().langu;}
    let p_including_substructres = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.p_including_substructres) {p_including_substructres.set(INPUT.p_including_substructres);}
    if (INPUT === undefined || INPUT.p_including_substructres === undefined) {p_including_substructres = abap.builtin.abap_false;}
    let lt_components = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_component_tab");
    let ls_component = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {});
    let ls_return = new abap.types.Structure({"tabname": new abap.types.Character(30, {}), "fieldname": new abap.types.Character(30, {}), "langu": new abap.types.Character(1, {}), "position": new abap.types.Numc({length: 4}), "offset": new abap.types.Numc({length: 6}), "domname": new abap.types.Character(30, {}), "rollname": new abap.types.Character(30, {}), "checktable": new abap.types.Character(1, {}), "leng": new abap.types.Numc({length: 6}), "intlen": new abap.types.Numc({length: 6}), "outputlen": new abap.types.Numc({length: 6}), "decimals": new abap.types.Numc({length: 6}), "datatype": new abap.types.Character(1, {}), "inttype": new abap.types.Character(1, {}), "reftable": new abap.types.Character(1, {}), "reffield": new abap.types.Character(1, {}), "precfield": new abap.types.Character(1, {}), "authorid": new abap.types.Character(1, {}), "memoryid": new abap.types.Character(1, {}), "logflag": new abap.types.Character(1, {}), "mask": new abap.types.Character(20, {}), "masklen": new abap.types.Character(1, {}), "convexit": new abap.types.Character(1, {}), "headlen": new abap.types.Character(1, {}), "scrlen1": new abap.types.Character(1, {}), "scrlen2": new abap.types.Character(1, {}), "scrlen3": new abap.types.Character(1, {}), "fieldtext": new abap.types.Character(1, {}), "reptext": new abap.types.Character(1, {}), "scrtext_s": new abap.types.Character(1, {}), "scrtext_m": new abap.types.Character(1, {}), "scrtext_l": new abap.types.Character(1, {}), "keyflag": new abap.types.Character(1, {}), "lowercase": new abap.types.Character(1, {}), "mac": new abap.types.Character(1, {}), "genkey": new abap.types.Character(1, {}), "noforkey": new abap.types.Character(1, {}), "valexi": new abap.types.Character(1, {}), "noauthch": new abap.types.Character(1, {}), "sign": new abap.types.Character(1, {}), "dynpfld": new abap.types.Character(1, {}), "f4availabl": new abap.types.Character(1, {}), "comptype": new abap.types.Character(1, {}), "outputstyle": new abap.types.Character(1, {}), "lfieldname": new abap.types.Character(132, {})}, "DFIES", "DFIES", {}, {});
    let lv_name = new abap.types.String({qualifiedName: "STRING"});
    let lv_keyfield = new abap.types.String({qualifiedName: "STRING"});
    let lo_elemdescr = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});
    let fs_component_ = new abap.types.FieldSymbol(new abap.types.Structure({"tabname": new abap.types.Character(30, {}), "fieldname": new abap.types.Character(30, {}), "langu": new abap.types.Character(1, {}), "position": new abap.types.Numc({length: 4}), "offset": new abap.types.Numc({length: 6}), "domname": new abap.types.Character(30, {}), "rollname": new abap.types.Character(30, {}), "checktable": new abap.types.Character(1, {}), "leng": new abap.types.Numc({length: 6}), "intlen": new abap.types.Numc({length: 6}), "outputlen": new abap.types.Numc({length: 6}), "decimals": new abap.types.Numc({length: 6}), "datatype": new abap.types.Character(1, {}), "inttype": new abap.types.Character(1, {}), "reftable": new abap.types.Character(1, {}), "reffield": new abap.types.Character(1, {}), "precfield": new abap.types.Character(1, {}), "authorid": new abap.types.Character(1, {}), "memoryid": new abap.types.Character(1, {}), "logflag": new abap.types.Character(1, {}), "mask": new abap.types.Character(20, {}), "masklen": new abap.types.Character(1, {}), "convexit": new abap.types.Character(1, {}), "headlen": new abap.types.Character(1, {}), "scrlen1": new abap.types.Character(1, {}), "scrlen2": new abap.types.Character(1, {}), "scrlen3": new abap.types.Character(1, {}), "fieldtext": new abap.types.Character(1, {}), "reptext": new abap.types.Character(1, {}), "scrtext_s": new abap.types.Character(1, {}), "scrtext_m": new abap.types.Character(1, {}), "scrtext_l": new abap.types.Character(1, {}), "keyflag": new abap.types.Character(1, {}), "lowercase": new abap.types.Character(1, {}), "mac": new abap.types.Character(1, {}), "genkey": new abap.types.Character(1, {}), "noforkey": new abap.types.Character(1, {}), "valexi": new abap.types.Character(1, {}), "noauthch": new abap.types.Character(1, {}), "sign": new abap.types.Character(1, {}), "dynpfld": new abap.types.Character(1, {}), "f4availabl": new abap.types.Character(1, {}), "comptype": new abap.types.Character(1, {}), "outputstyle": new abap.types.Character(1, {}), "lfieldname": new abap.types.Character(132, {})}, "DFIES", "DFIES", {}, {}));
    lt_components.set((await this.get_components()));
    abap.statements.assert(abap.compare.cp(this.absolute_name, new abap.types.Character(7).set('+TYPE=*')));
    lv_name.set(this.absolute_name.getOffset({offset: 6}));
    for await (const unique119 of abap.statements.loop(lt_components)) {
      ls_component.set(unique119);
      abap.statements.clear(ls_return);
      ls_return.get().tabname.set(lv_name);
      ls_return.get().fieldname.set(ls_component.get().name);
      if (abap.compare.eq(ls_component.get().type.get().kind, abap.Classes['CL_ABAP_TYPEDESCR'].kind_elem)) {
        await abap.statements.cast(lo_elemdescr, ls_component.get().type);
        ls_return.get().leng.set(lo_elemdescr.get().output_length);
      }
      abap.statements.append({source: ls_return, target: rt_components});
    }
    for (const keyfield of abap.DDIC[lv_name.get()]?.keyFields || [] ) {
      lv_keyfield.set(keyfield);
      abap.statements.readTable(rt_components,{assigning: fs_component_,
        withKey: (i) => {return abap.compare.eq(i.fieldname, lv_keyfield);},
        withKeyValue: [{key: (i) => {return i.fieldname}, value: lv_keyfield}],
        usesTableLine: false,
        withKeySimple: {"fieldname": lv_keyfield}});
      abap.statements.assert(abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0)));
      fs_component_.get().keyflag.set(abap.builtin.abap_true);
    }
    return rt_components;
  }
  async construct_from_data(INPUT) {
    return cl_abap_structdescr.construct_from_data(INPUT);
  }
  static async construct_from_data(INPUT) {
    let descr = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_STRUCTDESCR", RTTIName: "\\CLASS=CL_ABAP_STRUCTDESCR"});
    let data = INPUT?.data;
    let lv_name = new abap.types.String({qualifiedName: "STRING"});
    let ls_ref = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {});
    let lv_suffix = new abap.types.String({qualifiedName: "STRING"});
    let lv_as_include = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    let lo_datadescr = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"});
    let fs_fs_ = new abap.types.FieldSymbol(new abap.types.Character(4));
    descr.set(await (new abap.Classes['CL_ABAP_STRUCTDESCR']()).constructor_());
    for (const name of Object.keys(INPUT.data.value)) {
        lv_name.set(name.toUpperCase());
      abap.statements.assign({component: lv_name, target: fs_fs_, source: data});
      await abap.statements.cast(lo_datadescr, (await abap.Classes['CL_ABAP_TYPEDESCR'].describe_by_data({p_data: fs_fs_})));
      ls_ref.get().name.set(lv_name);
      ls_ref.get().type.set(lo_datadescr);
      if (INPUT.data?.getAsInclude) {
          lv_as_include.set(INPUT.data?.getAsInclude()?.[name.toLowerCase()] ? "X" : " ");
      }
      ls_ref.get().as_include.set(lv_as_include);
      if (INPUT.data?.getSuffix) {
          lv_as_include.set(INPUT.data?.getSuffix()?.[name.toLowerCase()] || "");
      }
      ls_ref.get().suffix.set(lv_suffix);
      abap.statements.append({source: ls_ref, target: descr.get().mt_refs});
    }
    await descr.get().update_components();
    return descr;
  }
  async update_components() {
    let ls_component = new abap.types.Structure({"length": new abap.types.Integer({qualifiedName: "LENGTH"}), "decimals": new abap.types.Integer({qualifiedName: "DECIMALS"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "name": new abap.types.Character(30, {"qualifiedName":"abap_compname"})}, "abap_compdescr", undefined, {}, {});
    let fs_ls_ref_ = new abap.types.FieldSymbol(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {}));
    abap.statements.clear(this.components);
    for await (const unique120 of abap.statements.loop(this.mt_refs)) {
      fs_ls_ref_.assign(unique120);
      ls_component.get().name.set(fs_ls_ref_.get().name);
      ls_component.get().type_kind.set(fs_ls_ref_.get().type.get().type_kind);
      ls_component.get().length.set(fs_ls_ref_.get().type.get().length);
      ls_component.get().decimals.set(fs_ls_ref_.get().type.get().decimals);
      abap.statements.append({source: ls_component, target: this.components});
    }
  }
  async get_components() {
    let rt_components = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_component_tab");
    rt_components.set(this.mt_refs);
    return rt_components;
  }
  async get_component_type(INPUT) {
    let p_descr_ref = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"});
    let p_name = INPUT?.p_name;
    let fs_line_ = new abap.types.FieldSymbol(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {}));
    abap.statements.readTable(this.mt_refs,{assigning: fs_line_,
      withKey: (i) => {return abap.compare.eq(i.name, p_name);},
      withKeyValue: [{key: (i) => {return i.name}, value: p_name}],
      usesTableLine: false,
      withKeySimple: {"name": p_name}});
    if (abap.compare.ne(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
      throw new abap.ClassicError({classic: "component_not_found"});
    } else {
      p_descr_ref.set(fs_line_.get().type);
    }
    return p_descr_ref;
  }
}
abap.Classes['CL_ABAP_STRUCTDESCR'] = cl_abap_structdescr;
cl_abap_structdescr.component = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {});
cl_abap_structdescr.component_table = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_component_tab");
cl_abap_structdescr.included_view = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"})}, "abap_simple_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_component_view_tab");
cl_abap_structdescr.symbol_table = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"})}, "abap_simple_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"HASHED","isUnique":true,"keyFields":["NAME"]},"secondary":[]}, "abap_component_symbol_tab");

//# sourceMappingURL=cl_abap_structdescr.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_tabledescr.clas.mjs":
/*!********************************************!*\
  !*** ./output/cl_abap_tabledescr.clas.mjs ***!
  \********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_tabledescr": () => (/* binding */ cl_abap_tabledescr)
/* harmony export */ });
const {cl_abap_datadescr} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_datadescr.clas.mjs */ "./output/cl_abap_datadescr.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_tabledescr.clas.abap
class cl_abap_tabledescr extends cl_abap_datadescr {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_TABLEDESCR';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"HAS_UNIQUE_KEY": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "KEY": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(255, {"qualifiedName":"abap_keyname"})}, "abap_keydescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_keydescr_tab");}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "KEY_DEFKIND": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_keydefkind"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "TABLE_KIND": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_tablekind"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "MO_LINE_TYPE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MT_KEYS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"components": abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"})}, "abap_table_keycompdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_table_keydescr-components"), "name": new abap.types.String({qualifiedName: "NAME"}), "is_primary": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "access_kind": new abap.types.String({qualifiedName: "ACCESS_KIND"}), "is_unique": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "key_kind": new abap.types.String({qualifiedName: "KEY_KIND"})}, "abap_table_keydescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_table_keydescr_tab");}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "TABLEKIND_ANY": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TABLEKIND_STD": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TABLEKIND_INDEX": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TABLEKIND_HASHED": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TABLEKIND_SORTED": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "KEYDEFKIND_DEFAULT": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "KEYDEFKIND_TABLELINE": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "KEYDEFKIND_USER": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "KEYDEFKIND_EMPTY": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"CONSTRUCT_FROM_DATA": {"visibility": "U", "parameters": {"DESCR": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TABLEDESCR", RTTIName: "\\CLASS=CL_ABAP_TABLEDESCR"});}, "is_optional": " "}, "DATA": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "GET_TABLE_LINE_TYPE": {"visibility": "U", "parameters": {"TYPE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"});}, "is_optional": " "}}},
  "GET": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TABLEDESCR", RTTIName: "\\CLASS=CL_ABAP_TABLEDESCR"});}, "is_optional": " "}, "TYPE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});}, "is_optional": " "}}},
  "GET_WITH_KEYS": {"visibility": "U", "parameters": {"P_RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TABLEDESCR", RTTIName: "\\CLASS=CL_ABAP_TABLEDESCR"});}, "is_optional": " "}, "P_LINE_TYPE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"});}, "is_optional": " "}, "P_KEYS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"components": abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"})}, "abap_table_keycompdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_table_keydescr-components"), "name": new abap.types.String({qualifiedName: "NAME"}), "is_primary": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "access_kind": new abap.types.String({qualifiedName: "ACCESS_KIND"}), "is_unique": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "key_kind": new abap.types.String({qualifiedName: "KEY_KIND"})}, "abap_table_keydescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_table_keydescr_tab");}, "is_optional": " "}}},
  "CREATE": {"visibility": "U", "parameters": {"REF": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TABLEDESCR", RTTIName: "\\CLASS=CL_ABAP_TABLEDESCR"});}, "is_optional": " "}, "P_LINE_TYPE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});}, "is_optional": " "}, "P_TABLE_KIND": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_tablekind"});}, "is_optional": " "}, "P_UNIQUE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "P_KEY": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(255, {"qualifiedName":"abap_keyname"})}, "abap_keydescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_keydescr_tab");}, "is_optional": " "}, "P_KEY_KIND": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_keydefkind"});}, "is_optional": " "}}},
  "GET_KEYS": {"visibility": "U", "parameters": {"P_KEYS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"components": abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"})}, "abap_table_keycompdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_table_keydescr-components"), "name": new abap.types.String({qualifiedName: "NAME"}), "is_primary": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "access_kind": new abap.types.String({qualifiedName: "ACCESS_KIND"}), "is_unique": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "key_kind": new abap.types.String({qualifiedName: "KEY_KIND"})}, "abap_table_keydescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_table_keydescr_tab");}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.has_unique_key = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    this.key = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(255, {"qualifiedName":"abap_keyname"})}, "abap_keydescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_keydescr_tab");
    this.key_defkind = new abap.types.Character(1, {"qualifiedName":"abap_keydefkind"});
    this.table_kind = new abap.types.Character(1, {"qualifiedName":"abap_tablekind"});
    this.mo_line_type = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});
    this.mt_keys = abap.types.TableFactory.construct(new abap.types.Structure({"components": abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"})}, "abap_table_keycompdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_table_keydescr-components"), "name": new abap.types.String({qualifiedName: "NAME"}), "is_primary": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "access_kind": new abap.types.String({qualifiedName: "ACCESS_KIND"}), "is_unique": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "key_kind": new abap.types.String({qualifiedName: "KEY_KIND"})}, "abap_table_keydescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_table_keydescr_tab");
    this.tablekind_any = cl_abap_tabledescr.tablekind_any;
    this.tablekind_std = cl_abap_tabledescr.tablekind_std;
    this.tablekind_index = cl_abap_tabledescr.tablekind_index;
    this.tablekind_hashed = cl_abap_tabledescr.tablekind_hashed;
    this.tablekind_sorted = cl_abap_tabledescr.tablekind_sorted;
    this.keydefkind_default = cl_abap_tabledescr.keydefkind_default;
    this.keydefkind_tableline = cl_abap_tabledescr.keydefkind_tableline;
    this.keydefkind_user = cl_abap_tabledescr.keydefkind_user;
    this.keydefkind_empty = cl_abap_tabledescr.keydefkind_empty;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async create(INPUT) {
    return cl_abap_tabledescr.create(INPUT);
  }
  static async create(INPUT) {
    let ref = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TABLEDESCR", RTTIName: "\\CLASS=CL_ABAP_TABLEDESCR"});
    let p_line_type = INPUT?.p_line_type;
    if (p_line_type?.getQualifiedName === undefined || p_line_type.getQualifiedName() !== "CL_ABAP_TYPEDESCR") { p_line_type = undefined; }
    if (p_line_type === undefined) { p_line_type = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"}).set(INPUT.p_line_type); }
    let p_table_kind = new abap.types.Character(1, {"qualifiedName":"abap_tablekind"});
    if (INPUT && INPUT.p_table_kind) {p_table_kind.set(INPUT.p_table_kind);}
    if (INPUT === undefined || INPUT.p_table_kind === undefined) {p_table_kind = this.tablekind_std;}
    let p_unique = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.p_unique) {p_unique.set(INPUT.p_unique);}
    if (INPUT === undefined || INPUT.p_unique === undefined) {p_unique = abap.builtin.abap_false;}
    let p_key = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(255, {"qualifiedName":"abap_keyname"})}, "abap_keydescr", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["NAME"]},"secondary":[]}, "abap_keydescr_tab");
    if (INPUT && INPUT.p_key) {p_key.set(INPUT.p_key);}
    let p_key_kind = new abap.types.Character(1, {"qualifiedName":"abap_keydefkind"});
    if (INPUT && INPUT.p_key_kind) {p_key_kind.set(INPUT.p_key_kind);}
    if (INPUT === undefined || INPUT.p_key_kind === undefined) {p_key_kind = this.keydefkind_default;}
    ref.set(await (new abap.Classes['CL_ABAP_TABLEDESCR']()).constructor_());
    ref.get().has_unique_key.set(p_unique);
    ref.get().mo_line_type.set(p_line_type);
    ref.get().key.set(p_key);
    ref.get().key_defkind.set(p_key_kind);
    ref.get().table_kind.set(p_table_kind);
    ref.get().type_kind.set(cl_abap_tabledescr.typekind_table);
    ref.get().kind.set(cl_abap_tabledescr.kind_table);
    return ref;
  }
  async get_keys() {
    let p_keys = abap.types.TableFactory.construct(new abap.types.Structure({"components": abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"})}, "abap_table_keycompdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_table_keydescr-components"), "name": new abap.types.String({qualifiedName: "NAME"}), "is_primary": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "access_kind": new abap.types.String({qualifiedName: "ACCESS_KIND"}), "is_unique": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "key_kind": new abap.types.String({qualifiedName: "KEY_KIND"})}, "abap_table_keydescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_table_keydescr_tab");
    p_keys.set(this.mt_keys);
    return p_keys;
  }
  async get_with_keys(INPUT) {
    return cl_abap_tabledescr.get_with_keys(INPUT);
  }
  static async get_with_keys(INPUT) {
    let p_result = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TABLEDESCR", RTTIName: "\\CLASS=CL_ABAP_TABLEDESCR"});
    let p_line_type = INPUT?.p_line_type;
    if (p_line_type?.getQualifiedName === undefined || p_line_type.getQualifiedName() !== "CL_ABAP_DATADESCR") { p_line_type = undefined; }
    if (p_line_type === undefined) { p_line_type = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}).set(INPUT.p_line_type); }
    let p_keys = INPUT?.p_keys;
    if (p_keys?.getQualifiedName === undefined || p_keys.getQualifiedName() !== "ABAP_TABLE_KEYDESCR_TAB") { p_keys = undefined; }
    if (p_keys === undefined) { p_keys = abap.types.TableFactory.construct(new abap.types.Structure({"components": abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"})}, "abap_table_keycompdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_table_keydescr-components"), "name": new abap.types.String({qualifiedName: "NAME"}), "is_primary": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "access_kind": new abap.types.String({qualifiedName: "ACCESS_KIND"}), "is_unique": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "key_kind": new abap.types.String({qualifiedName: "KEY_KIND"})}, "abap_table_keydescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_table_keydescr_tab").set(INPUT.p_keys); }
    let ls_key = new abap.types.Structure({"components": abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"})}, "abap_table_keycompdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_table_keydescr-components"), "name": new abap.types.String({qualifiedName: "NAME"}), "is_primary": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "access_kind": new abap.types.String({qualifiedName: "ACCESS_KIND"}), "is_unique": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "key_kind": new abap.types.String({qualifiedName: "KEY_KIND"})}, "abap_table_keydescr", undefined, {}, {});
    if (abap.compare.ne(abap.builtin.lines({val: p_keys}), abap.IntegerFactory.get(1))) {
      abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    }
    abap.statements.readTable(p_keys,{index: abap.IntegerFactory.get(1),
      into: ls_key});
    abap.statements.assert(abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0)));
    p_result.set(await (new abap.Classes['CL_ABAP_TABLEDESCR']()).constructor_());
    p_result.get().has_unique_key.set(ls_key.get().is_unique);
    p_result.get().mo_line_type.set(p_line_type);
    p_result.get().key_defkind.set(ls_key.get().key_kind);
    p_result.get().table_kind.set(ls_key.get().access_kind);
    p_result.get().mt_keys.set(p_keys);
    p_result.get().type_kind.set(cl_abap_tabledescr.typekind_table);
    p_result.get().kind.set(cl_abap_tabledescr.kind_table);
    return p_result;
  }
  async get(INPUT) {
    return cl_abap_tabledescr.get(INPUT);
  }
  static async get(INPUT) {
    let val = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TABLEDESCR", RTTIName: "\\CLASS=CL_ABAP_TABLEDESCR"});
    let type = INPUT?.type;
    if (type?.getQualifiedName === undefined || type.getQualifiedName() !== "CL_ABAP_TYPEDESCR") { type = undefined; }
    if (type === undefined) { type = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"}).set(INPUT.type); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return val;
  }
  async construct_from_data(INPUT) {
    return cl_abap_tabledescr.construct_from_data(INPUT);
  }
  static async construct_from_data(INPUT) {
    let descr = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TABLEDESCR", RTTIName: "\\CLASS=CL_ABAP_TABLEDESCR"});
    let data = INPUT?.data;
    let lv_dummy = new abap.types.Integer({qualifiedName: "I"});
    let lv_flag = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    let lv_str = new abap.types.String({qualifiedName: "STRING"});
    let lv_type = new abap.types.String({qualifiedName: "STRING"});
    let lo_struct = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_STRUCTDESCR", RTTIName: "\\CLASS=CL_ABAP_STRUCTDESCR"});
    let lt_components = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_component_tab");
    let ls_component = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {});
    let ls_key = new abap.types.Structure({"name": new abap.types.Character(255, {"qualifiedName":"abap_keyname"})}, "abap_keydescr", undefined, {}, {});
    descr.set(await (new abap.Classes['CL_ABAP_TABLEDESCR']()).constructor_());
    lv_flag.set(data.getOptions()?.primaryKey?.isUnique === true ? "X" : "");
    descr.get().has_unique_key.set(lv_flag);
    lv_type.set(data.getOptions()?.primaryKey?.type || "");
    let unique121 = lv_type;
    if (abap.compare.eq(unique121, new abap.types.Character(8).set('STANDARD'))) {
      descr.get().table_kind.set(cl_abap_tabledescr.tablekind_std);
    } else if (abap.compare.eq(unique121, new abap.types.Character(6).set('SORTED'))) {
      descr.get().table_kind.set(cl_abap_tabledescr.tablekind_sorted);
    } else if (abap.compare.eq(unique121, new abap.types.Character(6).set('HASHED'))) {
      descr.get().table_kind.set(cl_abap_tabledescr.tablekind_hashed);
    } else {
      descr.get().table_kind.set(cl_abap_tabledescr.tablekind_std);
    }
    lv_dummy = data.getRowType();
    descr.get().mo_line_type.set((await abap.Classes['CL_ABAP_TYPEDESCR'].describe_by_data({p_data: lv_dummy})));
    lv_flag.set(data.getOptions()?.primaryKey?.keyFields.length > 0 ? "X" : "");
    if (abap.compare.eq(lv_flag, abap.builtin.abap_true)) {
      descr.get().key_defkind.set(cl_abap_tabledescr.keydefkind_user);
      for (const k of data.getOptions()?.primaryKey?.keyFields) {
        lv_str.set(k);
        ls_key.get().name.set(lv_str);
        abap.statements.append({source: ls_key, target: descr.get().key});
      }
      if (abap.compare.eq(abap.builtin.lines({val: descr.get().key}), abap.IntegerFactory.get(1)) && abap.compare.eq(ls_key.get().name, new abap.types.Character(10).set('TABLE_LINE'))) {
        descr.get().key_defkind.set(cl_abap_tabledescr.keydefkind_tableline);
      }
    } else {
      descr.get().key_defkind.set(cl_abap_tabledescr.keydefkind_default);
      if (abap.compare.eq(descr.get().mo_line_type.get().kind, cl_abap_tabledescr.kind_struct)) {
        await abap.statements.cast(lo_struct, descr.get().mo_line_type);
        lt_components.set((await lo_struct.get().get_components()));
        for await (const unique122 of abap.statements.loop(lt_components)) {
          ls_component.set(unique122);
          ls_key.get().name.set(ls_component.get().name);
          abap.statements.append({source: ls_key, target: descr.get().key});
        }
      }
    }
    return descr;
  }
  async get_table_line_type() {
    let type = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"});
    await abap.statements.cast(type, this.mo_line_type);
    return type;
  }
}
abap.Classes['CL_ABAP_TABLEDESCR'] = cl_abap_tabledescr;
cl_abap_tabledescr.tablekind_any = new abap.types.Character(1, {});
cl_abap_tabledescr.tablekind_any.set('A');
cl_abap_tabledescr.tablekind_std = new abap.types.Character(1, {});
cl_abap_tabledescr.tablekind_std.set('S');
cl_abap_tabledescr.tablekind_index = new abap.types.Character(1, {});
cl_abap_tabledescr.tablekind_index.set('I');
cl_abap_tabledescr.tablekind_hashed = new abap.types.Character(1, {});
cl_abap_tabledescr.tablekind_hashed.set('H');
cl_abap_tabledescr.tablekind_sorted = new abap.types.Character(1, {});
cl_abap_tabledescr.tablekind_sorted.set('O');
cl_abap_tabledescr.keydefkind_default = new abap.types.Character(1, {});
cl_abap_tabledescr.keydefkind_default.set('D');
cl_abap_tabledescr.keydefkind_tableline = new abap.types.Character(1, {});
cl_abap_tabledescr.keydefkind_tableline.set('L');
cl_abap_tabledescr.keydefkind_user = new abap.types.Character(1, {});
cl_abap_tabledescr.keydefkind_user.set('U');
cl_abap_tabledescr.keydefkind_empty = new abap.types.Character(1, {});
cl_abap_tabledescr.keydefkind_empty.set('E');

//# sourceMappingURL=cl_abap_tabledescr.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_timefm.clas.mjs":
/*!****************************************!*\
  !*** ./output/cl_abap_timefm.clas.mjs ***!
  \****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_timefm": () => (/* binding */ cl_abap_timefm)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_timefm.clas.abap
class cl_abap_timefm {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_TIMEFM';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"CONV_TIME_EXT_TO_INT": {"visibility": "U", "parameters": {"TIME_EXT": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "IS_24_ALLOWED": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "TIME_INT": {"type": () => {return new abap.types.Time({qualifiedName: "T"});}, "is_optional": " "}}},
  "CONV_TIME_INT_TO_EXT": {"visibility": "U", "parameters": {"TIME_INT": {"type": () => {return new abap.types.Time({qualifiedName: "T"});}, "is_optional": " "}, "TIME_EXT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_ENVIRONMENT_TIMEFM": {"visibility": "U", "parameters": {"TIMEFM": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"cl_abap_timefm=>ty_timefm"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async conv_time_ext_to_int(INPUT) {
    return cl_abap_timefm.conv_time_ext_to_int(INPUT);
  }
  static async conv_time_ext_to_int(INPUT) {
    let time_ext = INPUT?.time_ext;
    let is_24_allowed = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.is_24_allowed) {is_24_allowed.set(INPUT.is_24_allowed);}
    if (INPUT === undefined || INPUT.is_24_allowed === undefined) {is_24_allowed = abap.builtin.abap_false;}
    let time_int = INPUT?.time_int || new abap.types.Time({qualifiedName: "T"});
    let lv_text = new abap.types.String({qualifiedName: "STRING"});
    abap.statements.assert(abap.compare.eq(is_24_allowed, abap.builtin.abap_true));
    abap.statements.find(time_ext, {regex: new abap.types.Character(44).set('^([0-1]?[0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$')});
    if (abap.compare.ne(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
      const unique30 = await (new abap.Classes['CX_ABAP_TIMEFM_INVALID']()).constructor_();
      unique30.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_timefm.clas.abap","INTERNAL_LINE": 38};
      throw unique30;
    }
    lv_text.set(time_ext);
    abap.statements.replace({target: lv_text, all: true, with: new abap.types.Character(1).set(''), of: new abap.types.Character(1).set(':')});
    time_int.set(lv_text);
  }
  async conv_time_int_to_ext(INPUT) {
    return cl_abap_timefm.conv_time_int_to_ext(INPUT);
  }
  static async conv_time_int_to_ext(INPUT) {
    let time_int = INPUT?.time_int;
    if (time_int?.getQualifiedName === undefined || time_int.getQualifiedName() !== "T") { time_int = undefined; }
    if (time_int === undefined) { time_int = new abap.types.Time({qualifiedName: "T"}).set(INPUT.time_int); }
    let time_ext = INPUT?.time_ext || new abap.types.String({qualifiedName: "STRING"});
    time_ext.set(new abap.types.String().set(`${abap.templateFormatting(time_int,{"time":"iso"})}`));
  }
  async get_environment_timefm() {
    return cl_abap_timefm.get_environment_timefm();
  }
  static async get_environment_timefm() {
    let timefm = new abap.types.Character(1, {"qualifiedName":"cl_abap_timefm=>ty_timefm"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return timefm;
  }
}
abap.Classes['CL_ABAP_TIMEFM'] = cl_abap_timefm;
cl_abap_timefm.ty_format = new abap.types.Integer({qualifiedName: "CL_ABAP_TIMEFM=>TY_FORMAT"});
cl_abap_timefm.ty_timefm = new abap.types.Character(1, {"qualifiedName":"cl_abap_timefm=>ty_timefm"});

//# sourceMappingURL=cl_abap_timefm.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_tstmp.clas.mjs":
/*!***************************************!*\
  !*** ./output/cl_abap_tstmp.clas.mjs ***!
  \***************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_tstmp": () => (/* binding */ cl_abap_tstmp)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_tstmp.clas.abap
class cl_abap_tstmp {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_TSTMP';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"SUBTRACT": {"visibility": "U", "parameters": {"R_SECS": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "TSTMP1": {"type": () => {return new abap.types.Packed({length: 1, decimals: 0});}, "is_optional": " "}, "TSTMP2": {"type": () => {return new abap.types.Packed({length: 1, decimals: 0});}, "is_optional": " "}}},
  "ADD": {"visibility": "U", "parameters": {"TIME": {"type": () => {return new abap.types.Packed({length: 15, decimals: 0, qualifiedName: "TIMESTAMP"});}, "is_optional": " "}, "TSTMP": {"type": () => {return new abap.types.Packed({length: 1, decimals: 0});}, "is_optional": " "}, "SECS": {"type": () => {return new abap.types.Packed({length: 8, decimals: 2});}, "is_optional": " "}}},
  "SUBTRACTSECS": {"visibility": "U", "parameters": {"TIME": {"type": () => {return new abap.types.Packed({length: 15, decimals: 0, qualifiedName: "TIMESTAMP"});}, "is_optional": " "}, "TSTMP": {"type": () => {return new abap.types.Packed({length: 1, decimals: 0});}, "is_optional": " "}, "SECS": {"type": () => {return new abap.types.Packed({length: 8, decimals: 2});}, "is_optional": " "}}},
  "TD_ADD": {"visibility": "U", "parameters": {"DATE": {"type": () => {return new abap.types.Date({qualifiedName: "D"});}, "is_optional": " "}, "TIME": {"type": () => {return new abap.types.Time({qualifiedName: "T"});}, "is_optional": " "}, "SECS": {"type": () => {return new abap.types.Packed({length: 8, decimals: 2});}, "is_optional": " "}, "RES_DATE": {"type": () => {return new abap.types.Date({qualifiedName: "D"});}, "is_optional": " "}, "RES_TIME": {"type": () => {return new abap.types.Time({qualifiedName: "T"});}, "is_optional": " "}}},
  "MOVE": {"visibility": "U", "parameters": {"TSTMP_SRC": {"type": () => {return new abap.types.Packed({length: 1, decimals: 0});}, "is_optional": " "}, "TSTMP_TGT": {"type": () => {return new abap.types.Packed({length: 1, decimals: 0});}, "is_optional": " "}}},
  "SYSTEMTSTMP_SYST2UTC": {"visibility": "U", "parameters": {"SYST_DATE": {"type": () => {return new abap.types.Date({qualifiedName: "D"});}, "is_optional": " "}, "SYST_TIME": {"type": () => {return new abap.types.Time({qualifiedName: "T"});}, "is_optional": " "}, "UTC_TSTMP": {"type": () => {return new abap.types.Packed({length: 1, decimals: 0});}, "is_optional": " "}}},
  "MOVE_TO_SHORT": {"visibility": "U", "parameters": {"TSTMP_OUT": {"type": () => {return new abap.types.Packed({length: 15, decimals: 0, qualifiedName: "TZNTSTMPS"});}, "is_optional": " "}, "TSTMP_SRC": {"type": () => {return new abap.types.Packed({length: 21, decimals: 7, qualifiedName: "TZNTSTMPL"});}, "is_optional": " "}}},
  "TD_SUBTRACT": {"visibility": "U", "parameters": {"DATE1": {"type": () => {return new abap.types.Date({qualifiedName: "D"});}, "is_optional": " "}, "TIME1": {"type": () => {return new abap.types.Time({qualifiedName: "T"});}, "is_optional": " "}, "DATE2": {"type": () => {return new abap.types.Date({qualifiedName: "D"});}, "is_optional": " "}, "TIME2": {"type": () => {return new abap.types.Time({qualifiedName: "T"});}, "is_optional": " "}, "RES_SECS": {"type": () => {return new abap.types.Packed({length: 8, decimals: 2});}, "is_optional": " "}}},
  "SYSTEMTSTMP_UTC2SYST": {"visibility": "U", "parameters": {"UTC_TSTMP": {"type": () => {return new abap.types.Packed({length: 15, decimals: 0, qualifiedName: "TIMESTAMP"});}, "is_optional": " "}, "SYST_DATE": {"type": () => {return new abap.types.Date({qualifiedName: "D"});}, "is_optional": " "}, "SYST_TIME": {"type": () => {return new abap.types.Time({qualifiedName: "T"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async td_add(INPUT) {
    return cl_abap_tstmp.td_add(INPUT);
  }
  static async td_add(INPUT) {
    let date = INPUT?.date;
    if (date?.getQualifiedName === undefined || date.getQualifiedName() !== "D") { date = undefined; }
    if (date === undefined) { date = new abap.types.Date({qualifiedName: "D"}).set(INPUT.date); }
    let time = INPUT?.time;
    if (time?.getQualifiedName === undefined || time.getQualifiedName() !== "T") { time = undefined; }
    if (time === undefined) { time = new abap.types.Time({qualifiedName: "T"}).set(INPUT.time); }
    let secs = INPUT?.secs;
    if (secs.constructor.name === "Character") {
        secs = new abap.types.Packed({length: 8, decimals: 2});
        secs.set(INPUT?.secs);
    }
    let res_date = INPUT?.res_date || new abap.types.Date({qualifiedName: "D"});
    let res_time = INPUT?.res_time || new abap.types.Time({qualifiedName: "T"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async systemtstmp_utc2syst(INPUT) {
    return cl_abap_tstmp.systemtstmp_utc2syst(INPUT);
  }
  static async systemtstmp_utc2syst(INPUT) {
    let utc_tstmp = INPUT?.utc_tstmp;
    if (utc_tstmp?.getQualifiedName === undefined || utc_tstmp.getQualifiedName() !== "TIMESTAMP") { utc_tstmp = undefined; }
    if (utc_tstmp === undefined) { utc_tstmp = new abap.types.Packed({length: 15, decimals: 0, qualifiedName: "TIMESTAMP"}).set(INPUT.utc_tstmp); }
    let syst_date = INPUT?.syst_date || new abap.types.Date({qualifiedName: "D"});
    let syst_time = INPUT?.syst_time || new abap.types.Time({qualifiedName: "T"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async move(INPUT) {
    return cl_abap_tstmp.move(INPUT);
  }
  static async move(INPUT) {
    let tstmp_src = INPUT?.tstmp_src;
    if (tstmp_src === undefined) { tstmp_src = new abap.types.Packed({length: 1, decimals: 0}).set(INPUT.tstmp_src); }
    let tstmp_tgt = INPUT?.tstmp_tgt || new abap.types.Packed({length: 1, decimals: 0});
    tstmp_tgt.set(tstmp_src);
  }
  async systemtstmp_syst2utc(INPUT) {
    return cl_abap_tstmp.systemtstmp_syst2utc(INPUT);
  }
  static async systemtstmp_syst2utc(INPUT) {
    let syst_date = INPUT?.syst_date;
    if (syst_date?.getQualifiedName === undefined || syst_date.getQualifiedName() !== "D") { syst_date = undefined; }
    if (syst_date === undefined) { syst_date = new abap.types.Date({qualifiedName: "D"}).set(INPUT.syst_date); }
    let syst_time = INPUT?.syst_time;
    if (syst_time?.getQualifiedName === undefined || syst_time.getQualifiedName() !== "T") { syst_time = undefined; }
    if (syst_time === undefined) { syst_time = new abap.types.Time({qualifiedName: "T"}).set(INPUT.syst_time); }
    let utc_tstmp = INPUT?.utc_tstmp || new abap.types.Packed({length: 1, decimals: 0});
    if (abap.compare.initial(syst_date)) {
      const unique31 = await (new abap.Classes['CX_PARAMETER_INVALID_RANGE']()).constructor_();
      unique31.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_tstmp.clas.abap","INTERNAL_LINE": 98};
      throw unique31;
    }
    utc_tstmp.set(new abap.types.String().set(`${abap.templateFormatting(syst_date)}${abap.templateFormatting(syst_time)}`));
  }
  async subtract(INPUT) {
    return cl_abap_tstmp.subtract(INPUT);
  }
  static async subtract(INPUT) {
    let r_secs = new abap.types.Integer({qualifiedName: "I"});
    let tstmp1 = INPUT?.tstmp1;
    if (tstmp1 === undefined) { tstmp1 = new abap.types.Packed({length: 1, decimals: 0}).set(INPUT.tstmp1); }
    let tstmp2 = INPUT?.tstmp2;
    if (tstmp2 === undefined) { tstmp2 = new abap.types.Packed({length: 1, decimals: 0}).set(INPUT.tstmp2); }
    let str = new abap.types.String({qualifiedName: "STRING"});
    let lv_dummy = new abap.types.String({qualifiedName: "STRING"});
    str.set(new abap.types.String().set(`${abap.templateFormatting(tstmp1,{"timestamp":"iso"})}`));
    if (abap.compare.ca(str, new abap.types.Character(1).set(','))) {
      abap.statements.split({source: str, at: new abap.types.Character(1).set(','), targets: [str,lv_dummy]});
    }
    let t1 = Date.parse(str.get());
    str.set(new abap.types.String().set(`${abap.templateFormatting(tstmp2,{"timestamp":"iso"})}`));
    if (abap.compare.ca(str, new abap.types.Character(1).set(','))) {
      abap.statements.split({source: str, at: new abap.types.Character(1).set(','), targets: [str,lv_dummy]});
    }
    let t2 = Date.parse(str.get());
    r_secs.set((t1 - t2)/1000);
    return r_secs;
  }
  async add(INPUT) {
    return cl_abap_tstmp.add(INPUT);
  }
  static async add(INPUT) {
    let time = new abap.types.Packed({length: 15, decimals: 0, qualifiedName: "TIMESTAMP"});
    let tstmp = INPUT?.tstmp;
    if (tstmp === undefined) { tstmp = new abap.types.Packed({length: 1, decimals: 0}).set(INPUT.tstmp); }
    let secs = INPUT?.secs;
    if (secs.constructor.name === "Character") {
        secs = new abap.types.Packed({length: 8, decimals: 2});
        secs.set(INPUT?.secs);
    }
    let str = new abap.types.String({qualifiedName: "STRING"});
    let lv_dummy = new abap.types.String({qualifiedName: "STRING"});
    str.set(new abap.types.String().set(`${abap.templateFormatting(tstmp,{"timestamp":"iso"})}`));
    if (abap.compare.ca(str, new abap.types.Character(1).set(','))) {
      abap.statements.split({source: str, at: new abap.types.Character(1).set(','), targets: [str,lv_dummy]});
    }
    let t1 = new Date(Date.parse(str.get() + "Z"));
    t1.setSeconds( t1.getSeconds() + secs.get() );
    time.set(t1.toISOString().slice(0, 19).replace(/-/g, "").replace(/:/g, "").replace("T", ""));
    return time;
  }
  async subtractsecs(INPUT) {
    return cl_abap_tstmp.subtractsecs(INPUT);
  }
  static async subtractsecs(INPUT) {
    let time = new abap.types.Packed({length: 15, decimals: 0, qualifiedName: "TIMESTAMP"});
    let tstmp = INPUT?.tstmp;
    if (tstmp === undefined) { tstmp = new abap.types.Packed({length: 1, decimals: 0}).set(INPUT.tstmp); }
    let secs = INPUT?.secs;
    if (secs.constructor.name === "Character") {
        secs = new abap.types.Packed({length: 8, decimals: 2});
        secs.set(INPUT?.secs);
    }
    let lv_secs = new abap.types.Integer({qualifiedName: "I"});
    lv_secs.set(abap.operators.multiply(secs,abap.IntegerFactory.get(-1)));
    time.set((await this.add({tstmp: tstmp, secs: lv_secs})));
    return time;
  }
  async move_to_short(INPUT) {
    return cl_abap_tstmp.move_to_short(INPUT);
  }
  static async move_to_short(INPUT) {
    let tstmp_out = new abap.types.Packed({length: 15, decimals: 0, qualifiedName: "TZNTSTMPS"});
    let tstmp_src = INPUT?.tstmp_src;
    if (tstmp_src?.getQualifiedName === undefined || tstmp_src.getQualifiedName() !== "TZNTSTMPL") { tstmp_src = undefined; }
    if (tstmp_src === undefined) { tstmp_src = new abap.types.Packed({length: 21, decimals: 7, qualifiedName: "TZNTSTMPL"}).set(INPUT.tstmp_src); }
    await this.move({tstmp_src: tstmp_src, tstmp_tgt: tstmp_out});
    return tstmp_out;
  }
  async td_subtract(INPUT) {
    return cl_abap_tstmp.td_subtract(INPUT);
  }
  static async td_subtract(INPUT) {
    let date1 = INPUT?.date1;
    if (date1?.getQualifiedName === undefined || date1.getQualifiedName() !== "D") { date1 = undefined; }
    if (date1 === undefined) { date1 = new abap.types.Date({qualifiedName: "D"}).set(INPUT.date1); }
    let time1 = INPUT?.time1;
    if (time1?.getQualifiedName === undefined || time1.getQualifiedName() !== "T") { time1 = undefined; }
    if (time1 === undefined) { time1 = new abap.types.Time({qualifiedName: "T"}).set(INPUT.time1); }
    let date2 = INPUT?.date2;
    if (date2?.getQualifiedName === undefined || date2.getQualifiedName() !== "D") { date2 = undefined; }
    if (date2 === undefined) { date2 = new abap.types.Date({qualifiedName: "D"}).set(INPUT.date2); }
    let time2 = INPUT?.time2;
    if (time2?.getQualifiedName === undefined || time2.getQualifiedName() !== "T") { time2 = undefined; }
    if (time2 === undefined) { time2 = new abap.types.Time({qualifiedName: "T"}).set(INPUT.time2); }
    let res_secs = INPUT?.res_secs || new abap.types.Packed({length: 8, decimals: 2});
    let lv_stamp1 = new abap.types.Packed({length: 15, decimals: 0, qualifiedName: "TIMESTAMP"});
    let lv_stamp2 = new abap.types.Packed({length: 15, decimals: 0, qualifiedName: "TIMESTAMP"});
    abap.statements.convert({date: date1,time: time1}, {stamp: lv_stamp1});
    abap.statements.convert({date: date2,time: time2}, {stamp: lv_stamp2});
    res_secs.set((await this.subtract({tstmp1: lv_stamp1, tstmp2: lv_stamp2})));
  }
}
abap.Classes['CL_ABAP_TSTMP'] = cl_abap_tstmp;

//# sourceMappingURL=cl_abap_tstmp.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_typedescr.clas.mjs":
/*!*******************************************!*\
  !*** ./output/cl_abap_typedescr.clas.mjs ***!
  \*******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_typedescr": () => (/* binding */ cl_abap_typedescr)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_typedescr.clas.abap
class cl_abap_typedescr {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_TYPEDESCR';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"GV_COUNTER": {"type": () => {return new abap.types.Numc({length: 10});}, "visibility": "I", "is_constant": " ", "is_class": "X"},
  "TYPE_KIND": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "KIND": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "DDIC": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "LENGTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "DECIMALS": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "ABSOLUTE_NAME": {"type": () => {return new abap.types.Character(200, {"qualifiedName":"abap_abstypename"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "RELATIVE_NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "TYPEKIND_ANY": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_CHAR": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_CLASS": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_CLIKE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_CSEQUENCE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_DATA": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_DATE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_DECFLOAT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_DECFLOAT16": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_DECFLOAT34": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_DREF": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_ENUM": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_FLOAT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_HEX": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_INT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_INT1": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_INT2": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_INT8": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_INTF": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_IREF": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_NUM": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_NUMERIC": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_OREF": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_PACKED": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_SIMPLE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_STRING": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_STRUCT1": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_STRUCT2": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_TABLE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_TIME": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_UTCLONG": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_W": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TYPEKIND_XSTRING": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"abap_typekind"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "KIND_ELEM": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "KIND_STRUCT": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "KIND_TABLE": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "KIND_REF": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "KIND_CLASS": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "KIND_INTF": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"DESCRIBE_BY_DASHES": {"visibility": "I", "parameters": {"TYPE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});}, "is_optional": " "}, "P_NAME": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "IS_DEEP": {"visibility": "I", "parameters": {"RV_DEEP": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "IO_STRUCT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_STRUCTDESCR", RTTIName: "\\CLASS=CL_ABAP_STRUCTDESCR"});}, "is_optional": " "}}},
  "DESCRIBE_BY_DATA": {"visibility": "U", "parameters": {"TYPE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});}, "is_optional": " "}, "P_DATA": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "DESCRIBE_BY_NAME": {"visibility": "U", "parameters": {"TYPE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});}, "is_optional": " "}, "P_NAME": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "DESCRIBE_BY_DATA_REF": {"visibility": "U", "parameters": {"TYPE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});}, "is_optional": " "}, "P_DATA_REF": {"type": () => {return new abap.types.DataReference(new abap.types.Character(4));}, "is_optional": " "}}},
  "DESCRIBE_BY_OBJECT_REF": {"visibility": "U", "parameters": {"P_DESCR_REF": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});}, "is_optional": " "}, "P_OBJECT_REF": {"type": () => {return new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});}, "is_optional": " "}}},
  "GET_DDIC_HEADER": {"visibility": "U", "parameters": {"P_HEADER": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "GET_RELATIVE_NAME": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "IS_DDIC_TYPE": {"visibility": "U", "parameters": {"P_ABAP_BOOL": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "IS_INSTANTIATABLE": {"visibility": "U", "parameters": {"P_RESULT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "GET_DDIC_OBJECT": {"visibility": "U", "parameters": {"P_OBJECT": {"type": () => {return abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "STRING_TABLE");}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.gv_counter = cl_abap_typedescr.gv_counter;
    this.type_kind = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
    this.kind = new abap.types.Character(1, {});
    this.ddic = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    this.length = new abap.types.Integer({qualifiedName: "I"});
    this.decimals = new abap.types.Integer({qualifiedName: "I"});
    this.absolute_name = new abap.types.Character(200, {"qualifiedName":"abap_abstypename"});
    this.relative_name = new abap.types.String({qualifiedName: "STRING"});
    this.typekind_any = cl_abap_typedescr.typekind_any;
    this.typekind_char = cl_abap_typedescr.typekind_char;
    this.typekind_class = cl_abap_typedescr.typekind_class;
    this.typekind_clike = cl_abap_typedescr.typekind_clike;
    this.typekind_csequence = cl_abap_typedescr.typekind_csequence;
    this.typekind_data = cl_abap_typedescr.typekind_data;
    this.typekind_date = cl_abap_typedescr.typekind_date;
    this.typekind_decfloat = cl_abap_typedescr.typekind_decfloat;
    this.typekind_decfloat16 = cl_abap_typedescr.typekind_decfloat16;
    this.typekind_decfloat34 = cl_abap_typedescr.typekind_decfloat34;
    this.typekind_dref = cl_abap_typedescr.typekind_dref;
    this.typekind_enum = cl_abap_typedescr.typekind_enum;
    this.typekind_float = cl_abap_typedescr.typekind_float;
    this.typekind_hex = cl_abap_typedescr.typekind_hex;
    this.typekind_int = cl_abap_typedescr.typekind_int;
    this.typekind_int1 = cl_abap_typedescr.typekind_int1;
    this.typekind_int2 = cl_abap_typedescr.typekind_int2;
    this.typekind_int8 = cl_abap_typedescr.typekind_int8;
    this.typekind_intf = cl_abap_typedescr.typekind_intf;
    this.typekind_iref = cl_abap_typedescr.typekind_iref;
    this.typekind_num = cl_abap_typedescr.typekind_num;
    this.typekind_numeric = cl_abap_typedescr.typekind_numeric;
    this.typekind_oref = cl_abap_typedescr.typekind_oref;
    this.typekind_packed = cl_abap_typedescr.typekind_packed;
    this.typekind_simple = cl_abap_typedescr.typekind_simple;
    this.typekind_string = cl_abap_typedescr.typekind_string;
    this.typekind_struct1 = cl_abap_typedescr.typekind_struct1;
    this.typekind_struct2 = cl_abap_typedescr.typekind_struct2;
    this.typekind_table = cl_abap_typedescr.typekind_table;
    this.typekind_time = cl_abap_typedescr.typekind_time;
    this.typekind_utclong = cl_abap_typedescr.typekind_utclong;
    this.typekind_w = cl_abap_typedescr.typekind_w;
    this.typekind_xstring = cl_abap_typedescr.typekind_xstring;
    this.kind_elem = cl_abap_typedescr.kind_elem;
    this.kind_struct = cl_abap_typedescr.kind_struct;
    this.kind_table = cl_abap_typedescr.kind_table;
    this.kind_ref = cl_abap_typedescr.kind_ref;
    this.kind_class = cl_abap_typedescr.kind_class;
    this.kind_intf = cl_abap_typedescr.kind_intf;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async get_ddic_object() {
    let p_object = abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "STRING_TABLE");
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return p_object;
  }
  async is_instantiatable() {
    let p_result = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return p_result;
  }
  async describe_by_dashes(INPUT) {
    return cl_abap_typedescr.describe_by_dashes(INPUT);
  }
  static async describe_by_dashes(INPUT) {
    let type = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});
    let p_name = INPUT?.p_name;
    let lt_parts = abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "");
    let lv_part = new abap.types.String({qualifiedName: "STRING"});
    let lo_current = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});
    let lo_struct = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_STRUCTDESCR", RTTIName: "\\CLASS=CL_ABAP_STRUCTDESCR"});
    abap.statements.split({source: p_name, at: new abap.types.Character(1).set('-'), table: lt_parts});
    for await (const unique123 of abap.statements.loop(lt_parts)) {
      lv_part.set(unique123);
      if (abap.compare.initial(lo_current)) {
        lo_current.set((await this.describe_by_name({p_name: lv_part})));
      } else if (abap.compare.eq(lo_current.get().kind, cl_abap_typedescr.kind_struct)) {
        await abap.statements.cast(lo_struct, lo_current);
        lo_current.set((await lo_struct.get().get_component_type({p_name: lv_part})));
      }
    }
    type.set(lo_current);
    return type;
  }
  async describe_by_name(INPUT) {
    return cl_abap_typedescr.describe_by_name(INPUT);
  }
  static async describe_by_name(INPUT) {
    let type = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});
    let p_name = INPUT?.p_name;
    let ref = new abap.types.DataReference(new abap.types.Character(4));
    let objectdescr = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_OBJECTDESCR", RTTIName: "\\CLASS=CL_ABAP_OBJECTDESCR"});
    let oo_type = new abap.types.String({qualifiedName: "STRING"});
    let lv_any = new abap.types.String({qualifiedName: "STRING"});
    if (abap.compare.ca(p_name, new abap.types.Character(1).set('-')) && abap.compare.np(p_name, new abap.types.Character(6).set('CLAS-*')) && abap.compare.np(p_name, new abap.types.Character(6).set('PROG-*'))) {
      type.set((await this.describe_by_dashes({p_name: p_name})));
      return type;
    }
    oo_type.set(abap.Classes[p_name.get().toUpperCase().trimEnd()]?.INTERNAL_TYPE || "");
    lv_any = abap.Classes[p_name.get().toUpperCase().trimEnd()];
    let unique124 = oo_type;
    if (abap.compare.eq(unique124, new abap.types.Character(4).set('INTF'))) {
      type.set(await (new abap.Classes['CL_ABAP_INTFDESCR']()).constructor_({p_object: lv_any}));
      type.get().type_kind.set(cl_abap_typedescr.typekind_intf);
      type.get().kind.set(cl_abap_typedescr.kind_intf);
      type.get().relative_name.set(abap.builtin.to_upper({val: p_name}));
      type.get().absolute_name.set(abap.operators.concat(new abap.types.Character(7).set('\\CLASS='),abap.builtin.to_upper({val: p_name})));
      await abap.statements.cast(objectdescr, type);
      objectdescr.get().mv_object_name.set(abap.builtin.to_upper({val: p_name}));
      objectdescr.get().mv_object_type.set(oo_type);
    } else if (abap.compare.eq(unique124, new abap.types.Character(4).set('CLAS'))) {
      type.set(await (new abap.Classes['CL_ABAP_CLASSDESCR']()).constructor_());
      type.get().type_kind.set(cl_abap_typedescr.typekind_class);
      type.get().kind.set(cl_abap_typedescr.kind_class);
      type.get().relative_name.set(abap.builtin.to_upper({val: p_name}));
      if (abap.compare.cp(p_name, new abap.types.Character(6).set('CLAS-*'))) {
        type.get().absolute_name.set((await abap.Classes['KERNEL_INTERNAL_NAME'].internal_to_rtti({iv_internal: p_name})));
      } else {
        type.get().absolute_name.set(abap.operators.concat(new abap.types.Character(7).set('\\CLASS='),abap.builtin.to_upper({val: p_name})));
      }
      await abap.statements.cast(objectdescr, type);
      objectdescr.get().mv_object_name.set(abap.builtin.to_upper({val: p_name}));
      objectdescr.get().mv_object_type.set(oo_type);
    } else {
      try {
        abap.statements.createData(ref,{"name": p_name.get()});
      } catch (e) {
        if ((abap.Classes['CX_SY_CREATE_DATA_ERROR'] && e instanceof abap.Classes['CX_SY_CREATE_DATA_ERROR'])) {
          throw new abap.ClassicError({classic: "type_not_found"});
        } else {
          throw e;
        }
      }
      type.set((await this.describe_by_data_ref({p_data_ref: ref})));
    }
    abap.builtin.sy.get().subrc.set(0);
    return type;
  }
  async get_relative_name() {
    let name = new abap.types.String({qualifiedName: "STRING"});
    name.set(this.relative_name);
    return name;
  }
  async get_ddic_header() {
    let p_header = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), abap.IntegerFactory.get(2)));
    return p_header;
  }
  async is_ddic_type() {
    let p_abap_bool = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    p_abap_bool.set(this.ddic);
    return p_abap_bool;
  }
  async describe_by_data_ref(INPUT) {
    return cl_abap_typedescr.describe_by_data_ref(INPUT);
  }
  static async describe_by_data_ref(INPUT) {
    let type = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});
    let p_data_ref = INPUT?.p_data_ref;
    if (p_data_ref === undefined) { p_data_ref = new abap.types.DataReference(new abap.types.Character(4)).set(INPUT.p_data_ref); }
    let fs_ref_ = new abap.types.FieldSymbol(new abap.types.Character(4));
    abap.statements.assign({target: fs_ref_, source: (p_data_ref).dereference()});
    type.set((await this.describe_by_data({p_data: fs_ref_})));
    return type;
  }
  async describe_by_object_ref(INPUT) {
    return cl_abap_typedescr.describe_by_object_ref(INPUT);
  }
  static async describe_by_object_ref(INPUT) {
    let p_descr_ref = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});
    let p_object_ref = INPUT?.p_object_ref;
    if (p_object_ref === undefined) { p_object_ref = new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined}).set(INPUT.p_object_ref); }
    let lv_name = new abap.types.String({qualifiedName: "STRING"});
    let lo_cdescr = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_CLASSDESCR", RTTIName: "\\CLASS=CL_ABAP_CLASSDESCR"});
    let lv_any = new abap.types.String({qualifiedName: "STRING"});
    if (abap.compare.initial(p_object_ref)) {
      throw new abap.ClassicError({classic: "reference_is_initial"});
    }
    lv_any = p_object_ref.get().constructor;
    lo_cdescr.set(await (new abap.Classes['CL_ABAP_CLASSDESCR']()).constructor_({p_object: lv_any}));
    lo_cdescr.get().type_kind.set(cl_abap_typedescr.typekind_class);
    lo_cdescr.get().kind.set(cl_abap_typedescr.kind_class);
    lv_name.set(p_object_ref.get().constructor.name.toUpperCase());
    lo_cdescr.get().relative_name.set(lv_name);
    lo_cdescr.get().absolute_name.set(abap.operators.concat(new abap.types.Character(7).set('\\CLASS='),lv_name));
    p_descr_ref.set(lo_cdescr);
    abap.builtin.sy.get().subrc.set(0);
    return p_descr_ref;
  }
  async is_deep(INPUT) {
    return cl_abap_typedescr.is_deep(INPUT);
  }
  static async is_deep(INPUT) {
    let rv_deep = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    let io_struct = INPUT?.io_struct;
    if (io_struct?.getQualifiedName === undefined || io_struct.getQualifiedName() !== "CL_ABAP_STRUCTDESCR") { io_struct = undefined; }
    if (io_struct === undefined) { io_struct = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_STRUCTDESCR", RTTIName: "\\CLASS=CL_ABAP_STRUCTDESCR"}).set(INPUT.io_struct); }
    let lt_components = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_component_tab");
    let fs_ls_component_ = new abap.types.FieldSymbol(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {}));
    lt_components.set((await io_struct.get().get_components()));
    rv_deep.set(abap.builtin.abap_false);
    for await (const unique125 of abap.statements.loop(lt_components)) {
      fs_ls_component_.assign(unique125);
      if (abap.compare.eq(fs_ls_component_.get().type.get().kind, cl_abap_typedescr.kind_struct) || abap.compare.eq(fs_ls_component_.get().type.get().type_kind, cl_abap_typedescr.typekind_string) || abap.compare.eq(fs_ls_component_.get().type.get().type_kind, cl_abap_typedescr.typekind_xstring) || abap.compare.eq(fs_ls_component_.get().type.get().kind, cl_abap_typedescr.kind_table)) {
        rv_deep.set(abap.builtin.abap_true);
        return rv_deep;
      }
    }
    return rv_deep;
  }
  async describe_by_data(INPUT) {
    return cl_abap_typedescr.describe_by_data(INPUT);
  }
  static async describe_by_data(INPUT) {
    let type = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});
    let p_data = INPUT?.p_data;
    let lo_elem = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});
    let lo_ref = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_REFDESCR", RTTIName: "\\CLASS=CL_ABAP_REFDESCR"});
    let lo_struct = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_STRUCTDESCR", RTTIName: "\\CLASS=CL_ABAP_STRUCTDESCR"});
    let lv_any = new abap.types.String({qualifiedName: "STRING"});
    let lv_convexit = new abap.types.String({qualifiedName: "STRING"});
    let lv_ddicname = new abap.types.String({qualifiedName: "STRING"});
    let lv_decimals = new abap.types.Integer({qualifiedName: "I"});
    let lv_length = new abap.types.Integer({qualifiedName: "I"});
    let lv_name = new abap.types.String({qualifiedName: "STRING"});
    let lv_prefix = new abap.types.String({qualifiedName: "STRING"});
    let lv_qualified = new abap.types.String({qualifiedName: "STRING"});
    let lv_rtti_name = new abap.types.String({qualifiedName: "STRING"});
    lv_name.set(p_data.constructor.name);
    lv_length.set(p_data.getLength ? p_data.getLength() : 0);
    lv_decimals.set(p_data.getDecimals ? p_data.getDecimals() : 0);
    let unique126 = lv_name;
    if (abap.compare.eq(unique126, new abap.types.Character(7).set('Integer'))) {
      type.set(await (new abap.Classes['CL_ABAP_ELEMDESCR']()).constructor_());
      type.get().type_kind.set(cl_abap_typedescr.typekind_int);
      type.get().kind.set(cl_abap_typedescr.kind_elem);
      type.get().length.set(abap.IntegerFactory.get(4));
      await abap.statements.cast(lo_elem, type);
      lo_elem.get().output_length.set(abap.IntegerFactory.get(11));
      type.get().absolute_name.set(new abap.types.Character(1).set('I'));
    } else if (abap.compare.eq(unique126, new abap.types.Character(8).set('Integer8'))) {
      type.set(await (new abap.Classes['CL_ABAP_ELEMDESCR']()).constructor_());
      type.get().type_kind.set(cl_abap_typedescr.typekind_int8);
      type.get().kind.set(cl_abap_typedescr.kind_elem);
      type.get().length.set(abap.IntegerFactory.get(8));
      await abap.statements.cast(lo_elem, type);
      lo_elem.get().output_length.set(abap.IntegerFactory.get(20));
      type.get().absolute_name.set(new abap.types.Character(4).set('INT8'));
    } else if (abap.compare.eq(unique126, new abap.types.Character(4).set('Numc'))) {
      type.set(await (new abap.Classes['CL_ABAP_ELEMDESCR']()).constructor_());
      type.get().type_kind.set(cl_abap_typedescr.typekind_num);
      type.get().kind.set(cl_abap_typedescr.kind_elem);
      type.get().length.set(abap.operators.multiply(lv_length,abap.IntegerFactory.get(2)));
      await abap.statements.cast(lo_elem, type);
      lo_elem.get().output_length.set(lv_length);
    } else if (abap.compare.eq(unique126, new abap.types.Character(3).set('Hex')) || abap.compare.eq(unique126, new abap.types.Character(8).set('HexUInt8'))) {
      type.set(await (new abap.Classes['CL_ABAP_ELEMDESCR']()).constructor_());
      type.get().type_kind.set(cl_abap_typedescr.typekind_hex);
      type.get().kind.set(cl_abap_typedescr.kind_elem);
      type.get().length.set(lv_length);
      await abap.statements.cast(lo_elem, type);
      lo_elem.get().output_length.set(abap.operators.multiply(lv_length,abap.IntegerFactory.get(2)));
    } else if (abap.compare.eq(unique126, new abap.types.Character(4).set('Date'))) {
      type.set(await (new abap.Classes['CL_ABAP_ELEMDESCR']()).constructor_());
      type.get().type_kind.set(cl_abap_typedescr.typekind_date);
      type.get().kind.set(cl_abap_typedescr.kind_elem);
      type.get().length.set(abap.IntegerFactory.get(16));
      await abap.statements.cast(lo_elem, type);
      lo_elem.get().output_length.set(abap.IntegerFactory.get(8));
      type.get().absolute_name.set(new abap.types.Character(1).set('D'));
    } else if (abap.compare.eq(unique126, new abap.types.Character(6).set('Packed'))) {
      type.set(await (new abap.Classes['CL_ABAP_ELEMDESCR']()).constructor_());
      type.get().type_kind.set(cl_abap_typedescr.typekind_packed);
      type.get().kind.set(cl_abap_typedescr.kind_elem);
      type.get().length.set(lv_length);
      type.get().decimals.set(lv_decimals);
    } else if (abap.compare.eq(unique126, new abap.types.Character(4).set('Time'))) {
      type.set(await (new abap.Classes['CL_ABAP_ELEMDESCR']()).constructor_());
      type.get().type_kind.set(cl_abap_typedescr.typekind_time);
      type.get().kind.set(cl_abap_typedescr.kind_elem);
      type.get().length.set(abap.IntegerFactory.get(12));
      await abap.statements.cast(lo_elem, type);
      lo_elem.get().output_length.set(abap.IntegerFactory.get(6));
      type.get().absolute_name.set(new abap.types.Character(1).set('T'));
    } else if (abap.compare.eq(unique126, new abap.types.Character(5).set('Float'))) {
      type.set(await (new abap.Classes['CL_ABAP_ELEMDESCR']()).constructor_());
      type.get().type_kind.set(cl_abap_typedescr.typekind_float);
      type.get().kind.set(cl_abap_typedescr.kind_elem);
      type.get().absolute_name.set(new abap.types.Character(1).set('F'));
    } else if (abap.compare.eq(unique126, new abap.types.Character(10).set('DecFloat34'))) {
      type.set(await (new abap.Classes['CL_ABAP_ELEMDESCR']()).constructor_());
      type.get().type_kind.set(cl_abap_typedescr.typekind_decfloat34);
      type.get().kind.set(cl_abap_typedescr.kind_elem);
    } else if (abap.compare.eq(unique126, new abap.types.Character(9).set('Structure'))) {
      lo_struct.set((await abap.Classes['CL_ABAP_STRUCTDESCR'].construct_from_data({data: p_data})));
      await abap.statements.cast(type, lo_struct);
      if (abap.compare.eq((await this.is_deep({io_struct: lo_struct})), abap.builtin.abap_true)) {
        type.get().type_kind.set(cl_abap_typedescr.typekind_struct2);
      } else {
        type.get().type_kind.set(cl_abap_typedescr.typekind_struct1);
      }
      type.get().kind.set(cl_abap_typedescr.kind_struct);
    } else if (abap.compare.eq(unique126, new abap.types.Character(5).set('Table')) || abap.compare.eq(unique126, new abap.types.Character(11).set('HashedTable'))) {
      await abap.statements.cast(type, (await abap.Classes['CL_ABAP_TABLEDESCR'].construct_from_data({data: p_data})));
      type.get().type_kind.set(cl_abap_typedescr.typekind_table);
      type.get().kind.set(cl_abap_typedescr.kind_table);
      type.get().length.set(abap.IntegerFactory.get(8));
    } else if (abap.compare.eq(unique126, new abap.types.Character(7).set('XString'))) {
      type.set(await (new abap.Classes['CL_ABAP_ELEMDESCR']()).constructor_());
      type.get().type_kind.set(cl_abap_typedescr.typekind_xstring);
      type.get().kind.set(cl_abap_typedescr.kind_elem);
      type.get().length.set(abap.IntegerFactory.get(8));
      type.get().absolute_name.set(new abap.types.Character(7).set('XSTRING'));
    } else if (abap.compare.eq(unique126, new abap.types.Character(6).set('String'))) {
      type.set(await (new abap.Classes['CL_ABAP_ELEMDESCR']()).constructor_());
      type.get().type_kind.set(cl_abap_typedescr.typekind_string);
      type.get().kind.set(cl_abap_typedescr.kind_elem);
      type.get().length.set(abap.IntegerFactory.get(8));
      type.get().absolute_name.set(new abap.types.Character(6).set('STRING'));
    } else if (abap.compare.eq(unique126, new abap.types.Character(9).set('Character'))) {
      type.set(await (new abap.Classes['CL_ABAP_ELEMDESCR']()).constructor_());
      type.get().type_kind.set(cl_abap_typedescr.typekind_char);
      type.get().kind.set(cl_abap_typedescr.kind_elem);
      type.get().length.set(abap.operators.multiply(lv_length,abap.IntegerFactory.get(2)));
      await abap.statements.cast(lo_elem, type);
      lo_elem.get().output_length.set(lv_length);
    } else if (abap.compare.eq(unique126, new abap.types.Character(11).set('FieldSymbol'))) {
      lv_name = p_data.getPointer();
      type.set((await this.describe_by_data({p_data: lv_name})));
      return type;
    } else if (abap.compare.eq(unique126, new abap.types.Character(10).set('ABAPObject'))) {
      type.set(await (new abap.Classes['CL_ABAP_REFDESCR']()).constructor_());
      type.get().type_kind.set(cl_abap_typedescr.typekind_oref);
      type.get().kind.set(cl_abap_typedescr.kind_ref);
      await abap.statements.cast(lo_ref, type);
      if (abap.compare.initial(p_data)) {
        lv_rtti_name.set(p_data.RTTIName || "");
        if (abap.compare.cp(lv_rtti_name, new abap.types.Character(13).set('\\CLASS-POOL=*'))) {
          lv_rtti_name.set((await abap.Classes['KERNEL_INTERNAL_NAME'].rtti_to_internal({iv_rtti: lv_rtti_name})));
          lo_ref.get().referenced.set((await this.describe_by_name({p_name: lv_rtti_name})));
        } else {
          lv_name.set(p_data.qualifiedName || "");
          lo_ref.get().referenced.set((await this.describe_by_name({p_name: lv_name})));
        }
      } else {
        lo_ref.get().referenced.set((await this.describe_by_object_ref({p_object_ref: p_data})));
      }
    } else if (abap.compare.eq(unique126, new abap.types.Character(7).set('UTCLong'))) {
      type.set(await (new abap.Classes['CL_ABAP_ELEMDESCR']()).constructor_());
      type.get().type_kind.set(cl_abap_typedescr.typekind_utclong);
      type.get().kind.set(cl_abap_typedescr.kind_elem);
    } else if (abap.compare.eq(unique126, new abap.types.Character(13).set('DataReference'))) {
      type.set(await (new abap.Classes['CL_ABAP_REFDESCR']()).constructor_());
      type.get().type_kind.set(cl_abap_typedescr.typekind_dref);
      type.get().kind.set(cl_abap_typedescr.kind_ref);
      await abap.statements.cast(lo_ref, type);
      lv_any = p_data.type;
      lo_ref.get().referenced.set((await this.describe_by_data({p_data: lv_any})));
    } else {
      abap.statements.write(lv_name,{newLine: true});
      abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(22).set('todo_cl_abap_typedescr')));
    }
    lv_ddicname.set(p_data.getDDICName ? p_data.getDDICName() || "" : "");
    lv_convexit.set(p_data.getConversionExit ? p_data.getConversionExit() || "" : "");
    lv_qualified.set(p_data.getQualifiedName ? p_data.getQualifiedName() || "" : "");
    if (abap.compare.na(lv_qualified, new abap.types.Character(1).set('-'))) {
      type.get().absolute_name.set(lv_qualified);
    } else if (abap.compare.ne(lv_ddicname, new abap.types.Character(1).set(''))) {
      type.get().absolute_name.set(lv_ddicname);
    }
    if(abap.DDIC[type.get().absolute_name.get().toUpperCase().trimEnd()]) { type.get().ddic.set("X"); }
    abap.statements.translate(type.get().absolute_name, "UPPER");
    abap.statements.translate(type.get().relative_name, "UPPER");
    if (abap.compare.eq(type.get().absolute_name, new abap.types.Character(9).set('ABAP_BOOL'))) {
      type.get().relative_name.set(new abap.types.Character(9).set('ABAP_BOOL'));
      type.get().absolute_name.set(new abap.types.Character(30).set('\\TYPE-POOL=ABAP\\TYPE=ABAP_BOOL'));
    } else if (abap.compare.initial(type.get().absolute_name)) {
      cl_abap_typedescr.gv_counter.set(abap.operators.add(cl_abap_typedescr.gv_counter,abap.IntegerFactory.get(1)));
      type.get().absolute_name.set(abap.operators.concat(new abap.types.Character(24).set('\\TYPE=%_T000000000000000'),cl_abap_typedescr.gv_counter));
    } else if (abap.compare.cs(type.get().absolute_name, new abap.types.Character(2).set('=>'))) {
      abap.statements.split({source: type.get().absolute_name, at: new abap.types.Character(2).set('=>'), targets: [lv_prefix,type.get().absolute_name]});
      type.get().relative_name.set(type.get().absolute_name);
      type.get().absolute_name.set(abap.operators.concat(new abap.types.Character(7).set('\\CLASS='),abap.operators.concat(lv_prefix,abap.operators.concat(new abap.types.Character(6).set('\\TYPE='),type.get().absolute_name))));
    } else if (abap.compare.eq(type.get().type_kind, cl_abap_typedescr.typekind_oref)) {
      type.get().relative_name.set(type.get().absolute_name);
      type.get().absolute_name.set(abap.operators.concat(new abap.types.Character(7).set('\\CLASS='),type.get().absolute_name));
    } else {
      type.get().relative_name.set(type.get().absolute_name);
      type.get().absolute_name.set(abap.operators.concat(new abap.types.Character(6).set('\\TYPE='),type.get().absolute_name));
    }
    if (abap.compare.ne(lv_convexit, new abap.types.Character(1).set(''))) {
      lo_elem.get().edit_mask.set(abap.operators.concat(new abap.types.Character(2).set('=='),lv_convexit));
    }
    return type;
  }
}
abap.Classes['CL_ABAP_TYPEDESCR'] = cl_abap_typedescr;
cl_abap_typedescr.gv_counter = new abap.types.Numc({length: 10});
cl_abap_typedescr.typekind_any = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_any.set('~');
cl_abap_typedescr.typekind_char = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_char.set('C');
cl_abap_typedescr.typekind_class = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_class.set('*');
cl_abap_typedescr.typekind_clike = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_clike.set('&');
cl_abap_typedescr.typekind_csequence = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_csequence.set('?');
cl_abap_typedescr.typekind_data = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_data.set('#');
cl_abap_typedescr.typekind_date = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_date.set('D');
cl_abap_typedescr.typekind_decfloat = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_decfloat.set('/');
cl_abap_typedescr.typekind_decfloat16 = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_decfloat16.set('a');
cl_abap_typedescr.typekind_decfloat34 = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_decfloat34.set('e');
cl_abap_typedescr.typekind_dref = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_dref.set('l');
cl_abap_typedescr.typekind_enum = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_enum.set('k');
cl_abap_typedescr.typekind_float = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_float.set('F');
cl_abap_typedescr.typekind_hex = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_hex.set('X');
cl_abap_typedescr.typekind_int = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_int.set('I');
cl_abap_typedescr.typekind_int1 = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_int1.set('b');
cl_abap_typedescr.typekind_int2 = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_int2.set('s');
cl_abap_typedescr.typekind_int8 = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_int8.set('8');
cl_abap_typedescr.typekind_intf = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_intf.set('+');
cl_abap_typedescr.typekind_iref = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_iref.set('m');
cl_abap_typedescr.typekind_num = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_num.set('N');
cl_abap_typedescr.typekind_numeric = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_numeric.set('%');
cl_abap_typedescr.typekind_oref = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_oref.set('r');
cl_abap_typedescr.typekind_packed = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_packed.set('P');
cl_abap_typedescr.typekind_simple = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_simple.set('$');
cl_abap_typedescr.typekind_string = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_string.set('g');
cl_abap_typedescr.typekind_struct1 = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_struct1.set('u');
cl_abap_typedescr.typekind_struct2 = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_struct2.set('v');
cl_abap_typedescr.typekind_table = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_table.set('h');
cl_abap_typedescr.typekind_time = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_time.set('T');
cl_abap_typedescr.typekind_utclong = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_utclong.set('p');
cl_abap_typedescr.typekind_w = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_w.set('w');
cl_abap_typedescr.typekind_xstring = new abap.types.Character(1, {"qualifiedName":"abap_typekind"});
cl_abap_typedescr.typekind_xstring.set('y');
cl_abap_typedescr.kind_elem = new abap.types.Character(1, {});
cl_abap_typedescr.kind_elem.set('E');
cl_abap_typedescr.kind_struct = new abap.types.Character(1, {});
cl_abap_typedescr.kind_struct.set('S');
cl_abap_typedescr.kind_table = new abap.types.Character(1, {});
cl_abap_typedescr.kind_table.set('T');
cl_abap_typedescr.kind_ref = new abap.types.Character(1, {});
cl_abap_typedescr.kind_ref.set('R');
cl_abap_typedescr.kind_class = new abap.types.Character(1, {});
cl_abap_typedescr.kind_class.set('C');
cl_abap_typedescr.kind_intf = new abap.types.Character(1, {});
cl_abap_typedescr.kind_intf.set('I');

//# sourceMappingURL=cl_abap_typedescr.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_unit_assert.clas.mjs":
/*!*********************************************!*\
  !*** ./output/cl_abap_unit_assert.clas.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_unit_assert": () => (/* binding */ cl_abap_unit_assert)
/* harmony export */ });
await __webpack_require__.e(/*! import() */ "output_cl_abap_unit_assert_clas_locals_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_unit_assert.clas.locals.mjs */ "./output/cl_abap_unit_assert.clas.locals.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_unit_assert.clas.abap
class cl_abap_unit_assert {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_UNIT_ASSERT';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"COMPARE_TABLES": {"visibility": "I", "parameters": {"ACT": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "EXP": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "ASSERT_EQUALS": {"visibility": "U", "parameters": {"ACT": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "EXP": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "MSG": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "TOL": {"type": () => {return new abap.types.Float({qualifiedName: "F"});}, "is_optional": " "}, "QUIT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "LEVEL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "ABORT": {"visibility": "U", "parameters": {"MSG": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "DETAIL": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "QUIT": {"type": () => {return new abap.types.Integer({qualifiedName: "INT1"});}, "is_optional": " "}}},
  "ASSERT_DIFFERS": {"visibility": "U", "parameters": {"ACT": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "EXP": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "MSG": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "QUIT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "LEVEL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "ASSERT_NUMBER_BETWEEN": {"visibility": "U", "parameters": {"LOWER": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "UPPER": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "NUMBER": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "MSG": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "QUIT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "LEVEL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "ASSERT_NOT_INITIAL": {"visibility": "U", "parameters": {"ACT": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "MSG": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "QUIT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "LEVEL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "ASSERT_INITIAL": {"visibility": "U", "parameters": {"ACT": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "MSG": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "QUIT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "LEVEL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "SKIP": {"visibility": "U", "parameters": {"MSG": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "DETAIL": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "FAIL": {"visibility": "U", "parameters": {"MSG": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "QUIT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "LEVEL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "DETAIL": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "ASSERT_SUBRC": {"visibility": "U", "parameters": {"EXP": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "ACT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "MSG": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "QUIT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "LEVEL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "ASSERT_TRUE": {"visibility": "U", "parameters": {"ACT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "MSG": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "QUIT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "LEVEL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "ASSERT_FALSE": {"visibility": "U", "parameters": {"ACT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "MSG": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "QUIT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "LEVEL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "ASSERT_CHAR_CP": {"visibility": "U", "parameters": {"ACT": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "EXP": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "MSG": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "QUIT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "LEVEL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "ASSERT_CHAR_NP": {"visibility": "U", "parameters": {"ACT": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "EXP": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "MSG": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "QUIT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "LEVEL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "ASSERT_BOUND": {"visibility": "U", "parameters": {"ACT": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "MSG": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "QUIT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "LEVEL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "ASSERT_NOT_BOUND": {"visibility": "U", "parameters": {"ACT": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "MSG": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "QUIT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "LEVEL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "ASSERT_TEXT_MATCHES": {"visibility": "U", "parameters": {"PATTERN": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "TEXT": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "MSG": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "QUIT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "LEVEL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async compare_tables(INPUT) {
    return cl_abap_unit_assert.compare_tables(INPUT);
  }
  static async compare_tables(INPUT) {
    let act = INPUT?.act;
    let exp = INPUT?.exp;
    let index = new abap.types.Integer({qualifiedName: "I"});
    let type1 = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TABLEDESCR", RTTIName: "\\CLASS=CL_ABAP_TABLEDESCR"});
    let type2 = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TABLEDESCR", RTTIName: "\\CLASS=CL_ABAP_TABLEDESCR"});
    let lv_match = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    let fs_tab1_ = new abap.types.FieldSymbol(abap.types.TableFactory.construct(new abap.types.Character(4), {"withHeader":false,"keyType":"DEFAULT"}));
    let fs_row1_ = new abap.types.FieldSymbol(new abap.types.Character(4));
    let fs_tab2_ = new abap.types.FieldSymbol(abap.types.TableFactory.construct(new abap.types.Character(4), {"withHeader":false,"keyType":"DEFAULT"}));
    let fs_row2_ = new abap.types.FieldSymbol(new abap.types.Character(4));
    if (abap.compare.ne(abap.builtin.lines({val: act}), abap.builtin.lines({val: exp}))) {
      const unique142 = await (new abap.Classes['KERNEL_CX_ASSERT']()).constructor_({msg: new abap.types.String().set(`Expected table to contain ${abap.templateFormatting(abap.builtin.lines({val: exp}))} rows, got ${abap.templateFormatting(abap.builtin.lines({val: act}))}`)});
      unique142.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_unit_assert.clas.abap","INTERNAL_LINE": 162};
      throw unique142;
    }
    abap.statements.assign({target: fs_tab1_, source: act});
    abap.statements.assign({target: fs_tab2_, source: exp});
    await abap.statements.cast(type1, (await abap.Classes['CL_ABAP_TYPEDESCR'].describe_by_data({p_data: act})));
    await abap.statements.cast(type2, (await abap.Classes['CL_ABAP_TYPEDESCR'].describe_by_data({p_data: exp})));
    if (abap.compare.eq(type1.get().table_kind, abap.Classes['CL_ABAP_TABLEDESCR'].tablekind_hashed) || abap.compare.eq(type2.get().table_kind, abap.Classes['CL_ABAP_TABLEDESCR'].tablekind_hashed)) {
      for await (const unique143 of abap.statements.loop(fs_tab1_)) {
        fs_row1_.assign(unique143);
        lv_match.set(abap.builtin.abap_false);
        for await (const unique144 of abap.statements.loop(fs_tab2_)) {
          fs_row2_.assign(unique144);
          try {
            await this.assert_equals({act: fs_row1_, exp: fs_row2_});
            lv_match.set(abap.builtin.abap_true);
            break;
          } catch (e) {
            if ((abap.Classes['KERNEL_CX_ASSERT'] && e instanceof abap.Classes['KERNEL_CX_ASSERT'])) {
            } else {
              throw e;
            }
          }
        }
        if (abap.compare.eq(lv_match, abap.builtin.abap_false)) {
          const unique145 = await (new abap.Classes['KERNEL_CX_ASSERT']()).constructor_({msg: new abap.types.String().set(`Hashed table contents differs`)});
          unique145.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_unit_assert.clas.abap","INTERNAL_LINE": 188};
          throw unique145;
        }
      }
    } else {
      const indexBackup1 = abap.builtin.sy.get().index.get();
      const unique146 = abap.builtin.lines({val: act}).get();
      for (let unique147 = 0; unique147 < unique146; unique147++) {
        abap.builtin.sy.get().index.set(unique147 + 1);
        index.set(abap.builtin.sy.get().index);
        abap.statements.readTable(fs_tab1_,{index: index,
          assigning: fs_row1_});
        await this.assert_subrc();
        abap.statements.readTable(fs_tab2_,{index: index,
          assigning: fs_row2_});
        await this.assert_subrc();
        await this.assert_equals({act: fs_row1_, exp: fs_row2_});
      }
      abap.builtin.sy.get().index.set(indexBackup1);
    }
  }
  async assert_text_matches(INPUT) {
    return cl_abap_unit_assert.assert_text_matches(INPUT);
  }
  static async assert_text_matches(INPUT) {
    let pattern = INPUT?.pattern;
    let text = INPUT?.text;
    let msg = INPUT?.msg || new abap.types.Character();
    let quit = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.quit) {quit.set(INPUT.quit);}
    let level = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.level) {level.set(INPUT.level);}
    let lv_match = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    lv_match.set(abap.builtin.boolc({val: abap.builtin.contains({val: text, regex: pattern})}));
    if (abap.compare.eq(lv_match, abap.builtin.abap_false)) {
      const unique148 = await (new abap.Classes['KERNEL_CX_ASSERT']()).constructor_({expected: pattern, actual: text, msg: msg});
      unique148.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_unit_assert.clas.abap","INTERNAL_LINE": 214};
      throw unique148;
    }
  }
  async abort(INPUT) {
    return cl_abap_unit_assert.abort(INPUT);
  }
  static async abort(INPUT) {
    let msg = INPUT?.msg || new abap.types.Character();
    let detail = INPUT?.detail || new abap.types.Character();
    let quit = new abap.types.Integer({qualifiedName: "INT1"});
    if (INPUT && INPUT.quit) {quit.set(INPUT.quit);}
    if (INPUT === undefined || INPUT.quit === undefined) {quit = abap.IntegerFactory.get(2);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async assert_bound(INPUT) {
    return cl_abap_unit_assert.assert_bound(INPUT);
  }
  static async assert_bound(INPUT) {
    let act = INPUT?.act;
    let msg = INPUT?.msg || new abap.types.Character();
    let quit = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.quit) {quit.set(INPUT.quit);}
    let level = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.level) {level.set(INPUT.level);}
    if (abap.compare.initial(act)) {
      const unique149 = await (new abap.Classes['KERNEL_CX_ASSERT']()).constructor_({msg: new abap.types.String().set(`Expected value to be bound`)});
      unique149.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_unit_assert.clas.abap","INTERNAL_LINE": 228};
      throw unique149;
    }
  }
  async assert_not_bound(INPUT) {
    return cl_abap_unit_assert.assert_not_bound(INPUT);
  }
  static async assert_not_bound(INPUT) {
    let act = INPUT?.act;
    let msg = INPUT?.msg || new abap.types.Character();
    let quit = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.quit) {quit.set(INPUT.quit);}
    let level = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.level) {level.set(INPUT.level);}
    if (abap.compare.initial(act) === false) {
      const unique150 = await (new abap.Classes['KERNEL_CX_ASSERT']()).constructor_({msg: new abap.types.String().set(`Expected value to not be bound`)});
      unique150.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_unit_assert.clas.abap","INTERNAL_LINE": 236};
      throw unique150;
    }
  }
  async assert_char_cp(INPUT) {
    return cl_abap_unit_assert.assert_char_cp(INPUT);
  }
  static async assert_char_cp(INPUT) {
    let act = INPUT?.act;
    let exp = INPUT?.exp;
    let msg = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.msg) {msg.set(INPUT.msg);}
    let quit = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.quit) {quit.set(INPUT.quit);}
    let level = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.level) {level.set(INPUT.level);}
    if (abap.compare.np(act, exp)) {
      const unique151 = await (new abap.Classes['KERNEL_CX_ASSERT']()).constructor_({expected: exp, actual: act, msg: msg});
      unique151.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_unit_assert.clas.abap","INTERNAL_LINE": 244};
      throw unique151;
    }
  }
  async assert_char_np(INPUT) {
    return cl_abap_unit_assert.assert_char_np(INPUT);
  }
  static async assert_char_np(INPUT) {
    let act = INPUT?.act;
    let exp = INPUT?.exp;
    let msg = INPUT?.msg || new abap.types.Character();
    let quit = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.quit) {quit.set(INPUT.quit);}
    let level = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.level) {level.set(INPUT.level);}
    if (abap.compare.cp(act, exp)) {
      const unique152 = await (new abap.Classes['KERNEL_CX_ASSERT']()).constructor_({msg: new abap.types.String().set(`Actual: ${abap.templateFormatting(act)}`)});
      unique152.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_unit_assert.clas.abap","INTERNAL_LINE": 254};
      throw unique152;
    }
  }
  async fail(INPUT) {
    return cl_abap_unit_assert.fail(INPUT);
  }
  static async fail(INPUT) {
    let msg = INPUT?.msg || new abap.types.Character();
    let quit = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.quit) {quit.set(INPUT.quit);}
    let level = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.level) {level.set(INPUT.level);}
    let detail = INPUT?.detail || new abap.types.Character();
    const unique153 = await (new abap.Classes['KERNEL_CX_ASSERT']()).constructor_({msg: msg});
    unique153.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_unit_assert.clas.abap","INTERNAL_LINE": 261};
    throw unique153;
  }
  async skip(INPUT) {
    return cl_abap_unit_assert.skip(INPUT);
  }
  static async skip(INPUT) {
    let msg = INPUT?.msg;
    let detail = INPUT?.detail || new abap.types.Character();
    return;
  }
  async assert_differs(INPUT) {
    return cl_abap_unit_assert.assert_differs(INPUT);
  }
  static async assert_differs(INPUT) {
    let act = INPUT?.act;
    let exp = INPUT?.exp;
    let msg = INPUT?.msg || new abap.types.Character();
    let quit = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.quit) {quit.set(INPUT.quit);}
    let level = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.level) {level.set(INPUT.level);}
    try {
      await this.assert_equals({act: act, exp: exp});
      const unique154 = await (new abap.Classes['KERNEL_CX_ASSERT']()).constructor_({msg: new abap.types.String().set(`Expected different values`), actual: act, expected: exp});
      unique154.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_unit_assert.clas.abap","INTERNAL_LINE": 275};
      throw unique154;
    } catch (e) {
      if ((abap.Classes['KERNEL_CX_ASSERT'] && e instanceof abap.Classes['KERNEL_CX_ASSERT'])) {
        return;
      } else {
        throw e;
      }
    }
  }
  async assert_true(INPUT) {
    return cl_abap_unit_assert.assert_true(INPUT);
  }
  static async assert_true(INPUT) {
    let act = INPUT?.act;
    if (act?.getQualifiedName === undefined || act.getQualifiedName() !== "ABAP_BOOL") { act = undefined; }
    if (act === undefined) { act = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}).set(INPUT.act); }
    let msg = INPUT?.msg || new abap.types.Character();
    let quit = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.quit) {quit.set(INPUT.quit);}
    let level = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.level) {level.set(INPUT.level);}
    if (abap.compare.ne(act, abap.builtin.abap_true)) {
      const unique155 = await (new abap.Classes['KERNEL_CX_ASSERT']()).constructor_({msg: new abap.types.String().set(`Expected abap_true`)});
      unique155.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_unit_assert.clas.abap","INTERNAL_LINE": 287};
      throw unique155;
    }
  }
  async assert_false(INPUT) {
    return cl_abap_unit_assert.assert_false(INPUT);
  }
  static async assert_false(INPUT) {
    let act = INPUT?.act;
    if (act?.getQualifiedName === undefined || act.getQualifiedName() !== "ABAP_BOOL") { act = undefined; }
    if (act === undefined) { act = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}).set(INPUT.act); }
    let msg = INPUT?.msg || new abap.types.Character();
    let quit = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.quit) {quit.set(INPUT.quit);}
    let level = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.level) {level.set(INPUT.level);}
    if (abap.compare.ne(act, abap.builtin.abap_false)) {
      const unique156 = await (new abap.Classes['KERNEL_CX_ASSERT']()).constructor_({msg: new abap.types.String().set(`Expected abap_false`)});
      unique156.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_unit_assert.clas.abap","INTERNAL_LINE": 295};
      throw unique156;
    }
  }
  async assert_equals(INPUT) {
    return cl_abap_unit_assert.assert_equals(INPUT);
  }
  static async assert_equals(INPUT) {
    let act = INPUT?.act;
    let exp = INPUT?.exp;
    let msg = INPUT?.msg || new abap.types.Character();
    let tol = new abap.types.Float({qualifiedName: "F"});
    if (INPUT && INPUT.tol) {tol.set(INPUT.tol);}
    let quit = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.quit) {quit.set(INPUT.quit);}
    let level = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.level) {level.set(INPUT.level);}
    let type1 = new abap.types.Character(1, {});
    let type2 = new abap.types.Character(1, {});
    let diff = new abap.types.Float({qualifiedName: "F"});
    let lv_exp = new abap.types.String({qualifiedName: "STRING"});
    let lv_act = new abap.types.String({qualifiedName: "STRING"});
    let lv_msg = new abap.types.String({qualifiedName: "STRING"});
    abap.statements.describe({field: act, type: type1});
    abap.statements.describe({field: exp, type: type2});
    if (abap.compare.ca(type1, new abap.types.Character(11).set('CgyIFPDTXN8'))) {
      if (abap.compare.initial(type2) === false) {
        if (abap.compare.na(type2, new abap.types.Character(11).set('CgyIFPDTXN8'))) {
          const unique157 = await (new abap.Classes['KERNEL_CX_ASSERT']()).constructor_({msg: new abap.types.String().set(`Unexpected types`)});
          unique157.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_unit_assert.clas.abap","INTERNAL_LINE": 316};
          throw unique157;
        }
      }
    } else if (abap.compare.initial(type1) === false && abap.compare.initial(type2) === false) {
      if (abap.compare.ne(type1, type2)) {
        const unique158 = await (new abap.Classes['KERNEL_CX_ASSERT']()).constructor_({msg: new abap.types.String().set(`Unexpected types`)});
        unique158.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_unit_assert.clas.abap","INTERNAL_LINE": 324};
        throw unique158;
      }
    }
    if (abap.compare.eq(type1, new abap.types.Character(1).set('h'))) {
      await this.compare_tables({act: act, exp: exp});
    } else if (INPUT && INPUT.tol) {
      diff.set(abap.operators.minus(exp,act));
      if (abap.compare.ge(diff, tol)) {
        const unique159 = await (new abap.Classes['KERNEL_CX_ASSERT']()).constructor_();
        unique159.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_unit_assert.clas.abap","INTERNAL_LINE": 339};
        throw unique159;
      }
    } else if (abap.compare.eq(type1, new abap.types.Character(1).set('l'))) {
      await this.assert_equals({act: (act).dereference(), exp: (exp).dereference()});
    } else if (abap.compare.ne(act, exp)) {
      lv_act.set((await abap.Classes['CLAS-CL_ABAP_UNIT_ASSERT-LCL_DUMP'].to_string({iv_val: act})));
      lv_exp.set((await abap.Classes['CLAS-CL_ABAP_UNIT_ASSERT-LCL_DUMP'].to_string({iv_val: exp})));
      if (abap.compare.ne(msg, new abap.types.Character(1).set(''))) {
        lv_msg.set(msg);
      } else {
        lv_msg.set(new abap.types.String().set(`Expected '${abap.templateFormatting(lv_exp)}', got '${abap.templateFormatting(lv_act)}'`));
      }
      const unique160 = await (new abap.Classes['KERNEL_CX_ASSERT']()).constructor_({msg: lv_msg, actual: lv_act, expected: lv_exp});
      unique160.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_unit_assert.clas.abap","INTERNAL_LINE": 353};
      throw unique160;
    }
  }
  async assert_not_initial(INPUT) {
    return cl_abap_unit_assert.assert_not_initial(INPUT);
  }
  static async assert_not_initial(INPUT) {
    let act = INPUT?.act;
    let msg = INPUT?.msg || new abap.types.Character();
    let quit = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.quit) {quit.set(INPUT.quit);}
    let level = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.level) {level.set(INPUT.level);}
    let lv_msg = new abap.types.String({qualifiedName: "STRING"});
    if (abap.compare.initial(act)) {
      lv_msg.set(msg);
      if (abap.compare.initial(lv_msg)) {
        lv_msg.set(new abap.types.String().set(`Expected non initial value`));
      }
      const unique161 = await (new abap.Classes['KERNEL_CX_ASSERT']()).constructor_({msg: lv_msg});
      unique161.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_unit_assert.clas.abap","INTERNAL_LINE": 368};
      throw unique161;
    }
  }
  async assert_initial(INPUT) {
    return cl_abap_unit_assert.assert_initial(INPUT);
  }
  static async assert_initial(INPUT) {
    let act = INPUT?.act;
    let msg = INPUT?.msg || new abap.types.Character();
    let quit = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.quit) {quit.set(INPUT.quit);}
    let level = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.level) {level.set(INPUT.level);}
    let lv_msg = new abap.types.String({qualifiedName: "STRING"});
    if (abap.compare.initial(act) === false) {
      lv_msg.set(msg);
      if (abap.compare.initial(lv_msg)) {
        lv_msg.set(new abap.types.String().set(`Expected initial value`));
      }
      const unique162 = await (new abap.Classes['KERNEL_CX_ASSERT']()).constructor_({msg: lv_msg});
      unique162.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_unit_assert.clas.abap","INTERNAL_LINE": 381};
      throw unique162;
    }
  }
  async assert_subrc(INPUT) {
    return cl_abap_unit_assert.assert_subrc(INPUT);
  }
  static async assert_subrc(INPUT) {
    let exp = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.exp) {exp.set(INPUT.exp);}
    if (INPUT === undefined || INPUT.exp === undefined) {exp = abap.IntegerFactory.get(0);}
    let act = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.act) {act.set(INPUT.act);}
    if (INPUT === undefined || INPUT.act === undefined) {act = abap.builtin.sy.get().subrc;}
    let msg = INPUT?.msg || new abap.types.Character();
    let quit = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.quit) {quit.set(INPUT.quit);}
    let level = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.level) {level.set(INPUT.level);}
    let lv_msg = new abap.types.String({qualifiedName: "STRING"});
    if (abap.compare.ne(act, exp)) {
      lv_msg.set(msg);
      if (abap.compare.initial(lv_msg)) {
        lv_msg.set(new abap.types.String().set(`Expected sy-subrc to equal ${abap.templateFormatting(exp)}, got ${abap.templateFormatting(act)}`));
      }
      const unique163 = await (new abap.Classes['KERNEL_CX_ASSERT']()).constructor_({msg: lv_msg});
      unique163.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_unit_assert.clas.abap","INTERNAL_LINE": 394};
      throw unique163;
    }
  }
  async assert_number_between(INPUT) {
    return cl_abap_unit_assert.assert_number_between(INPUT);
  }
  static async assert_number_between(INPUT) {
    let lower = INPUT?.lower;
    if (lower?.getQualifiedName === undefined || lower.getQualifiedName() !== "I") { lower = undefined; }
    if (lower === undefined) { lower = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.lower); }
    let upper = INPUT?.upper;
    if (upper?.getQualifiedName === undefined || upper.getQualifiedName() !== "I") { upper = undefined; }
    if (upper === undefined) { upper = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.upper); }
    let number = INPUT?.number;
    if (number?.getQualifiedName === undefined || number.getQualifiedName() !== "I") { number = undefined; }
    if (number === undefined) { number = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.number); }
    let msg = INPUT?.msg || new abap.types.Character();
    let quit = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.quit) {quit.set(INPUT.quit);}
    let level = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.level) {level.set(INPUT.level);}
    if (abap.compare.lt(number, lower) || abap.compare.gt(number, upper)) {
      const unique164 = await (new abap.Classes['KERNEL_CX_ASSERT']()).constructor_();
      unique164.EXTRA_CX = {"INTERNAL_FILENAME": "cl_abap_unit_assert.clas.abap","INTERNAL_LINE": 402};
      throw unique164;
    }
  }
}
abap.Classes['CL_ABAP_UNIT_ASSERT'] = cl_abap_unit_assert;

//# sourceMappingURL=cl_abap_unit_assert.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_weak_reference.clas.mjs":
/*!************************************************!*\
  !*** ./output/cl_abap_weak_reference.clas.mjs ***!
  \************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_weak_reference": () => (/* binding */ cl_abap_weak_reference)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_weak_reference.clas.abap
class cl_abap_weak_reference {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_WEAK_REFERENCE';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"MV_REF": {"type": () => {return new abap.types.Hex();}, "visibility": "I", "is_constant": " ", "is_class": " "}};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"OREF": {"type": () => {return new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});}, "is_optional": " "}}},
  "GET": {"visibility": "U", "parameters": {"OREF": {"type": () => {return new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.mv_ref = new abap.types.Hex();
  }
  async constructor_(INPUT) {
    let oref = INPUT?.oref;
    if (oref === undefined) { oref = new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined}).set(INPUT.oref); }
    abap.statements.assert(abap.compare.initial(oref) === false);
    this.mv_ref = new WeakRef(oref);
    return this;
  }
  async get() {
    let oref = new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});
    oref.set(this.mv_ref.deref());
    return oref;
  }
}
abap.Classes['CL_ABAP_WEAK_REFERENCE'] = cl_abap_weak_reference;

//# sourceMappingURL=cl_abap_weak_reference.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_abap_zip.clas.mjs":
/*!*************************************!*\
  !*** ./output/cl_abap_zip.clas.mjs ***!
  \*************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_abap_zip": () => (/* binding */ cl_abap_zip)
/* harmony export */ });
await __webpack_require__.e(/*! import() */ "output_cl_abap_zip_clas_locals_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_zip.clas.locals.mjs */ "./output/cl_abap_zip.clas.locals.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_abap_zip.clas.abap
class cl_abap_zip {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ABAP_ZIP';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"FILES": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "CL_ABAP_ZIP=>T_FILE-NAME"}), "size": new abap.types.Integer({qualifiedName: "CL_ABAP_ZIP=>T_FILE-SIZE"})}, "cl_abap_zip=>t_file", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "cl_abap_zip=>t_files");}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "MT_CONTENTS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "CL_ABAP_ZIP=>TY_CONTENTS-NAME"}), "content": new abap.types.XString({qualifiedName: "CL_ABAP_ZIP=>TY_CONTENTS-CONTENT"}), "compressed": new abap.types.XString({qualifiedName: "CL_ABAP_ZIP=>TY_CONTENTS-COMPRESSED"})}, "cl_abap_zip=>ty_contents", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "");}, "visibility": "I", "is_constant": " ", "is_class": " "}};
  static METHODS = {"ADD": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "CONTENT": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "SAVE": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "LOAD": {"visibility": "U", "parameters": {"ZIP": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "GET": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "INDEX": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "CONTENT": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "DELETE": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "INDEX": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "CRC32": {"visibility": "U", "parameters": {"CRC": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "CONTENT": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.files = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "CL_ABAP_ZIP=>T_FILE-NAME"}), "size": new abap.types.Integer({qualifiedName: "CL_ABAP_ZIP=>T_FILE-SIZE"})}, "cl_abap_zip=>t_file", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "cl_abap_zip=>t_files");
    this.mt_contents = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "CL_ABAP_ZIP=>TY_CONTENTS-NAME"}), "content": new abap.types.XString({qualifiedName: "CL_ABAP_ZIP=>TY_CONTENTS-CONTENT"}), "compressed": new abap.types.XString({qualifiedName: "CL_ABAP_ZIP=>TY_CONTENTS-COMPRESSED"})}, "cl_abap_zip=>ty_contents", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "");
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async crc32(INPUT) {
    return cl_abap_zip.crc32(INPUT);
  }
  static async crc32(INPUT) {
    let crc = new abap.types.Integer({qualifiedName: "I"});
    let content = INPUT?.content;
    if (content?.getQualifiedName === undefined || content.getQualifiedName() !== "XSTRING") { content = undefined; }
    if (content === undefined) { content = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.content); }
    let lo_stream = new abap.types.ABAPObject({qualifiedName: "LCL_STREAM", RTTIName: "\\CLASS-POOL=CL_ABAP_ZIP\\CLASS=LCL_STREAM"});
    lo_stream.set(await (new abap.Classes['CLAS-CL_ABAP_ZIP-LCL_STREAM']()).constructor_());
    crc.set((await lo_stream.get().append_crc({iv_little_endian: abap.builtin.abap_false, iv_xstring: content})));
    return crc;
  }
  async delete(INPUT) {
    let name = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.name) {name.set(INPUT.name);}
    let index = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.index) {index.set(INPUT.index);}
    if (INPUT === undefined || INPUT.index === undefined) {index = abap.IntegerFactory.get(0);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async get(INPUT) {
    let name = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.name) {name.set(INPUT.name);}
    let index = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.index) {index.set(INPUT.index);}
    let content = INPUT?.content || new abap.types.XString({qualifiedName: "XSTRING"});
    let ls_length = new abap.types.Integer({qualifiedName: "I"});
    let ls_contents = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "CL_ABAP_ZIP=>TY_CONTENTS-NAME"}), "content": new abap.types.XString({qualifiedName: "CL_ABAP_ZIP=>TY_CONTENTS-CONTENT"}), "compressed": new abap.types.XString({qualifiedName: "CL_ABAP_ZIP=>TY_CONTENTS-COMPRESSED"})}, "cl_abap_zip=>ty_contents", undefined, {}, {});
    abap.statements.assert(abap.compare.initial(name) === false);
    abap.statements.assert(abap.compare.initial(index));
    abap.statements.readTable(this.mt_contents,{into: ls_contents,
      withKey: (i) => {return abap.compare.eq(i.name, name);},
      withKeyValue: [{key: (i) => {return i.name}, value: name}],
      usesTableLine: false,
      withKeySimple: {"name": name}});
    await abap.Classes['CL_ABAP_GZIP'].decompress_binary({gzip_in: ls_contents.get().compressed, raw_out: content, raw_out_len: ls_length});
  }
  async add(INPUT) {
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    let content = INPUT?.content;
    if (content?.getQualifiedName === undefined || content.getQualifiedName() !== "XSTRING") { content = undefined; }
    if (content === undefined) { content = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.content); }
    let ls_contents = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "CL_ABAP_ZIP=>TY_CONTENTS-NAME"}), "content": new abap.types.XString({qualifiedName: "CL_ABAP_ZIP=>TY_CONTENTS-CONTENT"}), "compressed": new abap.types.XString({qualifiedName: "CL_ABAP_ZIP=>TY_CONTENTS-COMPRESSED"})}, "cl_abap_zip=>ty_contents", undefined, {}, {});
    ls_contents.get().name.set(name);
    ls_contents.get().content.set(content);
    await abap.Classes['CL_ABAP_GZIP'].compress_binary({raw_in: content, gzip_out: ls_contents.get().compressed});
    abap.statements.insertInternal({data: ls_contents, table: this.mt_contents});
  }
  async load(INPUT) {
    let zip = INPUT?.zip;
    if (zip?.getQualifiedName === undefined || zip.getQualifiedName() !== "XSTRING") { zip = undefined; }
    if (zip === undefined) { zip = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.zip); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async save() {
    let val = new abap.types.XString({qualifiedName: "XSTRING"});
    let lo_total = new abap.types.ABAPObject({qualifiedName: "LCL_STREAM", RTTIName: "\\CLASS-POOL=CL_ABAP_ZIP\\CLASS=LCL_STREAM"});
    let lo_file = new abap.types.ABAPObject({qualifiedName: "LCL_STREAM", RTTIName: "\\CLASS-POOL=CL_ABAP_ZIP\\CLASS=LCL_STREAM"});
    let lo_central = new abap.types.ABAPObject({qualifiedName: "LCL_STREAM", RTTIName: "\\CLASS-POOL=CL_ABAP_ZIP\\CLASS=LCL_STREAM"});
    let ls_contents = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "CL_ABAP_ZIP=>TY_CONTENTS-NAME"}), "content": new abap.types.XString({qualifiedName: "CL_ABAP_ZIP=>TY_CONTENTS-CONTENT"}), "compressed": new abap.types.XString({qualifiedName: "CL_ABAP_ZIP=>TY_CONTENTS-COMPRESSED"})}, "cl_abap_zip=>ty_contents", undefined, {}, {});
    let lv_buffer = new abap.types.XString({qualifiedName: "XSTRING"});
    let lv_tmp = new abap.types.XString({qualifiedName: "XSTRING"});
    let lv_start = new abap.types.Integer({qualifiedName: "I"});
    let lo_conv = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_CONV_OUT_CE", RTTIName: "\\CLASS=CL_ABAP_CONV_OUT_CE"});
    lo_central.set(await (new abap.Classes['CLAS-CL_ABAP_ZIP-LCL_STREAM']()).constructor_());
    lo_total.set(await (new abap.Classes['CLAS-CL_ABAP_ZIP-LCL_STREAM']()).constructor_());
    lo_conv.set((await abap.Classes['CL_ABAP_CONV_OUT_CE'].create()));
    for await (const unique11 of abap.statements.loop(this.mt_contents)) {
      ls_contents.set(unique11);
      await lo_conv.get().convert({data: ls_contents.get().name, buffer: lv_buffer});
      lo_file.set(await (new abap.Classes['CLAS-CL_ABAP_ZIP-LCL_STREAM']()).constructor_());
      await lo_file.get().append({iv_xstr: new abap.types.Character(8).set('504B0304')});
      await lo_file.get().append({iv_xstr: new abap.types.Character(4).set('1400')});
      await lo_file.get().append({iv_xstr: new abap.types.Character(4).set('0000')});
      await lo_file.get().append({iv_xstr: new abap.types.Character(4).set('0800')});
      await lo_file.get().append({iv_xstr: new abap.types.Character(4).set('0699')});
      await lo_file.get().append({iv_xstr: new abap.types.Character(4).set('F856')});
      await lo_file.get().append_crc({iv_little_endian: abap.builtin.abap_true, iv_xstring: ls_contents.get().content});
      await lo_file.get().append_int4({iv_int: abap.builtin.xstrlen({val: ls_contents.get().compressed})});
      await lo_file.get().append_int4({iv_int: abap.builtin.xstrlen({val: ls_contents.get().content})});
      await lo_file.get().append_int2({iv_int: abap.builtin.xstrlen({val: lv_buffer})});
      await lo_file.get().append({iv_xstr: new abap.types.Character(4).set('0000')});
      await lo_file.get().append({iv_xstr: lv_buffer});
      await lo_file.get().append({iv_xstr: ls_contents.get().compressed});
      await lo_central.get().append({iv_xstr: new abap.types.Character(8).set('504B0102')});
      await lo_central.get().append({iv_xstr: new abap.types.Character(4).set('1400')});
      lv_tmp.set((await lo_file.get().get()));
      await lo_central.get().append({iv_xstr: lv_tmp.getOffset({offset: 4, length: 26})});
      await lo_central.get().append_int2({iv_int: abap.IntegerFactory.get(0)});
      await lo_central.get().append_int2({iv_int: abap.IntegerFactory.get(0)});
      await lo_central.get().append_int2({iv_int: abap.IntegerFactory.get(0)});
      await lo_central.get().append_int4({iv_int: abap.IntegerFactory.get(0)});
      await lo_central.get().append_int4({iv_int: (abap.builtin.xstrlen({val: (await lo_total.get().get())}))});
      await lo_central.get().append({iv_xstr: lv_buffer});
      await lo_total.get().append({iv_xstr: (await lo_file.get().get())});
    }
    lv_start.set((abap.builtin.xstrlen({val: (await lo_total.get().get())})));
    await lo_total.get().append({iv_xstr: (await lo_central.get().get())});
    await lo_total.get().append({iv_xstr: new abap.types.Character(8).set('504B0506')});
    await lo_total.get().append_int2({iv_int: abap.IntegerFactory.get(0)});
    await lo_total.get().append_int2({iv_int: abap.IntegerFactory.get(0)});
    await lo_total.get().append_int2({iv_int: abap.builtin.lines({val: this.mt_contents})});
    await lo_total.get().append_int2({iv_int: abap.builtin.lines({val: this.mt_contents})});
    await lo_total.get().append_int4({iv_int: (abap.builtin.xstrlen({val: (await lo_central.get().get())}))});
    await lo_total.get().append_int4({iv_int: lv_start});
    await lo_total.get().append_int2({iv_int: abap.IntegerFactory.get(0)});
    val.set((await lo_total.get().get()));
    return val;
  }
}
abap.Classes['CL_ABAP_ZIP'] = cl_abap_zip;
cl_abap_zip.t_file = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "CL_ABAP_ZIP=>T_FILE-NAME"}), "size": new abap.types.Integer({qualifiedName: "CL_ABAP_ZIP=>T_FILE-SIZE"})}, "cl_abap_zip=>t_file", undefined, {}, {});
cl_abap_zip.t_files = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "CL_ABAP_ZIP=>T_FILE-NAME"}), "size": new abap.types.Integer({qualifiedName: "CL_ABAP_ZIP=>T_FILE-SIZE"})}, "cl_abap_zip=>t_file", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "cl_abap_zip=>t_files");
cl_abap_zip.ty_contents = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "CL_ABAP_ZIP=>TY_CONTENTS-NAME"}), "content": new abap.types.XString({qualifiedName: "CL_ABAP_ZIP=>TY_CONTENTS-CONTENT"}), "compressed": new abap.types.XString({qualifiedName: "CL_ABAP_ZIP=>TY_CONTENTS-COMPRESSED"})}, "cl_abap_zip=>ty_contents", undefined, {}, {});

//# sourceMappingURL=cl_abap_zip.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_apc_tcp_client_manager.clas.mjs":
/*!***************************************************!*\
  !*** ./output/cl_apc_tcp_client_manager.clas.mjs ***!
  \***************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_apc_tcp_client_manager": () => (/* binding */ cl_apc_tcp_client_manager)
/* harmony export */ });
await __webpack_require__.e(/*! import() */ "output_cl_apc_tcp_client_manager_clas_locals_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_apc_tcp_client_manager.clas.locals.mjs */ "./output/cl_apc_tcp_client_manager.clas.locals.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_apc_tcp_client_manager.clas.abap
class cl_apc_tcp_client_manager {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_APC_TCP_CLIENT_MANAGER';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"CO_PROTOCOL_TYPE_TCP": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_PROTOCOL_TYPE_TCPS": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"CREATE": {"visibility": "U", "parameters": {"RI_CLIENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_CLIENT", RTTIName: "\\INTERFACE=IF_APC_WSP_CLIENT"});}, "is_optional": " "}, "I_HOST": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "I_PORT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "I_FRAME": {"type": () => {return new abap.types.Structure({"frame_type": new abap.types.Integer({qualifiedName: "IF_ABAP_CHANNEL_TYPES=>TY_APC_TCP_FRAME-FRAME_TYPE"}), "fixed_length": new abap.types.Integer({qualifiedName: "IF_ABAP_CHANNEL_TYPES=>TY_APC_TCP_FRAME-FIXED_LENGTH"}), "terminator": new abap.types.String({qualifiedName: "IF_ABAP_CHANNEL_TYPES=>TY_APC_TCP_FRAME-TERMINATOR"}), "length_field_length": new abap.types.Integer({qualifiedName: "IF_ABAP_CHANNEL_TYPES=>TY_APC_TCP_FRAME-LENGTH_FIELD_LENGTH"}), "length_field_offset": new abap.types.Integer({qualifiedName: "IF_ABAP_CHANNEL_TYPES=>TY_APC_TCP_FRAME-LENGTH_FIELD_OFFSET"}), "length_field_header": new abap.types.Integer({qualifiedName: "IF_ABAP_CHANNEL_TYPES=>TY_APC_TCP_FRAME-LENGTH_FIELD_HEADER"})}, "if_abap_channel_types=>ty_apc_tcp_frame", undefined, {}, {});}, "is_optional": " "}, "I_EVENT_HANDLER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_EVENT_HANDLER", RTTIName: "\\INTERFACE=IF_APC_WSP_EVENT_HANDLER"});}, "is_optional": " "}, "I_PROTOCOL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "I_SSL_ID": {"type": () => {return new abap.types.Character(6, {"qualifiedName":"SSFAPPLSSL","ddicName":"SSFAPPLSSL"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.co_protocol_type_tcp = cl_apc_tcp_client_manager.co_protocol_type_tcp;
    this.co_protocol_type_tcps = cl_apc_tcp_client_manager.co_protocol_type_tcps;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async create(INPUT) {
    return cl_apc_tcp_client_manager.create(INPUT);
  }
  static async create(INPUT) {
    let ri_client = new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_CLIENT", RTTIName: "\\INTERFACE=IF_APC_WSP_CLIENT"});
    let i_host = INPUT?.i_host;
    if (i_host?.getQualifiedName === undefined || i_host.getQualifiedName() !== "STRING") { i_host = undefined; }
    if (i_host === undefined) { i_host = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.i_host); }
    let i_port = INPUT?.i_port;
    if (i_port?.getQualifiedName === undefined || i_port.getQualifiedName() !== "STRING") { i_port = undefined; }
    if (i_port === undefined) { i_port = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.i_port); }
    let i_frame = INPUT?.i_frame;
    if (i_frame?.getQualifiedName === undefined || i_frame.getQualifiedName() !== "IF_ABAP_CHANNEL_TYPES=>TY_APC_TCP_FRAME") { i_frame = undefined; }
    if (i_frame === undefined) { i_frame = new abap.types.Structure({"frame_type": new abap.types.Integer({qualifiedName: "IF_ABAP_CHANNEL_TYPES=>TY_APC_TCP_FRAME-FRAME_TYPE"}), "fixed_length": new abap.types.Integer({qualifiedName: "IF_ABAP_CHANNEL_TYPES=>TY_APC_TCP_FRAME-FIXED_LENGTH"}), "terminator": new abap.types.String({qualifiedName: "IF_ABAP_CHANNEL_TYPES=>TY_APC_TCP_FRAME-TERMINATOR"}), "length_field_length": new abap.types.Integer({qualifiedName: "IF_ABAP_CHANNEL_TYPES=>TY_APC_TCP_FRAME-LENGTH_FIELD_LENGTH"}), "length_field_offset": new abap.types.Integer({qualifiedName: "IF_ABAP_CHANNEL_TYPES=>TY_APC_TCP_FRAME-LENGTH_FIELD_OFFSET"}), "length_field_header": new abap.types.Integer({qualifiedName: "IF_ABAP_CHANNEL_TYPES=>TY_APC_TCP_FRAME-LENGTH_FIELD_HEADER"})}, "if_abap_channel_types=>ty_apc_tcp_frame", undefined, {}, {}).set(INPUT.i_frame); }
    let i_event_handler = INPUT?.i_event_handler;
    if (i_event_handler?.getQualifiedName === undefined || i_event_handler.getQualifiedName() !== "IF_APC_WSP_EVENT_HANDLER") { i_event_handler = undefined; }
    if (i_event_handler === undefined) { i_event_handler = new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_EVENT_HANDLER", RTTIName: "\\INTERFACE=IF_APC_WSP_EVENT_HANDLER"}).set(INPUT.i_event_handler); }
    let i_protocol = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.i_protocol) {i_protocol.set(INPUT.i_protocol);}
    if (INPUT === undefined || INPUT.i_protocol === undefined) {i_protocol = this.co_protocol_type_tcp;}
    let i_ssl_id = new abap.types.Character(6, {"qualifiedName":"SSFAPPLSSL","ddicName":"SSFAPPLSSL"});
    if (INPUT && INPUT.i_ssl_id) {i_ssl_id.set(INPUT.i_ssl_id);}
    let lv_port = new abap.types.Integer({qualifiedName: "I"});
    lv_port.set(i_port);
    ri_client.set(await (new abap.Classes['CLAS-CL_APC_TCP_CLIENT_MANAGER-LCL_CLIENT']()).constructor_({iv_host: i_host, iv_port: lv_port, io_handler: i_event_handler, iv_protocol: i_protocol}));
    return ri_client;
  }
}
abap.Classes['CL_APC_TCP_CLIENT_MANAGER'] = cl_apc_tcp_client_manager;
cl_apc_tcp_client_manager.co_protocol_type_tcp = new abap.types.Integer({qualifiedName: "I"});
cl_apc_tcp_client_manager.co_protocol_type_tcp.set(1);
cl_apc_tcp_client_manager.co_protocol_type_tcps = new abap.types.Integer({qualifiedName: "I"});
cl_apc_tcp_client_manager.co_protocol_type_tcps.set(2);

//# sourceMappingURL=cl_apc_tcp_client_manager.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_apc_wsp_ext_stateless_base.clas.mjs":
/*!*******************************************************!*\
  !*** ./output/cl_apc_wsp_ext_stateless_base.clas.mjs ***!
  \*******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_apc_wsp_ext_stateless_base": () => (/* binding */ cl_apc_wsp_ext_stateless_base)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_apc_wsp_ext_stateless_base.clas.abap
class cl_apc_wsp_ext_stateless_base {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_APC_WSP_EXT_STATELESS_BASE';
  static IMPLEMENTED_INTERFACES = ["IF_APC_WSP_EXTENSION"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async if_apc_wsp_extension$on_start(INPUT) {
    let i_context = INPUT?.i_context;
    if (i_context?.getQualifiedName === undefined || i_context.getQualifiedName() !== "IF_APC_WSP_SERVER_CONTEXT") { i_context = undefined; }
    if (i_context === undefined) { i_context = new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_SERVER_CONTEXT", RTTIName: "\\INTERFACE=IF_APC_WSP_SERVER_CONTEXT"}).set(INPUT.i_context); }
    let i_message_manager = INPUT?.i_message_manager;
    if (i_message_manager?.getQualifiedName === undefined || i_message_manager.getQualifiedName() !== "IF_APC_WSP_MESSAGE_MANAGER") { i_message_manager = undefined; }
    if (i_message_manager === undefined) { i_message_manager = new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_MESSAGE_MANAGER", RTTIName: "\\INTERFACE=IF_APC_WSP_MESSAGE_MANAGER"}).set(INPUT.i_message_manager); }
    return;
  }
  async if_apc_wsp_extension$on_message(INPUT) {
    let i_message = INPUT?.i_message;
    if (i_message?.getQualifiedName === undefined || i_message.getQualifiedName() !== "IF_APC_WSP_MESSAGE") { i_message = undefined; }
    if (i_message === undefined) { i_message = new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_MESSAGE", RTTIName: "\\INTERFACE=IF_APC_WSP_MESSAGE"}).set(INPUT.i_message); }
    let i_message_manager = INPUT?.i_message_manager;
    if (i_message_manager?.getQualifiedName === undefined || i_message_manager.getQualifiedName() !== "IF_APC_WSP_MESSAGE_MANAGER") { i_message_manager = undefined; }
    if (i_message_manager === undefined) { i_message_manager = new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_MESSAGE_MANAGER", RTTIName: "\\INTERFACE=IF_APC_WSP_MESSAGE_MANAGER"}).set(INPUT.i_message_manager); }
    let i_context = INPUT?.i_context;
    if (i_context?.getQualifiedName === undefined || i_context.getQualifiedName() !== "IF_APC_WSP_SERVER_CONTEXT") { i_context = undefined; }
    if (i_context === undefined) { i_context = new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_SERVER_CONTEXT", RTTIName: "\\INTERFACE=IF_APC_WSP_SERVER_CONTEXT"}).set(INPUT.i_context); }
    return;
  }
}
abap.Classes['CL_APC_WSP_EXT_STATELESS_BASE'] = cl_apc_wsp_ext_stateless_base;

//# sourceMappingURL=cl_apc_wsp_ext_stateless_base.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_bcs.clas.mjs":
/*!********************************!*\
  !*** ./output/cl_bcs.clas.mjs ***!
  \********************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_bcs": () => (/* binding */ cl_bcs)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_bcs.clas.abap
class cl_bcs {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_BCS';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"CREATE_PERSISTENT": {"visibility": "U", "parameters": {"RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_BCS", RTTIName: "\\CLASS=CL_BCS"});}, "is_optional": " "}}},
  "ADD_RECIPIENT": {"visibility": "U", "parameters": {"I_RECIPIENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_RECIPIENT_BCS", RTTIName: "\\INTERFACE=IF_RECIPIENT_BCS"});}, "is_optional": " "}, "I_EXPRESS": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "I_COPY": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "I_BLIND_COPY": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "I_NO_FORWARD": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "SET_SENDER": {"visibility": "U", "parameters": {"I_SENDER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_SENDER_BCS", RTTIName: "\\INTERFACE=IF_SENDER_BCS"});}, "is_optional": " "}}},
  "SET_STATUS_ATTRIBUTES": {"visibility": "U", "parameters": {"I_REQUESTED_STATUS": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "SET_DOCUMENT": {"visibility": "U", "parameters": {"I_DOCUMENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_DOCUMENT_BCS", RTTIName: "\\INTERFACE=IF_DOCUMENT_BCS"});}, "is_optional": " "}}},
  "SET_MESSAGE_SUBJECT": {"visibility": "U", "parameters": {"IP_SUBJECT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SEND": {"visibility": "U", "parameters": {"RESULT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "I_WITH_ERROR_SCREEN": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "SET_SEND_IMMEDIATELY": {"visibility": "U", "parameters": {"I_SEND_IMMEDIATELY": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async set_document(INPUT) {
    let i_document = INPUT?.i_document;
    if (i_document?.getQualifiedName === undefined || i_document.getQualifiedName() !== "IF_DOCUMENT_BCS") { i_document = undefined; }
    if (i_document === undefined) { i_document = new abap.types.ABAPObject({qualifiedName: "IF_DOCUMENT_BCS", RTTIName: "\\INTERFACE=IF_DOCUMENT_BCS"}).set(INPUT.i_document); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async set_status_attributes(INPUT) {
    let i_requested_status = INPUT?.i_requested_status;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async set_send_immediately(INPUT) {
    let i_send_immediately = INPUT?.i_send_immediately;
    if (i_send_immediately?.getQualifiedName === undefined || i_send_immediately.getQualifiedName() !== "ABAP_BOOL") { i_send_immediately = undefined; }
    if (i_send_immediately === undefined) { i_send_immediately = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}).set(INPUT.i_send_immediately); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async set_message_subject(INPUT) {
    let ip_subject = INPUT?.ip_subject;
    if (ip_subject?.getQualifiedName === undefined || ip_subject.getQualifiedName() !== "STRING") { ip_subject = undefined; }
    if (ip_subject === undefined) { ip_subject = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.ip_subject); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async set_sender(INPUT) {
    let i_sender = INPUT?.i_sender;
    if (i_sender?.getQualifiedName === undefined || i_sender.getQualifiedName() !== "IF_SENDER_BCS") { i_sender = undefined; }
    if (i_sender === undefined) { i_sender = new abap.types.ABAPObject({qualifiedName: "IF_SENDER_BCS", RTTIName: "\\INTERFACE=IF_SENDER_BCS"}).set(INPUT.i_sender); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async send(INPUT) {
    let result = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    let i_with_error_screen = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_with_error_screen) {i_with_error_screen.set(INPUT.i_with_error_screen);}
    if (INPUT === undefined || INPUT.i_with_error_screen === undefined) {i_with_error_screen = abap.builtin.abap_false;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return result;
  }
  async create_persistent() {
    return cl_bcs.create_persistent();
  }
  static async create_persistent() {
    let result = new abap.types.ABAPObject({qualifiedName: "CL_BCS", RTTIName: "\\CLASS=CL_BCS"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return result;
  }
  async add_recipient(INPUT) {
    let i_recipient = INPUT?.i_recipient;
    if (i_recipient?.getQualifiedName === undefined || i_recipient.getQualifiedName() !== "IF_RECIPIENT_BCS") { i_recipient = undefined; }
    if (i_recipient === undefined) { i_recipient = new abap.types.ABAPObject({qualifiedName: "IF_RECIPIENT_BCS", RTTIName: "\\INTERFACE=IF_RECIPIENT_BCS"}).set(INPUT.i_recipient); }
    let i_express = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_express) {i_express.set(INPUT.i_express);}
    let i_copy = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_copy) {i_copy.set(INPUT.i_copy);}
    let i_blind_copy = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_blind_copy) {i_blind_copy.set(INPUT.i_blind_copy);}
    let i_no_forward = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_no_forward) {i_no_forward.set(INPUT.i_no_forward);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
}
abap.Classes['CL_BCS'] = cl_bcs;

//# sourceMappingURL=cl_bcs.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_bcs_convert.clas.mjs":
/*!****************************************!*\
  !*** ./output/cl_bcs_convert.clas.mjs ***!
  \****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_bcs_convert": () => (/* binding */ cl_bcs_convert)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_bcs_convert.clas.abap
class cl_bcs_convert {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_BCS_CONVERT';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"STRING_TO_SOLI": {"visibility": "U", "parameters": {"ET_SOLI": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"line": new abap.types.Character(255, {"qualifiedName":"SO_TEXT255","ddicName":"SO_TEXT255"})}, "SOLI", "SOLI", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SOLI_TAB");}, "is_optional": " "}, "IV_STRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "XSTRING_TO_SOLIX": {"visibility": "U", "parameters": {"ET_SOLIX": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"line": new abap.types.Hex({length: 255})}, "SOLIX", "SOLIX", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SOLIX_TAB");}, "is_optional": " "}, "IV_XSTRING": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "RAW_TO_STRING": {"visibility": "U", "parameters": {"EV_STRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "IT_SOLI": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"line": new abap.types.Character(255, {"qualifiedName":"SO_TEXT255","ddicName":"SO_TEXT255"})}, "SOLI", "SOLI", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SOLI_TAB");}, "is_optional": " "}}},
  "SOLIX_TO_XSTRING": {"visibility": "U", "parameters": {"EV_XSTRING": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "IT_SOLIX": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"line": new abap.types.Hex({length: 255})}, "SOLIX", "SOLIX", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SOLIX_TAB");}, "is_optional": " "}, "IV_SIZE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async string_to_soli(INPUT) {
    return cl_bcs_convert.string_to_soli(INPUT);
  }
  static async string_to_soli(INPUT) {
    let et_soli = abap.types.TableFactory.construct(new abap.types.Structure({"line": new abap.types.Character(255, {"qualifiedName":"SO_TEXT255","ddicName":"SO_TEXT255"})}, "SOLI", "SOLI", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SOLI_TAB");
    let iv_string = INPUT?.iv_string;
    if (iv_string?.getQualifiedName === undefined || iv_string.getQualifiedName() !== "STRING") { iv_string = undefined; }
    if (iv_string === undefined) { iv_string = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.iv_string); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return et_soli;
  }
  async solix_to_xstring(INPUT) {
    return cl_bcs_convert.solix_to_xstring(INPUT);
  }
  static async solix_to_xstring(INPUT) {
    let ev_xstring = new abap.types.XString({qualifiedName: "XSTRING"});
    let it_solix = INPUT?.it_solix;
    if (it_solix?.getQualifiedName === undefined || it_solix.getQualifiedName() !== "SOLIX_TAB") { it_solix = undefined; }
    if (it_solix === undefined) { it_solix = abap.types.TableFactory.construct(new abap.types.Structure({"line": new abap.types.Hex({length: 255})}, "SOLIX", "SOLIX", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SOLIX_TAB").set(INPUT.it_solix); }
    let iv_size = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.iv_size) {iv_size.set(INPUT.iv_size);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return ev_xstring;
  }
  async xstring_to_solix(INPUT) {
    return cl_bcs_convert.xstring_to_solix(INPUT);
  }
  static async xstring_to_solix(INPUT) {
    let et_solix = abap.types.TableFactory.construct(new abap.types.Structure({"line": new abap.types.Hex({length: 255})}, "SOLIX", "SOLIX", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SOLIX_TAB");
    let iv_xstring = INPUT?.iv_xstring;
    if (iv_xstring?.getQualifiedName === undefined || iv_xstring.getQualifiedName() !== "XSTRING") { iv_xstring = undefined; }
    if (iv_xstring === undefined) { iv_xstring = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.iv_xstring); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return et_solix;
  }
  async raw_to_string(INPUT) {
    return cl_bcs_convert.raw_to_string(INPUT);
  }
  static async raw_to_string(INPUT) {
    let ev_string = new abap.types.String({qualifiedName: "STRING"});
    let it_soli = INPUT?.it_soli;
    if (it_soli?.getQualifiedName === undefined || it_soli.getQualifiedName() !== "SOLI_TAB") { it_soli = undefined; }
    if (it_soli === undefined) { it_soli = abap.types.TableFactory.construct(new abap.types.Structure({"line": new abap.types.Character(255, {"qualifiedName":"SO_TEXT255","ddicName":"SO_TEXT255"})}, "SOLI", "SOLI", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SOLI_TAB").set(INPUT.it_soli); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return ev_string;
  }
}
abap.Classes['CL_BCS_CONVERT'] = cl_bcs_convert;

//# sourceMappingURL=cl_bcs_convert.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_cam_address_bcs.clas.mjs":
/*!********************************************!*\
  !*** ./output/cl_cam_address_bcs.clas.mjs ***!
  \********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_cam_address_bcs": () => (/* binding */ cl_cam_address_bcs)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_cam_address_bcs.clas.abap
class cl_cam_address_bcs {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_CAM_ADDRESS_BCS';
  static IMPLEMENTED_INTERFACES = ["IF_RECIPIENT_BCS","IF_SENDER_BCS"];
  static ATTRIBUTES = {};
  static METHODS = {"CREATE_INTERNET_ADDRESS": {"visibility": "U", "parameters": {"RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_CAM_ADDRESS_BCS", RTTIName: "\\CLASS=CL_CAM_ADDRESS_BCS"});}, "is_optional": " "}, "I_ADDRESS_STRING": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "I_ADDRESS_NAME": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "I_INCL_SAPUSER": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async create_internet_address(INPUT) {
    return cl_cam_address_bcs.create_internet_address(INPUT);
  }
  static async create_internet_address(INPUT) {
    let result = new abap.types.ABAPObject({qualifiedName: "CL_CAM_ADDRESS_BCS", RTTIName: "\\CLASS=CL_CAM_ADDRESS_BCS"});
    let i_address_string = INPUT?.i_address_string;
    let i_address_name = INPUT?.i_address_name || new abap.types.Character();
    let i_incl_sapuser = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_incl_sapuser) {i_incl_sapuser.set(INPUT.i_incl_sapuser);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return result;
  }
}
abap.Classes['CL_CAM_ADDRESS_BCS'] = cl_cam_address_bcs;

//# sourceMappingURL=cl_cam_address_bcs.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_demo_output.clas.mjs":
/*!****************************************!*\
  !*** ./output/cl_demo_output.clas.mjs ***!
  \****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_demo_output": () => (/* binding */ cl_demo_output)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_demo_output.clas.abap
class cl_demo_output {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_DEMO_OUTPUT';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"WRITE": {"visibility": "U", "parameters": {"DATA": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "CLEAR": {"visibility": "U", "parameters": {}},
  "DISPLAY": {"visibility": "U", "parameters": {"DATA": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async write(INPUT) {
    return cl_demo_output.write(INPUT);
  }
  static async write(INPUT) {
    let data = INPUT?.data;
    let name = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.name) {name.set(INPUT.name);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(13).set('not supported')));
  }
  async clear() {
    return cl_demo_output.clear();
  }
  static async clear() {
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(13).set('not supported')));
  }
  async display(INPUT) {
    return cl_demo_output.display(INPUT);
  }
  static async display(INPUT) {
    let data = INPUT?.data || new abap.types.Character(4);
    let name = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.name) {name.set(INPUT.name);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(13).set('not supported')));
  }
}
abap.Classes['CL_DEMO_OUTPUT'] = cl_demo_output;

//# sourceMappingURL=cl_demo_output.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_document_bcs.clas.mjs":
/*!*****************************************!*\
  !*** ./output/cl_document_bcs.clas.mjs ***!
  \*****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_document_bcs": () => (/* binding */ cl_document_bcs)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_document_bcs.clas.abap
class cl_document_bcs {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_DOCUMENT_BCS';
  static IMPLEMENTED_INTERFACES = ["IF_DOCUMENT_BCS"];
  static ATTRIBUTES = {};
  static METHODS = {"CREATE_DOCUMENT": {"visibility": "U", "parameters": {"RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_DOCUMENT_BCS", RTTIName: "\\CLASS=CL_DOCUMENT_BCS"});}, "is_optional": " "}, "I_TYPE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "I_SUBJECT": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "I_TEXT": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "I_LENGTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "ADD_ATTACHMENT": {"visibility": "U", "parameters": {"I_ATTACHMENT_TYPE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "I_ATTACHMENT_SUBJECT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "I_ATTACHMENT_SIZE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "I_ATT_CONTENT_TEXT": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "I_ATT_CONTENT_HEX": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "I_ATTACHMENT_HEADER": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"line": new abap.types.Character(255, {"qualifiedName":"SO_TEXT255","ddicName":"SO_TEXT255"})}, "SOLI", "SOLI", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SOLI_TAB");}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async create_document(INPUT) {
    return cl_document_bcs.create_document(INPUT);
  }
  static async create_document(INPUT) {
    let result = new abap.types.ABAPObject({qualifiedName: "CL_DOCUMENT_BCS", RTTIName: "\\CLASS=CL_DOCUMENT_BCS"});
    let i_type = INPUT?.i_type;
    if (i_type?.getQualifiedName === undefined || i_type.getQualifiedName() !== "STRING") { i_type = undefined; }
    if (i_type === undefined) { i_type = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.i_type); }
    let i_subject = INPUT?.i_subject;
    let i_text = INPUT?.i_text || new abap.types.Character(4);
    let i_length = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.i_length) {i_length.set(INPUT.i_length);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return result;
  }
  async add_attachment(INPUT) {
    let i_attachment_type = INPUT?.i_attachment_type;
    if (i_attachment_type?.getQualifiedName === undefined || i_attachment_type.getQualifiedName() !== "STRING") { i_attachment_type = undefined; }
    if (i_attachment_type === undefined) { i_attachment_type = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.i_attachment_type); }
    let i_attachment_subject = INPUT?.i_attachment_subject;
    if (i_attachment_subject?.getQualifiedName === undefined || i_attachment_subject.getQualifiedName() !== "STRING") { i_attachment_subject = undefined; }
    if (i_attachment_subject === undefined) { i_attachment_subject = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.i_attachment_subject); }
    let i_attachment_size = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.i_attachment_size) {i_attachment_size.set(INPUT.i_attachment_size);}
    let i_att_content_text = INPUT?.i_att_content_text || new abap.types.Character(4);
    let i_att_content_hex = INPUT?.i_att_content_hex || new abap.types.Character(4);
    let i_attachment_header = abap.types.TableFactory.construct(new abap.types.Structure({"line": new abap.types.Character(255, {"qualifiedName":"SO_TEXT255","ddicName":"SO_TEXT255"})}, "SOLI", "SOLI", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SOLI_TAB");
    if (INPUT && INPUT.i_attachment_header) {i_attachment_header.set(INPUT.i_attachment_header);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
}
abap.Classes['CL_DOCUMENT_BCS'] = cl_document_bcs;

//# sourceMappingURL=cl_document_bcs.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_express_icf_shim.clas.mjs":
/*!*********************************************!*\
  !*** ./output/cl_express_icf_shim.clas.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_express_icf_shim": () => (/* binding */ cl_express_icf_shim)
/* harmony export */ });
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
await __webpack_require__.e(/*! import() */ "output_cl_express_icf_shim_clas_locals_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_express_icf_shim.clas.locals.mjs */ "./output/cl_express_icf_shim.clas.locals.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_express_icf_shim.clas.abap
class cl_express_icf_shim {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_EXPRESS_ICF_SHIM';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"MI_SERVER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_SERVER", RTTIName: "\\INTERFACE=IF_HTTP_SERVER"});}, "visibility": "I", "is_constant": " ", "is_class": "X"}};
  static METHODS = {"RESPONSE": {"visibility": "I", "parameters": {"RES": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "REQUEST": {"visibility": "I", "parameters": {"REQ": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "BASE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "RUN": {"visibility": "U", "parameters": {"RES": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "REQ": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "BASE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.mi_server = cl_express_icf_shim.mi_server;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async run(INPUT) {
    return cl_express_icf_shim.run(INPUT);
  }
  static async run(INPUT) {
    let res = INPUT?.res;
    let req = INPUT?.req;
    let base = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.base) {base.set(INPUT.base);}
    let lv_classname = new abap.types.String({qualifiedName: "STRING"});
    let li_handler = new abap.types.ABAPObject({qualifiedName: "IF_HTTP_EXTENSION", RTTIName: "\\INTERFACE=IF_HTTP_EXTENSION"});
    lv_classname.set(INPUT.class);
    abap.statements.translate(lv_classname, "UPPER");
    let unique181 = abap.Classes["CLAS-CL_EXPRESS_ICF_SHIM-"+lv_classname.get().trimEnd()];
    if (unique181 === undefined) { unique181 = abap.Classes[lv_classname.get().trimEnd()]; }
    if (unique181 === undefined) { throw new abap.Classes['CX_SY_CREATE_OBJECT_ERROR']; }
    li_handler.set(await (new unique181()).constructor_());
    if (abap.compare.initial(cl_express_icf_shim.mi_server)) {
      cl_express_icf_shim.mi_server.set(await (new abap.Classes['CLAS-CL_EXPRESS_ICF_SHIM-LCL_SERVER']()).constructor_());
    }
    cl_express_icf_shim.mi_server.get().if_http_server$request.set(await (new abap.Classes['CL_HTTP_ENTITY']()).constructor_());
    await this.request({req: req, base: base});
    cl_express_icf_shim.mi_server.get().if_http_server$response.set(await (new abap.Classes['CL_HTTP_ENTITY']()).constructor_());
    await li_handler.get().if_http_extension$handle_request({server: cl_express_icf_shim.mi_server});
    await this.response({res: res});
  }
  async request(INPUT) {
    return cl_express_icf_shim.request(INPUT);
  }
  static async request(INPUT) {
    let req = INPUT?.req;
    let base = INPUT?.base;
    if (base?.getQualifiedName === undefined || base.getQualifiedName() !== "STRING") { base = undefined; }
    if (base === undefined) { base = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.base); }
    let lv_xstr = new abap.types.XString({qualifiedName: "XSTRING"});
    let lv_str = new abap.types.String({qualifiedName: "STRING"});
    let lv_name = new abap.types.String({qualifiedName: "STRING"});
    let lv_value = new abap.types.String({qualifiedName: "STRING"});
    let lt_fields = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");
    lv_xstr.set(INPUT.req.body.toString("hex").toUpperCase());
    await cl_express_icf_shim.mi_server.get().if_http_server$request.get().if_http_entity$set_data({data: lv_xstr});
    lv_str.set(INPUT.req.method);
    await cl_express_icf_shim.mi_server.get().if_http_server$request.get().if_http_request$set_method({method: lv_str});
    for (const h in INPUT.req.headers) {
        lv_name.set(h);
        lv_value.set(INPUT.req.headers[h]);
      await cl_express_icf_shim.mi_server.get().if_http_server$request.get().if_http_entity$set_header_field({name: lv_name, value: lv_value});
    }
    lv_value.set(INPUT.req.url);
    await cl_express_icf_shim.mi_server.get().if_http_server$request.get().if_http_entity$set_header_field({name: new abap.types.Character(12).set('~request_uri'), value: lv_value});
    abap.statements.split({source: lv_value, at: new abap.types.Character(1).set('?'), targets: [lv_value,lv_value]});
    await cl_express_icf_shim.mi_server.get().if_http_server$request.get().if_http_entity$set_header_field({name: new abap.types.Character(13).set('~query_string'), value: lv_value});
    lt_fields.set((await abap.Classes['CL_HTTP_UTILITY'].if_http_utility$string_to_fields({string: lv_value})));
    await cl_express_icf_shim.mi_server.get().if_http_server$request.get().if_http_entity$set_form_fields({fields: lt_fields});
    lv_value.set(INPUT.req.path);
    await cl_express_icf_shim.mi_server.get().if_http_server$request.get().if_http_entity$set_header_field({name: new abap.types.Character(5).set('~path'), value: lv_value});
    await cl_express_icf_shim.mi_server.get().if_http_server$request.get().if_http_entity$set_header_field({name: new abap.types.Character(25).set('~path_translated_expanded'), value: lv_value});
    abap.statements.replace({target: lv_value, all: false, with: new abap.types.Character(1).set(''), of: base});
    await cl_express_icf_shim.mi_server.get().if_http_server$request.get().if_http_entity$set_header_field({name: new abap.types.Character(10).set('~path_info'), value: lv_value});
    await cl_express_icf_shim.mi_server.get().if_http_server$request.get().if_http_entity$set_header_field({name: new abap.types.Character(19).set('~path_info_expanded'), value: lv_value});
  }
  async response(INPUT) {
    return cl_express_icf_shim.response(INPUT);
  }
  static async response(INPUT) {
    let res = INPUT?.res;
    let lv_code = new abap.types.Integer({qualifiedName: "I"});
    let lv_xstr = new abap.types.XString({qualifiedName: "XSTRING"});
    let lv_content_type = new abap.types.String({qualifiedName: "STRING"});
    let lt_header_fields = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");
    let ls_field = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {});
    await cl_express_icf_shim.mi_server.get().if_http_server$response.get().if_http_response$get_status({code: lv_code});
    if (abap.compare.initial(lv_code)) {
      lv_code.set(abap.IntegerFactory.get(200));
    }
    lv_content_type.set((await cl_express_icf_shim.mi_server.get().if_http_server$response.get().if_http_entity$get_content_type()));
    if (abap.compare.initial(lv_content_type)) {
      await cl_express_icf_shim.mi_server.get().if_http_server$response.get().if_http_entity$set_content_type({content_type: new abap.types.Character(9).set('text/html')});
    }
    await cl_express_icf_shim.mi_server.get().if_http_server$response.get().if_http_entity$get_header_fields({fields: lt_header_fields});
    for await (const unique182 of abap.statements.loop(lt_header_fields)) {
      ls_field.set(unique182);
      INPUT.res.append(ls_field.get().name.get(), ls_field.get().value.get());
    }
    lv_xstr.set((await cl_express_icf_shim.mi_server.get().if_http_server$response.get().if_http_entity$get_data()));
    INPUT.res.status(lv_code.get()).send(Buffer.from(lv_xstr.get(), "hex"));
  }
}
abap.Classes['CL_EXPRESS_ICF_SHIM'] = cl_express_icf_shim;
cl_express_icf_shim.mi_server = new abap.types.ABAPObject({qualifiedName: "IF_HTTP_SERVER", RTTIName: "\\INTERFACE=IF_HTTP_SERVER"});

//# sourceMappingURL=cl_express_icf_shim.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_function_test_environment.clas.mjs":
/*!******************************************************!*\
  !*** ./output/cl_function_test_environment.clas.mjs ***!
  \******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_function_test_environment": () => (/* binding */ cl_function_test_environment)
/* harmony export */ });
await __webpack_require__.e(/*! import() */ "output_cl_function_test_environment_clas_locals_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_function_test_environment.clas.locals.mjs */ "./output/cl_function_test_environment.clas.locals.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_function_test_environment.clas.abap
class cl_function_test_environment {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_FUNCTION_TEST_ENVIRONMENT';
  static IMPLEMENTED_INTERFACES = ["IF_FUNCTION_TEST_ENVIRONMENT"];
  static ATTRIBUTES = {"GT_BACKUP": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"SXCO_FM_NAME","ddicName":"SXCO_FM_NAME"}), "backup": new abap.types.Integer({qualifiedName: "CL_FUNCTION_TEST_ENVIRONMENT=>TY_BACKUP-BACKUP"}), "double_": new abap.types.ABAPObject({qualifiedName: "IF_FUNCTION_TESTDOUBLE", RTTIName: "\\INTERFACE=IF_FUNCTION_TESTDOUBLE"})}, "cl_function_test_environment=>ty_backup", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"SORTED","isUnique":true,"keyFields":["NAME"]},"secondary":[]}, "");}, "visibility": "I", "is_constant": " ", "is_class": "X"}};
  static METHODS = {"CREATE": {"visibility": "U", "parameters": {"FUNCTION_TEST_ENVIRONMENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_FUNCTION_TEST_ENVIRONMENT", RTTIName: "\\INTERFACE=IF_FUNCTION_TEST_ENVIRONMENT"});}, "is_optional": " "}, "FUNCTION_MODULES": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Character(30, {"qualifiedName":"SXCO_FM_NAME","ddicName":"SXCO_FM_NAME"}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["TABLE_LINE"]},"secondary":[]}, "if_function_test_environment=>tt_function_dependencies");}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.gt_backup = cl_function_test_environment.gt_backup;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async create(INPUT) {
    return cl_function_test_environment.create(INPUT);
  }
  static async create(INPUT) {
    let function_test_environment = new abap.types.ABAPObject({qualifiedName: "IF_FUNCTION_TEST_ENVIRONMENT", RTTIName: "\\INTERFACE=IF_FUNCTION_TEST_ENVIRONMENT"});
    let function_modules = INPUT?.function_modules;
    if (function_modules?.getQualifiedName === undefined || function_modules.getQualifiedName() !== "IF_FUNCTION_TEST_ENVIRONMENT=>TT_FUNCTION_DEPENDENCIES") { function_modules = undefined; }
    if (function_modules === undefined) { function_modules = abap.types.TableFactory.construct(new abap.types.Character(30, {"qualifiedName":"SXCO_FM_NAME","ddicName":"SXCO_FM_NAME"}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["TABLE_LINE"]},"secondary":[]}, "if_function_test_environment=>tt_function_dependencies").set(INPUT.function_modules); }
    let lv_module = new abap.types.Character(30, {"qualifiedName":"SXCO_FM_NAME","ddicName":"SXCO_FM_NAME"});
    let ls_row = new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"SXCO_FM_NAME","ddicName":"SXCO_FM_NAME"}), "backup": new abap.types.Integer({qualifiedName: "CL_FUNCTION_TEST_ENVIRONMENT=>TY_BACKUP-BACKUP"}), "double_": new abap.types.ABAPObject({qualifiedName: "IF_FUNCTION_TESTDOUBLE", RTTIName: "\\INTERFACE=IF_FUNCTION_TESTDOUBLE"})}, "cl_function_test_environment=>ty_backup", undefined, {}, {});
    abap.statements.assert(abap.compare.gt(abap.builtin.lines({val: function_modules}), abap.IntegerFactory.get(0)));
    for await (const unique169 of abap.statements.loop(function_modules)) {
      lv_module.set(unique169);
      ls_row.get().name.set(lv_module);
      ls_row.get().double_.set(await (new abap.Classes['CLAS-CL_FUNCTION_TEST_ENVIRONMENT-LCL_DOUBLE']()).constructor_({iv_name: lv_module}));
      ls_row.get().backup = abap.FunctionModules[lv_module.get().trimEnd()];
      abap.statements.insertInternal({data: ls_row, table: cl_function_test_environment.gt_backup});
    }
    function_test_environment.set(await (new abap.Classes['CL_FUNCTION_TEST_ENVIRONMENT']()).constructor_());
    return function_test_environment;
  }
  async if_function_test_environment$get_double(INPUT) {
    let result = new abap.types.ABAPObject({qualifiedName: "IF_FUNCTION_TESTDOUBLE", RTTIName: "\\INTERFACE=IF_FUNCTION_TESTDOUBLE"});
    let function_name = INPUT?.function_name;
    if (function_name?.getQualifiedName === undefined || function_name.getQualifiedName() !== "SXCO_FM_NAME") { function_name = undefined; }
    if (function_name === undefined) { function_name = new abap.types.Character(30, {"qualifiedName":"SXCO_FM_NAME","ddicName":"SXCO_FM_NAME"}).set(INPUT.function_name); }
    let fs_ls_row_ = new abap.types.FieldSymbol(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"SXCO_FM_NAME","ddicName":"SXCO_FM_NAME"}), "backup": new abap.types.Integer({qualifiedName: "CL_FUNCTION_TEST_ENVIRONMENT=>TY_BACKUP-BACKUP"}), "double_": new abap.types.ABAPObject({qualifiedName: "IF_FUNCTION_TESTDOUBLE", RTTIName: "\\INTERFACE=IF_FUNCTION_TESTDOUBLE"})}, "cl_function_test_environment=>ty_backup", undefined, {}, {}));
    abap.statements.readTable(cl_function_test_environment.gt_backup,{assigning: fs_ls_row_,
      withKey: (i) => {return abap.compare.eq(i.name, function_name);},
      withKeyValue: [{key: (i) => {return i.name}, value: function_name}],
      usesTableLine: false,
      withKeySimple: {"name": function_name}});
    abap.statements.assert(abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0)));
    result.set(fs_ls_row_.get().double_);
    return result;
  }
  async if_function_test_environment$clear_doubles() {
    let fs_ls_row_ = new abap.types.FieldSymbol(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"SXCO_FM_NAME","ddicName":"SXCO_FM_NAME"}), "backup": new abap.types.Integer({qualifiedName: "CL_FUNCTION_TEST_ENVIRONMENT=>TY_BACKUP-BACKUP"}), "double_": new abap.types.ABAPObject({qualifiedName: "IF_FUNCTION_TESTDOUBLE", RTTIName: "\\INTERFACE=IF_FUNCTION_TESTDOUBLE"})}, "cl_function_test_environment=>ty_backup", undefined, {}, {}));
    for await (const unique170 of abap.statements.loop(cl_function_test_environment.gt_backup)) {
      fs_ls_row_.assign(unique170);
      abap.FunctionModules[fs_ls_row_.get().name.get().trimEnd()] = fs_ls_row_.get().backup;
    }
    abap.statements.clear(cl_function_test_environment.gt_backup);
  }
}
abap.Classes['CL_FUNCTION_TEST_ENVIRONMENT'] = cl_function_test_environment;
cl_function_test_environment.gt_backup = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"SXCO_FM_NAME","ddicName":"SXCO_FM_NAME"}), "backup": new abap.types.Integer({qualifiedName: "CL_FUNCTION_TEST_ENVIRONMENT=>TY_BACKUP-BACKUP"}), "double_": new abap.types.ABAPObject({qualifiedName: "IF_FUNCTION_TESTDOUBLE", RTTIName: "\\INTERFACE=IF_FUNCTION_TESTDOUBLE"})}, "cl_function_test_environment=>ty_backup", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"SORTED","isUnique":true,"keyFields":["NAME"]},"secondary":[]}, "");
cl_function_test_environment.ty_backup = new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"SXCO_FM_NAME","ddicName":"SXCO_FM_NAME"}), "backup": new abap.types.Integer({qualifiedName: "CL_FUNCTION_TEST_ENVIRONMENT=>TY_BACKUP-BACKUP"}), "double_": new abap.types.ABAPObject({qualifiedName: "IF_FUNCTION_TESTDOUBLE", RTTIName: "\\INTERFACE=IF_FUNCTION_TESTDOUBLE"})}, "cl_function_test_environment=>ty_backup", undefined, {}, {});

//# sourceMappingURL=cl_function_test_environment.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_gdt_conversion.clas.mjs":
/*!*******************************************!*\
  !*** ./output/cl_gdt_conversion.clas.mjs ***!
  \*******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_gdt_conversion": () => (/* binding */ cl_gdt_conversion)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_gdt_conversion.clas.abap
class cl_gdt_conversion {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_GDT_CONVERSION';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"LANGUAGE_CODE_OUTBOUND": {"visibility": "U", "parameters": {"IM_VALUE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"SPRAS","ddicName":"SPRAS"});}, "is_optional": " "}, "EX_VALUE": {"type": () => {return new abap.types.Character(2, {"qualifiedName":"LAISO","ddicName":"LAISO"});}, "is_optional": " "}}},
  "LANGUAGE_CODE_INBOUND": {"visibility": "U", "parameters": {"IM_VALUE": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "EX_VALUE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"SPRAS","ddicName":"SPRAS"});}, "is_optional": " "}}},
  "AMOUNT_OUTBOUND": {"visibility": "U", "parameters": {"IM_VALUE": {"type": () => {return new abap.types.Packed({length: 1, decimals: 0});}, "is_optional": " "}, "IM_CURRENCY_CODE": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "EX_VALUE": {"type": () => {return new abap.types.Packed({length: 1, decimals: 0});}, "is_optional": " "}}},
  "COUNTRY_CODE_OUTBOUND": {"visibility": "U", "parameters": {"IM_VALUE": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"LAND1","ddicName":"LAND1"});}, "is_optional": " "}, "EX_VALUE": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "DATE_TIME_INBOUND": {"visibility": "U", "parameters": {"IM_VALUE": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "EX_VALUE_SHORT": {"type": () => {return new abap.types.Packed({length: 15, decimals: 0, qualifiedName: "TIMESTAMP"});}, "is_optional": " "}}},
  "UNIT_CODE_INBOUND": {"visibility": "U", "parameters": {"IM_VALUE": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "EX_VALUE": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"MSEHI","ddicName":"MSEHI"});}, "is_optional": " "}}},
  "UNIT_CODE_OUTBOUND": {"visibility": "U", "parameters": {"IM_VALUE": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"MSEHI","ddicName":"MSEHI"});}, "is_optional": " "}, "EX_VALUE": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async amount_outbound(INPUT) {
    return cl_gdt_conversion.amount_outbound(INPUT);
  }
  static async amount_outbound(INPUT) {
    let im_value = INPUT?.im_value;
    if (im_value === undefined) { im_value = new abap.types.Packed({length: 1, decimals: 0}).set(INPUT.im_value); }
    let im_currency_code = INPUT?.im_currency_code;
    let ex_value = INPUT?.ex_value || new abap.types.Packed({length: 1, decimals: 0});
    let unique23 = im_currency_code;
    if (abap.compare.eq(unique23, new abap.types.Character(3).set('DKK')) || abap.compare.eq(unique23, new abap.types.Character(3).set('EUR')) || abap.compare.eq(unique23, new abap.types.Character(3).set('USD'))) {
      ex_value.set(im_value);
    } else if (abap.compare.eq(unique23, new abap.types.Character(3).set('VND'))) {
      ex_value.set(abap.operators.multiply(im_value,abap.IntegerFactory.get(100)));
    } else {
      abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    }
  }
  async language_code_inbound(INPUT) {
    return cl_gdt_conversion.language_code_inbound(INPUT);
  }
  static async language_code_inbound(INPUT) {
    let im_value = INPUT?.im_value;
    let ex_value = INPUT?.ex_value || new abap.types.Character(1, {"qualifiedName":"SPRAS","ddicName":"SPRAS"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async unit_code_outbound(INPUT) {
    return cl_gdt_conversion.unit_code_outbound(INPUT);
  }
  static async unit_code_outbound(INPUT) {
    let im_value = INPUT?.im_value;
    if (im_value?.getQualifiedName === undefined || im_value.getQualifiedName() !== "MSEHI") { im_value = undefined; }
    if (im_value === undefined) { im_value = new abap.types.Character(3, {"qualifiedName":"MSEHI","ddicName":"MSEHI"}).set(INPUT.im_value); }
    let ex_value = INPUT?.ex_value || new abap.types.Character();
    let unique24 = im_value;
    if (abap.compare.eq(unique24, new abap.types.Character(1).set(''))) {
      const unique25 = await (new abap.Classes['CX_GDT_CONVERSION']()).constructor_();
      unique25.EXTRA_CX = {"INTERNAL_FILENAME": "cl_gdt_conversion.clas.abap","INTERNAL_LINE": 81};
      throw unique25;
    } else if (abap.compare.eq(unique24, new abap.types.Character(2).set('ST'))) {
      ex_value.set(new abap.types.Character(3).set('PCE'));
    } else if (abap.compare.eq(unique24, new abap.types.Character(2).set('KG'))) {
      ex_value.set(new abap.types.Character(3).set('KGM'));
    } else if (abap.compare.eq(unique24, new abap.types.Character(3).set('CDM'))) {
      ex_value.set(new abap.types.Character(3).set('DMQ'));
    } else {
      abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    }
  }
  async country_code_outbound(INPUT) {
    return cl_gdt_conversion.country_code_outbound(INPUT);
  }
  static async country_code_outbound(INPUT) {
    let im_value = INPUT?.im_value;
    if (im_value?.getQualifiedName === undefined || im_value.getQualifiedName() !== "LAND1") { im_value = undefined; }
    if (im_value === undefined) { im_value = new abap.types.Character(3, {"qualifiedName":"LAND1","ddicName":"LAND1"}).set(INPUT.im_value); }
    let ex_value = INPUT?.ex_value || new abap.types.Character();
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async date_time_inbound(INPUT) {
    return cl_gdt_conversion.date_time_inbound(INPUT);
  }
  static async date_time_inbound(INPUT) {
    let im_value = INPUT?.im_value;
    let ex_value_short = INPUT?.ex_value_short || new abap.types.Packed({length: 15, decimals: 0, qualifiedName: "TIMESTAMP"});
    let lv_str = new abap.types.String({qualifiedName: "STRING"});
    if (abap.compare.np(im_value, new abap.types.Character(2).set('*Z'))) {
      abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(30).set('todo, only handles UTC for now')));
    }
    lv_str.set(im_value);
    abap.statements.replace({target: lv_str, all: true, with: new abap.types.Character(1).set(''), of: new abap.types.Character(1).set('-')});
    abap.statements.replace({target: lv_str, all: true, with: new abap.types.Character(1).set(''), of: new abap.types.Character(1).set(':')});
    abap.statements.replace({target: lv_str, all: true, with: new abap.types.Character(1).set(''), of: new abap.types.Character(1).set('T')});
    abap.statements.replace({target: lv_str, all: true, with: new abap.types.Character(1).set(''), of: new abap.types.Character(1).set('Z')});
    ex_value_short.set(lv_str);
  }
  async unit_code_inbound(INPUT) {
    return cl_gdt_conversion.unit_code_inbound(INPUT);
  }
  static async unit_code_inbound(INPUT) {
    let im_value = INPUT?.im_value;
    let ex_value = INPUT?.ex_value || new abap.types.Character(3, {"qualifiedName":"MSEHI","ddicName":"MSEHI"});
    let unique26 = im_value;
    if (abap.compare.eq(unique26, new abap.types.Character(3).set('MTR'))) {
      ex_value.set(new abap.types.Character(1).set('M'));
    } else if (abap.compare.eq(unique26, new abap.types.Character(3).set('PCE'))) {
      ex_value.set(new abap.types.Character(2).set('PC'));
    } else if (abap.compare.eq(unique26, new abap.types.Character(3).set('KGM'))) {
      ex_value.set(new abap.types.Character(2).set('KG'));
    } else if (abap.compare.eq(unique26, new abap.types.Character(3).set('LTR'))) {
      ex_value.set(new abap.types.Character(1).set('L'));
    } else {
      abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    }
  }
  async language_code_outbound(INPUT) {
    return cl_gdt_conversion.language_code_outbound(INPUT);
  }
  static async language_code_outbound(INPUT) {
    let im_value = INPUT?.im_value;
    if (im_value?.getQualifiedName === undefined || im_value.getQualifiedName() !== "SPRAS") { im_value = undefined; }
    if (im_value === undefined) { im_value = new abap.types.Character(1, {"qualifiedName":"SPRAS","ddicName":"SPRAS"}).set(INPUT.im_value); }
    let ex_value = INPUT?.ex_value || new abap.types.Character(2, {"qualifiedName":"LAISO","ddicName":"LAISO"});
    try {
      ex_value.set(await abap.Classes['CL_I18N_LANGUAGES'].sap1_to_sap2({im_lang_sap1: im_value}));
      abap.builtin.sy.get().subrc.set(0);
    } catch (e) {
      if (e.classic) {
          switch (e.classic.toUpperCase()) {
          case "NO_ASSIGNMENT": abap.builtin.sy.get().subrc.set(1); break;
          default: abap.builtin.sy.get().subrc.set(2); break;
            }
        } else {
            throw e;
        }
      }
      abap.statements.translate(ex_value, "LOWER");
      if (abap.compare.ne(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
        const unique27 = await (new abap.Classes['CX_GDT_CONVERSION']()).constructor_();
        unique27.EXTRA_CX = {"INTERNAL_FILENAME": "cl_gdt_conversion.clas.abap","INTERNAL_LINE": 143};
        throw unique27;
      }
    }
  }
  abap.Classes['CL_GDT_CONVERSION'] = cl_gdt_conversion;

//# sourceMappingURL=cl_gdt_conversion.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_gui_cfw.clas.mjs":
/*!************************************!*\
  !*** ./output/cl_gui_cfw.clas.mjs ***!
  \************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_gui_cfw": () => (/* binding */ cl_gui_cfw)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_gui_cfw.clas.abap
class cl_gui_cfw {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_GUI_CFW';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"COMPUTE_PIXEL_FROM_METRIC": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "X_OR_Y": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "IN_": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "FLUSH": {"visibility": "U", "parameters": {}},
  "SET_NEW_OK_CODE": {"visibility": "U", "parameters": {"NEW_CODE": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async compute_pixel_from_metric(INPUT) {
    return cl_gui_cfw.compute_pixel_from_metric(INPUT);
  }
  static async compute_pixel_from_metric(INPUT) {
    let val = new abap.types.Integer({qualifiedName: "I"});
    let x_or_y = INPUT?.x_or_y;
    let in_ = INPUT?.in_;
    if (in_?.getQualifiedName === undefined || in_.getQualifiedName() !== "I") { in_ = undefined; }
    if (in_ === undefined) { in_ = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.in_); }
    val.set(abap.IntegerFactory.get(1));
    return val;
  }
  async flush() {
    return cl_gui_cfw.flush();
  }
  static async flush() {
    return;
  }
  async set_new_ok_code(INPUT) {
    return cl_gui_cfw.set_new_ok_code(INPUT);
  }
  static async set_new_ok_code(INPUT) {
    let new_code = INPUT?.new_code;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(15).set('not implemented')));
  }
}
abap.Classes['CL_GUI_CFW'] = cl_gui_cfw;

//# sourceMappingURL=cl_gui_cfw.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_gui_container.clas.mjs":
/*!******************************************!*\
  !*** ./output/cl_gui_container.clas.mjs ***!
  \******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_gui_container": () => (/* binding */ cl_gui_container)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_gui_container.clas.abap
class cl_gui_container {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_GUI_CONTAINER';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"SCREEN0": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_GUI_CONTAINER", RTTIName: "\\CLASS=CL_GUI_CONTAINER"});}, "visibility": "U", "is_constant": " ", "is_class": "X"},
  "DEFAULT_SCREEN": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_GUI_CONTAINER", RTTIName: "\\CLASS=CL_GUI_CONTAINER"});}, "visibility": "U", "is_constant": " ", "is_class": "X"},
  "VISIBLE_TRUE": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "VISIBLE_FALSE": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"FREE": {"visibility": "U", "parameters": {}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.screen0 = cl_gui_container.screen0;
    this.default_screen = cl_gui_container.default_screen;
    this.visible_true = cl_gui_container.visible_true;
    this.visible_false = cl_gui_container.visible_false;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async free() {
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(13).set('not supported')));
  }
}
abap.Classes['CL_GUI_CONTAINER'] = cl_gui_container;
cl_gui_container.screen0 = new abap.types.ABAPObject({qualifiedName: "CL_GUI_CONTAINER", RTTIName: "\\CLASS=CL_GUI_CONTAINER"});
cl_gui_container.default_screen = new abap.types.ABAPObject({qualifiedName: "CL_GUI_CONTAINER", RTTIName: "\\CLASS=CL_GUI_CONTAINER"});
cl_gui_container.visible_true = new abap.types.Character(1, {});
cl_gui_container.visible_true.set('1');
cl_gui_container.visible_false = new abap.types.Character(1, {});
cl_gui_container.visible_false.set('0');

//# sourceMappingURL=cl_gui_container.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_gui_frontend_services.clas.mjs":
/*!**************************************************!*\
  !*** ./output/cl_gui_frontend_services.clas.mjs ***!
  \**************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_gui_frontend_services": () => (/* binding */ cl_gui_frontend_services)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_gui_frontend_services.clas.abap
class cl_gui_frontend_services {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_GUI_FRONTEND_SERVICES';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"FILETYPE_ALL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "FILETYPE_XML": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "FILETYPE_TEXT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "ACTION_CANCEL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "ACTION_OK": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "PLATFORM_NT351": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "PLATFORM_NT40": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "PLATFORM_NT50": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "PLATFORM_WINDOWS95": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "PLATFORM_WINDOWS98": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "PLATFORM_WINDOWSXP": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"GUI_DOWNLOAD": {"visibility": "U", "parameters": {"BIN_FILESIZE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "FILENAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "FILETYPE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "WRITE_LF": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "WRITE_FIELD_SEPARATOR": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"CHAR1","ddicName":"CHAR1"});}, "is_optional": " "}, "CONFIRM_OVERWRITE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "DATA_TAB": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "FILE_EXIST": {"visibility": "U", "parameters": {"RESULT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "FILE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "DIRECTORY_LIST_FILES": {"visibility": "U", "parameters": {"DIRECTORY": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "FILES_ONLY": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "FILE_TABLE": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "COUNT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GUI_UPLOAD": {"visibility": "U", "parameters": {"FILENAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "FILETYPE": {"type": () => {return new abap.types.Character(10, {"qualifiedName":"CHAR10","ddicName":"CHAR10"});}, "is_optional": " "}, "CODEPAGE": {"type": () => {return new abap.types.Character(20, {"qualifiedName":"abap_encoding"});}, "is_optional": " "}, "READ_BY_LINE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "FILELENGTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "DATA_TAB": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "FILE_OPEN_DIALOG": {"visibility": "U", "parameters": {"WINDOW_TITLE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "DEFAULT_FILENAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "DEFAULT_EXTENSION": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "MULTISELECTION": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "FILE_FILTER": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "INITIAL_DIRECTORY": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "FILE_TABLE": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"filename": new abap.types.Character(1024, {})}, "FILE_TABLE", "FILE_TABLE", {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "FILETABLE");}, "is_optional": " "}, "RC": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "USER_ACTION": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_PLATFORM": {"visibility": "U", "parameters": {"PLATFORM": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "FILE_SAVE_DIALOG": {"visibility": "U", "parameters": {"WINDOW_TITLE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "DEFAULT_EXTENSION": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "DEFAULT_FILE_NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "FILE_FILTER": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "INITIAL_DIRECTORY": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PROMPT_ON_OVERWRITE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "FILENAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PATH": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "FULLPATH": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "USER_ACTION": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "DIRECTORY_BROWSE": {"visibility": "U", "parameters": {"WINDOW_TITLE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "INITIAL_FOLDER": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "SELECTED_FOLDER": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "EXECUTE": {"visibility": "U", "parameters": {"DOCUMENT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "APPLICATION": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PARAMETER": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "DEFAULT_DIRECTORY": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "MAXIMIZED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "MINIMIZED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "SYNCHRONOUS": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "OPERATION": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_FILE_SEPARATOR": {"visibility": "U", "parameters": {"FILE_SEPARATOR": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "DIRECTORY_EXIST": {"visibility": "U", "parameters": {"RESULT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "DIRECTORY": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "DIRECTORY_CREATE": {"visibility": "U", "parameters": {"DIRECTORY": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "RC": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "CLIPBOARD_EXPORT": {"visibility": "U", "parameters": {"NO_AUTH_CHECK": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "DATA": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "RC": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_SYSTEM_DIRECTORY": {"visibility": "U", "parameters": {"SYSTEM_DIRECTORY": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_GUI_VERSION": {"visibility": "U", "parameters": {"VERSION_TABLE": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"filename": new abap.types.Character(1024, {})}, "FILE_TABLE", "FILE_TABLE", {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "FILETABLE");}, "is_optional": " "}, "RC": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "CLIPBOARD_IMPORT": {"visibility": "U", "parameters": {"DATA": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Character(4), {"withHeader":false,"keyType":"DEFAULT"});}, "is_optional": " "}, "LENGTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "FILE_DELETE": {"visibility": "U", "parameters": {"FILENAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "RC": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_SAPGUI_WORKDIR": {"visibility": "U", "parameters": {"SAPWORKDIR": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.filetype_all = cl_gui_frontend_services.filetype_all;
    this.filetype_xml = cl_gui_frontend_services.filetype_xml;
    this.filetype_text = cl_gui_frontend_services.filetype_text;
    this.action_cancel = cl_gui_frontend_services.action_cancel;
    this.action_ok = cl_gui_frontend_services.action_ok;
    this.platform_nt351 = cl_gui_frontend_services.platform_nt351;
    this.platform_nt40 = cl_gui_frontend_services.platform_nt40;
    this.platform_nt50 = cl_gui_frontend_services.platform_nt50;
    this.platform_windows95 = cl_gui_frontend_services.platform_windows95;
    this.platform_windows98 = cl_gui_frontend_services.platform_windows98;
    this.platform_windowsxp = cl_gui_frontend_services.platform_windowsxp;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async directory_exist(INPUT) {
    return cl_gui_frontend_services.directory_exist(INPUT);
  }
  static async directory_exist(INPUT) {
    let result = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    let directory = INPUT?.directory;
    if (directory?.getQualifiedName === undefined || directory.getQualifiedName() !== "STRING") { directory = undefined; }
    if (directory === undefined) { directory = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.directory); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(29).set('directory_exist not supported')));
    return result;
  }
  async get_sapgui_workdir(INPUT) {
    return cl_gui_frontend_services.get_sapgui_workdir(INPUT);
  }
  static async get_sapgui_workdir(INPUT) {
    let sapworkdir = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.sapworkdir) {sapworkdir = INPUT.sapworkdir;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(32).set('get_sapgui_workdir not supported')));
  }
  async file_exist(INPUT) {
    return cl_gui_frontend_services.file_exist(INPUT);
  }
  static async file_exist(INPUT) {
    let result = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    let file = INPUT?.file;
    if (file?.getQualifiedName === undefined || file.getQualifiedName() !== "STRING") { file = undefined; }
    if (file === undefined) { file = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.file); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(24).set('file_exist not supported')));
    return result;
  }
  async file_delete(INPUT) {
    return cl_gui_frontend_services.file_delete(INPUT);
  }
  static async file_delete(INPUT) {
    let filename = INPUT?.filename;
    if (filename?.getQualifiedName === undefined || filename.getQualifiedName() !== "STRING") { filename = undefined; }
    if (filename === undefined) { filename = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.filename); }
    let rc = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.rc) {rc = INPUT.rc;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(25).set('file_delete not supported')));
  }
  async clipboard_import(INPUT) {
    return cl_gui_frontend_services.clipboard_import(INPUT);
  }
  static async clipboard_import(INPUT) {
    let data = INPUT?.data || abap.types.TableFactory.construct(new abap.types.Character(4), {"withHeader":false,"keyType":"DEFAULT"});
    let length = INPUT?.length || new abap.types.Integer({qualifiedName: "I"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(30).set('clipboard_import not supported')));
  }
  async directory_list_files(INPUT) {
    return cl_gui_frontend_services.directory_list_files(INPUT);
  }
  static async directory_list_files(INPUT) {
    let directory = INPUT?.directory;
    if (directory?.getQualifiedName === undefined || directory.getQualifiedName() !== "STRING") { directory = undefined; }
    if (directory === undefined) { directory = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.directory); }
    let files_only = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.files_only) {files_only.set(INPUT.files_only);}
    let file_table = new abap.types.Character(4);
    if (INPUT && INPUT.file_table) {file_table = INPUT.file_table;}
    let count = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.count) {count = INPUT.count;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(34).set('directory_list_files not supported')));
  }
  async directory_create(INPUT) {
    return cl_gui_frontend_services.directory_create(INPUT);
  }
  static async directory_create(INPUT) {
    let directory = INPUT?.directory;
    if (directory?.getQualifiedName === undefined || directory.getQualifiedName() !== "STRING") { directory = undefined; }
    if (directory === undefined) { directory = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.directory); }
    let rc = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.rc) {rc = INPUT.rc;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(30).set('directory_create not supported')));
  }
  async gui_download(INPUT) {
    return cl_gui_frontend_services.gui_download(INPUT);
  }
  static async gui_download(INPUT) {
    let bin_filesize = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.bin_filesize) {bin_filesize.set(INPUT.bin_filesize);}
    let filename = INPUT?.filename;
    if (filename?.getQualifiedName === undefined || filename.getQualifiedName() !== "STRING") { filename = undefined; }
    if (filename === undefined) { filename = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.filename); }
    let filetype = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.filetype) {filetype.set(INPUT.filetype);}
    let write_lf = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.write_lf) {write_lf.set(INPUT.write_lf);}
    let write_field_separator = new abap.types.Character(1, {"qualifiedName":"CHAR1","ddicName":"CHAR1"});
    if (INPUT && INPUT.write_field_separator) {write_field_separator.set(INPUT.write_field_separator);}
    let confirm_overwrite = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.confirm_overwrite) {confirm_overwrite.set(INPUT.confirm_overwrite);}
    let data_tab = new abap.types.Character(4);
    if (INPUT && INPUT.data_tab) {data_tab = INPUT.data_tab;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(26).set('gui_download not supported')));
  }
  async get_file_separator(INPUT) {
    return cl_gui_frontend_services.get_file_separator(INPUT);
  }
  static async get_file_separator(INPUT) {
    let file_separator = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.file_separator) {file_separator = INPUT.file_separator;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(32).set('get_file_separator not supported')));
  }
  async execute(INPUT) {
    return cl_gui_frontend_services.execute(INPUT);
  }
  static async execute(INPUT) {
    let document = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.document) {document.set(INPUT.document);}
    let application = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.application) {application.set(INPUT.application);}
    let parameter = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.parameter) {parameter.set(INPUT.parameter);}
    let default_directory = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.default_directory) {default_directory.set(INPUT.default_directory);}
    let maximized = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.maximized) {maximized.set(INPUT.maximized);}
    let minimized = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.minimized) {minimized.set(INPUT.minimized);}
    let synchronous = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.synchronous) {synchronous.set(INPUT.synchronous);}
    let operation = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.operation) {operation.set(INPUT.operation);}
    if (INPUT === undefined || INPUT.operation === undefined) {operation = new abap.types.Character(4).set('OPEN');}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(21).set('execute not supported')));
  }
  async directory_browse(INPUT) {
    return cl_gui_frontend_services.directory_browse(INPUT);
  }
  static async directory_browse(INPUT) {
    let window_title = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.window_title) {window_title.set(INPUT.window_title);}
    let initial_folder = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.initial_folder) {initial_folder.set(INPUT.initial_folder);}
    let selected_folder = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.selected_folder) {selected_folder = INPUT.selected_folder;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(30).set('directory_browse not supported')));
  }
  async gui_upload(INPUT) {
    return cl_gui_frontend_services.gui_upload(INPUT);
  }
  static async gui_upload(INPUT) {
    let filename = INPUT?.filename;
    if (filename?.getQualifiedName === undefined || filename.getQualifiedName() !== "STRING") { filename = undefined; }
    if (filename === undefined) { filename = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.filename); }
    let filetype = new abap.types.Character(10, {"qualifiedName":"CHAR10","ddicName":"CHAR10"});
    if (INPUT && INPUT.filetype) {filetype.set(INPUT.filetype);}
    let codepage = new abap.types.Character(20, {"qualifiedName":"abap_encoding"});
    if (INPUT && INPUT.codepage) {codepage.set(INPUT.codepage);}
    if (INPUT === undefined || INPUT.codepage === undefined) {codepage = abap.builtin.space;}
    let read_by_line = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.read_by_line) {read_by_line.set(INPUT.read_by_line);}
    let filelength = INPUT?.filelength || new abap.types.Integer({qualifiedName: "I"});
    let data_tab = new abap.types.Character(4);
    if (INPUT && INPUT.data_tab) {data_tab = INPUT.data_tab;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(24).set('gui_upload not supported')));
  }
  async file_open_dialog(INPUT) {
    return cl_gui_frontend_services.file_open_dialog(INPUT);
  }
  static async file_open_dialog(INPUT) {
    let window_title = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.window_title) {window_title.set(INPUT.window_title);}
    let default_filename = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.default_filename) {default_filename.set(INPUT.default_filename);}
    let default_extension = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.default_extension) {default_extension.set(INPUT.default_extension);}
    let multiselection = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.multiselection) {multiselection.set(INPUT.multiselection);}
    let file_filter = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.file_filter) {file_filter.set(INPUT.file_filter);}
    let initial_directory = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.initial_directory) {initial_directory.set(INPUT.initial_directory);}
    let file_table = abap.types.TableFactory.construct(new abap.types.Structure({"filename": new abap.types.Character(1024, {})}, "FILE_TABLE", "FILE_TABLE", {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "FILETABLE");
    if (INPUT && INPUT.file_table) {file_table = INPUT.file_table;}
    let rc = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.rc) {rc = INPUT.rc;}
    let user_action = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.user_action) {user_action = INPUT.user_action;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(30).set('file_open_dialog not supported')));
  }
  async file_save_dialog(INPUT) {
    return cl_gui_frontend_services.file_save_dialog(INPUT);
  }
  static async file_save_dialog(INPUT) {
    let window_title = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.window_title) {window_title.set(INPUT.window_title);}
    let default_extension = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.default_extension) {default_extension.set(INPUT.default_extension);}
    let default_file_name = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.default_file_name) {default_file_name.set(INPUT.default_file_name);}
    let file_filter = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.file_filter) {file_filter.set(INPUT.file_filter);}
    let initial_directory = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.initial_directory) {initial_directory.set(INPUT.initial_directory);}
    let prompt_on_overwrite = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.prompt_on_overwrite) {prompt_on_overwrite.set(INPUT.prompt_on_overwrite);}
    let filename = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.filename) {filename = INPUT.filename;}
    let path = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.path) {path = INPUT.path;}
    let fullpath = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.fullpath) {fullpath = INPUT.fullpath;}
    let user_action = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.user_action) {user_action = INPUT.user_action;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(30).set('file_save_dialog not supported')));
  }
  async get_platform() {
    return cl_gui_frontend_services.get_platform();
  }
  static async get_platform() {
    let platform = new abap.types.Integer({qualifiedName: "I"});
    platform.set(cl_gui_frontend_services.platform_windowsxp);
    return platform;
  }
  async clipboard_export(INPUT) {
    return cl_gui_frontend_services.clipboard_export(INPUT);
  }
  static async clipboard_export(INPUT) {
    let no_auth_check = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.no_auth_check) {no_auth_check.set(INPUT.no_auth_check);}
    let data = INPUT?.data || new abap.types.Character(4);
    let rc = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.rc) {rc = INPUT.rc;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(30).set('clipboard_export not supported')));
  }
  async get_system_directory(INPUT) {
    return cl_gui_frontend_services.get_system_directory(INPUT);
  }
  static async get_system_directory(INPUT) {
    let system_directory = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.system_directory) {system_directory = INPUT.system_directory;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(34).set('get_system_directory not supported')));
  }
  async get_gui_version(INPUT) {
    return cl_gui_frontend_services.get_gui_version(INPUT);
  }
  static async get_gui_version(INPUT) {
    let version_table = abap.types.TableFactory.construct(new abap.types.Structure({"filename": new abap.types.Character(1024, {})}, "FILE_TABLE", "FILE_TABLE", {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "FILETABLE");
    if (INPUT && INPUT.version_table) {version_table = INPUT.version_table;}
    let rc = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.rc) {rc = INPUT.rc;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(29).set('get_gui_verison not supported')));
  }
}
abap.Classes['CL_GUI_FRONTEND_SERVICES'] = cl_gui_frontend_services;
cl_gui_frontend_services.filetype_all = new abap.types.String({qualifiedName: "STRING"});
cl_gui_frontend_services.filetype_all.set('abc');
cl_gui_frontend_services.filetype_xml = new abap.types.String({qualifiedName: "STRING"});
cl_gui_frontend_services.filetype_xml.set('xml');
cl_gui_frontend_services.filetype_text = new abap.types.String({qualifiedName: "STRING"});
cl_gui_frontend_services.filetype_text.set('txt');
cl_gui_frontend_services.action_cancel = new abap.types.Integer({qualifiedName: "I"});
cl_gui_frontend_services.action_cancel.set(1);
cl_gui_frontend_services.action_ok = new abap.types.Integer({qualifiedName: "I"});
cl_gui_frontend_services.action_ok.set(1);
cl_gui_frontend_services.platform_nt351 = new abap.types.Integer({qualifiedName: "I"});
cl_gui_frontend_services.platform_nt351.set(1);
cl_gui_frontend_services.platform_nt40 = new abap.types.Integer({qualifiedName: "I"});
cl_gui_frontend_services.platform_nt40.set(2);
cl_gui_frontend_services.platform_nt50 = new abap.types.Integer({qualifiedName: "I"});
cl_gui_frontend_services.platform_nt50.set(3);
cl_gui_frontend_services.platform_windows95 = new abap.types.Integer({qualifiedName: "I"});
cl_gui_frontend_services.platform_windows95.set(4);
cl_gui_frontend_services.platform_windows98 = new abap.types.Integer({qualifiedName: "I"});
cl_gui_frontend_services.platform_windows98.set(5);
cl_gui_frontend_services.platform_windowsxp = new abap.types.Integer({qualifiedName: "I"});
cl_gui_frontend_services.platform_windowsxp.set(6);

//# sourceMappingURL=cl_gui_frontend_services.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_http_client.clas.mjs":
/*!****************************************!*\
  !*** ./output/cl_http_client.clas.mjs ***!
  \****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_http_client": () => (/* binding */ cl_http_client)
/* harmony export */ });
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_http_client.clas.abap
class cl_http_client {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_HTTP_CLIENT';
  static IMPLEMENTED_INTERFACES = ["IF_HTTP_CLIENT"];
  static ATTRIBUTES = {"MV_HOST": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "IF_HTTP_CLIENT~REQUEST": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_REQUEST", RTTIName: "\\INTERFACE=IF_HTTP_REQUEST"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "IF_HTTP_CLIENT~RESPONSE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_RESPONSE", RTTIName: "\\INTERFACE=IF_HTTP_RESPONSE"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "IF_HTTP_CLIENT~PROPERTYTYPE_LOGON_POPUP": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "IF_HTTP_CLIENT~PROPERTYTYPE_ACCEPT_COOKIE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "IF_HTTP_CLIENT~PROPERTYTYPE_REDIRECT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "IF_HTTP_CLIENT~CO_DISABLED": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_CLIENT~CO_ENABLED": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_CLIENT~CO_TIMEOUT_DEFAULT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"CREATE_BY_URL": {"visibility": "U", "parameters": {"URL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "SSL_ID": {"type": () => {return new abap.types.Character(6, {"qualifiedName":"SSFAPPLSSL","ddicName":"SSFAPPLSSL"});}, "is_optional": " "}, "PROXY_HOST": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PROXY_SERVICE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_CLIENT", RTTIName: "\\INTERFACE=IF_HTTP_CLIENT"});}, "is_optional": " "}}},
  "CREATE_BY_DESTINATION": {"visibility": "U", "parameters": {"DESTINATION": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_CLIENT", RTTIName: "\\INTERFACE=IF_HTTP_CLIENT"});}, "is_optional": " "}}},
  "CREATE_INTERNAL": {"visibility": "U", "parameters": {"CLIENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_CLIENT", RTTIName: "\\INTERFACE=IF_HTTP_CLIENT"});}, "is_optional": " "}}},
  "CONSTRUCTOR": {"visibility": "U", "parameters": {"URL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.mv_host = new abap.types.String({qualifiedName: "STRING"});
    this.if_http_client$co_disabled = abap.Classes['IF_HTTP_CLIENT'].if_http_client$co_disabled;
    this.if_http_client$co_enabled = abap.Classes['IF_HTTP_CLIENT'].if_http_client$co_enabled;
    this.if_http_client$co_timeout_default = abap.Classes['IF_HTTP_CLIENT'].if_http_client$co_timeout_default;
    if (this.if_http_client$request === undefined) this.if_http_client$request = new abap.types.ABAPObject({qualifiedName: "IF_HTTP_REQUEST", RTTIName: "\\INTERFACE=IF_HTTP_REQUEST"});
    if (this.if_http_client$response === undefined) this.if_http_client$response = new abap.types.ABAPObject({qualifiedName: "IF_HTTP_RESPONSE", RTTIName: "\\INTERFACE=IF_HTTP_RESPONSE"});
    if (this.if_http_client$propertytype_logon_popup === undefined) this.if_http_client$propertytype_logon_popup = new abap.types.Integer({qualifiedName: "I"});
    if (this.if_http_client$propertytype_accept_cookie === undefined) this.if_http_client$propertytype_accept_cookie = new abap.types.Integer({qualifiedName: "I"});
    if (this.if_http_client$propertytype_redirect === undefined) this.if_http_client$propertytype_redirect = new abap.types.Integer({qualifiedName: "I"});
  }
  async constructor_(INPUT) {
    let url = INPUT?.url;
    if (url?.getQualifiedName === undefined || url.getQualifiedName() !== "STRING") { url = undefined; }
    if (url === undefined) { url = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.url); }
    let lv_uri = new abap.types.String({qualifiedName: "STRING"});
    let lv_query = new abap.types.String({qualifiedName: "STRING"});
    this.if_http_client$response.set(await (new abap.Classes['CL_HTTP_ENTITY']()).constructor_());
    abap.statements.find(url, {regex: new abap.types.Character(19).set('\\w(\\/[\\w\\d\\.\\-\\/]+)'), submatches: [lv_uri]});
    this.mv_host.set(url);
    abap.statements.replace({target: this.mv_host, all: false, with: new abap.types.Character(1).set(''), of: lv_uri});
    this.if_http_client$request.set(await (new abap.Classes['CL_HTTP_ENTITY']()).constructor_());
    await this.if_http_client$request.get().if_http_entity$set_header_field({name: new abap.types.Character(12).set('~request_uri'), value: lv_uri});
    abap.statements.find(url, {regex: new abap.types.Character(6).set('\\?(.*)'), submatches: [lv_query]});
    if (abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
      await abap.Classes['CL_HTTP_UTILITY'].set_query({request: this.if_http_client$request, query: lv_query});
    }
    return this;
  }
  async if_http_client$escape_url(INPUT) {
    return cl_http_client.if_http_client$escape_url(INPUT);
  }
  static async if_http_client$escape_url(INPUT) {
    let escaped = new abap.types.String({qualifiedName: "STRING"});
    let unescaped = INPUT?.unescaped;
    if (unescaped?.getQualifiedName === undefined || unescaped.getQualifiedName() !== "STRING") { unescaped = undefined; }
    if (unescaped === undefined) { unescaped = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.unescaped); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return escaped;
  }
  async create_by_url(INPUT) {
    return cl_http_client.create_by_url(INPUT);
  }
  static async create_by_url(INPUT) {
    let url = INPUT?.url;
    if (url?.getQualifiedName === undefined || url.getQualifiedName() !== "STRING") { url = undefined; }
    if (url === undefined) { url = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.url); }
    let ssl_id = new abap.types.Character(6, {"qualifiedName":"SSFAPPLSSL","ddicName":"SSFAPPLSSL"});
    if (INPUT && INPUT.ssl_id) {ssl_id.set(INPUT.ssl_id);}
    let proxy_host = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.proxy_host) {proxy_host.set(INPUT.proxy_host);}
    let proxy_service = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.proxy_service) {proxy_service.set(INPUT.proxy_service);}
    let client = INPUT?.client || new abap.types.ABAPObject({qualifiedName: "IF_HTTP_CLIENT", RTTIName: "\\INTERFACE=IF_HTTP_CLIENT"});
    client.set(await (new abap.Classes['CL_HTTP_CLIENT']()).constructor_({url: url}));
    abap.builtin.sy.get().subrc.set(abap.IntegerFactory.get(0));
  }
  async if_http_client$authenticate(INPUT) {
    let proxy_authentication = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.proxy_authentication) {proxy_authentication.set(INPUT.proxy_authentication);}
    let username = INPUT?.username;
    if (username?.getQualifiedName === undefined || username.getQualifiedName() !== "STRING") { username = undefined; }
    if (username === undefined) { username = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.username); }
    let password = INPUT?.password;
    if (password?.getQualifiedName === undefined || password.getQualifiedName() !== "STRING") { password = undefined; }
    if (password === undefined) { password = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.password); }
    let lv_base64 = new abap.types.String({qualifiedName: "STRING"});
    lv_base64.set((await abap.Classes['CL_HTTP_UTILITY'].if_http_utility$encode_base64({unencoded: new abap.types.String().set(`${abap.templateFormatting(username)}:${abap.templateFormatting(password)}`)})));
    await this.if_http_client$request.get().if_http_entity$set_header_field({name: new abap.types.Character(13).set('authorization'), value: new abap.types.String().set(`Basic ${abap.templateFormatting(lv_base64)}`)});
  }
  async if_http_client$close() {
    return;
  }
  async create_by_destination(INPUT) {
    return cl_http_client.create_by_destination(INPUT);
  }
  static async create_by_destination(INPUT) {
    let destination = INPUT?.destination;
    let client = INPUT?.client || new abap.types.ABAPObject({qualifiedName: "IF_HTTP_CLIENT", RTTIName: "\\INTERFACE=IF_HTTP_CLIENT"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async create_internal(INPUT) {
    return cl_http_client.create_internal(INPUT);
  }
  static async create_internal(INPUT) {
    let client = INPUT?.client || new abap.types.ABAPObject({qualifiedName: "IF_HTTP_CLIENT", RTTIName: "\\INTERFACE=IF_HTTP_CLIENT"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    abap.builtin.sy.get().subrc.set(0);
  }
  async if_http_client$create_abs_url(INPUT) {
    let url = new abap.types.String({qualifiedName: "STRING"});
    let path = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.path) {path.set(INPUT.path);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return url;
  }
  async if_http_client$send(INPUT) {
    let timeout = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.timeout) {timeout.set(INPUT.timeout);}
    if (INPUT === undefined || INPUT.timeout === undefined) {timeout = abap.IntegerFactory.get(0);}
    let lv_method = new abap.types.String({qualifiedName: "STRING"});
    let lv_url = new abap.types.String({qualifiedName: "STRING"});
    let lv_body = new abap.types.String({qualifiedName: "STRING"});
    let lv_name = new abap.types.String({qualifiedName: "STRING"});
    let lv_value = new abap.types.String({qualifiedName: "STRING"});
    let lv_content_type = new abap.types.String({qualifiedName: "STRING"});
    let lv_xstr = new abap.types.XString({qualifiedName: "XSTRING"});
    let lt_form_fields = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");
    let lt_header_fields = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");
    let ls_field = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {});
    lv_method.set((await this.if_http_client$request.get().if_http_request$get_method()));
    if (abap.compare.initial(lv_method)) {
      lv_method.set(new abap.types.Character(3).set('GET'));
    }
    if (abap.compare.initial((await this.if_http_client$request.get().if_http_entity$get_header_field({name: new abap.types.Character(10).set('user-agent')})))) {
      await this.if_http_client$request.get().if_http_entity$set_header_field({name: new abap.types.Character(10).set('user-agent'), value: new abap.types.Character(14).set('open-abap-http')});
    }
    lv_url.set((await this.if_http_client$request.get().if_http_entity$get_header_field({name: new abap.types.Character(12).set('~request_uri')})));
    abap.statements.replace({target: lv_url, all: false, with: new abap.types.Character(1).set(''), of: this.mv_host});
    lv_url.set(abap.operators.concat(this.mv_host,lv_url));
    await this.if_http_client$request.get().if_http_entity$get_form_fields({fields: lt_form_fields});
    if (abap.compare.gt(abap.builtin.lines({val: lt_form_fields}), abap.IntegerFactory.get(0))) {
      let unique36 = lv_method;
      if (abap.compare.eq(unique36, new abap.types.Character(3).set('GET'))) {
        lv_url.set(abap.operators.concat(lv_url,abap.operators.concat(new abap.types.Character(1).set('?'),(await abap.Classes['CL_HTTP_UTILITY'].if_http_utility$fields_to_string({fields: lt_form_fields})))));
      } else if (abap.compare.eq(unique36, new abap.types.Character(4).set('POST'))) {
        await this.if_http_client$request.get().if_http_entity$set_cdata({data: (await abap.Classes['CL_HTTP_UTILITY'].if_http_utility$fields_to_string({fields: lt_form_fields}))});
      }
    }
    await this.if_http_client$request.get().if_http_entity$get_header_fields({fields: lt_header_fields});
    let headers = {};
    for await (const unique37 of abap.statements.loop(lt_header_fields,{where: async (I) => {return abap.compare.ne(I.name, new abap.types.Character(12).set('~request_uri'));}})) {
      ls_field.set(unique37);
      headers[ls_field.get().name.get()] = ls_field.get().value.get();
    }
    lv_content_type.set((await this.if_http_client$request.get().if_http_entity$get_content_type()));
    if (abap.compare.initial(lv_content_type) === false) {
      headers["content-type"] = lv_content_type.get();
    }
    headers["accept-encoding"] = "gzip";
    lv_body.set((await this.if_http_client$request.get().if_http_entity$get_cdata()));
    if (abap.compare.gt(abap.builtin.strlen({val: lv_body}), abap.IntegerFactory.get(0))) {
      headers["content-length"] = lv_body.get().length;
    }
    const https = await __webpack_require__.e(/*! import() */ "_4854").then(__webpack_require__.t.bind(__webpack_require__, /*! https */ "?4854", 19));
    const http = await __webpack_require__.e(/*! import() */ "_0eef").then(__webpack_require__.t.bind(__webpack_require__, /*! http */ "?0eef", 19));
    function postData(url, options, requestBody) {
        return new Promise((resolve, reject) => {
            const prot = url.startsWith("http://") ? http : https;
            const req = prot.request(url, options,
              (res) => {
                  let chunks = [];
                  res.on("data", (chunk) => {chunks.push(chunk);});
                  res.on("error", reject);
                  res.on("end", () => {
                        resolve({statusCode: res.statusCode, headers: res.headers, body: Buffer.concat(chunks)});
                    });
                  });
                req.on("error", reject);
                req.write(requestBody, "binary");
                req.end();
              });
          }
          const prot = lv_url.get().startsWith("http://") ? http : https;
          if (this.agent === undefined) {this.agent = new prot.Agent({keepAlive: true, maxSockets: 1});}
          let response = await postData(lv_url.get(), {method: lv_method.get(), headers: headers, agent: this.agent}, lv_body.get());
          for (const h in response.headers) {
              lv_name.set(h);
              if (Array.isArray(response.headers[h])) continue;
              lv_value.set(response.headers[h]);
            await this.if_http_client$response.get().if_http_entity$set_header_field({name: lv_name, value: lv_value});
          }
          this.if_http_client$response.get().mv_content_type.set(response.headers["content-type"] || "");
          this.if_http_client$response.get().mv_status.set(response.statusCode);
          this.if_http_client$response.get().mv_data.set(response.body.toString("hex").toUpperCase());
          lv_value.set((await this.if_http_client$response.get().if_http_entity$get_header_field({name: new abap.types.Character(16).set('content-encoding')})));
          if (abap.compare.eq(lv_value, new abap.types.Character(4).set('gzip'))) {
            await abap.Classes['CL_ABAP_GZIP'].decompress_binary_with_header({gzip_in: (await this.if_http_client$response.get().if_http_entity$get_data()), raw_out: lv_xstr});
            await this.if_http_client$response.get().if_http_entity$set_data({data: lv_xstr});
          }
          abap.builtin.sy.get().subrc.set(abap.IntegerFactory.get(0));
        }
        async if_http_client$receive() {
          abap.builtin.sy.get().subrc.set(abap.IntegerFactory.get(0));
        }
        async if_http_client$get_last_error(INPUT) {
          let code = INPUT?.code || new abap.types.Integer({qualifiedName: "I"});
          let message = INPUT?.message || new abap.types.String({qualifiedName: "STRING"});
          await this.if_http_client$response.get().if_http_response$get_status({code: code});
          message.set(new abap.types.Character(14).set('todo_open_abap'));
        }
        async if_http_client$send_sap_logon_ticket() {
          return;
        }
        async if_http_client$refresh_request() {
          abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
        }
      }
      abap.Classes['CL_HTTP_CLIENT'] = cl_http_client;
      cl_http_client.if_http_client$co_disabled = new abap.types.Integer({qualifiedName: "I"});
      cl_http_client.if_http_client$co_disabled.set(0);
      cl_http_client.if_http_client$co_enabled = new abap.types.Integer({qualifiedName: "I"});
      cl_http_client.if_http_client$co_enabled.set(1);
      cl_http_client.if_http_client$co_timeout_default = new abap.types.Integer({qualifiedName: "I"});
      cl_http_client.if_http_client$co_timeout_default.set(60);

//# sourceMappingURL=cl_http_client.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_http_entity.clas.mjs":
/*!****************************************!*\
  !*** ./output/cl_http_entity.clas.mjs ***!
  \****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_http_entity": () => (/* binding */ cl_http_entity)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_http_entity.clas.abap
class cl_http_entity {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_HTTP_ENTITY';
  static IMPLEMENTED_INTERFACES = ["IF_HTTP_RESPONSE","IF_HTTP_REQUEST","IF_HTTP_ENTITY","IF_HTTP_ENTITY"];
  static ATTRIBUTES = {"M_LAST_ERROR": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "O", "is_constant": " ", "is_class": " "},
  "MV_STATUS": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MV_REASON": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MV_CONTENT_TYPE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MV_METHOD": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MV_DATA": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MT_HEADERS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MT_FORM_FIELDS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "IF_HTTP_ENTITY~CO_REQUEST_METHOD_GET": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_REQUEST_METHOD_POST": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_BODY_BEFORE_QUERY_STRING": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_PROTOCOL_VERSION_1_0": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_PROTOCOL_VERSION_1_1": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_COMPRESS_BASED_ON_MIME_TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_REQUEST_METHOD_GET": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_REQUEST_METHOD_POST": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_BODY_BEFORE_QUERY_STRING": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_PROTOCOL_VERSION_1_0": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_PROTOCOL_VERSION_1_1": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_COMPRESS_BASED_ON_MIME_TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.m_last_error = new abap.types.Integer({qualifiedName: "I"});
    this.mv_status = new abap.types.Integer({qualifiedName: "I"});
    this.mv_reason = new abap.types.String({qualifiedName: "STRING"});
    this.mv_content_type = new abap.types.String({qualifiedName: "STRING"});
    this.mv_method = new abap.types.String({qualifiedName: "STRING"});
    this.mv_data = new abap.types.XString({qualifiedName: "XSTRING"});
    this.mt_headers = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");
    this.mt_form_fields = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");
    this.if_http_entity$co_request_method_get = abap.Classes['IF_HTTP_ENTITY'].if_http_entity$co_request_method_get;
    this.if_http_entity$co_request_method_post = abap.Classes['IF_HTTP_ENTITY'].if_http_entity$co_request_method_post;
    this.if_http_entity$co_body_before_query_string = abap.Classes['IF_HTTP_ENTITY'].if_http_entity$co_body_before_query_string;
    this.if_http_entity$co_protocol_version_1_0 = abap.Classes['IF_HTTP_ENTITY'].if_http_entity$co_protocol_version_1_0;
    this.if_http_entity$co_protocol_version_1_1 = abap.Classes['IF_HTTP_ENTITY'].if_http_entity$co_protocol_version_1_1;
    this.if_http_entity$co_compress_based_on_mime_type = abap.Classes['IF_HTTP_ENTITY'].if_http_entity$co_compress_based_on_mime_type;
    this.if_http_response$get_header_field = this.if_http_entity$get_header_field;
    this.if_http_response$get_cdata = this.if_http_entity$get_cdata;
    this.if_http_response$get_content_type = this.if_http_entity$get_content_type;
    this.if_http_response$set_content_type = this.if_http_entity$set_content_type;
    this.if_http_response$get_data = this.if_http_entity$get_data;
    this.if_http_response$set_data = this.if_http_entity$set_data;
    this.if_http_response$get_header_fields = this.if_http_entity$get_header_fields;
    this.if_http_response$set_header_field = this.if_http_entity$set_header_field;
    this.if_http_response$set_cdata = this.if_http_entity$set_cdata;
    this.if_http_response$append_cdata = this.if_http_entity$append_cdata;
    this.if_http_response$set_cookie = this.if_http_entity$set_cookie;
    this.if_http_response$delete_header_field = this.if_http_entity$delete_header_field;
    this.if_http_response$set_compression = this.if_http_entity$set_compression;
    this.if_http_response$get_cookies = this.if_http_entity$get_cookies;
    this.if_http_entity$co_request_method_get = abap.Classes['IF_HTTP_ENTITY'].if_http_entity$co_request_method_get;
    this.if_http_entity$co_request_method_post = abap.Classes['IF_HTTP_ENTITY'].if_http_entity$co_request_method_post;
    this.if_http_entity$co_body_before_query_string = abap.Classes['IF_HTTP_ENTITY'].if_http_entity$co_body_before_query_string;
    this.if_http_entity$co_protocol_version_1_0 = abap.Classes['IF_HTTP_ENTITY'].if_http_entity$co_protocol_version_1_0;
    this.if_http_entity$co_protocol_version_1_1 = abap.Classes['IF_HTTP_ENTITY'].if_http_entity$co_protocol_version_1_1;
    this.if_http_entity$co_compress_based_on_mime_type = abap.Classes['IF_HTTP_ENTITY'].if_http_entity$co_compress_based_on_mime_type;
    this.if_http_request$add_multipart = this.if_http_entity$add_multipart;
    this.if_http_request$append_cdata = this.if_http_entity$append_cdata;
    this.if_http_request$append_cdata2 = this.if_http_entity$append_cdata2;
    this.if_http_request$append_data = this.if_http_entity$append_data;
    this.if_http_request$co_protocol_version_1_0 = this.if_http_entity$co_protocol_version_1_0;
    this.if_http_request$co_protocol_version_1_1 = this.if_http_entity$co_protocol_version_1_1;
    this.if_http_request$co_request_method_get = this.if_http_entity$co_request_method_get;
    this.if_http_request$co_request_method_post = this.if_http_entity$co_request_method_post;
    this.if_http_request$get_cdata = this.if_http_entity$get_cdata;
    this.if_http_request$get_content_type = this.if_http_entity$get_content_type;
    this.if_http_request$get_cookie_field = this.if_http_entity$get_cookie_field;
    this.if_http_request$get_cookies = this.if_http_entity$get_cookies;
    this.if_http_request$get_data = this.if_http_entity$get_data;
    this.if_http_request$get_form_field = this.if_http_entity$get_form_field;
    this.if_http_request$get_form_fields = this.if_http_entity$get_form_fields;
    this.if_http_request$get_form_fields_cs = this.if_http_entity$get_form_fields_cs;
    this.if_http_request$get_header_field = this.if_http_entity$get_header_field;
    this.if_http_request$get_header_fields = this.if_http_entity$get_header_fields;
    this.if_http_request$get_last_error = this.if_http_entity$get_last_error;
    this.if_http_request$get_multipart = this.if_http_entity$get_multipart;
    this.if_http_request$num_multiparts = this.if_http_entity$num_multiparts;
    this.if_http_request$set_cdata = this.if_http_entity$set_cdata;
    this.if_http_request$set_compression = this.if_http_entity$set_compression;
    this.if_http_request$set_content_type = this.if_http_entity$set_content_type;
    this.if_http_request$set_cookie = this.if_http_entity$set_cookie;
    this.if_http_request$set_data = this.if_http_entity$set_data;
    this.if_http_request$set_form_field = this.if_http_entity$set_form_field;
    this.if_http_request$set_form_fields = this.if_http_entity$set_form_fields;
    this.if_http_request$set_header_field = this.if_http_entity$set_header_field;
    this.if_http_request$set_header_fields = this.if_http_entity$set_header_fields;
    this.set_header_field = this.if_http_entity$set_header_field;
    this.append_cdata = this.if_http_entity$append_cdata;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async if_http_response$server_cache_expire_rel(INPUT) {
    let expires_rel = INPUT?.expires_rel;
    if (expires_rel?.getQualifiedName === undefined || expires_rel.getQualifiedName() !== "I") { expires_rel = undefined; }
    if (expires_rel === undefined) { expires_rel = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.expires_rel); }
    let etag = new abap.types.Character(32, {"qualifiedName":"CHAR32","ddicName":"CHAR32"});
    if (INPUT && INPUT.etag) {etag.set(INPUT.etag);}
    let browser_dependent = new abap.types.Character(1, {"qualifiedName":"BOOLEAN","ddicName":"BOOLEAN"});
    if (INPUT && INPUT.browser_dependent) {browser_dependent.set(INPUT.browser_dependent);}
    if (INPUT === undefined || INPUT.browser_dependent === undefined) {browser_dependent = abap.builtin.abap_false;}
    let no_ufo_cache = new abap.types.Character(1, {"qualifiedName":"BOOLEAN","ddicName":"BOOLEAN"});
    if (INPUT && INPUT.no_ufo_cache) {no_ufo_cache.set(INPUT.no_ufo_cache);}
    if (INPUT === undefined || INPUT.no_ufo_cache === undefined) {no_ufo_cache = abap.builtin.abap_false;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_response$server_cache_expire_default(INPUT) {
    let etag = new abap.types.Character(32, {"qualifiedName":"CHAR32","ddicName":"CHAR32"});
    if (INPUT && INPUT.etag) {etag.set(INPUT.etag);}
    let browser_dependent = new abap.types.Character(1, {"qualifiedName":"BOOLEAN","ddicName":"BOOLEAN"});
    if (INPUT && INPUT.browser_dependent) {browser_dependent.set(INPUT.browser_dependent);}
    if (INPUT === undefined || INPUT.browser_dependent === undefined) {browser_dependent = abap.builtin.abap_false;}
    let no_ufo_cache = new abap.types.Character(1, {"qualifiedName":"BOOLEAN","ddicName":"BOOLEAN"});
    if (INPUT && INPUT.no_ufo_cache) {no_ufo_cache.set(INPUT.no_ufo_cache);}
    if (INPUT === undefined || INPUT.no_ufo_cache === undefined) {no_ufo_cache = abap.builtin.abap_false;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_response$server_cache_expire_abs(INPUT) {
    let expires_abs_date = new abap.types.Date({qualifiedName: "D"});
    if (INPUT && INPUT.expires_abs_date) {expires_abs_date.set(INPUT.expires_abs_date);}
    let expires_abs_time = new abap.types.Time({qualifiedName: "T"});
    if (INPUT && INPUT.expires_abs_time) {expires_abs_time.set(INPUT.expires_abs_time);}
    let etag = new abap.types.Character(32, {"qualifiedName":"CHAR32","ddicName":"CHAR32"});
    if (INPUT && INPUT.etag) {etag.set(INPUT.etag);}
    let browser_dependent = new abap.types.Character(1, {"qualifiedName":"BOOLEAN","ddicName":"BOOLEAN"});
    if (INPUT && INPUT.browser_dependent) {browser_dependent.set(INPUT.browser_dependent);}
    if (INPUT === undefined || INPUT.browser_dependent === undefined) {browser_dependent = abap.builtin.abap_false;}
    let no_ufo_cache = new abap.types.Character(1, {"qualifiedName":"BOOLEAN","ddicName":"BOOLEAN"});
    if (INPUT && INPUT.no_ufo_cache) {no_ufo_cache.set(INPUT.no_ufo_cache);}
    if (INPUT === undefined || INPUT.no_ufo_cache === undefined) {no_ufo_cache = abap.builtin.abap_false;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_response$server_cache_browser_dependent(INPUT) {
    let dependent = new abap.types.Character(1, {"qualifiedName":"BOOLEAN","ddicName":"BOOLEAN"});
    if (INPUT && INPUT.dependent) {dependent.set(INPUT.dependent);}
    if (INPUT === undefined || INPUT.dependent === undefined) {dependent = abap.builtin.abap_true;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_response$get_raw_message() {
    let data = new abap.types.XString({qualifiedName: "XSTRING"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return data;
  }
  async if_http_response$copy() {
    let response = new abap.types.ABAPObject({qualifiedName: "IF_HTTP_RESPONSE", RTTIName: "\\INTERFACE=IF_HTTP_RESPONSE"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return response;
  }
  async if_http_request$get_user_agent(INPUT) {
    let user_agent_type = INPUT?.user_agent_type || new abap.types.Integer({qualifiedName: "I"});
    let user_agent_version = INPUT?.user_agent_version || new abap.types.Integer({qualifiedName: "I"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_request$get_uri_parameter(INPUT) {
    let value = new abap.types.String({qualifiedName: "STRING"});
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return value;
  }
  async if_http_request$get_raw_message() {
    let data = new abap.types.XString({qualifiedName: "XSTRING"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return data;
  }
  async if_http_request$get_form_data(INPUT) {
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    let data = new abap.types.Character(4);
    if (INPUT && INPUT.data) {data = INPUT.data;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_request$get_authorization(INPUT) {
    let auth_type = INPUT?.auth_type || new abap.types.Integer({qualifiedName: "I"});
    let username = INPUT?.username || new abap.types.String({qualifiedName: "STRING"});
    let password = INPUT?.password || new abap.types.String({qualifiedName: "STRING"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_request$copy() {
    let request = new abap.types.ABAPObject({qualifiedName: "IF_HTTP_REQUEST", RTTIName: "\\INTERFACE=IF_HTTP_REQUEST"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return request;
  }
  async if_http_request$set_authorization(INPUT) {
    let auth_type = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.auth_type) {auth_type.set(INPUT.auth_type);}
    if (INPUT === undefined || INPUT.auth_type === undefined) {auth_type = abap.IntegerFactory.get(1);}
    let username = INPUT?.username;
    if (username?.getQualifiedName === undefined || username.getQualifiedName() !== "STRING") { username = undefined; }
    if (username === undefined) { username = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.username); }
    let password = INPUT?.password;
    if (password?.getQualifiedName === undefined || password.getQualifiedName() !== "STRING") { password = undefined; }
    if (password === undefined) { password = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.password); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_entity$add_multipart(INPUT) {
    let entity = new abap.types.ABAPObject({qualifiedName: "IF_HTTP_ENTITY", RTTIName: "\\INTERFACE=IF_HTTP_ENTITY"});
    let suppress_content_length = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.suppress_content_length) {suppress_content_length.set(INPUT.suppress_content_length);}
    if (INPUT === undefined || INPUT.suppress_content_length === undefined) {suppress_content_length = abap.builtin.abap_false;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return entity;
  }
  async if_http_entity$get_cookie_field(INPUT) {
    let field_value = new abap.types.String({qualifiedName: "STRING"});
    let cookie_name = INPUT?.cookie_name;
    if (cookie_name?.getQualifiedName === undefined || cookie_name.getQualifiedName() !== "STRING") { cookie_name = undefined; }
    if (cookie_name === undefined) { cookie_name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.cookie_name); }
    let cookie_path = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.cookie_path) {cookie_path.set(INPUT.cookie_path);}
    let field_name = INPUT?.field_name;
    if (field_name?.getQualifiedName === undefined || field_name.getQualifiedName() !== "STRING") { field_name = undefined; }
    if (field_name === undefined) { field_name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.field_name); }
    let base64 = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.base64) {base64.set(INPUT.base64);}
    if (INPUT === undefined || INPUT.base64 === undefined) {base64 = abap.IntegerFactory.get(1);}
    abap.statements.clear(field_value);
    return field_value;
  }
  async if_http_entity$set_compression(INPUT) {
    let disable_extended_checks = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.disable_extended_checks) {disable_extended_checks.set(INPUT.disable_extended_checks);}
    if (INPUT === undefined || INPUT.disable_extended_checks === undefined) {disable_extended_checks = abap.builtin.abap_false;}
    let options = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.options) {options.set(INPUT.options);}
    if (INPUT === undefined || INPUT.options === undefined) {options = abap.Classes['IF_HTTP_ENTITY'].if_http_entity$co_compress_based_on_mime_type;}
  }
  async if_http_entity$append_cdata(INPUT) {
    let data = INPUT?.data;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_entity$append_cdata2(INPUT) {
    let data = INPUT?.data;
    if (data?.getQualifiedName === undefined || data.getQualifiedName() !== "STRING") { data = undefined; }
    if (data === undefined) { data = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.data); }
    let encoding = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.encoding) {encoding.set(INPUT.encoding);}
    let offset = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.offset) {offset.set(INPUT.offset);}
    let length = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.length) {length.set(INPUT.length);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_entity$add_cookie_field(INPUT) {
    let cookie_name = INPUT?.cookie_name;
    if (cookie_name?.getQualifiedName === undefined || cookie_name.getQualifiedName() !== "STRING") { cookie_name = undefined; }
    if (cookie_name === undefined) { cookie_name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.cookie_name); }
    let cookie_path = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.cookie_path) {cookie_path.set(INPUT.cookie_path);}
    let field_name = INPUT?.field_name;
    if (field_name?.getQualifiedName === undefined || field_name.getQualifiedName() !== "STRING") { field_name = undefined; }
    if (field_name === undefined) { field_name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.field_name); }
    let field_value = INPUT?.field_value;
    if (field_value?.getQualifiedName === undefined || field_value.getQualifiedName() !== "STRING") { field_value = undefined; }
    if (field_value === undefined) { field_value = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.field_value); }
    let base64 = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.base64) {base64.set(INPUT.base64);}
    if (INPUT === undefined || INPUT.base64 === undefined) {base64 = abap.IntegerFactory.get(1);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_entity$append_data(INPUT) {
    let data = INPUT?.data;
    if (data?.getQualifiedName === undefined || data.getQualifiedName() !== "XSTRING") { data = undefined; }
    if (data === undefined) { data = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.data); }
    let offset = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.offset) {offset.set(INPUT.offset);}
    let length = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.length) {length.set(INPUT.length);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_entity$to_xstring() {
    let data = new abap.types.XString({qualifiedName: "XSTRING"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return data;
  }
  async if_http_entity$delete_cookie_secure(INPUT) {
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    let path = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.path) {path.set(INPUT.path);}
    if (INPUT === undefined || INPUT.path === undefined) {path = new abap.types.String().set(``);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_entity$get_cookies(INPUT) {
    let cookies = new abap.types.Character(4);
    if (INPUT && INPUT.cookies) {cookies = INPUT.cookies;}
    abap.statements.clear(cookies);
  }
  async if_http_entity$delete_form_field(INPUT) {
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_entity$delete_form_field_secure(INPUT) {
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_entity$get_cookie(INPUT) {
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    let path = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.path) {path.set(INPUT.path);}
    if (INPUT === undefined || INPUT.path === undefined) {path = new abap.types.String().set(``);}
    let value = INPUT?.value || new abap.types.String({qualifiedName: "STRING"});
    let domain = INPUT?.domain || new abap.types.String({qualifiedName: "STRING"});
    let expires = INPUT?.expires || new abap.types.String({qualifiedName: "STRING"});
    let secure = INPUT?.secure || new abap.types.Integer({qualifiedName: "I"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_entity$get_data_length(INPUT) {
    let data_length = INPUT?.data_length || new abap.types.Integer({qualifiedName: "I"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_entity$from_xstring(INPUT) {
    let data = INPUT?.data;
    if (data?.getQualifiedName === undefined || data.getQualifiedName() !== "XSTRING") { data = undefined; }
    if (data === undefined) { data = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.data); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_entity$get_form_field_cs(INPUT) {
    let value = new abap.types.String({qualifiedName: "STRING"});
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    let formfield_encoding = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.formfield_encoding) {formfield_encoding.set(INPUT.formfield_encoding);}
    let search_option = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.search_option) {search_option.set(INPUT.search_option);}
    if (INPUT === undefined || INPUT.search_option === undefined) {search_option = abap.Classes['IF_HTTP_ENTITY'].if_http_entity$co_body_before_query_string;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return value;
  }
  async if_http_entity$get_last_error() {
    let rc = new abap.types.Integer({qualifiedName: "I"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return rc;
  }
  async if_http_entity$delete_header_field(INPUT) {
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_entity$delete_header_field_secure(INPUT) {
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_entity$delete_cookie(INPUT) {
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    let path = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.path) {path.set(INPUT.path);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_entity$set_header_fields(INPUT) {
    let fields = INPUT?.fields;
    if (fields?.getQualifiedName === undefined || fields.getQualifiedName() !== "TIHTTPNVP") { fields = undefined; }
    if (fields === undefined) { fields = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP").set(INPUT.fields); }
    let ls_field = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {});
    for await (const unique38 of abap.statements.loop(fields)) {
      ls_field.set(unique38);
      await this.if_http_entity$set_header_field({name: ls_field.get().name, value: ls_field.get().value});
    }
  }
  async if_http_entity$suppress_content_type(INPUT) {
    let suppress = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.suppress) {suppress.set(INPUT.suppress);}
    if (INPUT === undefined || INPUT.suppress === undefined) {suppress = abap.builtin.abap_true;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_entity$set_formfield_encoding(INPUT) {
    let formfield_encoding = INPUT?.formfield_encoding;
    if (formfield_encoding?.getQualifiedName === undefined || formfield_encoding.getQualifiedName() !== "I") { formfield_encoding = undefined; }
    if (formfield_encoding === undefined) { formfield_encoding = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.formfield_encoding); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_entity$set_cookie(INPUT) {
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    let path = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.path) {path.set(INPUT.path);}
    let value = INPUT?.value;
    if (value?.getQualifiedName === undefined || value.getQualifiedName() !== "STRING") { value = undefined; }
    if (value === undefined) { value = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.value); }
    let domain = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.domain) {domain.set(INPUT.domain);}
    let expires = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.expires) {expires.set(INPUT.expires);}
    let secure = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.secure) {secure.set(INPUT.secure);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_entity$get_version() {
    let version = new abap.types.Integer({qualifiedName: "I"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return version;
  }
  async if_http_entity$get_serialized_message_length(INPUT) {
    let body_length = INPUT?.body_length || new abap.types.Integer({qualifiedName: "I"});
    let header_length = INPUT?.header_length || new abap.types.Integer({qualifiedName: "I"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_entity$get_header_field(INPUT) {
    let value = new abap.types.String({qualifiedName: "STRING"});
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    let ls_header = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {});
    abap.statements.readTable(this.mt_headers,{into: ls_header,
      withKey: (i) => {return abap.compare.eq(i.name, abap.builtin.to_lower({val: name}));},
      withKeyValue: [{key: (i) => {return i.name}, value: abap.builtin.to_lower({val: name})}],
      usesTableLine: false,
      withKeySimple: {"name": abap.builtin.to_lower({val: name})}});
    if (abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
      value.set(ls_header.get().value);
    }
    return value;
  }
  async if_http_entity$get_header_fields(INPUT) {
    let fields = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");
    if (INPUT && INPUT.fields) {fields = INPUT.fields;}
    fields.set(this.mt_headers);
  }
  async if_http_response$get_status(INPUT) {
    let code = INPUT?.code || new abap.types.Integer({qualifiedName: "I"});
    let reason = INPUT?.reason || new abap.types.String({qualifiedName: "STRING"});
    code.set(this.mv_status);
    reason.set(this.mv_reason);
  }
  async if_http_entity$get_cdata() {
    let data = new abap.types.String({qualifiedName: "STRING"});
    await (await abap.Classes['CL_ABAP_CONV_IN_CE'].create({encoding: new abap.types.Character(5).set('UTF-8')})).get().convert({input: this.mv_data, data: data});
    return data;
  }
  async if_http_response$set_status(INPUT) {
    let code = INPUT?.code;
    if (code?.getQualifiedName === undefined || code.getQualifiedName() !== "I") { code = undefined; }
    if (code === undefined) { code = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.code); }
    let reason = INPUT?.reason;
    if (reason?.getQualifiedName === undefined || reason.getQualifiedName() !== "STRING") { reason = undefined; }
    if (reason === undefined) { reason = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.reason); }
    this.mv_status.set(code);
    this.mv_reason.set(reason);
  }
  async if_http_entity$set_cdata(INPUT) {
    let data = INPUT?.data;
    if (data?.getQualifiedName === undefined || data.getQualifiedName() !== "STRING") { data = undefined; }
    if (data === undefined) { data = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.data); }
    let offset = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.offset) {offset.set(INPUT.offset);}
    let length = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.length) {length.set(INPUT.length);}
    await (await abap.Classes['CL_ABAP_CONV_OUT_CE'].create({encoding: new abap.types.Character(5).set('UTF-8')})).get().convert({data: data, buffer: this.mv_data});
  }
  async if_http_entity$get_content_type() {
    let content_type = new abap.types.String({qualifiedName: "STRING"});
    content_type.set((await this.if_http_entity$get_header_field({name: new abap.types.Character(12).set('content-type')})));
    return content_type;
  }
  async if_http_entity$set_content_type(INPUT) {
    let content_type = INPUT?.content_type;
    if (content_type?.getQualifiedName === undefined || content_type.getQualifiedName() !== "STRING") { content_type = undefined; }
    if (content_type === undefined) { content_type = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.content_type); }
    await this.if_http_entity$set_header_field({name: new abap.types.Character(12).set('content-type'), value: content_type});
  }
  async if_http_entity$get_data() {
    let data = new abap.types.XString({qualifiedName: "XSTRING"});
    data.set(this.mv_data);
    return data;
  }
  async if_http_entity$set_data(INPUT) {
    let data = INPUT?.data;
    if (data?.getQualifiedName === undefined || data.getQualifiedName() !== "XSTRING") { data = undefined; }
    if (data === undefined) { data = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.data); }
    this.mv_data.set(data);
  }
  async if_http_response$delete_cookie_at_client(INPUT) {
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    let path = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.path) {path.set(INPUT.path);}
    let domain = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.domain) {domain.set(INPUT.domain);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(2), new abap.types.Character(4).set('todo')));
  }
  async if_http_response$redirect(INPUT) {
    let url = INPUT?.url;
    if (url?.getQualifiedName === undefined || url.getQualifiedName() !== "STRING") { url = undefined; }
    if (url === undefined) { url = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.url); }
    let permanently = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.permanently) {permanently.set(INPUT.permanently);}
    let explanation = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.explanation) {explanation.set(INPUT.explanation);}
    let protocol_dependent = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.protocol_dependent) {protocol_dependent.set(INPUT.protocol_dependent);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(2), new abap.types.Character(4).set('todo')));
  }
  async if_http_entity$num_multiparts() {
    let num = new abap.types.Integer({qualifiedName: "I"});
    num.set(abap.IntegerFactory.get(0));
    return num;
  }
  async if_http_entity$get_multipart(INPUT) {
    let entity = new abap.types.ABAPObject({qualifiedName: "IF_HTTP_ENTITY", RTTIName: "\\INTERFACE=IF_HTTP_ENTITY"});
    let index = INPUT?.index;
    if (index?.getQualifiedName === undefined || index.getQualifiedName() !== "I") { index = undefined; }
    if (index === undefined) { index = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.index); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(2), new abap.types.Character(4).set('todo')));
    return entity;
  }
  async if_http_entity$get_form_fields_cs(INPUT) {
    let formfield_encoding = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.formfield_encoding) {formfield_encoding.set(INPUT.formfield_encoding);}
    let search_option = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.search_option) {search_option.set(INPUT.search_option);}
    if (INPUT === undefined || INPUT.search_option === undefined) {search_option = abap.Classes['IF_HTTP_ENTITY'].if_http_entity$co_body_before_query_string;}
    let fields = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");
    if (INPUT && INPUT.fields) {fields = INPUT.fields;}
    fields.set(this.mt_form_fields);
  }
  async if_http_entity$set_form_fields(INPUT) {
    let fields = INPUT?.fields;
    if (fields?.getQualifiedName === undefined || fields.getQualifiedName() !== "TIHTTPNVP") { fields = undefined; }
    if (fields === undefined) { fields = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP").set(INPUT.fields); }
    let multivalue = new abap.types.Integer({qualifiedName: "INT4"});
    if (INPUT && INPUT.multivalue) {multivalue.set(INPUT.multivalue);}
    this.mt_form_fields.set(fields);
  }
  async if_http_entity$get_form_fields(INPUT) {
    let fields = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");
    if (INPUT && INPUT.fields) {fields = INPUT.fields;}
    let ls_field = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {});
    for await (const unique39 of abap.statements.loop(this.mt_form_fields)) {
      ls_field.set(unique39);
      abap.statements.translate(ls_field.get().name, "LOWER");
      abap.statements.append({source: ls_field, target: fields});
    }
  }
  async if_http_entity$get_form_field(INPUT) {
    let value = new abap.types.String({qualifiedName: "STRING"});
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    let ls_field = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {});
    abap.statements.readTable(this.mt_form_fields,{into: ls_field,
      withKey: (i) => {return abap.compare.eq(i.name, abap.builtin.to_lower({val: name}));},
      withKeyValue: [{key: (i) => {return i.name}, value: abap.builtin.to_lower({val: name})}],
      usesTableLine: false,
      withKeySimple: {"name": abap.builtin.to_lower({val: name})}});
    if (abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
      value.set(ls_field.get().value);
    }
    return value;
  }
  async if_http_entity$set_header_field(INPUT) {
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    let value = INPUT?.value;
    if (value?.getQualifiedName === undefined || value.getQualifiedName() !== "STRING") { value = undefined; }
    if (value === undefined) { value = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.value); }
    let ls_header = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {});
    let fs_ls_header_ = new abap.types.FieldSymbol(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}));
    abap.statements.readTable(this.mt_headers,{assigning: fs_ls_header_,
      withKey: (i) => {return abap.compare.eq(i.name, abap.builtin.to_lower({val: name}));},
      withKeyValue: [{key: (i) => {return i.name}, value: abap.builtin.to_lower({val: name})}],
      usesTableLine: false,
      withKeySimple: {"name": abap.builtin.to_lower({val: name})}});
    if (abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
      fs_ls_header_.get().value.set(value);
    } else {
      ls_header.get().name.set(abap.builtin.to_lower({val: name}));
      ls_header.get().value.set(value);
      abap.statements.append({source: ls_header, target: this.mt_headers});
    }
    if (abap.compare.eq(name, new abap.types.Character(15).set('~request_method'))) {
      await this.if_http_request$set_method({method: value});
    }
  }
  async if_http_request$set_method(INPUT) {
    let method = INPUT?.method;
    if (method?.getQualifiedName === undefined || method.getQualifiedName() !== "STRING") { method = undefined; }
    if (method === undefined) { method = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.method); }
    this.mv_method.set(method);
  }
  async if_http_request$get_method() {
    let meth = new abap.types.String({qualifiedName: "STRING"});
    meth.set(this.mv_method);
    return meth;
  }
  async if_http_request$set_version(INPUT) {
    let version = INPUT?.version;
    if (version?.getQualifiedName === undefined || version.getQualifiedName() !== "I") { version = undefined; }
    if (version === undefined) { version = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.version); }
    return;
  }
  async if_http_entity$set_form_field(INPUT) {
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    let value = INPUT?.value;
    if (value?.getQualifiedName === undefined || value.getQualifiedName() !== "STRING") { value = undefined; }
    if (value === undefined) { value = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.value); }
    let ls_field = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {});
    ls_field.get().name.set(name);
    ls_field.get().value.set(value);
    abap.statements.append({source: ls_field, target: this.mt_form_fields});
  }
}
abap.Classes['CL_HTTP_ENTITY'] = cl_http_entity;
cl_http_entity.if_http_entity$co_request_method_get = new abap.types.String({qualifiedName: "STRING"});
cl_http_entity.if_http_entity$co_request_method_get.set('GET');
cl_http_entity.if_http_entity$co_request_method_post = new abap.types.String({qualifiedName: "STRING"});
cl_http_entity.if_http_entity$co_request_method_post.set('POST');
cl_http_entity.if_http_entity$co_body_before_query_string = new abap.types.Integer({qualifiedName: "I"});
cl_http_entity.if_http_entity$co_body_before_query_string.set(3);
cl_http_entity.if_http_entity$co_protocol_version_1_0 = new abap.types.Integer({qualifiedName: "I"});
cl_http_entity.if_http_entity$co_protocol_version_1_0.set(1000);
cl_http_entity.if_http_entity$co_protocol_version_1_1 = new abap.types.Integer({qualifiedName: "I"});
cl_http_entity.if_http_entity$co_protocol_version_1_1.set(1001);
cl_http_entity.if_http_entity$co_compress_based_on_mime_type = new abap.types.Integer({qualifiedName: "I"});
cl_http_entity.if_http_entity$co_compress_based_on_mime_type.set(2);
cl_http_entity.if_http_entity$co_request_method_get = new abap.types.String({qualifiedName: "STRING"});
cl_http_entity.if_http_entity$co_request_method_get.set('GET');
cl_http_entity.if_http_entity$co_request_method_post = new abap.types.String({qualifiedName: "STRING"});
cl_http_entity.if_http_entity$co_request_method_post.set('POST');
cl_http_entity.if_http_entity$co_body_before_query_string = new abap.types.Integer({qualifiedName: "I"});
cl_http_entity.if_http_entity$co_body_before_query_string.set(3);
cl_http_entity.if_http_entity$co_protocol_version_1_0 = new abap.types.Integer({qualifiedName: "I"});
cl_http_entity.if_http_entity$co_protocol_version_1_0.set(1000);
cl_http_entity.if_http_entity$co_protocol_version_1_1 = new abap.types.Integer({qualifiedName: "I"});
cl_http_entity.if_http_entity$co_protocol_version_1_1.set(1001);
cl_http_entity.if_http_entity$co_compress_based_on_mime_type = new abap.types.Integer({qualifiedName: "I"});
cl_http_entity.if_http_entity$co_compress_based_on_mime_type.set(2);

//# sourceMappingURL=cl_http_entity.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_http_server.clas.mjs":
/*!****************************************!*\
  !*** ./output/cl_http_server.clas.mjs ***!
  \****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_http_server": () => (/* binding */ cl_http_server)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_http_server.clas.abap
class cl_http_server {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_HTTP_SERVER';
  static IMPLEMENTED_INTERFACES = ["IF_HTTP_SERVER"];
  static ATTRIBUTES = {"C_COMPRESSION_SUPPORTED": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": " ", "is_class": "X"},
  "M_PROTOCOL_VERSION": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "IF_HTTP_SERVER~SESSION_ID": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": " ", "is_class": "X"},
  "IF_HTTP_SERVER~AUTHENTICATION_METHOD": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": " ", "is_class": "X"},
  "IF_HTTP_SERVER~AUTHENTICATED": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": " ", "is_class": "X"},
  "IF_HTTP_SERVER~RESPONSE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_RESPONSE", RTTIName: "\\INTERFACE=IF_HTTP_RESPONSE"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "IF_HTTP_SERVER~REQUEST": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_REQUEST", RTTIName: "\\INTERFACE=IF_HTTP_REQUEST"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "IF_HTTP_SERVER~AUTHMETHOD_SERVICE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_SERVER~CO_COMPRESS_BASED_ON_MIME_TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_SERVER~CO_DISABLED": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_SERVER~CO_ENABLED": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_SERVER~CO_PAGE_ERROR_TYPE": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_SERVER~CO_RESPONSE_PAGE_OPTION": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"GET_LOCATION": {"visibility": "U", "parameters": {"APPLICATION": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "PORT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "OUT_PROTOCOL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "HOST": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.c_compression_supported = cl_http_server.c_compression_supported;
    this.m_protocol_version = new abap.types.String({qualifiedName: "STRING"});
    this.if_http_server$authmethod_service = abap.Classes['IF_HTTP_SERVER'].if_http_server$authmethod_service;
    this.if_http_server$co_compress_based_on_mime_type = abap.Classes['IF_HTTP_SERVER'].if_http_server$co_compress_based_on_mime_type;
    this.if_http_server$co_disabled = abap.Classes['IF_HTTP_SERVER'].if_http_server$co_disabled;
    this.if_http_server$co_enabled = abap.Classes['IF_HTTP_SERVER'].if_http_server$co_enabled;
    this.if_http_server$co_page_error_type = abap.Classes['IF_HTTP_SERVER'].if_http_server$co_page_error_type;
    this.if_http_server$co_response_page_option = abap.Classes['IF_HTTP_SERVER'].if_http_server$co_response_page_option;
    if (this.if_http_server$session_id === undefined) this.if_http_server$session_id = cl_http_server.if_http_server$session_id;
    if (this.if_http_server$authentication_method === undefined) this.if_http_server$authentication_method = cl_http_server.if_http_server$authentication_method;
    if (this.if_http_server$authenticated === undefined) this.if_http_server$authenticated = cl_http_server.if_http_server$authenticated;
    if (this.if_http_server$response === undefined) this.if_http_server$response = new abap.types.ABAPObject({qualifiedName: "IF_HTTP_RESPONSE", RTTIName: "\\INTERFACE=IF_HTTP_RESPONSE"});
    if (this.if_http_server$request === undefined) this.if_http_server$request = new abap.types.ABAPObject({qualifiedName: "IF_HTTP_REQUEST", RTTIName: "\\INTERFACE=IF_HTTP_REQUEST"});
    this.co_enabled = this.if_http_server$co_enabled;
    this.append_field_url = this.if_http_server$append_field_url;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async if_http_server$logoff(INPUT) {
    let delete_mysapsso2_cookie = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.delete_mysapsso2_cookie) {delete_mysapsso2_cookie.set(INPUT.delete_mysapsso2_cookie);}
    let propagate_logoff = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.propagate_logoff) {propagate_logoff.set(INPUT.propagate_logoff);}
    let redirect_url = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.redirect_url) {redirect_url.set(INPUT.redirect_url);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_server$set_session_stateful(INPUT) {
    let stateful = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.stateful) {stateful.set(INPUT.stateful);}
    if (INPUT === undefined || INPUT.stateful === undefined) {stateful = abap.Classes['IF_HTTP_SERVER'].if_http_server$co_enabled;}
    let path = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.path) {path.set(INPUT.path);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_server$append_field_url(INPUT) {
    return cl_http_server.if_http_server$append_field_url(INPUT);
  }
  static async if_http_server$append_field_url(INPUT) {
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    let value = INPUT?.value;
    if (value?.getQualifiedName === undefined || value.getQualifiedName() !== "STRING") { value = undefined; }
    if (value === undefined) { value = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.value); }
    let url = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.url) {url = INPUT.url;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_server$create_abs_url(INPUT) {
    let url = new abap.types.String({qualifiedName: "STRING"});
    let protocol = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.protocol) {protocol.set(INPUT.protocol);}
    let post = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.post) {post.set(INPUT.post);}
    let port = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.port) {port.set(INPUT.port);}
    let path = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.path) {path.set(INPUT.path);}
    let querystring = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.querystring) {querystring.set(INPUT.querystring);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return url;
  }
  async if_http_server$create_rel_url(INPUT) {
    let url = new abap.types.String({qualifiedName: "STRING"});
    let path = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.path) {path.set(INPUT.path);}
    let querystring = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.querystring) {querystring.set(INPUT.querystring);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return url;
  }
  async if_http_server$decode_base64(INPUT) {
    return cl_http_server.if_http_server$decode_base64(INPUT);
  }
  static async if_http_server$decode_base64(INPUT) {
    let decoded = new abap.types.String({qualifiedName: "STRING"});
    let encoded = INPUT?.encoded;
    if (encoded?.getQualifiedName === undefined || encoded.getQualifiedName() !== "STRING") { encoded = undefined; }
    if (encoded === undefined) { encoded = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.encoded); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return decoded;
  }
  async if_http_server$enable_foreign_session_access(INPUT) {
    let url_path = INPUT?.url_path;
    if (url_path?.getQualifiedName === undefined || url_path.getQualifiedName() !== "STRING") { url_path = undefined; }
    if (url_path === undefined) { url_path = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.url_path); }
    let user_id = new abap.types.Character(12, {"qualifiedName":"SYUNAME","ddicName":"SYUNAME"});
    if (INPUT && INPUT.user_id) {user_id.set(INPUT.user_id);}
    let one_time_access_token = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.one_time_access_token) {one_time_access_token.set(INPUT.one_time_access_token);}
    if (INPUT === undefined || INPUT.one_time_access_token === undefined) {one_time_access_token = abap.builtin.abap_true;}
    let session_access_token = INPUT?.session_access_token || new abap.types.String({qualifiedName: "STRING"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_server$encode_base64(INPUT) {
    return cl_http_server.if_http_server$encode_base64(INPUT);
  }
  static async if_http_server$encode_base64(INPUT) {
    let encoded = new abap.types.String({qualifiedName: "STRING"});
    let unencoded = INPUT?.unencoded;
    if (unencoded?.getQualifiedName === undefined || unencoded.getQualifiedName() !== "STRING") { unencoded = undefined; }
    if (unencoded === undefined) { unencoded = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.unencoded); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return encoded;
  }
  async if_http_server$escape_html(INPUT) {
    return cl_http_server.if_http_server$escape_html(INPUT);
  }
  static async if_http_server$escape_html(INPUT) {
    let escaped = new abap.types.String({qualifiedName: "STRING"});
    let unescaped = INPUT?.unescaped;
    if (unescaped?.getQualifiedName === undefined || unescaped.getQualifiedName() !== "STRING") { unescaped = undefined; }
    if (unescaped === undefined) { unescaped = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.unescaped); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return escaped;
  }
  async if_http_server$escape_url(INPUT) {
    return cl_http_server.if_http_server$escape_url(INPUT);
  }
  static async if_http_server$escape_url(INPUT) {
    let escaped = new abap.types.String({qualifiedName: "STRING"});
    let unescaped = INPUT?.unescaped;
    if (unescaped?.getQualifiedName === undefined || unescaped.getQualifiedName() !== "STRING") { unescaped = undefined; }
    if (unescaped === undefined) { unescaped = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.unescaped); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return escaped;
  }
  async if_http_server$get_extension_info(INPUT) {
    return cl_http_server.if_http_server$get_extension_info(INPUT);
  }
  static async if_http_server$get_extension_info(INPUT) {
    let extension_class = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.extension_class) {extension_class.set(INPUT.extension_class);}
    let urls = INPUT?.urls || abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "STRING_TABLE");
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_server$get_extension_url(INPUT) {
    return cl_http_server.if_http_server$get_extension_url(INPUT);
  }
  static async if_http_server$get_extension_url(INPUT) {
    let extension_class = INPUT?.extension_class;
    if (extension_class?.getQualifiedName === undefined || extension_class.getQualifiedName() !== "STRING") { extension_class = undefined; }
    if (extension_class === undefined) { extension_class = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.extension_class); }
    let urls = INPUT?.urls || abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "STRING_TABLE");
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_server$get_last_error() {
    let rc = new abap.types.Integer({qualifiedName: "I"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return rc;
  }
  async if_http_server$get_location(INPUT) {
    return cl_http_server.if_http_server$get_location(INPUT);
  }
  static async if_http_server$get_location(INPUT) {
    let url_part = new abap.types.String({qualifiedName: "STRING"});
    let protocol = INPUT?.protocol || new abap.types.Character();
    let application = INPUT?.application || new abap.types.Character();
    let for_domain = INPUT?.for_domain || new abap.types.Character();
    let server = new abap.types.ABAPObject({qualifiedName: "IF_HTTP_SERVER", RTTIName: "\\INTERFACE=IF_HTTP_SERVER"});
    if (INPUT && INPUT.server) {server.set(INPUT.server);}
    let use_ticket_protocol = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.use_ticket_protocol) {use_ticket_protocol.set(INPUT.use_ticket_protocol);}
    if (INPUT === undefined || INPUT.use_ticket_protocol === undefined) {use_ticket_protocol = abap.builtin.abap_true;}
    let host = INPUT?.host || new abap.types.String({qualifiedName: "STRING"});
    let port = INPUT?.port || new abap.types.String({qualifiedName: "STRING"});
    let out_protocol = INPUT?.out_protocol || new abap.types.String({qualifiedName: "STRING"});
    let vh_switch = INPUT?.vh_switch || new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return url_part;
  }
  async if_http_server$get_location_exception(INPUT) {
    return cl_http_server.if_http_server$get_location_exception(INPUT);
  }
  static async if_http_server$get_location_exception(INPUT) {
    let url_part = new abap.types.String({qualifiedName: "STRING"});
    let protocol = INPUT?.protocol || new abap.types.Character();
    let application = INPUT?.application || new abap.types.Character();
    let for_domain = INPUT?.for_domain || new abap.types.Character();
    let server = new abap.types.ABAPObject({qualifiedName: "IF_HTTP_SERVER", RTTIName: "\\INTERFACE=IF_HTTP_SERVER"});
    if (INPUT && INPUT.server) {server.set(INPUT.server);}
    let use_ticket_protocol = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.use_ticket_protocol) {use_ticket_protocol.set(INPUT.use_ticket_protocol);}
    if (INPUT === undefined || INPUT.use_ticket_protocol === undefined) {use_ticket_protocol = abap.builtin.abap_true;}
    let host = INPUT?.host || new abap.types.String({qualifiedName: "STRING"});
    let port = INPUT?.port || new abap.types.String({qualifiedName: "STRING"});
    let out_protocol = INPUT?.out_protocol || new abap.types.String({qualifiedName: "STRING"});
    let vh_switch = INPUT?.vh_switch || new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return url_part;
  }
  async if_http_server$get_xsrf_token(INPUT) {
    let token = INPUT?.token || new abap.types.String({qualifiedName: "STRING"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_server$send_page() {
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_server$set_compression(INPUT) {
    let options = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.options) {options.set(INPUT.options);}
    if (INPUT === undefined || INPUT.options === undefined) {options = abap.Classes['IF_HTTP_SERVER'].if_http_server$co_compress_based_on_mime_type;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_server$set_page(INPUT) {
    let response_page_type = new abap.types.Character(1, {"qualifiedName":"CHAR1","ddicName":"CHAR1"});
    if (INPUT && INPUT.response_page_type) {response_page_type.set(INPUT.response_page_type);}
    if (INPUT === undefined || INPUT.response_page_type === undefined) {response_page_type = abap.Classes['IF_HTTP_SERVER'].if_http_server$co_page_error_type;}
    let response_option = new abap.types.Character(1, {"qualifiedName":"CHAR1","ddicName":"CHAR1"});
    if (INPUT && INPUT.response_option) {response_option.set(INPUT.response_option);}
    if (INPUT === undefined || INPUT.response_option === undefined) {response_option = abap.Classes['IF_HTTP_SERVER'].if_http_server$co_response_page_option;}
    let response_option_page = INPUT?.response_option_page || new abap.types.Character(4);
    let response_option_redirect_url = INPUT?.response_option_redirect_url || new abap.types.Character(4);
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_server$set_session_stateful_via_url(INPUT) {
    let stateful = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.stateful) {stateful.set(INPUT.stateful);}
    if (INPUT === undefined || INPUT.stateful === undefined) {stateful = abap.Classes['IF_HTTP_SERVER'].if_http_server$co_enabled;}
    let rewrite_url = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.rewrite_url) {rewrite_url = INPUT.rewrite_url;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_http_server$unescape_url(INPUT) {
    return cl_http_server.if_http_server$unescape_url(INPUT);
  }
  static async if_http_server$unescape_url(INPUT) {
    let unescaped = new abap.types.String({qualifiedName: "STRING"});
    let escaped = INPUT?.escaped;
    if (escaped?.getQualifiedName === undefined || escaped.getQualifiedName() !== "STRING") { escaped = undefined; }
    if (escaped === undefined) { escaped = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.escaped); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return unescaped;
  }
  async if_http_server$validate_xsrf_token(INPUT) {
    let token = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.token) {token.set(INPUT.token);}
    let successful = INPUT?.successful || new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async get_location(INPUT) {
    return cl_http_server.get_location(INPUT);
  }
  static async get_location(INPUT) {
    let application = INPUT?.application || new abap.types.Character();
    let port = INPUT?.port || new abap.types.String({qualifiedName: "STRING"});
    let out_protocol = INPUT?.out_protocol || new abap.types.String({qualifiedName: "STRING"});
    let host = INPUT?.host || new abap.types.String({qualifiedName: "STRING"});
    host.set(new abap.types.Character(13).set('open-abap.org'));
  }
}
abap.Classes['CL_HTTP_SERVER'] = cl_http_server;
cl_http_server.c_compression_supported = new abap.types.Integer({qualifiedName: "I"});
cl_http_server.if_http_server$session_id = new abap.types.String({qualifiedName: "STRING"});
cl_http_server.if_http_server$authentication_method = new abap.types.Integer({qualifiedName: "I"});
cl_http_server.if_http_server$authenticated = new abap.types.Integer({qualifiedName: "I"});
cl_http_server.if_http_server$authmethod_service = new abap.types.Integer({qualifiedName: "I"});
cl_http_server.if_http_server$authmethod_service.set(4);
cl_http_server.if_http_server$co_compress_based_on_mime_type = new abap.types.Integer({qualifiedName: "I"});
cl_http_server.if_http_server$co_compress_based_on_mime_type.set(2);
cl_http_server.if_http_server$co_disabled = new abap.types.Integer({qualifiedName: "I"});
cl_http_server.if_http_server$co_disabled.set(0);
cl_http_server.if_http_server$co_enabled = new abap.types.Integer({qualifiedName: "I"});
cl_http_server.if_http_server$co_enabled.set(1);
cl_http_server.if_http_server$co_page_error_type = new abap.types.Character(1, {});
cl_http_server.if_http_server$co_page_error_type.set('1');
cl_http_server.if_http_server$co_response_page_option = new abap.types.Character(1, {});
cl_http_server.if_http_server$co_response_page_option.set(' ');
cl_http_server.co_enabled = cl_http_server.if_http_server$co_enabled;

//# sourceMappingURL=cl_http_server.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_http_utility.clas.mjs":
/*!*****************************************!*\
  !*** ./output/cl_http_utility.clas.mjs ***!
  \*****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_http_utility": () => (/* binding */ cl_http_utility)
/* harmony export */ });
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_http_utility.clas.abap
class cl_http_utility {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_HTTP_UTILITY';
  static IMPLEMENTED_INTERFACES = ["IF_HTTP_UTILITY"];
  static ATTRIBUTES = {};
  static METHODS = {"DECODE_X_BASE64": {"visibility": "U", "parameters": {"DECODED": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "ENCODED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "ENCODE_X_BASE64": {"visibility": "U", "parameters": {"ENCODED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "UNENCODED": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "SET_QUERY": {"visibility": "U", "parameters": {"REQUEST": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_REQUEST", RTTIName: "\\INTERFACE=IF_HTTP_REQUEST"});}, "is_optional": " "}, "QUERY": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_REQUEST_URI": {"visibility": "U", "parameters": {"REQUEST": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_REQUEST", RTTIName: "\\INTERFACE=IF_HTTP_REQUEST"});}, "is_optional": " "}, "URI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "ESCAPE_XML_ATTR_VALUE": {"visibility": "U", "parameters": {"ESCAPED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "UNESCAPED": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "ESCAPE_HTML": {"visibility": "U", "parameters": {"ESCAPED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "UNESCAPED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "KEEP_NUM_CHAR_REF": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "ESCAPE_JAVASCRIPT": {"visibility": "U", "parameters": {"ESCAPED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "UNESCAPED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "INSIDE_HTML": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.decode_base64 = this.if_http_utility$decode_base64;
    this.encode_base64 = this.if_http_utility$encode_base64;
    this.escape_url = this.if_http_utility$escape_url;
    this.fields_to_string = this.if_http_utility$fields_to_string;
    this.get_last_error = this.if_http_utility$get_last_error;
    this.string_to_fields = this.if_http_utility$string_to_fields;
    this.unescape_url = this.if_http_utility$unescape_url;
    this.normalize_url = this.if_http_utility$normalize_url;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async set_request_uri(INPUT) {
    return cl_http_utility.set_request_uri(INPUT);
  }
  static async set_request_uri(INPUT) {
    let request = INPUT?.request;
    if (request?.getQualifiedName === undefined || request.getQualifiedName() !== "IF_HTTP_REQUEST") { request = undefined; }
    if (request === undefined) { request = new abap.types.ABAPObject({qualifiedName: "IF_HTTP_REQUEST", RTTIName: "\\INTERFACE=IF_HTTP_REQUEST"}).set(INPUT.request); }
    let uri = INPUT?.uri;
    if (uri?.getQualifiedName === undefined || uri.getQualifiedName() !== "STRING") { uri = undefined; }
    if (uri === undefined) { uri = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.uri); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async escape_html(INPUT) {
    return cl_http_utility.escape_html(INPUT);
  }
  static async escape_html(INPUT) {
    let escaped = new abap.types.String({qualifiedName: "STRING"});
    let unescaped = INPUT?.unescaped;
    if (unescaped?.getQualifiedName === undefined || unescaped.getQualifiedName() !== "STRING") { unescaped = undefined; }
    if (unescaped === undefined) { unescaped = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.unescaped); }
    let keep_num_char_ref = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.keep_num_char_ref) {keep_num_char_ref.set(INPUT.keep_num_char_ref);}
    if (INPUT === undefined || INPUT.keep_num_char_ref === undefined) {keep_num_char_ref = abap.builtin.abap_undefined;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return escaped;
  }
  async escape_javascript(INPUT) {
    return cl_http_utility.escape_javascript(INPUT);
  }
  static async escape_javascript(INPUT) {
    let escaped = new abap.types.String({qualifiedName: "STRING"});
    let unescaped = INPUT?.unescaped;
    if (unescaped?.getQualifiedName === undefined || unescaped.getQualifiedName() !== "STRING") { unescaped = undefined; }
    if (unescaped === undefined) { unescaped = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.unescaped); }
    let inside_html = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.inside_html) {inside_html.set(INPUT.inside_html);}
    if (INPUT === undefined || INPUT.inside_html === undefined) {inside_html = abap.builtin.abap_false;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return escaped;
  }
  async escape_xml_attr_value(INPUT) {
    return cl_http_utility.escape_xml_attr_value(INPUT);
  }
  static async escape_xml_attr_value(INPUT) {
    let escaped = new abap.types.String({qualifiedName: "STRING"});
    let unescaped = INPUT?.unescaped;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return escaped;
  }
  async if_http_utility$get_last_error() {
    return cl_http_utility.if_http_utility$get_last_error();
  }
  static async if_http_utility$get_last_error() {
    let rc = new abap.types.Integer({qualifiedName: "I"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return rc;
  }
  async if_http_utility$string_to_fields(INPUT) {
    return cl_http_utility.if_http_utility$string_to_fields(INPUT);
  }
  static async if_http_utility$string_to_fields(INPUT) {
    let fields = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");
    let string = INPUT?.string;
    if (string?.getQualifiedName === undefined || string.getQualifiedName() !== "STRING") { string = undefined; }
    if (string === undefined) { string = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.string); }
    let ignore_parenthesis = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.ignore_parenthesis) {ignore_parenthesis.set(INPUT.ignore_parenthesis);}
    if (INPUT === undefined || INPUT.ignore_parenthesis === undefined) {ignore_parenthesis = abap.IntegerFactory.get(0);}
    let tab = abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "");
    let str = new abap.types.String({qualifiedName: "STRING"});
    let ls_field = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {});
    abap.statements.assert(abap.compare.eq(ignore_parenthesis, abap.IntegerFactory.get(0)));
    abap.statements.split({source: string, at: new abap.types.Character(1).set('&'), table: tab});
    for await (const unique40 of abap.statements.loop(tab)) {
      str.set(unique40);
      abap.statements.split({source: str, at: new abap.types.Character(1).set('='), targets: [ls_field.get().name,ls_field.get().value]});
      abap.statements.append({source: ls_field, target: fields});
    }
    return fields;
  }
  async set_query(INPUT) {
    return cl_http_utility.set_query(INPUT);
  }
  static async set_query(INPUT) {
    let request = INPUT?.request;
    if (request?.getQualifiedName === undefined || request.getQualifiedName() !== "IF_HTTP_REQUEST") { request = undefined; }
    if (request === undefined) { request = new abap.types.ABAPObject({qualifiedName: "IF_HTTP_REQUEST", RTTIName: "\\INTERFACE=IF_HTTP_REQUEST"}).set(INPUT.request); }
    let query = INPUT?.query;
    if (query?.getQualifiedName === undefined || query.getQualifiedName() !== "STRING") { query = undefined; }
    if (query === undefined) { query = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.query); }
    await request.get().if_http_entity$set_form_fields({fields: (await this.if_http_utility$string_to_fields({string: query}))});
  }
  async if_http_utility$normalize_url(INPUT) {
    return cl_http_utility.if_http_utility$normalize_url(INPUT);
  }
  static async if_http_utility$normalize_url(INPUT) {
    let normalized = new abap.types.String({qualifiedName: "STRING"});
    let unnormalized = INPUT?.unnormalized;
    if (unnormalized?.getQualifiedName === undefined || unnormalized.getQualifiedName() !== "STRING") { unnormalized = undefined; }
    if (unnormalized === undefined) { unnormalized = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.unnormalized); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return normalized;
  }
  async if_http_utility$fields_to_string(INPUT) {
    return cl_http_utility.if_http_utility$fields_to_string(INPUT);
  }
  static async if_http_utility$fields_to_string(INPUT) {
    let string = new abap.types.String({qualifiedName: "STRING"});
    let fields = INPUT?.fields;
    if (fields?.getQualifiedName === undefined || fields.getQualifiedName() !== "TIHTTPNVP") { fields = undefined; }
    if (fields === undefined) { fields = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP").set(INPUT.fields); }
    let tab = abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "");
    let str = new abap.types.String({qualifiedName: "STRING"});
    let ls_field = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {});
    for await (const unique41 of abap.statements.loop(fields)) {
      ls_field.set(unique41);
      ls_field.get().value.set((await this.if_http_utility$escape_url({unescaped: ls_field.get().value})));
      str.set(abap.operators.concat(ls_field.get().name,abap.operators.concat(new abap.types.Character(1).set('='),ls_field.get().value)));
      abap.statements.append({source: str, target: tab});
    }
    string.set(abap.builtin.concat_lines_of({table: tab, sep: new abap.types.Character(1).set('&')}));
    return string;
  }
  async encode_x_base64(INPUT) {
    return cl_http_utility.encode_x_base64(INPUT);
  }
  static async encode_x_base64(INPUT) {
    let encoded = new abap.types.String({qualifiedName: "STRING"});
    let unencoded = INPUT?.unencoded;
    if (unencoded?.getQualifiedName === undefined || unencoded.getQualifiedName() !== "XSTRING") { unencoded = undefined; }
    if (unencoded === undefined) { unencoded = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.unencoded); }
    let buffer = Buffer.from(unencoded.get(), "hex");
    encoded.set(buffer.toString("base64"));
    return encoded;
  }
  async decode_x_base64(INPUT) {
    return cl_http_utility.decode_x_base64(INPUT);
  }
  static async decode_x_base64(INPUT) {
    let decoded = new abap.types.XString({qualifiedName: "XSTRING"});
    let encoded = INPUT?.encoded;
    if (encoded?.getQualifiedName === undefined || encoded.getQualifiedName() !== "STRING") { encoded = undefined; }
    if (encoded === undefined) { encoded = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.encoded); }
    let buffer = Buffer.from(encoded.get(), "base64");
    decoded.set(buffer.toString("hex").toUpperCase());
    return decoded;
  }
  async if_http_utility$unescape_url(INPUT) {
    return cl_http_utility.if_http_utility$unescape_url(INPUT);
  }
  static async if_http_utility$unescape_url(INPUT) {
    let unescaped = new abap.types.String({qualifiedName: "STRING"});
    let escaped = INPUT?.escaped;
    if (escaped?.getQualifiedName === undefined || escaped.getQualifiedName() !== "STRING") { escaped = undefined; }
    if (escaped === undefined) { escaped = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.escaped); }
    let options = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.options) {options.set(INPUT.options);}
    let foo = escaped.get();
    unescaped.set(decodeURIComponent(foo));
    return unescaped;
  }
  async if_http_utility$escape_url(INPUT) {
    return cl_http_utility.if_http_utility$escape_url(INPUT);
  }
  static async if_http_utility$escape_url(INPUT) {
    let escaped = new abap.types.String({qualifiedName: "STRING"});
    let unescaped = INPUT?.unescaped;
    if (unescaped?.getQualifiedName === undefined || unescaped.getQualifiedName() !== "STRING") { unescaped = undefined; }
    if (unescaped === undefined) { unescaped = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.unescaped); }
    let lv_index = new abap.types.Integer({qualifiedName: "I"});
    let lv_char = new abap.types.String({qualifiedName: "STRING"});
    const indexBackup1 = abap.builtin.sy.get().index.get();
    const unique42 = abap.builtin.strlen({val: unescaped}).get();
    for (let unique43 = 0; unique43 < unique42; unique43++) {
      abap.builtin.sy.get().index.set(unique43 + 1);
      lv_index.set(abap.operators.minus(abap.builtin.sy.get().index,abap.IntegerFactory.get(1)));
      lv_char.set(unescaped.getOffset({offset: lv_index, length: 1}));
      if (abap.compare.ca(abap.builtin.to_upper({val: lv_char}), abap.builtin.sy.get().abcde) || abap.compare.ca(lv_char, new abap.types.Character(14).set('0123456789.-()'))) {
        escaped.set(abap.operators.concat(escaped,lv_char));
      } else {
        escaped.set(abap.operators.concat(escaped,abap.operators.concat(new abap.types.Character(1).set('%'),(abap.builtin.to_lower({val: (await abap.Classes['CL_ABAP_CODEPAGE'].convert_to({source: lv_char}))})))));
      }
    }
    abap.builtin.sy.get().index.set(indexBackup1);
    return escaped;
  }
  async if_http_utility$encode_base64(INPUT) {
    return cl_http_utility.if_http_utility$encode_base64(INPUT);
  }
  static async if_http_utility$encode_base64(INPUT) {
    let encoded = new abap.types.String({qualifiedName: "STRING"});
    let unencoded = INPUT?.unencoded;
    if (unencoded?.getQualifiedName === undefined || unencoded.getQualifiedName() !== "STRING") { unencoded = undefined; }
    if (unencoded === undefined) { unencoded = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.unencoded); }
    let buffer = Buffer.from(unencoded.get());
    encoded.set(buffer.toString("base64"));
    return encoded;
  }
  async if_http_utility$decode_base64(INPUT) {
    return cl_http_utility.if_http_utility$decode_base64(INPUT);
  }
  static async if_http_utility$decode_base64(INPUT) {
    let decoded = new abap.types.String({qualifiedName: "STRING"});
    let encoded = INPUT?.encoded;
    if (encoded?.getQualifiedName === undefined || encoded.getQualifiedName() !== "STRING") { encoded = undefined; }
    if (encoded === undefined) { encoded = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.encoded); }
    let buffer = Buffer.from(encoded.get(), "base64");
    decoded.set(buffer.toString());
    return decoded;
  }
}
abap.Classes['CL_HTTP_UTILITY'] = cl_http_utility;

//# sourceMappingURL=cl_http_utility.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_i18n_languages.clas.mjs":
/*!*******************************************!*\
  !*** ./output/cl_i18n_languages.clas.mjs ***!
  \*******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_i18n_languages": () => (/* binding */ cl_i18n_languages)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_i18n_languages.clas.abap
class cl_i18n_languages {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_I18N_LANGUAGES';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"SAP1_TO_SAP2": {"visibility": "U", "parameters": {"RE_LANG_SAP2": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "IM_LANG_SAP1": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"sy-langu","conversionExit":"ISOLA"});}, "is_optional": " "}}},
  "SAP2_TO_SAP1": {"visibility": "U", "parameters": {"RE_LANG_SAP1": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"sy-langu","conversionExit":"ISOLA"});}, "is_optional": " "}, "IM_LANG_SAP2": {"type": () => {return new abap.types.Character(2, {"qualifiedName":"LAISO","ddicName":"LAISO"});}, "is_optional": " "}}},
  "SAP2_TO_ISO639_1": {"visibility": "U", "parameters": {"IM_LANG_SAP2": {"type": () => {return new abap.types.Character(2, {"qualifiedName":"LAISO","ddicName":"LAISO"});}, "is_optional": " "}, "EX_LANG_ISO639": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "EX_COUNTRY": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"LAND1","ddicName":"LAND1"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async sap2_to_sap1(INPUT) {
    return cl_i18n_languages.sap2_to_sap1(INPUT);
  }
  static async sap2_to_sap1(INPUT) {
    let re_lang_sap1 = new abap.types.Character(1, {"qualifiedName":"sy-langu","conversionExit":"ISOLA"});
    let im_lang_sap2 = INPUT?.im_lang_sap2;
    if (im_lang_sap2?.getQualifiedName === undefined || im_lang_sap2.getQualifiedName() !== "LAISO") { im_lang_sap2 = undefined; }
    if (im_lang_sap2 === undefined) { im_lang_sap2 = new abap.types.Character(2, {"qualifiedName":"LAISO","ddicName":"LAISO"}).set(INPUT.im_lang_sap2); }
    let unique16 = abap.builtin.to_upper({val: im_lang_sap2});
    if (abap.compare.eq(unique16, new abap.types.Character(2).set('SR'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('0'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('ZH'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('1'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('TH'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('2'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('KO'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('3'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('RO'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('4'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('SL'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('5'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('HR'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('6'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('MS'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('7'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('UK'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('8'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('ET'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('9'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('AR'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('A'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('HE'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('B'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('CS'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('C'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('DE'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('D'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('EN'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('E'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('FR'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('F'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('EL'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('G'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('HU'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('H'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('IT'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('I'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('JA'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('J'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('DA'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('K'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('PL'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('L'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('ZF'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('M'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('NL'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('N'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('NO'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('O'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('PT'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('P'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('SK'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('Q'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('RU'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('R'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('ES'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('S'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('TR'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('T'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('FI'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('U'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('SV'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('V'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('BG'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('W'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('LT'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('X'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('LV'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('Y'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('Z1'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('Z'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('AF'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('a'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('IS'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('b'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('CA'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('c'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('SH'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('d'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('ID'))) {
      re_lang_sap1.set(new abap.types.Character(1).set('i'));
    } else if (abap.compare.eq(unique16, new abap.types.Character(2).set('1Q'))) {
      re_lang_sap1.set(new abap.types.Character(1).set(''));
    } else {
      throw new abap.ClassicError({classic: "no_assignment"});
    }
    abap.builtin.sy.get().subrc.set(0);
    return re_lang_sap1;
  }
  async sap1_to_sap2(INPUT) {
    return cl_i18n_languages.sap1_to_sap2(INPUT);
  }
  static async sap1_to_sap2(INPUT) {
    let re_lang_sap2 = new abap.types.String({qualifiedName: "STRING"});
    let im_lang_sap1 = INPUT?.im_lang_sap1;
    if (im_lang_sap1?.getQualifiedName === undefined || im_lang_sap1.getQualifiedName() !== "SY-LANGU") { im_lang_sap1 = undefined; }
    if (im_lang_sap1 === undefined) { im_lang_sap1 = new abap.types.Character(1, {"qualifiedName":"sy-langu","conversionExit":"ISOLA"}).set(INPUT.im_lang_sap1); }
    let unique17 = im_lang_sap1;
    if (abap.compare.eq(unique17, new abap.types.Character(1).set('0'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('SR'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('1'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('ZH'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('2'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('TH'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('3'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('KO'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('4'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('RO'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('5'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('SL'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('6'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('HR'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('7'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('MS'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('8'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('UK'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('9'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('ET'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('A'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('AR'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('B'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('HE'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('C'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('CS'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('D'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('DE'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('E'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('EN'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('F'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('FR'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('G'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('EL'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('H'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('HU'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('I'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('IT'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('J'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('JA'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('K'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('DA'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('L'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('PL'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('M'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('ZF'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('N'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('NL'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('O'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('NO'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('P'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('PT'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('Q'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('SK'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('R'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('RU'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('S'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('ES'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('T'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('TR'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('U'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('FI'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('V'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('SV'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('W'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('BG'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('X'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('LT'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('Y'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('LV'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('Z'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('Z1'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('a'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('AF'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('b'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('IS'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('c'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('CA'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('d'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('SH'));
    } else if (abap.compare.eq(unique17, new abap.types.Character(1).set('i'))) {
      re_lang_sap2.set(new abap.types.Character(2).set('ID'));
    } else {
      throw new abap.ClassicError({classic: "no_assignment"});
    }
    abap.builtin.sy.get().subrc.set(0);
    return re_lang_sap2;
  }
  async sap2_to_iso639_1(INPUT) {
    return cl_i18n_languages.sap2_to_iso639_1(INPUT);
  }
  static async sap2_to_iso639_1(INPUT) {
    let im_lang_sap2 = INPUT?.im_lang_sap2;
    if (im_lang_sap2?.getQualifiedName === undefined || im_lang_sap2.getQualifiedName() !== "LAISO") { im_lang_sap2 = undefined; }
    if (im_lang_sap2 === undefined) { im_lang_sap2 = new abap.types.Character(2, {"qualifiedName":"LAISO","ddicName":"LAISO"}).set(INPUT.im_lang_sap2); }
    let ex_lang_iso639 = INPUT?.ex_lang_iso639 || new abap.types.String({qualifiedName: "STRING"});
    let ex_country = INPUT?.ex_country || new abap.types.Character(3, {"qualifiedName":"LAND1","ddicName":"LAND1"});
    let unique18 = im_lang_sap2;
    if (abap.compare.eq(unique18, new abap.types.Character(2).set('SR'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('sr'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('ZH'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('zh'));
      ex_country.set(new abap.types.Character(2).set('CN'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('TH'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('th'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('KO'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('ko'));
      ex_country.set(new abap.types.Character(2).set('KR'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('RO'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('ro'));
      ex_country.set(new abap.types.Character(2).set('RO'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('SL'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('sl'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('HR'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('hr'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('MS'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('ms'));
      ex_country.set(new abap.types.Character(2).set('MY'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('UK'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('uk'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('ET'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('et'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('AR'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('ar'));
      ex_country.set(new abap.types.Character(2).set('SA'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('HE'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('he'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('CS'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('cs'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('DE'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('de'));
      ex_country.set(new abap.types.Character(2).set('DE'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('EN'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('en'));
      ex_country.set(new abap.types.Character(2).set('US'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('FR'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('fr'));
      ex_country.set(new abap.types.Character(2).set('FR'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('EL'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('el'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('HU'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('hu'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('IT'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('it'));
      ex_country.set(new abap.types.Character(2).set('IT'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('JA'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('ja'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('DA'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('da'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('PL'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('pl'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('ZF'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('zh'));
      ex_country.set(new abap.types.Character(2).set('TW'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('NL'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('nl'));
      ex_country.set(new abap.types.Character(2).set('NL'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('NO'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('no'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('PT'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('pt'));
      ex_country.set(new abap.types.Character(2).set('BR'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('SK'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('sk'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('RU'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('ru'));
      ex_country.set(new abap.types.Character(2).set('RU'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('ES'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('es'));
      ex_country.set(new abap.types.Character(2).set('ES'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('TR'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('tr'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('FI'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('fi'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('SV'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('sv'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('BG'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('bg'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('LT'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('lt'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('LV'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('lv'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('AF'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('af'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('IS'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('is'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('CA'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('ca'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('SH'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('sr'));
    } else if (abap.compare.eq(unique18, new abap.types.Character(2).set('ID'))) {
      ex_lang_iso639.set(new abap.types.Character(2).set('id'));
    } else {
      throw new abap.ClassicError({classic: "no_assignment"});
    }
    abap.builtin.sy.get().subrc.set(0);
  }
}
abap.Classes['CL_I18N_LANGUAGES'] = cl_i18n_languages;

//# sourceMappingURL=cl_i18n_languages.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_icf_tree.clas.mjs":
/*!*************************************!*\
  !*** ./output/cl_icf_tree.clas.mjs ***!
  \*************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_icf_tree": () => (/* binding */ cl_icf_tree)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_icf_tree.clas.abap
class cl_icf_tree {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_ICF_TREE';
  static IMPLEMENTED_INTERFACES = ["IF_ICF_TREE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async if_icf_tree$service_from_url(INPUT) {
    return cl_icf_tree.if_icf_tree$service_from_url(INPUT);
  }
  static async if_icf_tree$service_from_url(INPUT) {
    let url = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.url) {url.set(INPUT.url);}
    if (INPUT === undefined || INPUT.url === undefined) {url = new abap.types.Character(1).set('/');}
    let hostnumber = INPUT?.hostnumber;
    if (hostnumber?.getQualifiedName === undefined || hostnumber.getQualifiedName() !== "I") { hostnumber = undefined; }
    if (hostnumber === undefined) { hostnumber = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.hostnumber); }
    let authority_check = INPUT?.authority_check || new abap.types.Character();
    if (INPUT === undefined || INPUT.authority_check === undefined) {authority_check = new abap.types.Character(1).set('X');}
    let urlsuffix = INPUT?.urlsuffix || new abap.types.String({qualifiedName: "STRING"});
    let icfnodguid = INPUT?.icfnodguid || new abap.types.Character(25, {"qualifiedName":"CHAR25","ddicName":"CHAR25"});
    let icf_name = INPUT?.icf_name || new abap.types.Character(15, {"qualifiedName":"CHAR15","ddicName":"CHAR15"});
    let icfactive = INPUT?.icfactive || new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    let icfaltnme = INPUT?.icfaltnme || new abap.types.String({qualifiedName: "STRING"});
    return;
    abap.builtin.sy.get().subrc.set(0);
  }
}
abap.Classes['CL_ICF_TREE'] = cl_icf_tree;

//# sourceMappingURL=cl_icf_tree.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_ixml.clas.mjs":
/*!*********************************!*\
  !*** ./output/cl_ixml.clas.mjs ***!
  \*********************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_ixml": () => (/* binding */ cl_ixml)
/* harmony export */ });
await __webpack_require__.e(/*! import() */ "output_cl_ixml_clas_locals_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_ixml.clas.locals.mjs */ "./output/cl_ixml.clas.locals.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_ixml.clas.abap
class cl_ixml {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_IXML';
  static IMPLEMENTED_INTERFACES = ["IF_IXML"];
  static ATTRIBUTES = {};
  static METHODS = {"CREATE": {"visibility": "U", "parameters": {"XML": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML", RTTIName: "\\INTERFACE=IF_IXML"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async create() {
    return cl_ixml.create();
  }
  static async create() {
    let xml = new abap.types.ABAPObject({qualifiedName: "IF_IXML", RTTIName: "\\INTERFACE=IF_IXML"});
    xml.set(await (new abap.Classes['CL_IXML']()).constructor_());
    return xml;
  }
  async if_ixml$create_encoding(INPUT) {
    let rval = new abap.types.ABAPObject({qualifiedName: "IF_IXML_ENCODING", RTTIName: "\\INTERFACE=IF_IXML_ENCODING"});
    let byte_order = INPUT?.byte_order;
    if (byte_order?.getQualifiedName === undefined || byte_order.getQualifiedName() !== "I") { byte_order = undefined; }
    if (byte_order === undefined) { byte_order = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.byte_order); }
    let character_set = INPUT?.character_set;
    if (character_set?.getQualifiedName === undefined || character_set.getQualifiedName() !== "STRING") { character_set = undefined; }
    if (character_set === undefined) { character_set = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.character_set); }
    rval.set(await (new abap.Classes['CLAS-CL_IXML-LCL_ENCODING']()).constructor_());
    return rval;
  }
  async if_ixml$create_document() {
    let doc = new abap.types.ABAPObject({qualifiedName: "IF_IXML_DOCUMENT", RTTIName: "\\INTERFACE=IF_IXML_DOCUMENT"});
    doc.set(await (new abap.Classes['CLAS-CL_IXML-LCL_DOCUMENT']()).constructor_());
    return doc;
  }
  async if_ixml$create_stream_factory() {
    let stream = new abap.types.ABAPObject({qualifiedName: "IF_IXML_STREAM_FACTORY", RTTIName: "\\INTERFACE=IF_IXML_STREAM_FACTORY"});
    stream.set(await (new abap.Classes['CLAS-CL_IXML-LCL_STREAM_FACTORY']()).constructor_());
    return stream;
  }
  async if_ixml$create_renderer(INPUT) {
    let renderer = new abap.types.ABAPObject({qualifiedName: "IF_IXML_RENDERER", RTTIName: "\\INTERFACE=IF_IXML_RENDERER"});
    let ostream = INPUT?.ostream;
    if (ostream?.getQualifiedName === undefined || ostream.getQualifiedName() !== "IF_IXML_OSTREAM") { ostream = undefined; }
    if (ostream === undefined) { ostream = new abap.types.ABAPObject({qualifiedName: "IF_IXML_OSTREAM", RTTIName: "\\INTERFACE=IF_IXML_OSTREAM"}).set(INPUT.ostream); }
    let document = INPUT?.document;
    if (document?.getQualifiedName === undefined || document.getQualifiedName() !== "IF_IXML_DOCUMENT") { document = undefined; }
    if (document === undefined) { document = new abap.types.ABAPObject({qualifiedName: "IF_IXML_DOCUMENT", RTTIName: "\\INTERFACE=IF_IXML_DOCUMENT"}).set(INPUT.document); }
    renderer.set(await (new abap.Classes['CLAS-CL_IXML-LCL_RENDERER']()).constructor_({ostream: ostream, document: document}));
    return renderer;
  }
  async if_ixml$create_parser(INPUT) {
    let parser = new abap.types.ABAPObject({qualifiedName: "IF_IXML_PARSER", RTTIName: "\\INTERFACE=IF_IXML_PARSER"});
    let stream_factory = INPUT?.stream_factory;
    if (stream_factory?.getQualifiedName === undefined || stream_factory.getQualifiedName() !== "IF_IXML_STREAM_FACTORY") { stream_factory = undefined; }
    if (stream_factory === undefined) { stream_factory = new abap.types.ABAPObject({qualifiedName: "IF_IXML_STREAM_FACTORY", RTTIName: "\\INTERFACE=IF_IXML_STREAM_FACTORY"}).set(INPUT.stream_factory); }
    let istream = INPUT?.istream;
    if (istream?.getQualifiedName === undefined || istream.getQualifiedName() !== "IF_IXML_ISTREAM") { istream = undefined; }
    if (istream === undefined) { istream = new abap.types.ABAPObject({qualifiedName: "IF_IXML_ISTREAM", RTTIName: "\\INTERFACE=IF_IXML_ISTREAM"}).set(INPUT.istream); }
    let document = INPUT?.document;
    if (document?.getQualifiedName === undefined || document.getQualifiedName() !== "IF_IXML_DOCUMENT") { document = undefined; }
    if (document === undefined) { document = new abap.types.ABAPObject({qualifiedName: "IF_IXML_DOCUMENT", RTTIName: "\\INTERFACE=IF_IXML_DOCUMENT"}).set(INPUT.document); }
    parser.set(await (new abap.Classes['CLAS-CL_IXML-LCL_PARSER']()).constructor_({istream: istream, document: document}));
    return parser;
  }
}
abap.Classes['CL_IXML'] = cl_ixml;

//# sourceMappingURL=cl_ixml.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_message_helper.clas.mjs":
/*!*******************************************!*\
  !*** ./output/cl_message_helper.clas.mjs ***!
  \*******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_message_helper": () => (/* binding */ cl_message_helper)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_message_helper.clas.abap
class cl_message_helper {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_MESSAGE_HELPER';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"GC_FALLBACK": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "I", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"SET_MSG_VARS_FOR_IF_MSG": {"visibility": "U", "parameters": {"TEXT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_MESSAGE", RTTIName: "\\INTERFACE=IF_MESSAGE"});}, "is_optional": " "}, "STRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_MSG_VARS_FOR_CLIKE": {"visibility": "U", "parameters": {"TEXT": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "GET_TEXT_FOR_MESSAGE": {"visibility": "U", "parameters": {"RESULT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "TEXT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_MESSAGE", RTTIName: "\\INTERFACE=IF_MESSAGE"});}, "is_optional": " "}}},
  "CHECK_MSG_KIND": {"visibility": "U", "parameters": {"MSG": {"type": () => {return new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});}, "is_optional": " "}, "T100KEY": {"type": () => {return new abap.types.Structure({"msgid": new abap.types.Character(20, {}), "msgno": new abap.types.Numc({length: 3}), "attr1": new abap.types.Character(255, {}), "attr2": new abap.types.Character(255, {}), "attr3": new abap.types.Character(255, {}), "attr4": new abap.types.Character(255, {})}, "SCX_T100KEY", "SCX_T100KEY", {}, {});}, "is_optional": " "}, "TEXTID": {"type": () => {return new abap.types.Character(32, {"qualifiedName":"SOTR_CONC","ddicName":"SOTR_CONC"});}, "is_optional": " "}}},
  "GET_OTR_TEXT_RAW": {"visibility": "U", "parameters": {"TEXTID": {"type": () => {return new abap.types.Character(32, {"qualifiedName":"SOTR_CONC","ddicName":"SOTR_CONC"});}, "is_optional": " "}, "RESULT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "REPLACE_TEXT_PARAMS": {"visibility": "U", "parameters": {"OBJ": {"type": () => {return new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});}, "is_optional": " "}, "RESULT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.gc_fallback = cl_message_helper.gc_fallback;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async get_otr_text_raw(INPUT) {
    return cl_message_helper.get_otr_text_raw(INPUT);
  }
  static async get_otr_text_raw(INPUT) {
    let textid = INPUT?.textid;
    if (textid?.getQualifiedName === undefined || textid.getQualifiedName() !== "SOTR_CONC") { textid = undefined; }
    if (textid === undefined) { textid = new abap.types.Character(32, {"qualifiedName":"SOTR_CONC","ddicName":"SOTR_CONC"}).set(INPUT.textid); }
    let result = INPUT?.result || new abap.types.String({qualifiedName: "STRING"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async replace_text_params(INPUT) {
    return cl_message_helper.replace_text_params(INPUT);
  }
  static async replace_text_params(INPUT) {
    let obj = INPUT?.obj;
    if (obj === undefined) { obj = new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined}).set(INPUT.obj); }
    let result = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.result) {result = INPUT.result;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async get_text_for_message(INPUT) {
    return cl_message_helper.get_text_for_message(INPUT);
  }
  static async get_text_for_message(INPUT) {
    let result = new abap.types.String({qualifiedName: "STRING"});
    let text = INPUT?.text;
    if (text?.getQualifiedName === undefined || text.getQualifiedName() !== "IF_MESSAGE") { text = undefined; }
    if (text === undefined) { text = new abap.types.ABAPObject({qualifiedName: "IF_MESSAGE", RTTIName: "\\INTERFACE=IF_MESSAGE"}).set(INPUT.text); }
    let lv_msgid = new abap.types.Character(20, {"qualifiedName":"sy-msgid"});
    let lv_msgno = new abap.types.Numc({length: 3, qualifiedName: "sy-msgno"});
    let lv_msgv1 = new abap.types.Character(50, {"qualifiedName":"sy-msgv1"});
    let lv_msgv2 = new abap.types.Character(50, {"qualifiedName":"sy-msgv2"});
    let lv_msgv3 = new abap.types.Character(50, {"qualifiedName":"sy-msgv3"});
    let lv_msgv4 = new abap.types.Character(50, {"qualifiedName":"sy-msgv4"});
    if (text.get()?.if_t100_message$t100key === undefined) { result.set(this.gc_fallback); return result; };
    lv_msgid.set(text.get().if_t100_message$t100key.get().msgid);
    lv_msgno.set(text.get().if_t100_message$t100key.get().msgno);
    lv_msgv1.set(text.get()[text.get().if_t100_message$t100key.get().attr1.get().toLowerCase().replace("~", "$").trimEnd()] ? text.get()[text.get().if_t100_message$t100key.get().attr1.get().toLowerCase().replace("~", "$").trimEnd()].get() : "");
    lv_msgv2.set(text.get()[text.get().if_t100_message$t100key.get().attr2.get().toLowerCase().replace("~", "$").trimEnd()] ? text.get()[text.get().if_t100_message$t100key.get().attr2.get().toLowerCase().replace("~", "$").trimEnd()].get() : "");
    lv_msgv3.set(text.get()[text.get().if_t100_message$t100key.get().attr3.get().toLowerCase().replace("~", "$").trimEnd()] ? text.get()[text.get().if_t100_message$t100key.get().attr3.get().toLowerCase().replace("~", "$").trimEnd()].get() : "");
    lv_msgv4.set(text.get()[text.get().if_t100_message$t100key.get().attr4.get().toLowerCase().replace("~", "$").trimEnd()] ? text.get()[text.get().if_t100_message$t100key.get().attr4.get().toLowerCase().replace("~", "$").trimEnd()].get() : "");
    await abap.statements.message({into: result, id: lv_msgid, type: new abap.types.Character(1).set('I'), number: lv_msgno, with: [lv_msgv1,lv_msgv2,lv_msgv3,lv_msgv4]});
    return result;
  }
  async set_msg_vars_for_if_msg(INPUT) {
    return cl_message_helper.set_msg_vars_for_if_msg(INPUT);
  }
  static async set_msg_vars_for_if_msg(INPUT) {
    let text = INPUT?.text;
    if (text?.getQualifiedName === undefined || text.getQualifiedName() !== "IF_MESSAGE") { text = undefined; }
    if (text === undefined) { text = new abap.types.ABAPObject({qualifiedName: "IF_MESSAGE", RTTIName: "\\INTERFACE=IF_MESSAGE"}).set(INPUT.text); }
    let string = INPUT?.string || new abap.types.String({qualifiedName: "STRING"});
    if (abap.compare.initial(text)) {
      const unique19 = await (new abap.Classes['CX_SY_MESSAGE_ILLEGAL_TEXT']()).constructor_();
      unique19.EXTRA_CX = {"INTERNAL_FILENAME": "cl_message_helper.clas.abap","INTERNAL_LINE": 76};
      throw unique19;
    }
    string.set((await this.get_text_for_message({text: text})));
    if (abap.compare.ne(string, cl_message_helper.gc_fallback)) {
      abap.statements.clear(abap.builtin.sy.get().msgty);
      return;
    }
    string.set((await text.get().if_message$get_text()));
    if (abap.compare.initial(string)) {
      abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    }
    await this.set_msg_vars_for_clike({text: string});
  }
  async set_msg_vars_for_clike(INPUT) {
    return cl_message_helper.set_msg_vars_for_clike(INPUT);
  }
  static async set_msg_vars_for_clike(INPUT) {
    let text = INPUT?.text;
    let lv_char200 = new abap.types.Character(200, {});
    lv_char200.set(text);
    abap.builtin.sy.get().msgid.set(new abap.types.Character(2).set('00'));
    abap.builtin.sy.get().msgno.set(new abap.types.Character(3).set('001'));
    abap.builtin.sy.get().msgv1.set(lv_char200);
    if (abap.compare.eq(lv_char200.getOffset({offset: 49, length: 1}), abap.builtin.space)) {
      lv_char200.set(lv_char200.getOffset({offset: 49}));
    } else {
      lv_char200.set(text.getOffset({offset: 50}));
    }
    abap.builtin.sy.get().msgv2.set(lv_char200);
    if (abap.compare.eq(lv_char200.getOffset({offset: 49, length: 1}), abap.builtin.space)) {
      lv_char200.set(lv_char200.getOffset({offset: 49}));
    } else {
      lv_char200.set(lv_char200.getOffset({offset: 50}));
    }
    abap.builtin.sy.get().msgv3.set(lv_char200);
    if (abap.compare.eq(lv_char200.getOffset({offset: 49, length: 1}), abap.builtin.space)) {
      lv_char200.set(lv_char200.getOffset({offset: 49}));
    } else {
      lv_char200.set(lv_char200.getOffset({offset: 50}));
    }
    abap.builtin.sy.get().msgv4.set(lv_char200);
  }
  async check_msg_kind(INPUT) {
    return cl_message_helper.check_msg_kind(INPUT);
  }
  static async check_msg_kind(INPUT) {
    let msg = INPUT?.msg;
    if (msg === undefined) { msg = new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined}).set(INPUT.msg); }
    let t100key = INPUT?.t100key || new abap.types.Structure({"msgid": new abap.types.Character(20, {}), "msgno": new abap.types.Numc({length: 3}), "attr1": new abap.types.Character(255, {}), "attr2": new abap.types.Character(255, {}), "attr3": new abap.types.Character(255, {}), "attr4": new abap.types.Character(255, {})}, "SCX_T100KEY", "SCX_T100KEY", {}, {});
    let textid = INPUT?.textid || new abap.types.Character(32, {"qualifiedName":"SOTR_CONC","ddicName":"SOTR_CONC"});
    let li_t100_message = new abap.types.ABAPObject({qualifiedName: "IF_T100_MESSAGE", RTTIName: "\\INTERFACE=IF_T100_MESSAGE"});
    try {
      await abap.statements.cast(li_t100_message, msg);
      t100key.set(li_t100_message.get().if_t100_message$t100key);
    } catch (e) {
      if ((abap.Classes['CX_SY_MOVE_CAST_ERROR'] && e instanceof abap.Classes['CX_SY_MOVE_CAST_ERROR'])) {
        abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
      } else {
        throw e;
      }
    }
  }
}
abap.Classes['CL_MESSAGE_HELPER'] = cl_message_helper;
cl_message_helper.gc_fallback = new abap.types.String({qualifiedName: "STRING"});
cl_message_helper.gc_fallback.set('An exception was raised.');

//# sourceMappingURL=cl_message_helper.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_mime_repository_api.clas.mjs":
/*!************************************************!*\
  !*** ./output/cl_mime_repository_api.clas.mjs ***!
  \************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_mime_repository_api": () => (/* binding */ cl_mime_repository_api)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_mime_repository_api.clas.abap
class cl_mime_repository_api {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_MIME_REPOSITORY_API';
  static IMPLEMENTED_INTERFACES = ["IF_MR_API"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.get_api = this.if_mr_api$get_api;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async if_mr_api$get_api(INPUT) {
    return cl_mime_repository_api.if_mr_api$get_api(INPUT);
  }
  static async if_mr_api$get_api(INPUT) {
    let r_mr_api = new abap.types.ABAPObject({qualifiedName: "IF_MR_API", RTTIName: "\\INTERFACE=IF_MR_API"});
    let i_prefix = INPUT?.i_prefix || new abap.types.Character();
    if (INPUT === undefined || INPUT.i_prefix === undefined) {i_prefix = abap.builtin.space;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return r_mr_api;
  }
  async if_mr_api$get(INPUT) {
    let i_url = INPUT?.i_url;
    let i_check_authority = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_check_authority) {i_check_authority.set(INPUT.i_check_authority);}
    if (INPUT === undefined || INPUT.i_check_authority === undefined) {i_check_authority = abap.builtin.abap_true;}
    let e_is_folder = INPUT?.e_is_folder || new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    let e_content = INPUT?.e_content || new abap.types.XString({qualifiedName: "XSTRING"});
    let e_mime_type = INPUT?.e_mime_type || new abap.types.Character();
    let e_loio = INPUT?.e_loio || new abap.types.Structure({"objtype": new abap.types.Character(1, {"qualifiedName":"SKWF_IOTY","ddicName":"SKWF_IOTY"}), "object": new abap.types.Structure({"class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SDOKOBJECT", "SDOKOBJECT", {}, {}), "class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SKWF_IO", "SKWF_IO", {}, {});
    let c_language = new abap.types.Character(1, {"qualifiedName":"LANGU","ddicName":"LANGU"});
    if (INPUT && INPUT.c_language) {c_language = INPUT.c_language;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_mr_api$create_folder(INPUT) {
    let i_url = INPUT?.i_url;
    let i_language = new abap.types.Character(1, {"qualifiedName":"LANGU","ddicName":"LANGU"});
    if (INPUT && INPUT.i_language) {i_language.set(INPUT.i_language);}
    if (INPUT === undefined || INPUT.i_language === undefined) {i_language = abap.builtin.sy.get().langu;}
    let i_description = INPUT?.i_description || new abap.types.Character();
    let i_check_authority = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_check_authority) {i_check_authority.set(INPUT.i_check_authority);}
    if (INPUT === undefined || INPUT.i_check_authority === undefined) {i_check_authority = abap.builtin.abap_true;}
    let i_suppress_package_dialog = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_suppress_package_dialog) {i_suppress_package_dialog.set(INPUT.i_suppress_package_dialog);}
    if (INPUT === undefined || INPUT.i_suppress_package_dialog === undefined) {i_suppress_package_dialog = abap.builtin.space;}
    let i_dev_package = new abap.types.Character(30, {"qualifiedName":"DEVCLASS","ddicName":"DEVCLASS"});
    if (INPUT && INPUT.i_dev_package) {i_dev_package.set(INPUT.i_dev_package);}
    let i_genflag = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_genflag) {i_genflag.set(INPUT.i_genflag);}
    if (INPUT === undefined || INPUT.i_genflag === undefined) {i_genflag = abap.builtin.abap_false;}
    let i_corr_number = new abap.types.Character(20, {"qualifiedName":"TRKORR","ddicName":"TRKORR"});
    if (INPUT && INPUT.i_corr_number) {i_corr_number.set(INPUT.i_corr_number);}
    let i_folder_loio = new abap.types.Structure({"objtype": new abap.types.Character(1, {"qualifiedName":"SKWF_IOTY","ddicName":"SKWF_IOTY"}), "object": new abap.types.Structure({"class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SDOKOBJECT", "SDOKOBJECT", {}, {}), "class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SKWF_IO", "SKWF_IO", {}, {});
    if (INPUT && INPUT.i_folder_loio) {i_folder_loio.set(INPUT.i_folder_loio);}
    let i_suppress_dialogs = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_suppress_dialogs) {i_suppress_dialogs.set(INPUT.i_suppress_dialogs);}
    let e_folder_io = INPUT?.e_folder_io || new abap.types.Structure({"objtype": new abap.types.Character(1, {"qualifiedName":"SKWF_IOTY","ddicName":"SKWF_IOTY"}), "object": new abap.types.Structure({"class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SDOKOBJECT", "SDOKOBJECT", {}, {}), "class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SKWF_IO", "SKWF_IO", {}, {});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_mr_api$put(INPUT) {
    let i_url = INPUT?.i_url;
    let i_content = INPUT?.i_content;
    if (i_content?.getQualifiedName === undefined || i_content.getQualifiedName() !== "XSTRING") { i_content = undefined; }
    if (i_content === undefined) { i_content = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.i_content); }
    let i_language = new abap.types.Character(1, {"qualifiedName":"LANGU","ddicName":"LANGU"});
    if (INPUT && INPUT.i_language) {i_language.set(INPUT.i_language);}
    if (INPUT === undefined || INPUT.i_language === undefined) {i_language = abap.builtin.sy.get().langu;}
    let i_description = INPUT?.i_description || new abap.types.Character();
    let i_check_authority = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_check_authority) {i_check_authority.set(INPUT.i_check_authority);}
    if (INPUT === undefined || INPUT.i_check_authority === undefined) {i_check_authority = abap.builtin.abap_true;}
    let i_suppress_package_dialog = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_suppress_package_dialog) {i_suppress_package_dialog.set(INPUT.i_suppress_package_dialog);}
    if (INPUT === undefined || INPUT.i_suppress_package_dialog === undefined) {i_suppress_package_dialog = abap.builtin.space;}
    let i_dev_package = new abap.types.Character(30, {"qualifiedName":"DEVCLASS","ddicName":"DEVCLASS"});
    if (INPUT && INPUT.i_dev_package) {i_dev_package.set(INPUT.i_dev_package);}
    let i_genflag = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_genflag) {i_genflag.set(INPUT.i_genflag);}
    if (INPUT === undefined || INPUT.i_genflag === undefined) {i_genflag = abap.builtin.abap_false;}
    let i_corr_number = new abap.types.Character(20, {"qualifiedName":"TRKORR","ddicName":"TRKORR"});
    if (INPUT && INPUT.i_corr_number) {i_corr_number.set(INPUT.i_corr_number);}
    let i_new_loio = new abap.types.Structure({"objtype": new abap.types.Character(1, {"qualifiedName":"SKWF_IOTY","ddicName":"SKWF_IOTY"}), "object": new abap.types.Structure({"class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SDOKOBJECT", "SDOKOBJECT", {}, {}), "class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SKWF_IO", "SKWF_IO", {}, {});
    if (INPUT && INPUT.i_new_loio) {i_new_loio.set(INPUT.i_new_loio);}
    let i_suppress_dialogs = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_suppress_dialogs) {i_suppress_dialogs.set(INPUT.i_suppress_dialogs);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_mr_api$delete(INPUT) {
    let i_url = INPUT?.i_url;
    let i_delete_children = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_delete_children) {i_delete_children.set(INPUT.i_delete_children);}
    if (INPUT === undefined || INPUT.i_delete_children === undefined) {i_delete_children = abap.builtin.abap_false;}
    let i_check_authority = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_check_authority) {i_check_authority.set(INPUT.i_check_authority);}
    if (INPUT === undefined || INPUT.i_check_authority === undefined) {i_check_authority = abap.builtin.abap_true;}
    let i_corr_number = new abap.types.Character(20, {"qualifiedName":"TRKORR","ddicName":"TRKORR"});
    if (INPUT && INPUT.i_corr_number) {i_corr_number.set(INPUT.i_corr_number);}
    let i_suppress_dialogs = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_suppress_dialogs) {i_suppress_dialogs.set(INPUT.i_suppress_dialogs);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_mr_api$file_list(INPUT) {
    let i_url = INPUT?.i_url;
    let i_recursive_call = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_recursive_call) {i_recursive_call.set(INPUT.i_recursive_call);}
    if (INPUT === undefined || INPUT.i_recursive_call === undefined) {i_recursive_call = abap.builtin.abap_false;}
    let i_check_authority = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_check_authority) {i_check_authority.set(INPUT.i_check_authority);}
    if (INPUT === undefined || INPUT.i_check_authority === undefined) {i_check_authority = abap.builtin.abap_true;}
    let e_files = INPUT?.e_files || abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "STRING_TABLE");
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_mr_api$properties(INPUT) {
    let i_url = INPUT?.i_url;
    let i_check_authority = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_check_authority) {i_check_authority.set(INPUT.i_check_authority);}
    if (INPUT === undefined || INPUT.i_check_authority === undefined) {i_check_authority = abap.builtin.abap_true;}
    let e_is_folder = INPUT?.e_is_folder || new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    let e_mime_type = INPUT?.e_mime_type || new abap.types.Character();
    let e_name = INPUT?.e_name || new abap.types.String({qualifiedName: "STRING"});
    let e_size = INPUT?.e_size || new abap.types.Integer({qualifiedName: "I"});
    let e_bin_data = INPUT?.e_bin_data || new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    let e_loio = INPUT?.e_loio || new abap.types.Structure({"objtype": new abap.types.Character(1, {"qualifiedName":"SKWF_IOTY","ddicName":"SKWF_IOTY"}), "object": new abap.types.Structure({"class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SDOKOBJECT", "SDOKOBJECT", {}, {}), "class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SKWF_IO", "SKWF_IO", {}, {});
    let e_phio = INPUT?.e_phio || new abap.types.Structure({"objtype": new abap.types.Character(1, {"qualifiedName":"SKWF_IOTY","ddicName":"SKWF_IOTY"}), "object": new abap.types.Structure({"class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SDOKOBJECT", "SDOKOBJECT", {}, {}), "class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SKWF_IO", "SKWF_IO", {}, {});
    let e_language = INPUT?.e_language || new abap.types.Character(1, {"qualifiedName":"LANGU","ddicName":"LANGU"});
    let e_phio_last_changed = INPUT?.e_phio_last_changed || new abap.types.String({qualifiedName: "STRING"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_mr_api$get_io_for_url(INPUT) {
    let i_url = INPUT?.i_url;
    let e_is_folder = INPUT?.e_is_folder || new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    let e_loio = INPUT?.e_loio || new abap.types.Structure({"objtype": new abap.types.Character(1, {"qualifiedName":"SKWF_IOTY","ddicName":"SKWF_IOTY"}), "object": new abap.types.Structure({"class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SDOKOBJECT", "SDOKOBJECT", {}, {}), "class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SKWF_IO", "SKWF_IO", {}, {});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
}
abap.Classes['CL_MIME_REPOSITORY_API'] = cl_mime_repository_api;

//# sourceMappingURL=cl_mime_repository_api.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_numberrange_runtime.clas.mjs":
/*!************************************************!*\
  !*** ./output/cl_numberrange_runtime.clas.mjs ***!
  \************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_numberrange_runtime": () => (/* binding */ cl_numberrange_runtime)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_numberrange_runtime.clas.abap
class cl_numberrange_runtime {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_NUMBERRANGE_RUNTIME';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"NUMBER_GET": {"visibility": "U", "parameters": {"NR_RANGE_NR": {"type": () => {return new abap.types.Character(2, {"qualifiedName":"cl_numberrange_runtime=>nr_interval"});}, "is_optional": " "}, "OBJECT": {"type": () => {return new abap.types.Character(10, {"qualifiedName":"cl_numberrange_runtime=>nr_object"});}, "is_optional": " "}, "NUMBER": {"type": () => {return new abap.types.Numc({length: 20, qualifiedName: "cl_numberrange_runtime=>nr_number"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async number_get(INPUT) {
    return cl_numberrange_runtime.number_get(INPUT);
  }
  static async number_get(INPUT) {
    let nr_range_nr = INPUT?.nr_range_nr;
    if (nr_range_nr?.getQualifiedName === undefined || nr_range_nr.getQualifiedName() !== "CL_NUMBERRANGE_RUNTIME=>NR_INTERVAL") { nr_range_nr = undefined; }
    if (nr_range_nr === undefined) { nr_range_nr = new abap.types.Character(2, {"qualifiedName":"cl_numberrange_runtime=>nr_interval"}).set(INPUT.nr_range_nr); }
    let object = INPUT?.object;
    if (object?.getQualifiedName === undefined || object.getQualifiedName() !== "CL_NUMBERRANGE_RUNTIME=>NR_OBJECT") { object = undefined; }
    if (object === undefined) { object = new abap.types.Character(10, {"qualifiedName":"cl_numberrange_runtime=>nr_object"}).set(INPUT.object); }
    let number = INPUT?.number || new abap.types.Numc({length: 20, qualifiedName: "cl_numberrange_runtime=>nr_number"});
    try {
      if (abap.FunctionModules['NUMBER_GET_NEXT'] === undefined && abap.Classes['CX_SY_DYN_CALL_ILLEGAL_FUNC'.trimEnd()] === undefined) { throw "CX_SY_DYN_CALL_ILLEGAL_FUNC not found"; }
      if (abap.FunctionModules['NUMBER_GET_NEXT'] === undefined) { throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_FUNC'.trimEnd()](); }
      await abap.FunctionModules['NUMBER_GET_NEXT']({exporting: {nr_range_nr: nr_range_nr, object: object}, importing: {number: number}});
      abap.builtin.sy.get().subrc.set(0);
    } catch (e) {
      if (e.classic) {
          switch (e.classic.toUpperCase()) {
          case "INTERVAL_NOT_FOUND": abap.builtin.sy.get().subrc.set(1); break;
          case "NUMBER_RANGE_NOT_INTERN": abap.builtin.sy.get().subrc.set(2); break;
          case "OBJECT_NOT_FOUND": abap.builtin.sy.get().subrc.set(3); break;
          case "QUANTITY_IS_0": abap.builtin.sy.get().subrc.set(4); break;
          case "QUANTITY_IS_NOT_1": abap.builtin.sy.get().subrc.set(5); break;
          case "INTERVAL_OVERFLOW": abap.builtin.sy.get().subrc.set(6); break;
          case "BUFFER_OVERFLOW": abap.builtin.sy.get().subrc.set(7); break;
          default: abap.builtin.sy.get().subrc.set(8); break;
            }
        } else {
            throw e;
        }
      }
      if (abap.compare.ne(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
        return;
      }
    }
  }
  abap.Classes['CL_NUMBERRANGE_RUNTIME'] = cl_numberrange_runtime;
  cl_numberrange_runtime.nr_interval = new abap.types.Character(2, {"qualifiedName":"cl_numberrange_runtime=>nr_interval"});
  cl_numberrange_runtime.nr_object = new abap.types.Character(10, {"qualifiedName":"cl_numberrange_runtime=>nr_object"});
  cl_numberrange_runtime.nr_number = new abap.types.Numc({length: 20, qualifiedName: "cl_numberrange_runtime=>nr_number"});

//# sourceMappingURL=cl_numberrange_runtime.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_oauth2_client.clas.mjs":
/*!******************************************!*\
  !*** ./output/cl_oauth2_client.clas.mjs ***!
  \******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_oauth2_client": () => (/* binding */ cl_oauth2_client)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_oauth2_client.clas.abap
class cl_oauth2_client {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_OAUTH2_CLIENT';
  static IMPLEMENTED_INTERFACES = ["IF_OAUTH2_CLIENT"];
  static ATTRIBUTES = {};
  static METHODS = {"CREATE": {"visibility": "U", "parameters": {"RO_OAUTH2_CLIENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_OAUTH2_CLIENT", RTTIName: "\\INTERFACE=IF_OAUTH2_CLIENT"});}, "is_optional": " "}, "I_PROFILE": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "I_CONFIGURATION": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async create(INPUT) {
    return cl_oauth2_client.create(INPUT);
  }
  static async create(INPUT) {
    let ro_oauth2_client = new abap.types.ABAPObject({qualifiedName: "IF_OAUTH2_CLIENT", RTTIName: "\\INTERFACE=IF_OAUTH2_CLIENT"});
    let i_profile = INPUT?.i_profile;
    let i_configuration = INPUT?.i_configuration || new abap.types.Character();
    abap.statements.write(new abap.types.Character(50).set('todo, cl_oauth2_client in open-abap-core, create()'),{newLine: true});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return ro_oauth2_client;
  }
  async if_oauth2_client$execute_cc_flow() {
    abap.statements.write(new abap.types.Character(59).set('todo, cl_oauth2_client in open-abap-core, execute_cc_flow()'),{newLine: true});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_oauth2_client$set_token(INPUT) {
    let ii_http_client = INPUT?.ii_http_client;
    if (ii_http_client?.getQualifiedName === undefined || ii_http_client.getQualifiedName() !== "IF_HTTP_CLIENT") { ii_http_client = undefined; }
    if (ii_http_client === undefined) { ii_http_client = new abap.types.ABAPObject({qualifiedName: "IF_HTTP_CLIENT", RTTIName: "\\INTERFACE=IF_HTTP_CLIENT"}).set(INPUT.ii_http_client); }
    abap.statements.write(new abap.types.Character(53).set('todo, cl_oauth2_client in open-abap-core, set_token()'),{newLine: true});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
}
abap.Classes['CL_OAUTH2_CLIENT'] = cl_oauth2_client;

//# sourceMappingURL=cl_oauth2_client.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_oo_factory.clas.mjs":
/*!***************************************!*\
  !*** ./output/cl_oo_factory.clas.mjs ***!
  \***************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_oo_factory": () => (/* binding */ cl_oo_factory)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_oo_factory.clas.abap
class cl_oo_factory {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_OO_FACTORY';
  static IMPLEMENTED_INTERFACES = ["IF_OO_CLIF_SOURCE"];
  static ATTRIBUTES = {"MV_NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "I", "is_constant": " ", "is_class": " "}};
  static METHODS = {"CREATE_INSTANCE": {"visibility": "U", "parameters": {"RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_OO_FACTORY", RTTIName: "\\CLASS=CL_OO_FACTORY"});}, "is_optional": " "}}},
  "CREATE_CLIF_SOURCE": {"visibility": "U", "parameters": {"RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_OO_CLIF_SOURCE", RTTIName: "\\INTERFACE=IF_OO_CLIF_SOURCE"});}, "is_optional": " "}, "CLIF_NAME": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.mv_name = new abap.types.String({qualifiedName: "STRING"});
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async create_instance() {
    return cl_oo_factory.create_instance();
  }
  static async create_instance() {
    let result = new abap.types.ABAPObject({qualifiedName: "CL_OO_FACTORY", RTTIName: "\\CLASS=CL_OO_FACTORY"});
    result.set(await (new abap.Classes['CL_OO_FACTORY']()).constructor_());
    return result;
  }
  async create_clif_source(INPUT) {
    let result = new abap.types.ABAPObject({qualifiedName: "IF_OO_CLIF_SOURCE", RTTIName: "\\INTERFACE=IF_OO_CLIF_SOURCE"});
    let clif_name = INPUT?.clif_name;
    result.set(this.me);
    this.mv_name.set(abap.builtin.to_upper({val: clif_name}));
    return result;
  }
  async if_oo_clif_source$get_source(INPUT) {
    let source = INPUT?.source || abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "STRING_TABLE");
    let ls_data = new abap.types.Structure({"progname": new abap.types.Character(40, {}), "data": new abap.types.String({qualifiedName: "STRING"}), "unam": new abap.types.Character(12, {}), "udat": new abap.types.Date(), "utime": new abap.types.Time()}, "REPOSRC", "REPOSRC", {}, {});
    await abap.statements.select(ls_data, {select: "SELECT * FROM " + abap.buildDbTableName("reposrc") + " WHERE \"progname\" = '" + this.mv_name.get() + "' UP TO 1 ROWS", primaryKey: ["progname"]});
    abap.statements.split({source: ls_data.get().data, at: new abap.types.String().set(`\n`), table: source});
  }
}
abap.Classes['CL_OO_FACTORY'] = cl_oo_factory;

//# sourceMappingURL=cl_oo_factory.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_osql_test_environment.clas.mjs":
/*!**************************************************!*\
  !*** ./output/cl_osql_test_environment.clas.mjs ***!
  \**************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_osql_test_environment": () => (/* binding */ cl_osql_test_environment)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_osql_test_environment.clas.abap
class cl_osql_test_environment {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_OSQL_TEST_ENVIRONMENT';
  static IMPLEMENTED_INTERFACES = ["IF_OSQL_TEST_ENVIRONMENT"];
  static ATTRIBUTES = {"MT_TABLES": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Character(30, {"qualifiedName":"abap_compname"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "if_osql_test_environment=>ty_t_sobjnames");}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MO_SQL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_SQL_STATEMENT", RTTIName: "\\CLASS=CL_SQL_STATEMENT"});}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MV_SCHEMA": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "I", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"INITIALIZE": {"visibility": "I", "parameters": {}},
  "VALIDATE": {"visibility": "I", "parameters": {}},
  "SET_RUNTIME_PREFIX": {"visibility": "I", "parameters": {}},
  "CREATE": {"visibility": "U", "parameters": {"R_RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_OSQL_TEST_ENVIRONMENT", RTTIName: "\\INTERFACE=IF_OSQL_TEST_ENVIRONMENT"});}, "is_optional": " "}, "I_DEPENDENCY_LIST": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Character(30, {"qualifiedName":"abap_compname"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "if_osql_test_environment=>ty_t_sobjnames");}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.mt_tables = abap.types.TableFactory.construct(new abap.types.Character(30, {"qualifiedName":"abap_compname"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "if_osql_test_environment=>ty_t_sobjnames");
    this.mo_sql = new abap.types.ABAPObject({qualifiedName: "CL_SQL_STATEMENT", RTTIName: "\\CLASS=CL_SQL_STATEMENT"});
    this.mv_schema = cl_osql_test_environment.mv_schema;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async create(INPUT) {
    return cl_osql_test_environment.create(INPUT);
  }
  static async create(INPUT) {
    let r_result = new abap.types.ABAPObject({qualifiedName: "IF_OSQL_TEST_ENVIRONMENT", RTTIName: "\\INTERFACE=IF_OSQL_TEST_ENVIRONMENT"});
    let i_dependency_list = INPUT?.i_dependency_list;
    if (i_dependency_list?.getQualifiedName === undefined || i_dependency_list.getQualifiedName() !== "IF_OSQL_TEST_ENVIRONMENT=>TY_T_SOBJNAMES") { i_dependency_list = undefined; }
    if (i_dependency_list === undefined) { i_dependency_list = abap.types.TableFactory.construct(new abap.types.Character(30, {"qualifiedName":"abap_compname"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "if_osql_test_environment=>ty_t_sobjnames").set(INPUT.i_dependency_list); }
    let lo_env = new abap.types.ABAPObject({qualifiedName: "CL_OSQL_TEST_ENVIRONMENT", RTTIName: "\\CLASS=CL_OSQL_TEST_ENVIRONMENT"});
    abap.statements.assert(abap.compare.eq(abap.builtin.sy.get().dbsys, new abap.types.Character(6).set('sqlite')));
    lo_env.set(await (new abap.Classes['CL_OSQL_TEST_ENVIRONMENT']()).constructor_());
    lo_env.get().mt_tables.set(i_dependency_list);
    lo_env.get().mo_sql.set(await (new abap.Classes['CL_SQL_STATEMENT']()).constructor_());
    await lo_env.get().initialize();
    r_result.set(lo_env);
    return r_result;
  }
  async validate() {
    let ref = new abap.types.DataReference(new abap.types.Character(4));
    let lv_table = new abap.types.Character(30, {"qualifiedName":"abap_compname"});
    let fs_fs_ = new abap.types.FieldSymbol(new abap.types.Character(4));
    for await (const unique177 of abap.statements.loop(this.mt_tables)) {
      lv_table.set(unique177);
      try {
        abap.statements.createData(ref,{"name": lv_table.get()});
        abap.statements.assign({target: fs_fs_, source: (ref).dereference()});
        await abap.statements.select(fs_fs_, {select: "SELECT * FROM " + abap.buildDbTableName(lv_table.get().trimEnd().toLowerCase()) + " UP TO 1 ROWS"});
      } catch (e) {
        if ((abap.Classes['CX_SY_CREATE_DATA_ERROR'] && e instanceof abap.Classes['CX_SY_CREATE_DATA_ERROR']) || (abap.Classes['CX_SY_DYNAMIC_OSQL_SEMANTICS'] && e instanceof abap.Classes['CX_SY_DYNAMIC_OSQL_SEMANTICS'])) {
          throw new Error(`table ${lv_table.get().trimEnd()} invalid or does not exist`);
        } else {
          throw e;
        }
      }
    }
  }
  async initialize() {
    let lv_table = new abap.types.Character(30, {"qualifiedName":"abap_compname"});
    let lv_sql = new abap.types.String({qualifiedName: "STRING"});
    let lo_result = new abap.types.ABAPObject({qualifiedName: "CL_SQL_RESULT_SET", RTTIName: "\\CLASS=CL_SQL_RESULT_SET"});
    let lr_ref = new abap.types.DataReference(new abap.types.Character(4));
    if (abap.dbo.schemaPrefix !== "") throw new Error("already prefixed");
    await this.validate();
    await this.mo_sql.get().execute_update({statement: new abap.types.String().set(`ATTACH DATABASE ':memory:' AS ${abap.templateFormatting(cl_osql_test_environment.mv_schema)};`)});
    for await (const unique178 of abap.statements.loop(this.mt_tables)) {
      lv_table.set(unique178);
      lv_table.set(abap.builtin.to_lower({val: lv_table}));
      lo_result.set((await this.mo_sql.get().execute_query({statement: new abap.types.String().set(`SELECT sql FROM main.sqlite_master WHERE type='table' AND name='${abap.templateFormatting(lv_table)}';`)})));
      lr_ref.assign(lv_sql);
      await lo_result.get().set_param({data_ref: lr_ref});
      await lo_result.get().next();
      await lo_result.get().close();
      abap.statements.replace({target: lv_sql, all: false, with: new abap.types.String().set(`${abap.templateFormatting(cl_osql_test_environment.mv_schema)}'.'${abap.templateFormatting(lv_table)}`), of: lv_table});
      abap.statements.assert(abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0)));
      await this.mo_sql.get().execute_update({statement: lv_sql});
    }
    await this.set_runtime_prefix();
  }
  async set_runtime_prefix() {
    abap.dbo.schemaPrefix = this.mv_schema.get();
  }
  async if_osql_test_environment$clear_doubles() {
    let lv_table = new abap.types.Character(30, {"qualifiedName":"abap_compname"});
    for await (const unique179 of abap.statements.loop(this.mt_tables)) {
      lv_table.set(unique179);
      lv_table.set(abap.builtin.to_lower({val: lv_table}));
      await this.mo_sql.get().execute_update({statement: new abap.types.String().set(`DELETE FROM ${abap.templateFormatting(cl_osql_test_environment.mv_schema)}."${abap.templateFormatting(lv_table)}";`)});
    }
  }
  async if_osql_test_environment$destroy() {
    await this.mo_sql.get().execute_update({statement: new abap.types.String().set(`DETACH DATABASE ${abap.templateFormatting(cl_osql_test_environment.mv_schema)};`)});
    abap.dbo.schemaPrefix = "";
  }
  async if_osql_test_environment$insert_test_data(INPUT) {
    let i_data = INPUT?.i_data;
    let lo_table_descr = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TABLEDESCR", RTTIName: "\\CLASS=CL_ABAP_TABLEDESCR"});
    let lo_struct_descr = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_STRUCTDESCR", RTTIName: "\\CLASS=CL_ABAP_STRUCTDESCR"});
    let lv_table = new abap.types.String({qualifiedName: "STRING"});
    await abap.statements.cast(lo_table_descr, (await abap.Classes['CL_ABAP_TYPEDESCR'].describe_by_data({p_data: i_data})));
    await abap.statements.cast(lo_struct_descr, (await lo_table_descr.get().get_table_line_type()));
    lv_table.set((await lo_struct_descr.get().get_relative_name()));
    abap.statements.assert(abap.compare.initial(lv_table) === false);
    abap.statements.readTable(this.mt_tables,{withKey: (i) => {return abap.compare.eq(i.table_line, lv_table);},
      withKeyValue: [{key: (i) => {return i.table_line}, value: lv_table}],
      usesTableLine: true,
      withKeySimple: {"table_line": lv_table}});
    abap.statements.assert(abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0)));
    await abap.statements.insertDatabase(lv_table.get().trimEnd().toLowerCase(), {"table": i_data});
    abap.statements.assert(abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0)));
  }
}
abap.Classes['CL_OSQL_TEST_ENVIRONMENT'] = cl_osql_test_environment;
cl_osql_test_environment.mv_schema = new abap.types.String({qualifiedName: "STRING"});
cl_osql_test_environment.mv_schema.set('double');

//# sourceMappingURL=cl_osql_test_environment.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_progress_indicator.clas.mjs":
/*!***********************************************!*\
  !*** ./output/cl_progress_indicator.clas.mjs ***!
  \***********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_progress_indicator": () => (/* binding */ cl_progress_indicator)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_progress_indicator.clas.abap
class cl_progress_indicator {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_PROGRESS_INDICATOR';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"PROGRESS_INDICATE": {"visibility": "U", "parameters": {"I_TEXT": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "I_PROCESSED": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "I_TOTAL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "I_OUTPUT_IMMEDIATELY": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "E_PROGRESS_SENT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async progress_indicate(INPUT) {
    return cl_progress_indicator.progress_indicate(INPUT);
  }
  static async progress_indicate(INPUT) {
    let i_text = INPUT?.i_text || new abap.types.Character(4);
    let i_processed = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.i_processed) {i_processed.set(INPUT.i_processed);}
    let i_total = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.i_total) {i_total.set(INPUT.i_total);}
    let i_output_immediately = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.i_output_immediately) {i_output_immediately.set(INPUT.i_output_immediately);}
    let e_progress_sent = INPUT?.e_progress_sent || new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    return;
  }
}
abap.Classes['CL_PROGRESS_INDICATOR'] = cl_progress_indicator;

//# sourceMappingURL=cl_progress_indicator.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_salv_aggregations.clas.mjs":
/*!**********************************************!*\
  !*** ./output/cl_salv_aggregations.clas.mjs ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_salv_aggregations": () => (/* binding */ cl_salv_aggregations)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_salv_aggregations.clas.abap
class cl_salv_aggregations {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_SALV_AGGREGATIONS';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"ADD_AGGREGATION": {"visibility": "U", "parameters": {"COLUMNNAME": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "AGGREGATION": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async add_aggregation(INPUT) {
    let columnname = INPUT?.columnname;
    let aggregation = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.aggregation) {aggregation.set(INPUT.aggregation);}
    if (INPUT === undefined || INPUT.aggregation === undefined) {aggregation = abap.Classes['IF_SALV_C_AGGREGATION'].if_salv_c_aggregation$total;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
}
abap.Classes['CL_SALV_AGGREGATIONS'] = cl_salv_aggregations;

//# sourceMappingURL=cl_salv_aggregations.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_salv_column.clas.mjs":
/*!****************************************!*\
  !*** ./output/cl_salv_column.clas.mjs ***!
  \****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_salv_column": () => (/* binding */ cl_salv_column)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_salv_column.clas.abap
class cl_salv_column {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_SALV_COLUMN';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"SET_TECHNICAL": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "SET_SHORT_TEXT": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_MEDIUM_TEXT": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_LONG_TEXT": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_OUTPUT_LENGTH": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "SET_SIGN": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async set_technical(INPUT) {
    let value = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.value) {value.set(INPUT.value);}
    if (INPUT === undefined || INPUT.value === undefined) {value = abap.builtin.abap_true;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async set_short_text(INPUT) {
    let value = INPUT?.value;
    if (value?.getQualifiedName === undefined || value.getQualifiedName() !== "STRING") { value = undefined; }
    if (value === undefined) { value = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.value); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async set_medium_text(INPUT) {
    let value = INPUT?.value;
    if (value?.getQualifiedName === undefined || value.getQualifiedName() !== "STRING") { value = undefined; }
    if (value === undefined) { value = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.value); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async set_long_text(INPUT) {
    let value = INPUT?.value;
    if (value?.getQualifiedName === undefined || value.getQualifiedName() !== "STRING") { value = undefined; }
    if (value === undefined) { value = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.value); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async set_output_length(INPUT) {
    let value = INPUT?.value;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async set_sign(INPUT) {
    let value = INPUT?.value || new abap.types.Character(4);
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
}
abap.Classes['CL_SALV_COLUMN'] = cl_salv_column;

//# sourceMappingURL=cl_salv_column.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_salv_columns_table.clas.mjs":
/*!***********************************************!*\
  !*** ./output/cl_salv_columns_table.clas.mjs ***!
  \***********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_salv_columns_table": () => (/* binding */ cl_salv_columns_table)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_salv_columns_table.clas.abap
class cl_salv_columns_table {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_SALV_COLUMNS_TABLE';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"SET_CELL_TYPE_COLUMN": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_OPTIMIZE": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "SET_COLOR_COLUMN": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_COLUMN": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_SALV_COLUMN", RTTIName: "\\CLASS=CL_SALV_COLUMN"});}, "is_optional": " "}, "COLUMNNAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_EXCEPTION_COLUMN": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "SET_HYPERLINK_ENTRY_COLUMN": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async set_hyperlink_entry_column(INPUT) {
    let value = INPUT?.value;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async get_column(INPUT) {
    let value = new abap.types.ABAPObject({qualifiedName: "CL_SALV_COLUMN", RTTIName: "\\CLASS=CL_SALV_COLUMN"});
    let columnname = INPUT?.columnname;
    if (columnname?.getQualifiedName === undefined || columnname.getQualifiedName() !== "STRING") { columnname = undefined; }
    if (columnname === undefined) { columnname = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.columnname); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return value;
  }
  async set_exception_column(INPUT) {
    let value = INPUT?.value;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async set_cell_type_column(INPUT) {
    let value = INPUT?.value;
    if (value?.getQualifiedName === undefined || value.getQualifiedName() !== "STRING") { value = undefined; }
    if (value === undefined) { value = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.value); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async set_optimize(INPUT) {
    let value = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.value) {value.set(INPUT.value);}
    if (INPUT === undefined || INPUT.value === undefined) {value = abap.builtin.abap_true;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async get() {
    let value = new abap.types.String({qualifiedName: "STRING"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return value;
  }
  async set_color_column(INPUT) {
    let value = INPUT?.value;
    if (value?.getQualifiedName === undefined || value.getQualifiedName() !== "STRING") { value = undefined; }
    if (value === undefined) { value = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.value); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
}
abap.Classes['CL_SALV_COLUMNS_TABLE'] = cl_salv_columns_table;

//# sourceMappingURL=cl_salv_columns_table.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_salv_events_table.clas.mjs":
/*!**********************************************!*\
  !*** ./output/cl_salv_events_table.clas.mjs ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_salv_events_table": () => (/* binding */ cl_salv_events_table)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_salv_events_table.clas.abap
class cl_salv_events_table {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_SALV_EVENTS_TABLE';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CL_SALV_EVENTS_TABLE'] = cl_salv_events_table;

//# sourceMappingURL=cl_salv_events_table.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_salv_filters.clas.mjs":
/*!*****************************************!*\
  !*** ./output/cl_salv_filters.clas.mjs ***!
  \*****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_salv_filters": () => (/* binding */ cl_salv_filters)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_salv_filters.clas.abap
class cl_salv_filters {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_SALV_FILTERS';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CL_SALV_FILTERS'] = cl_salv_filters;

//# sourceMappingURL=cl_salv_filters.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_salv_functional_settings.clas.mjs":
/*!*****************************************************!*\
  !*** ./output/cl_salv_functional_settings.clas.mjs ***!
  \*****************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_salv_functional_settings": () => (/* binding */ cl_salv_functional_settings)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_salv_functional_settings.clas.abap
class cl_salv_functional_settings {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_SALV_FUNCTIONAL_SETTINGS';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"GET_HYPERLINKS": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_SALV_HYPERLINKS", RTTIName: "\\CLASS=CL_SALV_HYPERLINKS"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async get_hyperlinks() {
    let value = new abap.types.ABAPObject({qualifiedName: "CL_SALV_HYPERLINKS", RTTIName: "\\CLASS=CL_SALV_HYPERLINKS"});
    return value;
    return value;
  }
}
abap.Classes['CL_SALV_FUNCTIONAL_SETTINGS'] = cl_salv_functional_settings;

//# sourceMappingURL=cl_salv_functional_settings.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_salv_functions_list.clas.mjs":
/*!************************************************!*\
  !*** ./output/cl_salv_functions_list.clas.mjs ***!
  \************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_salv_functions_list": () => (/* binding */ cl_salv_functions_list)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_salv_functions_list.clas.abap
class cl_salv_functions_list {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_SALV_FUNCTIONS_LIST';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"SET_ALL": {"visibility": "U", "parameters": {"FLAG": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "GET_FUNCTIONS": {"visibility": "U", "parameters": {"SDF": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_DEFAULT": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "ADD_FUNCTION": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "ICON": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "TEXT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "TOOLTIP": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "POSITION": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async set_all(INPUT) {
    let flag = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.flag) {flag.set(INPUT.flag);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async get_functions() {
    let sdf = new abap.types.String({qualifiedName: "STRING"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return sdf;
  }
  async set_default(INPUT) {
    let value = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.value) {value.set(INPUT.value);}
    if (INPUT === undefined || INPUT.value === undefined) {value = abap.builtin.abap_true;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async add_function(INPUT) {
    let name = INPUT?.name;
    let icon = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.icon) {icon.set(INPUT.icon);}
    let text = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.text) {text.set(INPUT.text);}
    let tooltip = INPUT?.tooltip;
    if (tooltip?.getQualifiedName === undefined || tooltip.getQualifiedName() !== "STRING") { tooltip = undefined; }
    if (tooltip === undefined) { tooltip = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.tooltip); }
    let position = INPUT?.position;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
}
abap.Classes['CL_SALV_FUNCTIONS_LIST'] = cl_salv_functions_list;

//# sourceMappingURL=cl_salv_functions_list.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_salv_hyperlinks.clas.mjs":
/*!********************************************!*\
  !*** ./output/cl_salv_hyperlinks.clas.mjs ***!
  \********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_salv_hyperlinks": () => (/* binding */ cl_salv_hyperlinks)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_salv_hyperlinks.clas.abap
class cl_salv_hyperlinks {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_SALV_HYPERLINKS';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"ADD_HYPERLINK": {"visibility": "U", "parameters": {"HANDLE": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "HYPERLINK": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async add_hyperlink(INPUT) {
    let handle = INPUT?.handle;
    let hyperlink = INPUT?.hyperlink || new abap.types.Character(4);
    return;
  }
}
abap.Classes['CL_SALV_HYPERLINKS'] = cl_salv_hyperlinks;

//# sourceMappingURL=cl_salv_hyperlinks.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_salv_layout.clas.mjs":
/*!****************************************!*\
  !*** ./output/cl_salv_layout.clas.mjs ***!
  \****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_salv_layout": () => (/* binding */ cl_salv_layout)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_salv_layout.clas.abap
class cl_salv_layout {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_SALV_LAYOUT';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"RESTRICT_NONE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"SET_KEY": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "SET_SAVE_RESTRICTION": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "SET_DEFAULT": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "HAS_DEFAULT": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "SET_INITIAL_LAYOUT": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.restrict_none = cl_salv_layout.restrict_none;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async set_key(INPUT) {
    let value = INPUT?.value;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(13).set('not supported')));
  }
  async set_initial_layout(INPUT) {
    let value = INPUT?.value;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(13).set('not supported')));
  }
  async set_save_restriction(INPUT) {
    let value = INPUT?.value || new abap.types.Character(4);
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(13).set('not supported')));
  }
  async set_default(INPUT) {
    let value = INPUT?.value;
    if (value?.getQualifiedName === undefined || value.getQualifiedName() !== "ABAP_BOOL") { value = undefined; }
    if (value === undefined) { value = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}).set(INPUT.value); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(13).set('not supported')));
  }
  async has_default() {
    let value = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(13).set('not supported')));
    return value;
  }
}
abap.Classes['CL_SALV_LAYOUT'] = cl_salv_layout;
cl_salv_layout.restrict_none = new abap.types.Integer({qualifiedName: "I"});
cl_salv_layout.restrict_none.set(3);

//# sourceMappingURL=cl_salv_layout.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_salv_sorts.clas.mjs":
/*!***************************************!*\
  !*** ./output/cl_salv_sorts.clas.mjs ***!
  \***************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_salv_sorts": () => (/* binding */ cl_salv_sorts)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_salv_sorts.clas.abap
class cl_salv_sorts {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_SALV_SORTS';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"ADD_SORT": {"visibility": "U", "parameters": {"COLUMNNAME": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "SUBTOTAL": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async add_sort(INPUT) {
    let columnname = INPUT?.columnname;
    let subtotal = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.subtotal) {subtotal.set(INPUT.subtotal);}
    if (INPUT === undefined || INPUT.subtotal === undefined) {subtotal = abap.builtin.abap_false;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
}
abap.Classes['CL_SALV_SORTS'] = cl_salv_sorts;

//# sourceMappingURL=cl_salv_sorts.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_salv_table.clas.mjs":
/*!***************************************!*\
  !*** ./output/cl_salv_table.clas.mjs ***!
  \***************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_salv_table": () => (/* binding */ cl_salv_table)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_salv_table.clas.abap
class cl_salv_table {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_SALV_TABLE';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"C_FUNCTIONS_ALL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"FACTORY": {"visibility": "U", "parameters": {"LIST_DISPLAY": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "R_CONTAINER": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "R_SALV_TABLE": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "T_TABLE": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "GET_SELECTIONS": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_SALV_TABLE", RTTIName: "\\CLASS=CL_SALV_TABLE"});}, "is_optional": " "}}},
  "SET_SELECTED_ROWS": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "SET_SELECTION_MODE": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_SELECTED_ROWS": {"visibility": "U", "parameters": {"ROWS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Integer({qualifiedName: "I"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "cl_salv_table=>ty_rows");}, "is_optional": " "}}},
  "CLOSE_SCREEN": {"visibility": "U", "parameters": {}},
  "REFRESH": {"visibility": "U", "parameters": {"REFRESH_MODE": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "DISPLAY": {"visibility": "U", "parameters": {}},
  "IS_OFFLINE": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "GET_METADATA": {"visibility": "U", "parameters": {}},
  "GET_LAYOUT": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_SALV_LAYOUT", RTTIName: "\\CLASS=CL_SALV_LAYOUT"});}, "is_optional": " "}}},
  "SET_SCREEN_STATUS": {"visibility": "U", "parameters": {"PFSTATUS": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "SET_FUNCTIONS": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "REPORT": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "SET_SCREEN_POPUP": {"visibility": "U", "parameters": {"START_COLUMN": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "END_COLUMN": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "START_LINE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "END_LINE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_EVENT": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_SALV_EVENTS_TABLE", RTTIName: "\\CLASS=CL_SALV_EVENTS_TABLE"});}, "is_optional": " "}}},
  "GET_DISPLAY_SETTINGS": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_SALV_TABLE", RTTIName: "\\CLASS=CL_SALV_TABLE"});}, "is_optional": " "}}},
  "SET_STRIPED_PATTERN": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "SET_LIST_HEADER": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "SET_TOP_OF_LIST": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "GET_COLUMNS": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_SALV_COLUMNS_TABLE", RTTIName: "\\CLASS=CL_SALV_COLUMNS_TABLE"});}, "is_optional": " "}}},
  "GET_FUNCTIONS": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_SALV_FUNCTIONS_LIST", RTTIName: "\\CLASS=CL_SALV_FUNCTIONS_LIST"});}, "is_optional": " "}}},
  "GET_AGGREGATIONS": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_SALV_AGGREGATIONS", RTTIName: "\\CLASS=CL_SALV_AGGREGATIONS"});}, "is_optional": " "}}},
  "GET_FILTERS": {"visibility": "U", "parameters": {"FOO": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_SALV_FILTERS", RTTIName: "\\CLASS=CL_SALV_FILTERS"});}, "is_optional": " "}}},
  "TO_XML": {"visibility": "U", "parameters": {"XML": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "XML_TYPE": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "GET_SORTS": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_SALV_SORTS", RTTIName: "\\CLASS=CL_SALV_SORTS"});}, "is_optional": " "}}},
  "GET_FUNCTIONAL_SETTINGS": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_SALV_FUNCTIONAL_SETTINGS", RTTIName: "\\CLASS=CL_SALV_FUNCTIONAL_SETTINGS"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.c_functions_all = cl_salv_table.c_functions_all;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async get_sorts() {
    let value = new abap.types.ABAPObject({qualifiedName: "CL_SALV_SORTS", RTTIName: "\\CLASS=CL_SALV_SORTS"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return value;
  }
  async get_functional_settings() {
    let value = new abap.types.ABAPObject({qualifiedName: "CL_SALV_FUNCTIONAL_SETTINGS", RTTIName: "\\CLASS=CL_SALV_FUNCTIONAL_SETTINGS"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return value;
  }
  async set_selected_rows(INPUT) {
    let val = INPUT?.val;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async get_layout() {
    let value = new abap.types.ABAPObject({qualifiedName: "CL_SALV_LAYOUT", RTTIName: "\\CLASS=CL_SALV_LAYOUT"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return value;
  }
  async to_xml(INPUT) {
    let xml = new abap.types.XString({qualifiedName: "XSTRING"});
    let xml_type = INPUT?.xml_type;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return xml;
  }
  async get_filters() {
    let foo = new abap.types.ABAPObject({qualifiedName: "CL_SALV_FILTERS", RTTIName: "\\CLASS=CL_SALV_FILTERS"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return foo;
  }
  async get_aggregations() {
    let value = new abap.types.ABAPObject({qualifiedName: "CL_SALV_AGGREGATIONS", RTTIName: "\\CLASS=CL_SALV_AGGREGATIONS"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return value;
  }
  async get_functions() {
    let val = new abap.types.ABAPObject({qualifiedName: "CL_SALV_FUNCTIONS_LIST", RTTIName: "\\CLASS=CL_SALV_FUNCTIONS_LIST"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return val;
  }
  async get_selected_rows() {
    let rows = abap.types.TableFactory.construct(new abap.types.Integer({qualifiedName: "I"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "cl_salv_table=>ty_rows");
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return rows;
  }
  async get_metadata() {
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async set_selection_mode(INPUT) {
    let val = INPUT?.val;
    if (val?.getQualifiedName === undefined || val.getQualifiedName() !== "I") { val = undefined; }
    if (val === undefined) { val = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.val); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async set_striped_pattern(INPUT) {
    let val = INPUT?.val;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async set_list_header(INPUT) {
    let val = INPUT?.val;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async factory(INPUT) {
    return cl_salv_table.factory(INPUT);
  }
  static async factory(INPUT) {
    let list_display = INPUT?.list_display || new abap.types.Character(4);
    let r_container = INPUT?.r_container || new abap.types.Character(4);
    let r_salv_table = INPUT?.r_salv_table || new abap.types.Character(4);
    let t_table = new abap.types.Character(4);
    if (INPUT && INPUT.t_table) {t_table = INPUT.t_table;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async is_offline() {
    let value = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return value;
  }
  async get_selections() {
    let val = new abap.types.ABAPObject({qualifiedName: "CL_SALV_TABLE", RTTIName: "\\CLASS=CL_SALV_TABLE"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return val;
  }
  async close_screen() {
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async refresh(INPUT) {
    let refresh_mode = INPUT?.refresh_mode || new abap.types.Character(4);
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async display() {
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async set_screen_status(INPUT) {
    let pfstatus = INPUT?.pfstatus;
    let set_functions = INPUT?.set_functions || new abap.types.Character(4);
    let report = INPUT?.report;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('TODO')));
  }
  async set_screen_popup(INPUT) {
    let start_column = INPUT?.start_column;
    if (start_column?.getQualifiedName === undefined || start_column.getQualifiedName() !== "I") { start_column = undefined; }
    if (start_column === undefined) { start_column = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.start_column); }
    let end_column = INPUT?.end_column;
    if (end_column?.getQualifiedName === undefined || end_column.getQualifiedName() !== "I") { end_column = undefined; }
    if (end_column === undefined) { end_column = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.end_column); }
    let start_line = INPUT?.start_line;
    if (start_line?.getQualifiedName === undefined || start_line.getQualifiedName() !== "I") { start_line = undefined; }
    if (start_line === undefined) { start_line = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.start_line); }
    let end_line = INPUT?.end_line;
    if (end_line?.getQualifiedName === undefined || end_line.getQualifiedName() !== "I") { end_line = undefined; }
    if (end_line === undefined) { end_line = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.end_line); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('TODO')));
  }
  async get_event() {
    let val = new abap.types.ABAPObject({qualifiedName: "CL_SALV_EVENTS_TABLE", RTTIName: "\\CLASS=CL_SALV_EVENTS_TABLE"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('TODO')));
    return val;
  }
  async get_display_settings() {
    let val = new abap.types.ABAPObject({qualifiedName: "CL_SALV_TABLE", RTTIName: "\\CLASS=CL_SALV_TABLE"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('TODO')));
    return val;
  }
  async set_top_of_list(INPUT) {
    let val = INPUT?.val;
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('TODO')));
  }
  async get_columns() {
    let val = new abap.types.ABAPObject({qualifiedName: "CL_SALV_COLUMNS_TABLE", RTTIName: "\\CLASS=CL_SALV_COLUMNS_TABLE"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('TODO')));
    return val;
  }
}
abap.Classes['CL_SALV_TABLE'] = cl_salv_table;
cl_salv_table.c_functions_all = new abap.types.Integer({qualifiedName: "I"});
cl_salv_table.c_functions_all.set(1);
cl_salv_table.ty_rows = abap.types.TableFactory.construct(new abap.types.Integer({qualifiedName: "I"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "cl_salv_table=>ty_rows");

//# sourceMappingURL=cl_salv_table.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_shm_area.clas.mjs":
/*!*************************************!*\
  !*** ./output/cl_shm_area.clas.mjs ***!
  \*************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_shm_area": () => (/* binding */ cl_shm_area)
/* harmony export */ });
const {cx_shm_general_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_general_error.clas.mjs */ "./output/cx_shm_general_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_shm_area.clas.abap
class cl_shm_area extends cx_shm_general_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_SHM_AREA';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {"MO_ROOT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});}, "visibility": "I", "is_constant": " ", "is_class": "X"},
  "PROPERTIES": {"type": () => {return new abap.types.Structure({"auto_build": new abap.types.Character(1, {}), "has_versions": new abap.types.Character(1, {})}, "SHM_PROPERTIES", "SHM_PROPERTIES", {}, {});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "INST_NAME": {"type": () => {return new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"MANDT","ddicName":"MANDT"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "INST_TRACE_ACTIVE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "visibility": "O", "is_constant": " ", "is_class": " "},
  "INST_TRACE_SERVICE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_SHM_TRACE", RTTIName: "\\INTERFACE=IF_SHM_TRACE"});}, "visibility": "O", "is_constant": " ", "is_class": " "},
  "_LOCK": {"type": () => {return new abap.types.Hex({length: 8});}, "visibility": "O", "is_constant": " ", "is_class": " "},
  "DEFAULT_INSTANCE": {"type": () => {return new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "INVOCATION_MODE_EXPLICIT": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_CONSTR_INVOCATION_MODE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "LIFE_CONTEXT_APPSERVER": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_LIFE_CONTEXT"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "ATTACH_MODE_DEFAULT": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_ATTACH_MODE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "ATTACH_MODE_WAIT": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_ATTACH_MODE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "AFFECT_LOCAL_SERVER": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_AFFECT_SERVER"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "ATTACH_MODE_WAIT_2ND_TRY": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_ATTACH_MODE"});}, "visibility": "O", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"_ATTACH_READ71": {"visibility": "O", "parameters": {"SNEAK_MODE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "LIFE_CONTEXT": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_LIFE_CONTEXT"});}, "is_optional": " "}, "ROOT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});}, "is_optional": " "}}},
  "_ATTACH_UPDATE70": {"visibility": "O", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "MODE": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_ATTACH_MODE"});}, "is_optional": " "}, "ROOT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});}, "is_optional": " "}, "WAIT_TIME": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "_ATTACH_WRITE70": {"visibility": "O", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "MODE": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_ATTACH_MODE"});}, "is_optional": " "}, "ROOT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});}, "is_optional": " "}, "WAIT_TIME": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "_INVALIDATE_AREA71": {"visibility": "O", "parameters": {"RC": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_RC"});}, "is_optional": " "}, "AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"});}, "is_optional": " "}, "CLIENT_SUPPLIED": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "TRANSACTIONAL": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "CLIENT_DEPENDENT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "TERMINATE_CHANGER": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "AFFECT_SERVER": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_AFFECT_SERVER"});}, "is_optional": " "}, "LIFE_CONTEXT": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_LIFE_CONTEXT"});}, "is_optional": " "}}},
  "_INVALIDATE_INSTANCE71": {"visibility": "O", "parameters": {"RC": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_RC"});}, "is_optional": " "}, "AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "INST_NAME": {"type": () => {return new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"});}, "is_optional": " "}, "CLIENT_SUPPLIED": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "TRANSACTIONAL": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "CLIENT_DEPENDENT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "TERMINATE_CHANGER": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "AFFECT_SERVER": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_AFFECT_SERVER"});}, "is_optional": " "}, "LIFE_CONTEXT": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_LIFE_CONTEXT"});}, "is_optional": " "}}},
  "_SET_ROOT": {"visibility": "O", "parameters": {"ROOT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});}, "is_optional": " "}}},
  "_DETACH_AREA71": {"visibility": "O", "parameters": {"RC": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_RC"});}, "is_optional": " "}, "AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"});}, "is_optional": " "}, "CLIENT_SUPPLIED": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "CLIENT_DEPENDENT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "LIFE_CONTEXT": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_LIFE_CONTEXT"});}, "is_optional": " "}}},
  "_FREE_AREA71": {"visibility": "O", "parameters": {"RC": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_RC"});}, "is_optional": " "}, "AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"});}, "is_optional": " "}, "CLIENT_SUPPLIED": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "TRANSACTIONAL": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "CLIENT_DEPENDENT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "TERMINATE_CHANGER": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "AFFECT_SERVER": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_AFFECT_SERVER"});}, "is_optional": " "}, "LIFE_CONTEXT": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_LIFE_CONTEXT"});}, "is_optional": " "}}},
  "_GET_INSTANCE_INFOS71": {"visibility": "O", "parameters": {"INFOS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"client": new abap.types.Character(3, {"qualifiedName":"MANDT","ddicName":"MANDT"}), "name": new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"})}, "SHM_INST_INFO", "SHM_INST_INFO", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SHM_INST_INFOS");}, "is_optional": " "}, "AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"});}, "is_optional": " "}, "CLIENT_SUPPLIED": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "CLIENT_DEPENDENT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "LIFE_CONTEXT": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_LIFE_CONTEXT"});}, "is_optional": " "}}},
  "_FREE_INSTANCE71": {"visibility": "O", "parameters": {"RC": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_RC"});}, "is_optional": " "}, "AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "INST_NAME": {"type": () => {return new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"});}, "is_optional": " "}, "CLIENT_SUPPLIED": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "TRANSACTIONAL": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "CLIENT_DEPENDENT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "TERMINATE_CHANGER": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "AFFECT_SERVER": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_AFFECT_SERVER"});}, "is_optional": " "}, "LIFE_CONTEXT": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_LIFE_CONTEXT"});}, "is_optional": " "}}},
  "DETACH_COMMIT": {"visibility": "U", "parameters": {}},
  "DETACH": {"visibility": "U", "parameters": {}},
  "GET_ROOT": {"visibility": "U", "parameters": {"ROOT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});}, "is_optional": " "}}},
  "IS_VALID": {"visibility": "U", "parameters": {"VALID": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.mo_root = cl_shm_area.mo_root;
    this.properties = new abap.types.Structure({"auto_build": new abap.types.Character(1, {}), "has_versions": new abap.types.Character(1, {})}, "SHM_PROPERTIES", "SHM_PROPERTIES", {}, {});
    this.inst_name = new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});
    this.client = new abap.types.Character(3, {"qualifiedName":"MANDT","ddicName":"MANDT"});
    this.inst_trace_active = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    this.inst_trace_active.set(' ');
    this.inst_trace_service = new abap.types.ABAPObject({qualifiedName: "IF_SHM_TRACE", RTTIName: "\\INTERFACE=IF_SHM_TRACE"});
    this._lock = new abap.types.Hex({length: 8});
    this.default_instance = cl_shm_area.default_instance;
    this.invocation_mode_explicit = cl_shm_area.invocation_mode_explicit;
    this.life_context_appserver = cl_shm_area.life_context_appserver;
    this.attach_mode_default = cl_shm_area.attach_mode_default;
    this.attach_mode_wait = cl_shm_area.attach_mode_wait;
    this.affect_local_server = cl_shm_area.affect_local_server;
    this.attach_mode_wait_2nd_try = cl_shm_area.attach_mode_wait_2nd_try;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async is_valid() {
    let valid = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    valid.set(abap.builtin.abap_true);
    return valid;
  }
  async _free_instance71(INPUT) {
    return cl_shm_area._free_instance71(INPUT);
  }
  static async _free_instance71(INPUT) {
    let rc = new abap.types.Integer({qualifiedName: "SHM_RC"});
    let area_name = INPUT?.area_name;
    if (area_name?.getQualifiedName === undefined || area_name.getQualifiedName() !== "SHM_AREA_NAME") { area_name = undefined; }
    if (area_name === undefined) { area_name = new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"}).set(INPUT.area_name); }
    let inst_name = INPUT?.inst_name;
    if (inst_name?.getQualifiedName === undefined || inst_name.getQualifiedName() !== "SHM_INST_NAME") { inst_name = undefined; }
    if (inst_name === undefined) { inst_name = new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"}).set(INPUT.inst_name); }
    let client = INPUT?.client;
    if (client?.getQualifiedName === undefined || client.getQualifiedName() !== "SHM_CLIENT") { client = undefined; }
    if (client === undefined) { client = new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"}).set(INPUT.client); }
    let client_supplied = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.client_supplied) {client_supplied.set(INPUT.client_supplied);}
    if (INPUT === undefined || INPUT.client_supplied === undefined) {client_supplied = abap.builtin.abap_false;}
    let transactional = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.transactional) {transactional.set(INPUT.transactional);}
    if (INPUT === undefined || INPUT.transactional === undefined) {transactional = abap.builtin.abap_false;}
    let client_dependent = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.client_dependent) {client_dependent.set(INPUT.client_dependent);}
    if (INPUT === undefined || INPUT.client_dependent === undefined) {client_dependent = abap.builtin.abap_false;}
    let terminate_changer = INPUT?.terminate_changer;
    if (terminate_changer?.getQualifiedName === undefined || terminate_changer.getQualifiedName() !== "ABAP_BOOL") { terminate_changer = undefined; }
    if (terminate_changer === undefined) { terminate_changer = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}).set(INPUT.terminate_changer); }
    let affect_server = INPUT?.affect_server;
    if (affect_server?.getQualifiedName === undefined || affect_server.getQualifiedName() !== "SHM_AFFECT_SERVER") { affect_server = undefined; }
    if (affect_server === undefined) { affect_server = new abap.types.Integer({qualifiedName: "SHM_AFFECT_SERVER"}).set(INPUT.affect_server); }
    let life_context = new abap.types.Integer({qualifiedName: "SHM_LIFE_CONTEXT"});
    if (INPUT && INPUT.life_context) {life_context.set(INPUT.life_context);}
    if (INPUT === undefined || INPUT.life_context === undefined) {life_context = this.life_context_appserver;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return rc;
  }
  async detach_commit() {
    return;
  }
  async detach() {
    return;
  }
  async _attach_read71(INPUT) {
    let sneak_mode = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.sneak_mode) {sneak_mode.set(INPUT.sneak_mode);}
    if (INPUT === undefined || INPUT.sneak_mode === undefined) {sneak_mode = abap.builtin.abap_false;}
    let area_name = INPUT?.area_name;
    if (area_name?.getQualifiedName === undefined || area_name.getQualifiedName() !== "SHM_AREA_NAME") { area_name = undefined; }
    if (area_name === undefined) { area_name = new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"}).set(INPUT.area_name); }
    let life_context = INPUT?.life_context;
    if (life_context?.getQualifiedName === undefined || life_context.getQualifiedName() !== "SHM_LIFE_CONTEXT") { life_context = undefined; }
    if (life_context === undefined) { life_context = new abap.types.Integer({qualifiedName: "SHM_LIFE_CONTEXT"}).set(INPUT.life_context); }
    let root = INPUT?.root || new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});
    let created = new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});
    let lv_name = new abap.types.String({qualifiedName: "STRING"});
    if (abap.compare.eq(sneak_mode, abap.builtin.abap_false) && abap.compare.initial(cl_shm_area.mo_root)) {
      lv_name.set(area_name);
      abap.statements.replace({target: lv_name, all: false, with: new abap.types.Character(5).set('_ROOT'), of: new abap.types.Character(5).set('_AREA')});
      let unique127 = abap.Classes["CLAS-CL_SHM_AREA-"+lv_name.get().trimEnd()];
      if (unique127 === undefined) { unique127 = abap.Classes[lv_name.get().trimEnd()]; }
      if (unique127 === undefined) { throw new abap.Classes['CX_SY_CREATE_OBJECT_ERROR']; }
      created.set(await (new unique127()).constructor_());
      await this._set_root({root: created});
    }
    root.set(cl_shm_area.mo_root);
  }
  async _get_instance_infos71(INPUT) {
    return cl_shm_area._get_instance_infos71(INPUT);
  }
  static async _get_instance_infos71(INPUT) {
    let infos = abap.types.TableFactory.construct(new abap.types.Structure({"client": new abap.types.Character(3, {"qualifiedName":"MANDT","ddicName":"MANDT"}), "name": new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"})}, "SHM_INST_INFO", "SHM_INST_INFO", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SHM_INST_INFOS");
    let area_name = INPUT?.area_name;
    if (area_name?.getQualifiedName === undefined || area_name.getQualifiedName() !== "SHM_AREA_NAME") { area_name = undefined; }
    if (area_name === undefined) { area_name = new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"}).set(INPUT.area_name); }
    let client = INPUT?.client;
    if (client?.getQualifiedName === undefined || client.getQualifiedName() !== "SHM_CLIENT") { client = undefined; }
    if (client === undefined) { client = new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"}).set(INPUT.client); }
    let client_supplied = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.client_supplied) {client_supplied.set(INPUT.client_supplied);}
    if (INPUT === undefined || INPUT.client_supplied === undefined) {client_supplied = abap.builtin.abap_false;}
    let client_dependent = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.client_dependent) {client_dependent.set(INPUT.client_dependent);}
    if (INPUT === undefined || INPUT.client_dependent === undefined) {client_dependent = abap.builtin.abap_false;}
    let life_context = INPUT?.life_context;
    if (life_context?.getQualifiedName === undefined || life_context.getQualifiedName() !== "SHM_LIFE_CONTEXT") { life_context = undefined; }
    if (life_context === undefined) { life_context = new abap.types.Integer({qualifiedName: "SHM_LIFE_CONTEXT"}).set(INPUT.life_context); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return infos;
  }
  async _detach_area71(INPUT) {
    return cl_shm_area._detach_area71(INPUT);
  }
  static async _detach_area71(INPUT) {
    let rc = new abap.types.Integer({qualifiedName: "SHM_RC"});
    let area_name = INPUT?.area_name;
    if (area_name?.getQualifiedName === undefined || area_name.getQualifiedName() !== "SHM_AREA_NAME") { area_name = undefined; }
    if (area_name === undefined) { area_name = new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"}).set(INPUT.area_name); }
    let client = INPUT?.client;
    if (client?.getQualifiedName === undefined || client.getQualifiedName() !== "SHM_CLIENT") { client = undefined; }
    if (client === undefined) { client = new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"}).set(INPUT.client); }
    let client_supplied = INPUT?.client_supplied;
    if (client_supplied?.getQualifiedName === undefined || client_supplied.getQualifiedName() !== "ABAP_BOOL") { client_supplied = undefined; }
    if (client_supplied === undefined) { client_supplied = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}).set(INPUT.client_supplied); }
    let client_dependent = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.client_dependent) {client_dependent.set(INPUT.client_dependent);}
    if (INPUT === undefined || INPUT.client_dependent === undefined) {client_dependent = abap.builtin.abap_false;}
    let life_context = INPUT?.life_context;
    if (life_context?.getQualifiedName === undefined || life_context.getQualifiedName() !== "SHM_LIFE_CONTEXT") { life_context = undefined; }
    if (life_context === undefined) { life_context = new abap.types.Integer({qualifiedName: "SHM_LIFE_CONTEXT"}).set(INPUT.life_context); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return rc;
  }
  async _free_area71(INPUT) {
    return cl_shm_area._free_area71(INPUT);
  }
  static async _free_area71(INPUT) {
    let rc = new abap.types.Integer({qualifiedName: "SHM_RC"});
    let area_name = INPUT?.area_name;
    if (area_name?.getQualifiedName === undefined || area_name.getQualifiedName() !== "SHM_AREA_NAME") { area_name = undefined; }
    if (area_name === undefined) { area_name = new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"}).set(INPUT.area_name); }
    let client = INPUT?.client;
    if (client?.getQualifiedName === undefined || client.getQualifiedName() !== "SHM_CLIENT") { client = undefined; }
    if (client === undefined) { client = new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"}).set(INPUT.client); }
    let client_supplied = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.client_supplied) {client_supplied.set(INPUT.client_supplied);}
    if (INPUT === undefined || INPUT.client_supplied === undefined) {client_supplied = abap.builtin.abap_false;}
    let transactional = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.transactional) {transactional.set(INPUT.transactional);}
    if (INPUT === undefined || INPUT.transactional === undefined) {transactional = abap.builtin.abap_false;}
    let client_dependent = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.client_dependent) {client_dependent.set(INPUT.client_dependent);}
    if (INPUT === undefined || INPUT.client_dependent === undefined) {client_dependent = abap.builtin.abap_false;}
    let terminate_changer = INPUT?.terminate_changer;
    if (terminate_changer?.getQualifiedName === undefined || terminate_changer.getQualifiedName() !== "ABAP_BOOL") { terminate_changer = undefined; }
    if (terminate_changer === undefined) { terminate_changer = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}).set(INPUT.terminate_changer); }
    let affect_server = INPUT?.affect_server;
    if (affect_server?.getQualifiedName === undefined || affect_server.getQualifiedName() !== "SHM_AFFECT_SERVER") { affect_server = undefined; }
    if (affect_server === undefined) { affect_server = new abap.types.Integer({qualifiedName: "SHM_AFFECT_SERVER"}).set(INPUT.affect_server); }
    let life_context = new abap.types.Integer({qualifiedName: "SHM_LIFE_CONTEXT"});
    if (INPUT && INPUT.life_context) {life_context.set(INPUT.life_context);}
    if (INPUT === undefined || INPUT.life_context === undefined) {life_context = this.life_context_appserver;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return rc;
  }
  async _set_root(INPUT) {
    let root = INPUT?.root;
    if (root === undefined) { root = new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined}).set(INPUT.root); }
    cl_shm_area.mo_root.set(root);
  }
  async _invalidate_instance71(INPUT) {
    return cl_shm_area._invalidate_instance71(INPUT);
  }
  static async _invalidate_instance71(INPUT) {
    let rc = new abap.types.Integer({qualifiedName: "SHM_RC"});
    let area_name = INPUT?.area_name;
    if (area_name?.getQualifiedName === undefined || area_name.getQualifiedName() !== "SHM_AREA_NAME") { area_name = undefined; }
    if (area_name === undefined) { area_name = new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"}).set(INPUT.area_name); }
    let inst_name = INPUT?.inst_name;
    if (inst_name?.getQualifiedName === undefined || inst_name.getQualifiedName() !== "SHM_INST_NAME") { inst_name = undefined; }
    if (inst_name === undefined) { inst_name = new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"}).set(INPUT.inst_name); }
    let client = INPUT?.client;
    if (client?.getQualifiedName === undefined || client.getQualifiedName() !== "SHM_CLIENT") { client = undefined; }
    if (client === undefined) { client = new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"}).set(INPUT.client); }
    let client_supplied = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.client_supplied) {client_supplied.set(INPUT.client_supplied);}
    if (INPUT === undefined || INPUT.client_supplied === undefined) {client_supplied = abap.builtin.abap_false;}
    let transactional = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.transactional) {transactional.set(INPUT.transactional);}
    if (INPUT === undefined || INPUT.transactional === undefined) {transactional = abap.builtin.abap_false;}
    let client_dependent = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.client_dependent) {client_dependent.set(INPUT.client_dependent);}
    if (INPUT === undefined || INPUT.client_dependent === undefined) {client_dependent = abap.builtin.abap_false;}
    let terminate_changer = INPUT?.terminate_changer;
    if (terminate_changer?.getQualifiedName === undefined || terminate_changer.getQualifiedName() !== "ABAP_BOOL") { terminate_changer = undefined; }
    if (terminate_changer === undefined) { terminate_changer = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}).set(INPUT.terminate_changer); }
    let affect_server = INPUT?.affect_server;
    if (affect_server?.getQualifiedName === undefined || affect_server.getQualifiedName() !== "SHM_AFFECT_SERVER") { affect_server = undefined; }
    if (affect_server === undefined) { affect_server = new abap.types.Integer({qualifiedName: "SHM_AFFECT_SERVER"}).set(INPUT.affect_server); }
    let life_context = new abap.types.Integer({qualifiedName: "SHM_LIFE_CONTEXT"});
    if (INPUT && INPUT.life_context) {life_context.set(INPUT.life_context);}
    if (INPUT === undefined || INPUT.life_context === undefined) {life_context = this.life_context_appserver;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return rc;
  }
  async _invalidate_area71(INPUT) {
    return cl_shm_area._invalidate_area71(INPUT);
  }
  static async _invalidate_area71(INPUT) {
    let rc = new abap.types.Integer({qualifiedName: "SHM_RC"});
    let area_name = INPUT?.area_name;
    if (area_name?.getQualifiedName === undefined || area_name.getQualifiedName() !== "SHM_AREA_NAME") { area_name = undefined; }
    if (area_name === undefined) { area_name = new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"}).set(INPUT.area_name); }
    let client = INPUT?.client;
    if (client?.getQualifiedName === undefined || client.getQualifiedName() !== "SHM_CLIENT") { client = undefined; }
    if (client === undefined) { client = new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"}).set(INPUT.client); }
    let client_supplied = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.client_supplied) {client_supplied.set(INPUT.client_supplied);}
    if (INPUT === undefined || INPUT.client_supplied === undefined) {client_supplied = abap.builtin.abap_false;}
    let transactional = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.transactional) {transactional.set(INPUT.transactional);}
    if (INPUT === undefined || INPUT.transactional === undefined) {transactional = abap.builtin.abap_false;}
    let client_dependent = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.client_dependent) {client_dependent.set(INPUT.client_dependent);}
    if (INPUT === undefined || INPUT.client_dependent === undefined) {client_dependent = abap.builtin.abap_false;}
    let terminate_changer = INPUT?.terminate_changer;
    if (terminate_changer?.getQualifiedName === undefined || terminate_changer.getQualifiedName() !== "ABAP_BOOL") { terminate_changer = undefined; }
    if (terminate_changer === undefined) { terminate_changer = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}).set(INPUT.terminate_changer); }
    let affect_server = INPUT?.affect_server;
    if (affect_server?.getQualifiedName === undefined || affect_server.getQualifiedName() !== "SHM_AFFECT_SERVER") { affect_server = undefined; }
    if (affect_server === undefined) { affect_server = new abap.types.Integer({qualifiedName: "SHM_AFFECT_SERVER"}).set(INPUT.affect_server); }
    let life_context = new abap.types.Integer({qualifiedName: "SHM_LIFE_CONTEXT"});
    if (INPUT && INPUT.life_context) {life_context.set(INPUT.life_context);}
    if (INPUT === undefined || INPUT.life_context === undefined) {life_context = this.life_context_appserver;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return rc;
  }
  async _attach_update70(INPUT) {
    let area_name = INPUT?.area_name;
    if (area_name?.getQualifiedName === undefined || area_name.getQualifiedName() !== "SHM_AREA_NAME") { area_name = undefined; }
    if (area_name === undefined) { area_name = new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"}).set(INPUT.area_name); }
    let mode = INPUT?.mode;
    if (mode?.getQualifiedName === undefined || mode.getQualifiedName() !== "SHM_ATTACH_MODE") { mode = undefined; }
    if (mode === undefined) { mode = new abap.types.Integer({qualifiedName: "SHM_ATTACH_MODE"}).set(INPUT.mode); }
    let root = INPUT?.root || new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});
    let wait_time = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.wait_time) {wait_time = INPUT.wait_time;}
    let created = new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});
    let lv_name = new abap.types.String({qualifiedName: "STRING"});
    if (abap.compare.initial(cl_shm_area.mo_root)) {
      abap.statements.replace({target: lv_name, all: false, with: new abap.types.Character(5).set('_ROOT'), of: new abap.types.Character(5).set('_AREA')});
      let unique128 = abap.Classes["CLAS-CL_SHM_AREA-"+lv_name.get().trimEnd()];
      if (unique128 === undefined) { unique128 = abap.Classes[lv_name.get().trimEnd()]; }
      if (unique128 === undefined) { throw new abap.Classes['CX_SY_CREATE_OBJECT_ERROR']; }
      created.set(await (new unique128()).constructor_());
      await this._set_root({root: created});
    }
    root.set(cl_shm_area.mo_root);
  }
  async _attach_write70(INPUT) {
    let area_name = INPUT?.area_name;
    if (area_name?.getQualifiedName === undefined || area_name.getQualifiedName() !== "SHM_AREA_NAME") { area_name = undefined; }
    if (area_name === undefined) { area_name = new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"}).set(INPUT.area_name); }
    let mode = INPUT?.mode;
    if (mode?.getQualifiedName === undefined || mode.getQualifiedName() !== "SHM_ATTACH_MODE") { mode = undefined; }
    if (mode === undefined) { mode = new abap.types.Integer({qualifiedName: "SHM_ATTACH_MODE"}).set(INPUT.mode); }
    let root = INPUT?.root || new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});
    let wait_time = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.wait_time) {wait_time = INPUT.wait_time;}
    return;
  }
}
abap.Classes['CL_SHM_AREA'] = cl_shm_area;
cl_shm_area.mo_root = new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});
cl_shm_area.default_instance = new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});
cl_shm_area.default_instance.set('$DEFAULT_INSTANCE$');
cl_shm_area.invocation_mode_explicit = new abap.types.Integer({qualifiedName: "SHM_CONSTR_INVOCATION_MODE"});
cl_shm_area.invocation_mode_explicit.set(319200300);
cl_shm_area.life_context_appserver = new abap.types.Integer({qualifiedName: "SHM_LIFE_CONTEXT"});
cl_shm_area.life_context_appserver.set(109200001);
cl_shm_area.attach_mode_default = new abap.types.Integer({qualifiedName: "SHM_ATTACH_MODE"});
cl_shm_area.attach_mode_default.set(1302197000);
cl_shm_area.attach_mode_wait = new abap.types.Integer({qualifiedName: "SHM_ATTACH_MODE"});
cl_shm_area.attach_mode_wait.set(1302197002);
cl_shm_area.affect_local_server = new abap.types.Integer({qualifiedName: "SHM_AFFECT_SERVER"});
cl_shm_area.affect_local_server.set(281119720);
cl_shm_area.attach_mode_wait_2nd_try = new abap.types.Integer({qualifiedName: "SHM_ATTACH_MODE"});
cl_shm_area.attach_mode_wait_2nd_try.set(1302197003);

//# sourceMappingURL=cl_shm_area.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_shm_service.clas.mjs":
/*!****************************************!*\
  !*** ./output/cl_shm_service.clas.mjs ***!
  \****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_shm_service": () => (/* binding */ cl_shm_service)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_shm_service.clas.abap
class cl_shm_service {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_SHM_SERVICE';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"INITIALIZE": {"visibility": "U", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"SHMA_CLIENT","ddicName":"SHMA_CLIENT"});}, "is_optional": " "}, "ATTRIBUTES": {"type": () => {return new abap.types.Structure({"area_name": new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"}), "properties": new abap.types.Structure({"auto_build": new abap.types.Character(1, {}), "has_versions": new abap.types.Character(1, {})}, "SHM_PROPERTIES", "SHM_PROPERTIES", {}, {}), "auto_build": new abap.types.Character(1, {}), "has_versions": new abap.types.Character(1, {})}, "SHMA_ATTRIBUTES", "SHMA_ATTRIBUTES", {}, {});}, "is_optional": " "}}},
  "GET_AUTO_BUILD_CLASS_NAME": {"visibility": "U", "parameters": {"AUTO_BUILD_CLASS_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AUTO_BUILD_CLASS_NAME","ddicName":"SHM_AUTO_BUILD_CLASS_NAME"});}, "is_optional": " "}, "AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}}},
  "TRACE_GET_SERVICE": {"visibility": "U", "parameters": {"TRACE_SERVICE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_SHM_TRACE", RTTIName: "\\INTERFACE=IF_SHM_TRACE"});}, "is_optional": " "}, "AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}}},
  "TRACE_IS_VARIANT_ACTIVE": {"visibility": "U", "parameters": {"IS_ACTIVE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "SERVICE_NAME": {"type": () => {return new abap.types.Character(32, {"qualifiedName":"SHMM_TRC_VARIANT_NAME","ddicName":"SHMM_TRC_VARIANT_NAME"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async initialize(INPUT) {
    return cl_shm_service.initialize(INPUT);
  }
  static async initialize(INPUT) {
    let area_name = INPUT?.area_name;
    if (area_name?.getQualifiedName === undefined || area_name.getQualifiedName() !== "SHM_AREA_NAME") { area_name = undefined; }
    if (area_name === undefined) { area_name = new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"}).set(INPUT.area_name); }
    let client = new abap.types.Character(3, {"qualifiedName":"SHMA_CLIENT","ddicName":"SHMA_CLIENT"});
    if (INPUT && INPUT.client) {client.set(INPUT.client);}
    let attributes = INPUT?.attributes || new abap.types.Structure({"area_name": new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"}), "properties": new abap.types.Structure({"auto_build": new abap.types.Character(1, {}), "has_versions": new abap.types.Character(1, {})}, "SHM_PROPERTIES", "SHM_PROPERTIES", {}, {}), "auto_build": new abap.types.Character(1, {}), "has_versions": new abap.types.Character(1, {})}, "SHMA_ATTRIBUTES", "SHMA_ATTRIBUTES", {}, {});
    return;
  }
  async get_auto_build_class_name(INPUT) {
    return cl_shm_service.get_auto_build_class_name(INPUT);
  }
  static async get_auto_build_class_name(INPUT) {
    let auto_build_class_name = new abap.types.Character(30, {"qualifiedName":"SHM_AUTO_BUILD_CLASS_NAME","ddicName":"SHM_AUTO_BUILD_CLASS_NAME"});
    let area_name = INPUT?.area_name;
    if (area_name?.getQualifiedName === undefined || area_name.getQualifiedName() !== "SHM_AREA_NAME") { area_name = undefined; }
    if (area_name === undefined) { area_name = new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"}).set(INPUT.area_name); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return auto_build_class_name;
  }
  async trace_get_service(INPUT) {
    return cl_shm_service.trace_get_service(INPUT);
  }
  static async trace_get_service(INPUT) {
    let trace_service = new abap.types.ABAPObject({qualifiedName: "IF_SHM_TRACE", RTTIName: "\\INTERFACE=IF_SHM_TRACE"});
    let area_name = new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});
    if (INPUT && INPUT.area_name) {area_name.set(INPUT.area_name);}
    return trace_service;
    return trace_service;
  }
  async trace_is_variant_active(INPUT) {
    return cl_shm_service.trace_is_variant_active(INPUT);
  }
  static async trace_is_variant_active(INPUT) {
    let is_active = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    let service_name = INPUT?.service_name;
    if (service_name?.getQualifiedName === undefined || service_name.getQualifiedName() !== "SHMM_TRC_VARIANT_NAME") { service_name = undefined; }
    if (service_name === undefined) { service_name = new abap.types.Character(32, {"qualifiedName":"SHMM_TRC_VARIANT_NAME","ddicName":"SHMM_TRC_VARIANT_NAME"}).set(INPUT.service_name); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return is_active;
  }
}
abap.Classes['CL_SHM_SERVICE'] = cl_shm_service;

//# sourceMappingURL=cl_shm_service.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_sql_result_set.clas.mjs":
/*!*******************************************!*\
  !*** ./output/cl_sql_result_set.clas.mjs ***!
  \*******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_sql_result_set": () => (/* binding */ cl_sql_result_set)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_sql_result_set.clas.abap
class cl_sql_result_set {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_SQL_RESULT_SET';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"MV_MAGIC": {"type": () => {return new abap.types.Hex();}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MV_INDEX": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MV_REF": {"type": () => {return new abap.types.DataReference(new abap.types.Character(4));}, "visibility": "I", "is_constant": " ", "is_class": " "}};
  static METHODS = {"SET_PARAM": {"visibility": "U", "parameters": {"DATA_REF": {"type": () => {return new abap.types.DataReference(new abap.types.Character(4));}, "is_optional": " "}}},
  "SET_PARAM_TABLE": {"visibility": "U", "parameters": {"ITAB_REF": {"type": () => {return new abap.types.DataReference(new abap.types.Character(4));}, "is_optional": " "}}},
  "NEXT": {"visibility": "U", "parameters": {"ROWS_RET": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "CLOSE": {"visibility": "U", "parameters": {}},
  "NEXT_PACKAGE": {"visibility": "U", "parameters": {}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.mv_magic = new abap.types.Hex();
    this.mv_index = new abap.types.Integer({qualifiedName: "I"});
    this.mv_ref = new abap.types.DataReference(new abap.types.Character(4));
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async set_param(INPUT) {
    let data_ref = INPUT?.data_ref;
    if (data_ref === undefined) { data_ref = new abap.types.DataReference(new abap.types.Character(4)).set(INPUT.data_ref); }
    this.mv_ref.set(data_ref);
  }
  async next() {
    let rows_ret = new abap.types.Integer({qualifiedName: "I"});
    let lv_total = new abap.types.Integer({qualifiedName: "I"});
    let lv_value = new abap.types.String({qualifiedName: "STRING"});
    lv_total.set(this.mv_magic.length);
    const current = this.mv_magic[this.mv_index.get()];
    lv_value.set(Object.values(current)[0]);
    this.mv_ref.dereference().set(lv_value);
    this.mv_index.set(abap.operators.add(this.mv_index,abap.IntegerFactory.get(1)));
    rows_ret.set(abap.operators.minus(lv_total,this.mv_index));
    return rows_ret;
  }
  async close() {
    return;
  }
  async set_param_table(INPUT) {
    let itab_ref = INPUT?.itab_ref;
    if (itab_ref === undefined) { itab_ref = new abap.types.DataReference(new abap.types.Character(4)).set(INPUT.itab_ref); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async next_package() {
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
}
abap.Classes['CL_SQL_RESULT_SET'] = cl_sql_result_set;

//# sourceMappingURL=cl_sql_result_set.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_sql_statement.clas.mjs":
/*!******************************************!*\
  !*** ./output/cl_sql_statement.clas.mjs ***!
  \******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_sql_statement": () => (/* binding */ cl_sql_statement)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_sql_statement.clas.abap
class cl_sql_statement {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_SQL_STATEMENT';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"CON_REF": {"type": () => {return new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});}, "is_optional": " "}}},
  "EXECUTE_UPDATE": {"visibility": "U", "parameters": {"STATEMENT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "EXECUTE_QUERY": {"visibility": "U", "parameters": {"RESULT_SET": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_SQL_RESULT_SET", RTTIName: "\\CLASS=CL_SQL_RESULT_SET"});}, "is_optional": " "}, "STATEMENT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "EXECUTE_DDL": {"visibility": "U", "parameters": {"STATEMENT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    let con_ref = new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});
    if (INPUT && INPUT.con_ref) {con_ref.set(INPUT.con_ref);}
    abap.statements.assert(abap.compare.initial(con_ref));
    return this;
  }
  async execute_ddl(INPUT) {
    let statement = INPUT?.statement;
    if (statement?.getQualifiedName === undefined || statement.getQualifiedName() !== "STRING") { statement = undefined; }
    if (statement === undefined) { statement = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.statement); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(13).set('not supported')));
  }
  async execute_update(INPUT) {
    let statement = INPUT?.statement;
    if (statement?.getQualifiedName === undefined || statement.getQualifiedName() !== "STRING") { statement = undefined; }
    if (statement === undefined) { statement = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.statement); }
    let lv_sql_message = new abap.types.String({qualifiedName: "STRING"});
    abap.statements.assert(abap.compare.initial(statement) === false);
    if (abap.context.databaseConnections["DEFAULT"] === undefined) {
      lv_sql_message.set(new abap.types.Character(19).set('not connected to db'));
    }
    if (abap.compare.initial(lv_sql_message) === false) {
      const unique12 = await (new abap.Classes['CX_SQL_EXCEPTION']()).constructor_();
      unique12.EXTRA_CX = {"INTERNAL_FILENAME": "cl_sql_statement.clas.abap","INTERNAL_LINE": 48};
      throw unique12;
    }
    try {
        await abap.context.databaseConnections["DEFAULT"].execute(statement.get());
    } catch(e) {
        lv_sql_message.set(e + "");
    }
    if (abap.compare.initial(lv_sql_message) === false) {
      const unique13 = await (new abap.Classes['CX_SQL_EXCEPTION']()).constructor_();
      unique13.EXTRA_CX = {"INTERNAL_FILENAME": "cl_sql_statement.clas.abap","INTERNAL_LINE": 57};
      throw unique13;
    }
  }
  async execute_query(INPUT) {
    let result_set = new abap.types.ABAPObject({qualifiedName: "CL_SQL_RESULT_SET", RTTIName: "\\CLASS=CL_SQL_RESULT_SET"});
    let statement = INPUT?.statement;
    if (statement?.getQualifiedName === undefined || statement.getQualifiedName() !== "STRING") { statement = undefined; }
    if (statement === undefined) { statement = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.statement); }
    let lv_sql_message = new abap.types.String({qualifiedName: "STRING"});
    abap.statements.assert(abap.compare.initial(statement) === false);
    if (abap.context.databaseConnections["DEFAULT"] === undefined) {
      lv_sql_message.set(new abap.types.Character(19).set('not connected to db'));
    }
    if (abap.compare.initial(lv_sql_message) === false) {
      const unique14 = await (new abap.Classes['CX_SQL_EXCEPTION']()).constructor_();
      unique14.EXTRA_CX = {"INTERNAL_FILENAME": "cl_sql_statement.clas.abap","INTERNAL_LINE": 71};
      throw unique14;
    }
    result_set.set(await (new abap.Classes['CL_SQL_RESULT_SET']()).constructor_());
    try {
        const res = await abap.context.databaseConnections["DEFAULT"].select({select: statement.get()});
        result_set.get().mv_magic = res.rows;
    } catch(e) {
        lv_sql_message.set(e + "");
    }
    if (abap.compare.initial(lv_sql_message) === false) {
      const unique15 = await (new abap.Classes['CX_SQL_EXCEPTION']()).constructor_();
      unique15.EXTRA_CX = {"INTERNAL_FILENAME": "cl_sql_statement.clas.abap","INTERNAL_LINE": 84};
      throw unique15;
    }
    return result_set;
  }
}
abap.Classes['CL_SQL_STATEMENT'] = cl_sql_statement;

//# sourceMappingURL=cl_sql_statement.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_sxml_string_reader.clas.mjs":
/*!***********************************************!*\
  !*** ./output/cl_sxml_string_reader.clas.mjs ***!
  \***********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_sxml_string_reader": () => (/* binding */ cl_sxml_string_reader)
/* harmony export */ });
await __webpack_require__.e(/*! import() */ "output_cl_sxml_string_reader_clas_locals_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_sxml_string_reader.clas.locals.mjs */ "./output/cl_sxml_string_reader.clas.locals.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_sxml_string_reader.clas.abap
class cl_sxml_string_reader {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_SXML_STRING_READER';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"CREATE": {"visibility": "U", "parameters": {"READER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_SXML_READER", RTTIName: "\\INTERFACE=IF_SXML_READER"});}, "is_optional": " "}, "INPUT": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async create(INPUT) {
    return cl_sxml_string_reader.create(INPUT);
  }
  static async create(INPUT) {
    let reader = new abap.types.ABAPObject({qualifiedName: "IF_SXML_READER", RTTIName: "\\INTERFACE=IF_SXML_READER"});
    let input = INPUT?.input;
    if (input?.getQualifiedName === undefined || input.getQualifiedName() !== "XSTRING") { input = undefined; }
    if (input === undefined) { input = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.input); }
    reader.set(await (new abap.Classes['CLAS-CL_SXML_STRING_READER-LCL_READER']()).constructor_({iv_json: (await abap.Classes['CL_ABAP_CODEPAGE'].convert_from({source: input}))}));
    return reader;
  }
}
abap.Classes['CL_SXML_STRING_READER'] = cl_sxml_string_reader;

//# sourceMappingURL=cl_sxml_string_reader.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_sxml_string_writer.clas.mjs":
/*!***********************************************!*\
  !*** ./output/cl_sxml_string_writer.clas.mjs ***!
  \***********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_sxml_string_writer": () => (/* binding */ cl_sxml_string_writer)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_sxml_string_writer.clas.abap
class cl_sxml_string_writer {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_SXML_STRING_WRITER';
  static IMPLEMENTED_INTERFACES = ["IF_SXML_WRITER"];
  static ATTRIBUTES = {"MV_OUTPUT": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MV_TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML=>XML_STREAM_TYPE"});}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "MT_STACK": {"type": () => {return abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "");}, "visibility": "I", "is_constant": " ", "is_class": " "},
  "IF_SXML_WRITER~CO_OPT_NORMALIZING": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_WRITER~CO_OPT_NO_EMPTY": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_WRITER~CO_OPT_IGNORE_CONV_ERRROS": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_WRITER~CO_OPT_LINEBREAKS": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_WRITER~CO_OPT_INDENT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_WRITER~CO_OPT_ILLEGAL_CHAR_REJECT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_WRITER~CO_OPT_ILLEGAL_CHAR_REPLACE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_WRITER~CO_OPT_ILLEGAL_CHAR_REPLACE_BY": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_WRITER~CO_OPT_BASE64_NO_LF": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"APPEND_TEXT": {"visibility": "I", "parameters": {"TEXT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_TEXT": {"visibility": "I", "parameters": {"TEXT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "PEEK": {"visibility": "I", "parameters": {"RV_NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "REMOVE": {"visibility": "I", "parameters": {"RV_NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "CONSTRUCTOR": {"visibility": "U", "parameters": {"TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML=>XML_STREAM_TYPE"});}, "is_optional": " "}}},
  "GET_OUTPUT": {"visibility": "U", "parameters": {"OUTPUT": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "CREATE": {"visibility": "U", "parameters": {"WRITER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_SXML_STRING_WRITER", RTTIName: "\\CLASS=CL_SXML_STRING_WRITER"});}, "is_optional": " "}, "TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML=>XML_STREAM_TYPE"});}, "is_optional": " "}, "IGNORE_CONVERSION_ERRORS": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "NORMALIZING": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "NO_EMPTY_ELEMENTS": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "ENCODING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.mv_output = new abap.types.XString({qualifiedName: "XSTRING"});
    this.mv_type = new abap.types.Integer({qualifiedName: "IF_SXML=>XML_STREAM_TYPE"});
    this.mt_stack = abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "");
    this.if_sxml_writer$co_opt_normalizing = abap.Classes['IF_SXML_WRITER'].if_sxml_writer$co_opt_normalizing;
    this.if_sxml_writer$co_opt_no_empty = abap.Classes['IF_SXML_WRITER'].if_sxml_writer$co_opt_no_empty;
    this.if_sxml_writer$co_opt_ignore_conv_errros = abap.Classes['IF_SXML_WRITER'].if_sxml_writer$co_opt_ignore_conv_errros;
    this.if_sxml_writer$co_opt_linebreaks = abap.Classes['IF_SXML_WRITER'].if_sxml_writer$co_opt_linebreaks;
    this.if_sxml_writer$co_opt_indent = abap.Classes['IF_SXML_WRITER'].if_sxml_writer$co_opt_indent;
    this.if_sxml_writer$co_opt_illegal_char_reject = abap.Classes['IF_SXML_WRITER'].if_sxml_writer$co_opt_illegal_char_reject;
    this.if_sxml_writer$co_opt_illegal_char_replace = abap.Classes['IF_SXML_WRITER'].if_sxml_writer$co_opt_illegal_char_replace;
    this.if_sxml_writer$co_opt_illegal_char_replace_by = abap.Classes['IF_SXML_WRITER'].if_sxml_writer$co_opt_illegal_char_replace_by;
    this.if_sxml_writer$co_opt_base64_no_lf = abap.Classes['IF_SXML_WRITER'].if_sxml_writer$co_opt_base64_no_lf;
  }
  async constructor_(INPUT) {
    let type = INPUT?.type;
    if (type?.getQualifiedName === undefined || type.getQualifiedName() !== "IF_SXML=>XML_STREAM_TYPE") { type = undefined; }
    if (type === undefined) { type = new abap.types.Integer({qualifiedName: "IF_SXML=>XML_STREAM_TYPE"}).set(INPUT.type); }
    this.mv_type.set(type);
    return this;
  }
  async if_sxml_writer$new_close_element() {
    return cl_sxml_string_writer.if_sxml_writer$new_close_element();
  }
  static async if_sxml_writer$new_close_element() {
    let element = new abap.types.ABAPObject({qualifiedName: "IF_SXML_CLOSE_ELEMENT", RTTIName: "\\INTERFACE=IF_SXML_CLOSE_ELEMENT"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return element;
  }
  async if_sxml_writer$write_attribute_raw(INPUT) {
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    let nsuri = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.nsuri) {nsuri.set(INPUT.nsuri);}
    let prefix = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}
    let value = new abap.types.XString({qualifiedName: "XSTRING"});
    if (INPUT && INPUT.value) {value.set(INPUT.value);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_sxml_writer$new_value() {
    return cl_sxml_string_writer.if_sxml_writer$new_value();
  }
  static async if_sxml_writer$new_value() {
    let value = new abap.types.ABAPObject({qualifiedName: "IF_SXML_VALUE_NODE", RTTIName: "\\INTERFACE=IF_SXML_VALUE_NODE"});
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return value;
  }
  async if_sxml_writer$new_open_element(INPUT) {
    return cl_sxml_string_writer.if_sxml_writer$new_open_element(INPUT);
  }
  static async if_sxml_writer$new_open_element(INPUT) {
    let element = new abap.types.ABAPObject({qualifiedName: "IF_SXML_OPEN_ELEMENT", RTTIName: "\\INTERFACE=IF_SXML_OPEN_ELEMENT"});
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    let nsuri = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.nsuri) {nsuri.set(INPUT.nsuri);}
    let prefix = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    return element;
  }
  async if_sxml_writer$write_value_raw(INPUT) {
    let value = INPUT?.value;
    if (value?.getQualifiedName === undefined || value.getQualifiedName() !== "XSTRING") { value = undefined; }
    if (value === undefined) { value = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.value); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_sxml_writer$write_namespace_declaration(INPUT) {
    let nsuri = INPUT?.nsuri;
    if (nsuri?.getQualifiedName === undefined || nsuri.getQualifiedName() !== "STRING") { nsuri = undefined; }
    if (nsuri === undefined) { nsuri = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.nsuri); }
    let prefix = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async if_sxml_writer$write_node(INPUT) {
    let node = INPUT?.node;
    if (node?.getQualifiedName === undefined || node.getQualifiedName() !== "IF_SXML_NODE") { node = undefined; }
    if (node === undefined) { node = new abap.types.ABAPObject({qualifiedName: "IF_SXML_NODE", RTTIName: "\\INTERFACE=IF_SXML_NODE"}).set(INPUT.node); }
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async create(INPUT) {
    return cl_sxml_string_writer.create(INPUT);
  }
  static async create(INPUT) {
    let writer = new abap.types.ABAPObject({qualifiedName: "CL_SXML_STRING_WRITER", RTTIName: "\\CLASS=CL_SXML_STRING_WRITER"});
    let type = new abap.types.Integer({qualifiedName: "IF_SXML=>XML_STREAM_TYPE"});
    if (INPUT && INPUT.type) {type.set(INPUT.type);}
    if (INPUT === undefined || INPUT.type === undefined) {type = abap.Classes['IF_SXML'].if_sxml$co_xt_xml10;}
    let ignore_conversion_errors = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.ignore_conversion_errors) {ignore_conversion_errors.set(INPUT.ignore_conversion_errors);}
    if (INPUT === undefined || INPUT.ignore_conversion_errors === undefined) {ignore_conversion_errors = abap.builtin.abap_false;}
    let normalizing = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.normalizing) {normalizing.set(INPUT.normalizing);}
    if (INPUT === undefined || INPUT.normalizing === undefined) {normalizing = abap.builtin.abap_false;}
    let no_empty_elements = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.no_empty_elements) {no_empty_elements.set(INPUT.no_empty_elements);}
    if (INPUT === undefined || INPUT.no_empty_elements === undefined) {no_empty_elements = abap.builtin.abap_false;}
    let encoding = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.encoding) {encoding.set(INPUT.encoding);}
    if (INPUT === undefined || INPUT.encoding === undefined) {encoding = new abap.types.Character(5).set('UTF-8');}
    writer.set(await (new abap.Classes['CL_SXML_STRING_WRITER']()).constructor_({type: type}));
    return writer;
  }
  async if_sxml_writer$set_option(INPUT) {
    let option = INPUT?.option;
    if (option?.getQualifiedName === undefined || option.getQualifiedName() !== "I") { option = undefined; }
    if (option === undefined) { option = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.option); }
    let value = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.value) {value.set(INPUT.value);}
    if (INPUT === undefined || INPUT.value === undefined) {value = abap.builtin.abap_true;}
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  async get_output() {
    let output = new abap.types.XString({qualifiedName: "XSTRING"});
    output.set(this.mv_output);
    return output;
  }
  async append_text(INPUT) {
    let text = INPUT?.text;
    if (text?.getQualifiedName === undefined || text.getQualifiedName() !== "STRING") { text = undefined; }
    if (text === undefined) { text = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.text); }
    let append = new abap.types.XString({qualifiedName: "XSTRING"});
    append.set((await (await abap.Classes['CL_ABAP_CONV_CODEPAGE'].create_out()).get().if_abap_conv_out$convert({source: text})));
    abap.statements.concatenate({source: [this.mv_output, append], target: this.mv_output});
  }
  async get_text() {
    let text = new abap.types.String({qualifiedName: "STRING"});
    text.set((await (await abap.Classes['CL_ABAP_CONV_CODEPAGE'].create_in()).get().if_abap_conv_in$convert({source: this.mv_output})));
    return text;
  }
  async if_sxml_writer$open_element(INPUT) {
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    let nsuri = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.nsuri) {nsuri.set(INPUT.nsuri);}
    let prefix = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}
    let parent = new abap.types.String({qualifiedName: "STRING"});
    parent.set((await this.peek()));
    if (abap.compare.eq(parent, new abap.types.Character(5).set('array')) && abap.compare.np((await this.get_text()), new abap.types.Character(2).set('*['))) {
      await this.append_text({text: new abap.types.Character(1).set(',')});
    }
    if (abap.compare.eq(parent, new abap.types.Character(6).set('object')) && abap.compare.np((await this.get_text()), new abap.types.Character(2).set('*{'))) {
      await this.append_text({text: new abap.types.Character(1).set(',')});
    }
    abap.statements.append({source: name, target: this.mt_stack});
    let unique137 = name;
    if (abap.compare.eq(unique137, new abap.types.Character(6).set('object'))) {
      await this.append_text({text: new abap.types.Character(1).set('{')});
    } else if (abap.compare.eq(unique137, new abap.types.Character(5).set('array'))) {
      await this.append_text({text: new abap.types.Character(1).set('[')});
    }
  }
  async remove() {
    let rv_name = new abap.types.String({qualifiedName: "STRING"});
    let index = new abap.types.Integer({qualifiedName: "I"});
    index.set(abap.builtin.lines({val: this.mt_stack}));
    abap.statements.readTable(this.mt_stack,{index: index,
      into: rv_name});
    await abap.statements.deleteInternal(this.mt_stack,{index: index});
    return rv_name;
  }
  async if_sxml_writer$close_element() {
    let name = new abap.types.String({qualifiedName: "STRING"});
    name.set((await this.remove()));
    let unique138 = name;
    if (abap.compare.eq(unique138, new abap.types.Character(6).set('object'))) {
      await this.append_text({text: new abap.types.Character(1).set('}')});
    } else if (abap.compare.eq(unique138, new abap.types.Character(5).set('array'))) {
      await this.append_text({text: new abap.types.Character(1).set(']')});
    }
  }
  async if_sxml_writer$write_attribute(INPUT) {
    let name = INPUT?.name;
    if (name?.getQualifiedName === undefined || name.getQualifiedName() !== "STRING") { name = undefined; }
    if (name === undefined) { name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.name); }
    let nsuri = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.nsuri) {nsuri.set(INPUT.nsuri);}
    let prefix = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.prefix) {prefix.set(INPUT.prefix);}
    let value = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.value) {value.set(INPUT.value);}
    await this.append_text({text: new abap.types.Character(1).set('"')});
    await this.append_text({text: value});
    await this.append_text({text: new abap.types.Character(2).set('":')});
  }
  async peek() {
    let rv_name = new abap.types.String({qualifiedName: "STRING"});
    let index = new abap.types.Integer({qualifiedName: "I"});
    index.set(abap.builtin.lines({val: this.mt_stack}));
    abap.statements.readTable(this.mt_stack,{index: index,
      into: rv_name});
    return rv_name;
  }
  async if_sxml_writer$write_value(INPUT) {
    let value = INPUT?.value;
    if (value?.getQualifiedName === undefined || value.getQualifiedName() !== "STRING") { value = undefined; }
    if (value === undefined) { value = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.value); }
    let name = new abap.types.String({qualifiedName: "STRING"});
    name.set((await this.peek()));
    let unique139 = name;
    if (abap.compare.eq(unique139, new abap.types.Character(3).set('str'))) {
      await this.append_text({text: new abap.types.Character(1).set('"')});
      await this.append_text({text: abap.builtin.condense({val: value})});
      await this.append_text({text: new abap.types.Character(1).set('"')});
    } else if (abap.compare.eq(unique139, new abap.types.Character(3).set('num'))) {
      await this.append_text({text: abap.builtin.condense({val: value})});
    } else {
      console.dir(name);
      abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(31).set('todo_if_sxml_writer_write_value')));
    }
  }
}
abap.Classes['CL_SXML_STRING_WRITER'] = cl_sxml_string_writer;
cl_sxml_string_writer.if_sxml_writer$co_opt_normalizing = new abap.types.Integer({qualifiedName: "I"});
cl_sxml_string_writer.if_sxml_writer$co_opt_normalizing.set(1);
cl_sxml_string_writer.if_sxml_writer$co_opt_no_empty = new abap.types.Integer({qualifiedName: "I"});
cl_sxml_string_writer.if_sxml_writer$co_opt_no_empty.set(2);
cl_sxml_string_writer.if_sxml_writer$co_opt_ignore_conv_errros = new abap.types.Integer({qualifiedName: "I"});
cl_sxml_string_writer.if_sxml_writer$co_opt_ignore_conv_errros.set(3);
cl_sxml_string_writer.if_sxml_writer$co_opt_linebreaks = new abap.types.Integer({qualifiedName: "I"});
cl_sxml_string_writer.if_sxml_writer$co_opt_linebreaks.set(4);
cl_sxml_string_writer.if_sxml_writer$co_opt_indent = new abap.types.Integer({qualifiedName: "I"});
cl_sxml_string_writer.if_sxml_writer$co_opt_indent.set(5);
cl_sxml_string_writer.if_sxml_writer$co_opt_illegal_char_reject = new abap.types.Integer({qualifiedName: "I"});
cl_sxml_string_writer.if_sxml_writer$co_opt_illegal_char_reject.set(6);
cl_sxml_string_writer.if_sxml_writer$co_opt_illegal_char_replace = new abap.types.Integer({qualifiedName: "I"});
cl_sxml_string_writer.if_sxml_writer$co_opt_illegal_char_replace.set(7);
cl_sxml_string_writer.if_sxml_writer$co_opt_illegal_char_replace_by = new abap.types.Integer({qualifiedName: "I"});
cl_sxml_string_writer.if_sxml_writer$co_opt_illegal_char_replace_by.set(8);
cl_sxml_string_writer.if_sxml_writer$co_opt_base64_no_lf = new abap.types.Integer({qualifiedName: "I"});
cl_sxml_string_writer.if_sxml_writer$co_opt_base64_no_lf.set(9);

//# sourceMappingURL=cl_sxml_string_writer.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_system_uuid.clas.mjs":
/*!****************************************!*\
  !*** ./output/cl_system_uuid.clas.mjs ***!
  \****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_system_uuid": () => (/* binding */ cl_system_uuid)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_system_uuid.clas.abap
class cl_system_uuid {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_SYSTEM_UUID';
  static IMPLEMENTED_INTERFACES = ["IF_SYSTEM_UUID_RFC4122_STATIC","IF_SYSTEM_UUID_STATIC"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.create_uuid_c32_static = this.if_system_uuid_static$create_uuid_c32;
    this.create_uuid_x16_static = this.if_system_uuid_static$create_uuid_x16;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async if_system_uuid_static$create_uuid_x16() {
    return cl_system_uuid.if_system_uuid_static$create_uuid_x16();
  }
  static async if_system_uuid_static$create_uuid_x16() {
    let uuid = new abap.types.Hex({length: 16});
    if (cl_system_uuid.CRYPTO === undefined) cl_system_uuid.CRYPTO = await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_crypto-browserify_index_js"), __webpack_require__.e("_d546-_8131-_3fc0-_cd53-_4068-_e7e4-_7bec-_0aec-_dbd9-_fbf1-_75ad-_6552-_1dfd-_ed1b-_b483-_d1-da8ac5")]).then(__webpack_require__.t.bind(__webpack_require__, /*! crypto */ "./node_modules/crypto-browserify/index.js", 19));
    uuid.set(cl_system_uuid.CRYPTO.randomBytes(16).toString("hex").toUpperCase());
    return uuid;
  }
  async if_system_uuid_static$create_uuid_c32() {
    return cl_system_uuid.if_system_uuid_static$create_uuid_c32();
  }
  static async if_system_uuid_static$create_uuid_c32() {
    let uuid = new abap.types.Character(32, {"qualifiedName":"SYSUUID_C32","ddicName":"SYSUUID_C32"});
    if (cl_system_uuid.CRYPTO === undefined) cl_system_uuid.CRYPTO = await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_crypto-browserify_index_js"), __webpack_require__.e("_d546-_8131-_3fc0-_cd53-_4068-_e7e4-_7bec-_0aec-_dbd9-_fbf1-_75ad-_6552-_1dfd-_ed1b-_b483-_d1-da8ac5")]).then(__webpack_require__.t.bind(__webpack_require__, /*! crypto */ "./node_modules/crypto-browserify/index.js", 19));
    uuid.set(cl_system_uuid.CRYPTO.randomBytes(16).toString("hex").toUpperCase());
    return uuid;
  }
  async if_system_uuid_rfc4122_static$create_uuid_c36_by_version(INPUT) {
    return cl_system_uuid.if_system_uuid_rfc4122_static$create_uuid_c36_by_version(INPUT);
  }
  static async if_system_uuid_rfc4122_static$create_uuid_c36_by_version(INPUT) {
    let uuid = new abap.types.Character(36, {"qualifiedName":"SYSUUID_C36","ddicName":"SYSUUID_C36"});
    let version = INPUT?.version;
    if (version?.getQualifiedName === undefined || version.getQualifiedName() !== "I") { version = undefined; }
    if (version === undefined) { version = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.version); }
    abap.statements.assert(abap.compare.eq(version, abap.IntegerFactory.get(4)));
    if (cl_system_uuid.CRYPTO === undefined) cl_system_uuid.CRYPTO = await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_crypto-browserify_index_js"), __webpack_require__.e("_d546-_8131-_3fc0-_cd53-_4068-_e7e4-_7bec-_0aec-_dbd9-_fbf1-_75ad-_6552-_1dfd-_ed1b-_b483-_d1-da8ac5")]).then(__webpack_require__.t.bind(__webpack_require__, /*! crypto */ "./node_modules/crypto-browserify/index.js", 19));
    uuid.set(cl_system_uuid.CRYPTO.randomUUID());
    return uuid;
  }
  async if_system_uuid_static$create_uuid_c22() {
    return cl_system_uuid.if_system_uuid_static$create_uuid_c22();
  }
  static async if_system_uuid_static$create_uuid_c22() {
    let uuid = new abap.types.Character(22, {"qualifiedName":"SYSUUID_C22","ddicName":"SYSUUID_C22"});
    if (cl_system_uuid.CRYPTO === undefined) cl_system_uuid.CRYPTO = await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_crypto-browserify_index_js"), __webpack_require__.e("_d546-_8131-_3fc0-_cd53-_4068-_e7e4-_7bec-_0aec-_dbd9-_fbf1-_75ad-_6552-_1dfd-_ed1b-_b483-_d1-da8ac5")]).then(__webpack_require__.t.bind(__webpack_require__, /*! crypto */ "./node_modules/crypto-browserify/index.js", 19));
    uuid.set(cl_system_uuid.CRYPTO.randomBytes(11).toString("hex"));
    return uuid;
  }
}
abap.Classes['CL_SYSTEM_UUID'] = cl_system_uuid;

//# sourceMappingURL=cl_system_uuid.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cl_web_http_utility.clas.mjs":
/*!*********************************************!*\
  !*** ./output/cl_web_http_utility.clas.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cl_web_http_utility": () => (/* binding */ cl_web_http_utility)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cl_web_http_utility.clas.abap
class cl_web_http_utility {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CL_WEB_HTTP_UTILITY';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"UNESCAPE_URL": {"visibility": "U", "parameters": {"UNESCAPED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "ESCAPED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "OPTIONS": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "DECODE_X_BASE64": {"visibility": "U", "parameters": {"DECODED": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "ENCODED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "ENCODE_X_BASE64": {"visibility": "U", "parameters": {"ENCODED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "UNENCODED": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async unescape_url(INPUT) {
    return cl_web_http_utility.unescape_url(INPUT);
  }
  static async unescape_url(INPUT) {
    let unescaped = new abap.types.String({qualifiedName: "STRING"});
    let escaped = INPUT?.escaped;
    if (escaped?.getQualifiedName === undefined || escaped.getQualifiedName() !== "STRING") { escaped = undefined; }
    if (escaped === undefined) { escaped = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.escaped); }
    let options = new abap.types.Integer({qualifiedName: "I"});
    if (INPUT && INPUT.options) {options.set(INPUT.options);}
    unescaped.set((await abap.Classes['CL_HTTP_UTILITY'].if_http_utility$unescape_url({escaped: escaped, options: options})));
    return unescaped;
  }
  async decode_x_base64(INPUT) {
    return cl_web_http_utility.decode_x_base64(INPUT);
  }
  static async decode_x_base64(INPUT) {
    let decoded = new abap.types.XString({qualifiedName: "XSTRING"});
    let encoded = INPUT?.encoded;
    if (encoded?.getQualifiedName === undefined || encoded.getQualifiedName() !== "STRING") { encoded = undefined; }
    if (encoded === undefined) { encoded = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.encoded); }
    decoded.set((await abap.Classes['CL_HTTP_UTILITY'].decode_x_base64({encoded: encoded})));
    return decoded;
  }
  async encode_x_base64(INPUT) {
    return cl_web_http_utility.encode_x_base64(INPUT);
  }
  static async encode_x_base64(INPUT) {
    let encoded = new abap.types.String({qualifiedName: "STRING"});
    let unencoded = INPUT?.unencoded;
    if (unencoded?.getQualifiedName === undefined || unencoded.getQualifiedName() !== "XSTRING") { unencoded = undefined; }
    if (unencoded === undefined) { unencoded = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.unencoded); }
    encoded.set((await abap.Classes['CL_HTTP_UTILITY'].encode_x_base64({unencoded: unencoded})));
    return encoded;
  }
}
abap.Classes['CL_WEB_HTTP_UTILITY'] = cl_web_http_utility;

//# sourceMappingURL=cl_web_http_utility.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_abap_datfm.clas.mjs":
/*!***************************************!*\
  !*** ./output/cx_abap_datfm.clas.mjs ***!
  \***************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_abap_datfm": () => (/* binding */ cx_abap_datfm)
/* harmony export */ });
const {cx_static_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_static_check.clas.mjs */ "./output/cx_static_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_abap_datfm.clas.abap
class cx_abap_datfm extends cx_static_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_ABAP_DATFM';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_ABAP_DATFM'] = cx_abap_datfm;

//# sourceMappingURL=cx_abap_datfm.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_abap_message_digest.clas.mjs":
/*!************************************************!*\
  !*** ./output/cx_abap_message_digest.clas.mjs ***!
  \************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_abap_message_digest": () => (/* binding */ cx_abap_message_digest)
/* harmony export */ });
const {cx_static_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_static_check.clas.mjs */ "./output/cx_static_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_abap_message_digest.clas.abap
class cx_abap_message_digest extends cx_static_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_ABAP_MESSAGE_DIGEST';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_ABAP_MESSAGE_DIGEST'] = cx_abap_message_digest;

//# sourceMappingURL=cx_abap_message_digest.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_abap_not_a_table.clas.mjs":
/*!*********************************************!*\
  !*** ./output/cx_abap_not_a_table.clas.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_abap_not_a_table": () => (/* binding */ cx_abap_not_a_table)
/* harmony export */ });
const {cx_static_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_static_check.clas.mjs */ "./output/cx_static_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_abap_not_a_table.clas.abap
class cx_abap_not_a_table extends cx_static_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_ABAP_NOT_A_TABLE';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_ABAP_NOT_A_TABLE'] = cx_abap_not_a_table;

//# sourceMappingURL=cx_abap_not_a_table.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_abap_not_in_package.clas.mjs":
/*!************************************************!*\
  !*** ./output/cx_abap_not_in_package.clas.mjs ***!
  \************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_abap_not_in_package": () => (/* binding */ cx_abap_not_in_package)
/* harmony export */ });
const {cx_static_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_static_check.clas.mjs */ "./output/cx_static_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_abap_not_in_package.clas.abap
class cx_abap_not_in_package extends cx_static_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_ABAP_NOT_IN_PACKAGE';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_ABAP_NOT_IN_PACKAGE'] = cx_abap_not_in_package;

//# sourceMappingURL=cx_abap_not_in_package.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_abap_not_in_whitelist.clas.mjs":
/*!**************************************************!*\
  !*** ./output/cx_abap_not_in_whitelist.clas.mjs ***!
  \**************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_abap_not_in_whitelist": () => (/* binding */ cx_abap_not_in_whitelist)
/* harmony export */ });
const {cx_static_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_static_check.clas.mjs */ "./output/cx_static_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_abap_not_in_whitelist.clas.abap
class cx_abap_not_in_whitelist extends cx_static_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_ABAP_NOT_IN_WHITELIST';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_ABAP_NOT_IN_WHITELIST'] = cx_abap_not_in_whitelist;

//# sourceMappingURL=cx_abap_not_in_whitelist.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_abap_random.clas.mjs":
/*!****************************************!*\
  !*** ./output/cx_abap_random.clas.mjs ***!
  \****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_abap_random": () => (/* binding */ cx_abap_random)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_abap_random.clas.abap
class cx_abap_random extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_ABAP_RANDOM';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_ABAP_RANDOM'] = cx_abap_random;

//# sourceMappingURL=cx_abap_random.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_abap_timefm_invalid.clas.mjs":
/*!************************************************!*\
  !*** ./output/cx_abap_timefm_invalid.clas.mjs ***!
  \************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_abap_timefm_invalid": () => (/* binding */ cx_abap_timefm_invalid)
/* harmony export */ });
const {cx_static_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_static_check.clas.mjs */ "./output/cx_static_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_abap_timefm_invalid.clas.abap
class cx_abap_timefm_invalid extends cx_static_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_ABAP_TIMEFM_INVALID';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_ABAP_TIMEFM_INVALID'] = cx_abap_timefm_invalid;

//# sourceMappingURL=cx_abap_timefm_invalid.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_apc_error.clas.mjs":
/*!**************************************!*\
  !*** ./output/cx_apc_error.clas.mjs ***!
  \**************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_apc_error": () => (/* binding */ cx_apc_error)
/* harmony export */ });
const {cx_static_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_static_check.clas.mjs */ "./output/cx_static_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_apc_error.clas.abap
class cx_apc_error extends cx_static_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_APC_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_APC_ERROR'] = cx_apc_error;

//# sourceMappingURL=cx_apc_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_bcs.clas.mjs":
/*!********************************!*\
  !*** ./output/cx_bcs.clas.mjs ***!
  \********************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_bcs": () => (/* binding */ cx_bcs)
/* harmony export */ });
const {cx_static_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_static_check.clas.mjs */ "./output/cx_static_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_bcs.clas.abap
class cx_bcs extends cx_static_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_BCS';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_BCS'] = cx_bcs;

//# sourceMappingURL=cx_bcs.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_dynamic_check.clas.mjs":
/*!******************************************!*\
  !*** ./output/cx_dynamic_check.clas.mjs ***!
  \******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_dynamic_check": () => (/* binding */ cx_dynamic_check)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_dynamic_check.clas.abap
class cx_dynamic_check extends cx_root {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_DYNAMIC_CHECK';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_DYNAMIC_CHECK'] = cx_dynamic_check;

//# sourceMappingURL=cx_dynamic_check.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_ftd_parameter_not_found.clas.mjs":
/*!****************************************************!*\
  !*** ./output/cx_ftd_parameter_not_found.clas.mjs ***!
  \****************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_ftd_parameter_not_found": () => (/* binding */ cx_ftd_parameter_not_found)
/* harmony export */ });
const {cx_no_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_no_check.clas.mjs */ "./output/cx_no_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_ftd_parameter_not_found.clas.abap
class cx_ftd_parameter_not_found extends cx_no_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_FTD_PARAMETER_NOT_FOUND';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_FTD_PARAMETER_NOT_FOUND'] = cx_ftd_parameter_not_found;

//# sourceMappingURL=cx_ftd_parameter_not_found.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_gdt_conversion.clas.mjs":
/*!*******************************************!*\
  !*** ./output/cx_gdt_conversion.clas.mjs ***!
  \*******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_gdt_conversion": () => (/* binding */ cx_gdt_conversion)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_gdt_conversion.clas.abap
class cx_gdt_conversion extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_GDT_CONVERSION';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_GDT_CONVERSION'] = cx_gdt_conversion;

//# sourceMappingURL=cx_gdt_conversion.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_no_check.clas.mjs":
/*!*************************************!*\
  !*** ./output/cx_no_check.clas.mjs ***!
  \*************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_no_check": () => (/* binding */ cx_no_check)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_no_check.clas.abap
class cx_no_check extends cx_root {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_NO_CHECK';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"TEXTID": {"type": () => {return new abap.types.Character(32, {});}, "is_optional": " "}, "PREVIOUS": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    let textid = new abap.types.Character(32, {});
    if (INPUT && INPUT.textid) {textid.set(INPUT.textid);}
    let previous = new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});
    if (INPUT && INPUT.previous) {previous.set(INPUT.previous);}
    await super.constructor_({previous: previous, textid: textid});
    return this;
  }
}
abap.Classes['CX_NO_CHECK'] = cx_no_check;

//# sourceMappingURL=cx_no_check.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_oo_clif_not_exists.clas.mjs":
/*!***********************************************!*\
  !*** ./output/cx_oo_clif_not_exists.clas.mjs ***!
  \***********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_oo_clif_not_exists": () => (/* binding */ cx_oo_clif_not_exists)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_oo_clif_not_exists.clas.abap
class cx_oo_clif_not_exists extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_OO_CLIF_NOT_EXISTS';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_OO_CLIF_NOT_EXISTS'] = cx_oo_clif_not_exists;

//# sourceMappingURL=cx_oo_clif_not_exists.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_parameter_invalid.clas.mjs":
/*!**********************************************!*\
  !*** ./output/cx_parameter_invalid.clas.mjs ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_parameter_invalid": () => (/* binding */ cx_parameter_invalid)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_parameter_invalid.clas.abap
class cx_parameter_invalid extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_PARAMETER_INVALID';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"TEXTID": {"type": () => {return new abap.types.Character(32, {});}, "is_optional": " "}, "PREVIOUS": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});}, "is_optional": " "}, "PARAMETER": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    let textid = new abap.types.Character(32, {});
    if (INPUT && INPUT.textid) {textid.set(INPUT.textid);}
    let previous = new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});
    if (INPUT && INPUT.previous) {previous.set(INPUT.previous);}
    let parameter = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.parameter) {parameter.set(INPUT.parameter);}
    await super.constructor_({textid: textid, previous: previous});
    return this;
  }
}
abap.Classes['CX_PARAMETER_INVALID'] = cx_parameter_invalid;

//# sourceMappingURL=cx_parameter_invalid.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_parameter_invalid_range.clas.mjs":
/*!****************************************************!*\
  !*** ./output/cx_parameter_invalid_range.clas.mjs ***!
  \****************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_parameter_invalid_range": () => (/* binding */ cx_parameter_invalid_range)
/* harmony export */ });
const {cx_parameter_invalid} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_parameter_invalid.clas.mjs */ "./output/cx_parameter_invalid.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_parameter_invalid_range.clas.abap
class cx_parameter_invalid_range extends cx_parameter_invalid {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_PARAMETER_INVALID_RANGE';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"TEXTID": {"type": () => {return new abap.types.Character(32, {});}, "is_optional": " "}, "PREVIOUS": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});}, "is_optional": " "}, "PARAMETER": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    let textid = new abap.types.Character(32, {});
    if (INPUT && INPUT.textid) {textid.set(INPUT.textid);}
    let previous = new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});
    if (INPUT && INPUT.previous) {previous.set(INPUT.previous);}
    let parameter = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.parameter) {parameter.set(INPUT.parameter);}
    let value = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.value) {value.set(INPUT.value);}
    await super.constructor_({textid: textid, previous: previous, parameter: parameter});
    return this;
  }
}
abap.Classes['CX_PARAMETER_INVALID_RANGE'] = cx_parameter_invalid_range;

//# sourceMappingURL=cx_parameter_invalid_range.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_parameter_invalid_type.clas.mjs":
/*!***************************************************!*\
  !*** ./output/cx_parameter_invalid_type.clas.mjs ***!
  \***************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_parameter_invalid_type": () => (/* binding */ cx_parameter_invalid_type)
/* harmony export */ });
const {cx_parameter_invalid} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_parameter_invalid.clas.mjs */ "./output/cx_parameter_invalid.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_parameter_invalid_type.clas.abap
class cx_parameter_invalid_type extends cx_parameter_invalid {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_PARAMETER_INVALID_TYPE';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_PARAMETER_INVALID_TYPE'] = cx_parameter_invalid_type;

//# sourceMappingURL=cx_parameter_invalid_type.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_root.clas.mjs":
/*!*********************************!*\
  !*** ./output/cx_root.clas.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_root": () => (/* binding */ cx_root)
/* harmony export */ });
// cx_root.clas.abap
class cx_root extends Error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_ROOT';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE"];
  static ATTRIBUTES = {"PREVIOUS": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "TEXTID": {"type": () => {return new abap.types.Character(32, {});}, "visibility": "U", "is_constant": " ", "is_class": " "}};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"TEXTID": {"type": () => {return new abap.types.Character(32, {});}, "is_optional": " "}, "PREVIOUS": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});}, "is_optional": " "}}},
  "GET_SOURCE_POSITION": {"visibility": "U", "parameters": {"PROGRAM_NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "INCLUDE_NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "SOURCE_LINE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.previous = new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});
    this.textid = new abap.types.Character(32, {});
    this.get_longtext = this.if_message$get_longtext;
    this.get_text = this.if_message$get_text;
  }
  async constructor_(INPUT) {
    let textid = new abap.types.Character(32, {});
    if (INPUT && INPUT.textid) {textid.set(INPUT.textid);}
    let previous = new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});
    if (INPUT && INPUT.previous) {previous.set(INPUT.previous);}
    this.me.get().previous.set(previous);
    this.me.get().textid.set(textid);
    return this;
  }
  async get_source_position(INPUT) {
    let program_name = INPUT?.program_name || new abap.types.String({qualifiedName: "STRING"});
    let include_name = INPUT?.include_name || new abap.types.String({qualifiedName: "STRING"});
    let source_line = INPUT?.source_line || new abap.types.Integer({qualifiedName: "I"});
    abap.statements.clear(program_name);
    abap.statements.clear(include_name);
    abap.statements.clear(source_line);
    source_line.set(this.EXTRA_CX.INTERNAL_LINE || 1);
    program_name.set(this.EXTRA_CX.INTERNAL_FILENAME || "error");
  }
  async if_message$get_longtext(INPUT) {
    let result = new abap.types.String({qualifiedName: "STRING"});
    let preserve_newlines = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    if (INPUT && INPUT.preserve_newlines) {preserve_newlines.set(INPUT.preserve_newlines);}
    result.set(new abap.types.Character(29).set('OpenAbapGetLongtextDummyValue'));
    return result;
  }
  async if_message$get_text() {
    let result = new abap.types.String({qualifiedName: "STRING"});
    result.set((await abap.Classes['CL_MESSAGE_HELPER'].get_text_for_message({text: this.me})));
    return result;
  }
}
abap.Classes['CX_ROOT'] = cx_root;

//# sourceMappingURL=cx_root.clas.mjs.map

/***/ }),

/***/ "./output/cx_salv_access_error.clas.mjs":
/*!**********************************************!*\
  !*** ./output/cx_salv_access_error.clas.mjs ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_salv_access_error": () => (/* binding */ cx_salv_access_error)
/* harmony export */ });
const {cx_salv_static_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_salv_static_check.clas.mjs */ "./output/cx_salv_static_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_salv_access_error.clas.abap
class cx_salv_access_error extends cx_salv_static_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SALV_ACCESS_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SALV_ACCESS_ERROR'] = cx_salv_access_error;

//# sourceMappingURL=cx_salv_access_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_salv_data_error.clas.mjs":
/*!********************************************!*\
  !*** ./output/cx_salv_data_error.clas.mjs ***!
  \********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_salv_data_error": () => (/* binding */ cx_salv_data_error)
/* harmony export */ });
const {cx_salv_static_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_salv_static_check.clas.mjs */ "./output/cx_salv_static_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_salv_data_error.clas.abap
class cx_salv_data_error extends cx_salv_static_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SALV_DATA_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SALV_DATA_ERROR'] = cx_salv_data_error;

//# sourceMappingURL=cx_salv_data_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_salv_error.clas.mjs":
/*!***************************************!*\
  !*** ./output/cx_salv_error.clas.mjs ***!
  \***************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_salv_error": () => (/* binding */ cx_salv_error)
/* harmony export */ });
const {cx_static_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_static_check.clas.mjs */ "./output/cx_static_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_salv_error.clas.abap
class cx_salv_error extends cx_static_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SALV_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SALV_ERROR'] = cx_salv_error;

//# sourceMappingURL=cx_salv_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_salv_existing.clas.mjs":
/*!******************************************!*\
  !*** ./output/cx_salv_existing.clas.mjs ***!
  \******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_salv_existing": () => (/* binding */ cx_salv_existing)
/* harmony export */ });
const {cx_salv_access_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_salv_access_error.clas.mjs */ "./output/cx_salv_access_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_salv_existing.clas.abap
class cx_salv_existing extends cx_salv_access_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SALV_EXISTING';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SALV_EXISTING'] = cx_salv_existing;

//# sourceMappingURL=cx_salv_existing.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_salv_msg.clas.mjs":
/*!*************************************!*\
  !*** ./output/cx_salv_msg.clas.mjs ***!
  \*************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_salv_msg": () => (/* binding */ cx_salv_msg)
/* harmony export */ });
const {cx_salv_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_salv_error.clas.mjs */ "./output/cx_salv_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_salv_msg.clas.abap
class cx_salv_msg extends cx_salv_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SALV_MSG';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SALV_MSG'] = cx_salv_msg;

//# sourceMappingURL=cx_salv_msg.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_salv_not_found.clas.mjs":
/*!*******************************************!*\
  !*** ./output/cx_salv_not_found.clas.mjs ***!
  \*******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_salv_not_found": () => (/* binding */ cx_salv_not_found)
/* harmony export */ });
const {cx_salv_access_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_salv_access_error.clas.mjs */ "./output/cx_salv_access_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_salv_not_found.clas.abap
class cx_salv_not_found extends cx_salv_access_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SALV_NOT_FOUND';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SALV_NOT_FOUND'] = cx_salv_not_found;

//# sourceMappingURL=cx_salv_not_found.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_salv_static_check.clas.mjs":
/*!**********************************************!*\
  !*** ./output/cx_salv_static_check.clas.mjs ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_salv_static_check": () => (/* binding */ cx_salv_static_check)
/* harmony export */ });
const {cx_salv_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_salv_error.clas.mjs */ "./output/cx_salv_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_salv_static_check.clas.abap
class cx_salv_static_check extends cx_salv_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SALV_STATIC_CHECK';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SALV_STATIC_CHECK'] = cx_salv_static_check;

//# sourceMappingURL=cx_salv_static_check.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shm_already_detached.clas.mjs":
/*!*************************************************!*\
  !*** ./output/cx_shm_already_detached.clas.mjs ***!
  \*************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shm_already_detached": () => (/* binding */ cx_shm_already_detached)
/* harmony export */ });
const {cx_shm_general_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_general_error.clas.mjs */ "./output/cx_shm_general_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shm_already_detached.clas.abap
class cx_shm_already_detached extends cx_shm_general_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHM_ALREADY_DETACHED';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"TEXTID": {"type": () => {return new abap.types.Character(32, {});}, "is_optional": " "}, "PREVIOUS": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});}, "is_optional": " "}, "AREA_NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "INST_NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    let textid = new abap.types.Character(32, {});
    if (INPUT && INPUT.textid) {textid.set(INPUT.textid);}
    let previous = new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});
    if (INPUT && INPUT.previous) {previous.set(INPUT.previous);}
    let area_name = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.area_name) {area_name.set(INPUT.area_name);}
    let inst_name = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.inst_name) {inst_name.set(INPUT.inst_name);}
    let client = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.client) {client.set(INPUT.client);}
    return this;
    return this;
  }
}
abap.Classes['CX_SHM_ALREADY_DETACHED'] = cx_shm_already_detached;

//# sourceMappingURL=cx_shm_already_detached.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shm_attach_error.clas.mjs":
/*!*********************************************!*\
  !*** ./output/cx_shm_attach_error.clas.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shm_attach_error": () => (/* binding */ cx_shm_attach_error)
/* harmony export */ });
const {cx_shm_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_error.clas.mjs */ "./output/cx_shm_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shm_attach_error.clas.abap
class cx_shm_attach_error extends cx_shm_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHM_ATTACH_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHM_ATTACH_ERROR'] = cx_shm_attach_error;

//# sourceMappingURL=cx_shm_attach_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shm_build_failed.clas.mjs":
/*!*********************************************!*\
  !*** ./output/cx_shm_build_failed.clas.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shm_build_failed": () => (/* binding */ cx_shm_build_failed)
/* harmony export */ });
const {cx_shm_general_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_general_error.clas.mjs */ "./output/cx_shm_general_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shm_build_failed.clas.abap
class cx_shm_build_failed extends cx_shm_general_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHM_BUILD_FAILED';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHM_BUILD_FAILED'] = cx_shm_build_failed;

//# sourceMappingURL=cx_shm_build_failed.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shm_change_lock_active.clas.mjs":
/*!***************************************************!*\
  !*** ./output/cx_shm_change_lock_active.clas.mjs ***!
  \***************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shm_change_lock_active": () => (/* binding */ cx_shm_change_lock_active)
/* harmony export */ });
const {cx_shm_attach_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_attach_error.clas.mjs */ "./output/cx_shm_attach_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shm_change_lock_active.clas.abap
class cx_shm_change_lock_active extends cx_shm_attach_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHM_CHANGE_LOCK_ACTIVE';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHM_CHANGE_LOCK_ACTIVE'] = cx_shm_change_lock_active;

//# sourceMappingURL=cx_shm_change_lock_active.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shm_completion_error.clas.mjs":
/*!*************************************************!*\
  !*** ./output/cx_shm_completion_error.clas.mjs ***!
  \*************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shm_completion_error": () => (/* binding */ cx_shm_completion_error)
/* harmony export */ });
const {cx_shm_detach_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_detach_error.clas.mjs */ "./output/cx_shm_detach_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shm_completion_error.clas.abap
class cx_shm_completion_error extends cx_shm_detach_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHM_COMPLETION_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHM_COMPLETION_ERROR'] = cx_shm_completion_error;

//# sourceMappingURL=cx_shm_completion_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shm_detach_error.clas.mjs":
/*!*********************************************!*\
  !*** ./output/cx_shm_detach_error.clas.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shm_detach_error": () => (/* binding */ cx_shm_detach_error)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shm_detach_error.clas.abap
class cx_shm_detach_error extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHM_DETACH_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHM_DETACH_ERROR'] = cx_shm_detach_error;

//# sourceMappingURL=cx_shm_detach_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shm_error.clas.mjs":
/*!**************************************!*\
  !*** ./output/cx_shm_error.clas.mjs ***!
  \**************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shm_error": () => (/* binding */ cx_shm_error)
/* harmony export */ });
const {cx_static_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_static_check.clas.mjs */ "./output/cx_static_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shm_error.clas.abap
class cx_shm_error extends cx_static_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHM_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHM_ERROR'] = cx_shm_error;

//# sourceMappingURL=cx_shm_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shm_event_execution_failed.clas.mjs":
/*!*******************************************************!*\
  !*** ./output/cx_shm_event_execution_failed.clas.mjs ***!
  \*******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shm_event_execution_failed": () => (/* binding */ cx_shm_event_execution_failed)
/* harmony export */ });
const {cx_shm_completion_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_completion_error.clas.mjs */ "./output/cx_shm_completion_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shm_event_execution_failed.clas.abap
class cx_shm_event_execution_failed extends cx_shm_completion_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHM_EVENT_EXECUTION_FAILED';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHM_EVENT_EXECUTION_FAILED'] = cx_shm_event_execution_failed;

//# sourceMappingURL=cx_shm_event_execution_failed.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shm_exclusive_lock_active.clas.mjs":
/*!******************************************************!*\
  !*** ./output/cx_shm_exclusive_lock_active.clas.mjs ***!
  \******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shm_exclusive_lock_active": () => (/* binding */ cx_shm_exclusive_lock_active)
/* harmony export */ });
const {cx_shm_attach_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_attach_error.clas.mjs */ "./output/cx_shm_attach_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shm_exclusive_lock_active.clas.abap
class cx_shm_exclusive_lock_active extends cx_shm_attach_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHM_EXCLUSIVE_LOCK_ACTIVE';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHM_EXCLUSIVE_LOCK_ACTIVE'] = cx_shm_exclusive_lock_active;

//# sourceMappingURL=cx_shm_exclusive_lock_active.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shm_general_error.clas.mjs":
/*!**********************************************!*\
  !*** ./output/cx_shm_general_error.clas.mjs ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shm_general_error": () => (/* binding */ cx_shm_general_error)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shm_general_error.clas.abap
class cx_shm_general_error extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHM_GENERAL_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHM_GENERAL_ERROR'] = cx_shm_general_error;

//# sourceMappingURL=cx_shm_general_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shm_inconsistent.clas.mjs":
/*!*********************************************!*\
  !*** ./output/cx_shm_inconsistent.clas.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shm_inconsistent": () => (/* binding */ cx_shm_inconsistent)
/* harmony export */ });
const {cx_shm_attach_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_attach_error.clas.mjs */ "./output/cx_shm_attach_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shm_inconsistent.clas.abap
class cx_shm_inconsistent extends cx_shm_attach_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHM_INCONSISTENT';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHM_INCONSISTENT'] = cx_shm_inconsistent;

//# sourceMappingURL=cx_shm_inconsistent.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shm_initial_reference.clas.mjs":
/*!**************************************************!*\
  !*** ./output/cx_shm_initial_reference.clas.mjs ***!
  \**************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shm_initial_reference": () => (/* binding */ cx_shm_initial_reference)
/* harmony export */ });
const {cx_shm_general_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_general_error.clas.mjs */ "./output/cx_shm_general_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shm_initial_reference.clas.abap
class cx_shm_initial_reference extends cx_shm_general_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHM_INITIAL_REFERENCE';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHM_INITIAL_REFERENCE'] = cx_shm_initial_reference;

//# sourceMappingURL=cx_shm_initial_reference.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shm_no_active_version.clas.mjs":
/*!**************************************************!*\
  !*** ./output/cx_shm_no_active_version.clas.mjs ***!
  \**************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shm_no_active_version": () => (/* binding */ cx_shm_no_active_version)
/* harmony export */ });
const {cx_shm_attach_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_attach_error.clas.mjs */ "./output/cx_shm_attach_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shm_no_active_version.clas.abap
class cx_shm_no_active_version extends cx_shm_attach_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHM_NO_ACTIVE_VERSION';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHM_NO_ACTIVE_VERSION'] = cx_shm_no_active_version;

//# sourceMappingURL=cx_shm_no_active_version.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shm_parameter_error.clas.mjs":
/*!************************************************!*\
  !*** ./output/cx_shm_parameter_error.clas.mjs ***!
  \************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shm_parameter_error": () => (/* binding */ cx_shm_parameter_error)
/* harmony export */ });
const {cx_shm_general_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_general_error.clas.mjs */ "./output/cx_shm_general_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shm_parameter_error.clas.abap
class cx_shm_parameter_error extends cx_shm_general_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHM_PARAMETER_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHM_PARAMETER_ERROR'] = cx_shm_parameter_error;

//# sourceMappingURL=cx_shm_parameter_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shm_pending_lock_removed.clas.mjs":
/*!*****************************************************!*\
  !*** ./output/cx_shm_pending_lock_removed.clas.mjs ***!
  \*****************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shm_pending_lock_removed": () => (/* binding */ cx_shm_pending_lock_removed)
/* harmony export */ });
const {cx_shm_attach_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_attach_error.clas.mjs */ "./output/cx_shm_attach_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shm_pending_lock_removed.clas.abap
class cx_shm_pending_lock_removed extends cx_shm_attach_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHM_PENDING_LOCK_REMOVED';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHM_PENDING_LOCK_REMOVED'] = cx_shm_pending_lock_removed;

//# sourceMappingURL=cx_shm_pending_lock_removed.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shm_read_lock_active.clas.mjs":
/*!*************************************************!*\
  !*** ./output/cx_shm_read_lock_active.clas.mjs ***!
  \*************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shm_read_lock_active": () => (/* binding */ cx_shm_read_lock_active)
/* harmony export */ });
const {cx_shm_attach_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_attach_error.clas.mjs */ "./output/cx_shm_attach_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shm_read_lock_active.clas.abap
class cx_shm_read_lock_active extends cx_shm_attach_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHM_READ_LOCK_ACTIVE';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHM_READ_LOCK_ACTIVE'] = cx_shm_read_lock_active;

//# sourceMappingURL=cx_shm_read_lock_active.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shm_secondary_commit.clas.mjs":
/*!*************************************************!*\
  !*** ./output/cx_shm_secondary_commit.clas.mjs ***!
  \*************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shm_secondary_commit": () => (/* binding */ cx_shm_secondary_commit)
/* harmony export */ });
const {cx_shm_detach_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_detach_error.clas.mjs */ "./output/cx_shm_detach_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shm_secondary_commit.clas.abap
class cx_shm_secondary_commit extends cx_shm_detach_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHM_SECONDARY_COMMIT';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHM_SECONDARY_COMMIT'] = cx_shm_secondary_commit;

//# sourceMappingURL=cx_shm_secondary_commit.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shm_version_limit_exceeded.clas.mjs":
/*!*******************************************************!*\
  !*** ./output/cx_shm_version_limit_exceeded.clas.mjs ***!
  \*******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shm_version_limit_exceeded": () => (/* binding */ cx_shm_version_limit_exceeded)
/* harmony export */ });
const {cx_shm_attach_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_attach_error.clas.mjs */ "./output/cx_shm_attach_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shm_version_limit_exceeded.clas.abap
class cx_shm_version_limit_exceeded extends cx_shm_attach_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHM_VERSION_LIMIT_EXCEEDED';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHM_VERSION_LIMIT_EXCEEDED'] = cx_shm_version_limit_exceeded;

//# sourceMappingURL=cx_shm_version_limit_exceeded.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shm_wrong_handle.clas.mjs":
/*!*********************************************!*\
  !*** ./output/cx_shm_wrong_handle.clas.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shm_wrong_handle": () => (/* binding */ cx_shm_wrong_handle)
/* harmony export */ });
const {cx_shm_general_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_general_error.clas.mjs */ "./output/cx_shm_general_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shm_wrong_handle.clas.abap
class cx_shm_wrong_handle extends cx_shm_general_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHM_WRONG_HANDLE';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHM_WRONG_HANDLE'] = cx_shm_wrong_handle;

//# sourceMappingURL=cx_shm_wrong_handle.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shma_dynamic.clas.mjs":
/*!*****************************************!*\
  !*** ./output/cx_shma_dynamic.clas.mjs ***!
  \*****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shma_dynamic": () => (/* binding */ cx_shma_dynamic)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shma_dynamic.clas.abap
class cx_shma_dynamic extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHMA_DYNAMIC';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHMA_DYNAMIC'] = cx_shma_dynamic;

//# sourceMappingURL=cx_shma_dynamic.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shma_inconsistent.clas.mjs":
/*!**********************************************!*\
  !*** ./output/cx_shma_inconsistent.clas.mjs ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shma_inconsistent": () => (/* binding */ cx_shma_inconsistent)
/* harmony export */ });
const {cx_shma_dynamic} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shma_dynamic.clas.mjs */ "./output/cx_shma_dynamic.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shma_inconsistent.clas.abap
class cx_shma_inconsistent extends cx_shma_dynamic {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHMA_INCONSISTENT';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHMA_INCONSISTENT'] = cx_shma_inconsistent;

//# sourceMappingURL=cx_shma_inconsistent.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_shma_not_configured.clas.mjs":
/*!************************************************!*\
  !*** ./output/cx_shma_not_configured.clas.mjs ***!
  \************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_shma_not_configured": () => (/* binding */ cx_shma_not_configured)
/* harmony export */ });
const {cx_shma_dynamic} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shma_dynamic.clas.mjs */ "./output/cx_shma_dynamic.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_shma_not_configured.clas.abap
class cx_shma_not_configured extends cx_shma_dynamic {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SHMA_NOT_CONFIGURED';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SHMA_NOT_CONFIGURED'] = cx_shma_not_configured;

//# sourceMappingURL=cx_shma_not_configured.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sql_exception.clas.mjs":
/*!******************************************!*\
  !*** ./output/cx_sql_exception.clas.mjs ***!
  \******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sql_exception": () => (/* binding */ cx_sql_exception)
/* harmony export */ });
const {cx_static_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_static_check.clas.mjs */ "./output/cx_static_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sql_exception.clas.abap
class cx_sql_exception extends cx_static_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SQL_EXCEPTION';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SQL_EXCEPTION'] = cx_sql_exception;

//# sourceMappingURL=cx_sql_exception.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_st_error.clas.mjs":
/*!*************************************!*\
  !*** ./output/cx_st_error.clas.mjs ***!
  \*************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_st_error": () => (/* binding */ cx_st_error)
/* harmony export */ });
const {cx_transformation_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_transformation_error.clas.mjs */ "./output/cx_transformation_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_st_error.clas.abap
class cx_st_error extends cx_transformation_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_ST_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_ST_ERROR'] = cx_st_error;

//# sourceMappingURL=cx_st_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_static_check.clas.mjs":
/*!*****************************************!*\
  !*** ./output/cx_static_check.clas.mjs ***!
  \*****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_static_check": () => (/* binding */ cx_static_check)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_static_check.clas.abap
class cx_static_check extends cx_root {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_STATIC_CHECK';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"TEXTID": {"type": () => {return new abap.types.Character(32, {});}, "is_optional": " "}, "PREVIOUS": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    let textid = new abap.types.Character(32, {});
    if (INPUT && INPUT.textid) {textid.set(INPUT.textid);}
    let previous = new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});
    if (INPUT && INPUT.previous) {previous.set(INPUT.previous);}
    await super.constructor_({textid: textid, previous: previous});
    return this;
  }
}
abap.Classes['CX_STATIC_CHECK'] = cx_static_check;

//# sourceMappingURL=cx_static_check.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sxml_error.clas.mjs":
/*!***************************************!*\
  !*** ./output/cx_sxml_error.clas.mjs ***!
  \***************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sxml_error": () => (/* binding */ cx_sxml_error)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sxml_error.clas.abap
class cx_sxml_error extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SXML_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SXML_ERROR'] = cx_sxml_error;

//# sourceMappingURL=cx_sxml_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sxml_illegal_argument_error.clas.mjs":
/*!********************************************************!*\
  !*** ./output/cx_sxml_illegal_argument_error.clas.mjs ***!
  \********************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sxml_illegal_argument_error": () => (/* binding */ cx_sxml_illegal_argument_error)
/* harmony export */ });
const {cx_sxml_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sxml_error.clas.mjs */ "./output/cx_sxml_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sxml_illegal_argument_error.clas.abap
class cx_sxml_illegal_argument_error extends cx_sxml_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SXML_ILLEGAL_ARGUMENT_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SXML_ILLEGAL_ARGUMENT_ERROR'] = cx_sxml_illegal_argument_error;

//# sourceMappingURL=cx_sxml_illegal_argument_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sxml_name_error.clas.mjs":
/*!********************************************!*\
  !*** ./output/cx_sxml_name_error.clas.mjs ***!
  \********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sxml_name_error": () => (/* binding */ cx_sxml_name_error)
/* harmony export */ });
const {cx_sxml_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sxml_error.clas.mjs */ "./output/cx_sxml_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sxml_name_error.clas.abap
class cx_sxml_name_error extends cx_sxml_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SXML_NAME_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SXML_NAME_ERROR'] = cx_sxml_name_error;

//# sourceMappingURL=cx_sxml_name_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sxml_parse_error.clas.mjs":
/*!*********************************************!*\
  !*** ./output/cx_sxml_parse_error.clas.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sxml_parse_error": () => (/* binding */ cx_sxml_parse_error)
/* harmony export */ });
const {cx_sxml_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sxml_error.clas.mjs */ "./output/cx_sxml_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sxml_parse_error.clas.abap
class cx_sxml_parse_error extends cx_sxml_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SXML_PARSE_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {"ERROR_TEXT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "RAWSTRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "XML_OFFSET": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "RC": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "KERNEL_PARSER": {"type": () => {return new abap.types.Character(32, {"qualifiedName":"SOTR_CONC","ddicName":"SOTR_CONC"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"XML_OFFSET": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.error_text = new abap.types.String({qualifiedName: "STRING"});
    this.rawstring = new abap.types.String({qualifiedName: "STRING"});
    this.xml_offset = new abap.types.Integer({qualifiedName: "I"});
    this.rc = new abap.types.Integer({qualifiedName: "I"});
    this.kernel_parser = cx_sxml_parse_error.kernel_parser;
  }
  async constructor_(INPUT) {
    let xml_offset = INPUT?.xml_offset;
    if (xml_offset?.getQualifiedName === undefined || xml_offset.getQualifiedName() !== "I") { xml_offset = undefined; }
    if (xml_offset === undefined) { xml_offset = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.xml_offset); }
    await super.constructor_();
    this.me.get().xml_offset.set(xml_offset);
    return this;
  }
}
abap.Classes['CX_SXML_PARSE_ERROR'] = cx_sxml_parse_error;
cx_sxml_parse_error.kernel_parser = new abap.types.Character(32, {"qualifiedName":"SOTR_CONC","ddicName":"SOTR_CONC"});
cx_sxml_parse_error.kernel_parser.set('00000000000000000000000000000000');

//# sourceMappingURL=cx_sxml_parse_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sxml_state_error.clas.mjs":
/*!*********************************************!*\
  !*** ./output/cx_sxml_state_error.clas.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sxml_state_error": () => (/* binding */ cx_sxml_state_error)
/* harmony export */ });
const {cx_sxml_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sxml_error.clas.mjs */ "./output/cx_sxml_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sxml_state_error.clas.abap
class cx_sxml_state_error extends cx_sxml_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SXML_STATE_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SXML_STATE_ERROR'] = cx_sxml_state_error;

//# sourceMappingURL=cx_sxml_state_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_arithmetic_error.clas.mjs":
/*!************************************************!*\
  !*** ./output/cx_sy_arithmetic_error.clas.mjs ***!
  \************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_arithmetic_error": () => (/* binding */ cx_sy_arithmetic_error)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_arithmetic_error.clas.abap
class cx_sy_arithmetic_error extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_ARITHMETIC_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_ARITHMETIC_ERROR'] = cx_sy_arithmetic_error;

//# sourceMappingURL=cx_sy_arithmetic_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_arithmetic_overflow.clas.mjs":
/*!***************************************************!*\
  !*** ./output/cx_sy_arithmetic_overflow.clas.mjs ***!
  \***************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_arithmetic_overflow": () => (/* binding */ cx_sy_arithmetic_overflow)
/* harmony export */ });
const {cx_sy_arithmetic_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_arithmetic_error.clas.mjs */ "./output/cx_sy_arithmetic_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_arithmetic_overflow.clas.abap
class cx_sy_arithmetic_overflow extends cx_sy_arithmetic_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_ARITHMETIC_OVERFLOW';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {"IF_MESSAGE~GET_TEXT": {"visibility": "U", "parameters": {}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async if_message$get_text() {
    let result = new abap.types.String({qualifiedName: "STRING"});
    result.set(new abap.types.Character(19).set('Arithmetic overflow'));
    return result;
  }
}
abap.Classes['CX_SY_ARITHMETIC_OVERFLOW'] = cx_sy_arithmetic_overflow;

//# sourceMappingURL=cx_sy_arithmetic_overflow.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_buffer_overflow.clas.mjs":
/*!***********************************************!*\
  !*** ./output/cx_sy_buffer_overflow.clas.mjs ***!
  \***********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_buffer_overflow": () => (/* binding */ cx_sy_buffer_overflow)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_buffer_overflow.clas.abap
class cx_sy_buffer_overflow extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_BUFFER_OVERFLOW';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_BUFFER_OVERFLOW'] = cx_sy_buffer_overflow;

//# sourceMappingURL=cx_sy_buffer_overflow.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_codepage_converter_init.clas.mjs":
/*!*******************************************************!*\
  !*** ./output/cx_sy_codepage_converter_init.clas.mjs ***!
  \*******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_codepage_converter_init": () => (/* binding */ cx_sy_codepage_converter_init)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_codepage_converter_init.clas.abap
class cx_sy_codepage_converter_init extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_CODEPAGE_CONVERTER_INIT';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_CODEPAGE_CONVERTER_INIT'] = cx_sy_codepage_converter_init;

//# sourceMappingURL=cx_sy_codepage_converter_init.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_compression_error.clas.mjs":
/*!*************************************************!*\
  !*** ./output/cx_sy_compression_error.clas.mjs ***!
  \*************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_compression_error": () => (/* binding */ cx_sy_compression_error)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_compression_error.clas.abap
class cx_sy_compression_error extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_COMPRESSION_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_COMPRESSION_ERROR'] = cx_sy_compression_error;

//# sourceMappingURL=cx_sy_compression_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_conversion_codepage.clas.mjs":
/*!***************************************************!*\
  !*** ./output/cx_sy_conversion_codepage.clas.mjs ***!
  \***************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_conversion_codepage": () => (/* binding */ cx_sy_conversion_codepage)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_conversion_codepage.clas.abap
class cx_sy_conversion_codepage extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_CONVERSION_CODEPAGE';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {"SOURCE_EXTRACT": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "visibility": "U", "is_constant": " ", "is_class": " "}};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.source_extract = new abap.types.XString({qualifiedName: "XSTRING"});
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_CONVERSION_CODEPAGE'] = cx_sy_conversion_codepage;

//# sourceMappingURL=cx_sy_conversion_codepage.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_conversion_data_loss.clas.mjs":
/*!****************************************************!*\
  !*** ./output/cx_sy_conversion_data_loss.clas.mjs ***!
  \****************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_conversion_data_loss": () => (/* binding */ cx_sy_conversion_data_loss)
/* harmony export */ });
const {cx_sy_conversion_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_conversion_error.clas.mjs */ "./output/cx_sy_conversion_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_conversion_data_loss.clas.abap
class cx_sy_conversion_data_loss extends cx_sy_conversion_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_CONVERSION_DATA_LOSS';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_CONVERSION_DATA_LOSS'] = cx_sy_conversion_data_loss;

//# sourceMappingURL=cx_sy_conversion_data_loss.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_conversion_error.clas.mjs":
/*!************************************************!*\
  !*** ./output/cx_sy_conversion_error.clas.mjs ***!
  \************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_conversion_error": () => (/* binding */ cx_sy_conversion_error)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_conversion_error.clas.abap
class cx_sy_conversion_error extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_CONVERSION_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_CONVERSION_ERROR'] = cx_sy_conversion_error;

//# sourceMappingURL=cx_sy_conversion_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_conversion_no_number.clas.mjs":
/*!****************************************************!*\
  !*** ./output/cx_sy_conversion_no_number.clas.mjs ***!
  \****************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_conversion_no_number": () => (/* binding */ cx_sy_conversion_no_number)
/* harmony export */ });
const {cx_sy_conversion_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_conversion_error.clas.mjs */ "./output/cx_sy_conversion_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_conversion_no_number.clas.abap
class cx_sy_conversion_no_number extends cx_sy_conversion_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_CONVERSION_NO_NUMBER';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {"IF_MESSAGE~GET_TEXT": {"visibility": "U", "parameters": {}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async if_message$get_text() {
    let result = new abap.types.String({qualifiedName: "STRING"});
    result.set(new abap.types.Character(20).set('Conversion no number'));
    return result;
  }
}
abap.Classes['CX_SY_CONVERSION_NO_NUMBER'] = cx_sy_conversion_no_number;

//# sourceMappingURL=cx_sy_conversion_no_number.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_conversion_overflow.clas.mjs":
/*!***************************************************!*\
  !*** ./output/cx_sy_conversion_overflow.clas.mjs ***!
  \***************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_conversion_overflow": () => (/* binding */ cx_sy_conversion_overflow)
/* harmony export */ });
const {cx_sy_conversion_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_conversion_error.clas.mjs */ "./output/cx_sy_conversion_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_conversion_overflow.clas.abap
class cx_sy_conversion_overflow extends cx_sy_conversion_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_CONVERSION_OVERFLOW';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"TEXTID": {"type": () => {return new abap.types.Character(32, {});}, "is_optional": " "}, "PREVIOUS": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});}, "is_optional": " "}, "VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    let textid = new abap.types.Character(32, {});
    if (INPUT && INPUT.textid) {textid.set(INPUT.textid);}
    let previous = new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});
    if (INPUT && INPUT.previous) {previous.set(INPUT.previous);}
    let value = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.value) {value.set(INPUT.value);}
    await super.constructor_({textid: textid, previous: previous});
    return this;
  }
}
abap.Classes['CX_SY_CONVERSION_OVERFLOW'] = cx_sy_conversion_overflow;

//# sourceMappingURL=cx_sy_conversion_overflow.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_create_data_error.clas.mjs":
/*!*************************************************!*\
  !*** ./output/cx_sy_create_data_error.clas.mjs ***!
  \*************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_create_data_error": () => (/* binding */ cx_sy_create_data_error)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_create_data_error.clas.abap
class cx_sy_create_data_error extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_CREATE_DATA_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_CREATE_DATA_ERROR'] = cx_sy_create_data_error;

//# sourceMappingURL=cx_sy_create_data_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_create_object_error.clas.mjs":
/*!***************************************************!*\
  !*** ./output/cx_sy_create_object_error.clas.mjs ***!
  \***************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_create_object_error": () => (/* binding */ cx_sy_create_object_error)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_create_object_error.clas.abap
class cx_sy_create_object_error extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_CREATE_OBJECT_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {"CLASSNAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": " ", "is_class": " "}};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"TEXTID": {"type": () => {return new abap.types.Character(32, {});}, "is_optional": " "}, "PREVIOUS": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});}, "is_optional": " "}, "CLASSNAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "IF_MESSAGE~GET_TEXT": {"visibility": "U", "parameters": {}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.classname = new abap.types.String({qualifiedName: "STRING"});
  }
  async constructor_(INPUT) {
    let textid = new abap.types.Character(32, {});
    if (INPUT && INPUT.textid) {textid.set(INPUT.textid);}
    let previous = new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});
    if (INPUT && INPUT.previous) {previous.set(INPUT.previous);}
    let classname = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.classname) {classname.set(INPUT.classname);}
    await super.constructor_({textid: textid, previous: previous});
    this.me.get().classname.set(classname);
    return this;
  }
  async if_message$get_text() {
    let result = new abap.types.String({qualifiedName: "STRING"});
    result.set(new abap.types.Character(62).set('The object could not be created: The class ??? does not exist.'));
    return result;
  }
}
abap.Classes['CX_SY_CREATE_OBJECT_ERROR'] = cx_sy_create_object_error;

//# sourceMappingURL=cx_sy_create_object_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_data_access_error.clas.mjs":
/*!*************************************************!*\
  !*** ./output/cx_sy_data_access_error.clas.mjs ***!
  \*************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_data_access_error": () => (/* binding */ cx_sy_data_access_error)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_data_access_error.clas.abap
class cx_sy_data_access_error extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_DATA_ACCESS_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_DATA_ACCESS_ERROR'] = cx_sy_data_access_error;

//# sourceMappingURL=cx_sy_data_access_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_duplicate_key.clas.mjs":
/*!*********************************************!*\
  !*** ./output/cx_sy_duplicate_key.clas.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_duplicate_key": () => (/* binding */ cx_sy_duplicate_key)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_duplicate_key.clas.abap
class cx_sy_duplicate_key extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_DUPLICATE_KEY';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_DUPLICATE_KEY'] = cx_sy_duplicate_key;

//# sourceMappingURL=cx_sy_duplicate_key.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_dyn_call_error.clas.mjs":
/*!**********************************************!*\
  !*** ./output/cx_sy_dyn_call_error.clas.mjs ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_dyn_call_error": () => (/* binding */ cx_sy_dyn_call_error)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_dyn_call_error.clas.abap
class cx_sy_dyn_call_error extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_DYN_CALL_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_DYN_CALL_ERROR'] = cx_sy_dyn_call_error;

//# sourceMappingURL=cx_sy_dyn_call_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_dyn_call_illegal_class.clas.mjs":
/*!******************************************************!*\
  !*** ./output/cx_sy_dyn_call_illegal_class.clas.mjs ***!
  \******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_dyn_call_illegal_class": () => (/* binding */ cx_sy_dyn_call_illegal_class)
/* harmony export */ });
const {cx_sy_dyn_call_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_dyn_call_error.clas.mjs */ "./output/cx_sy_dyn_call_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_dyn_call_illegal_class.clas.abap
class cx_sy_dyn_call_illegal_class extends cx_sy_dyn_call_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_DYN_CALL_ILLEGAL_CLASS';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_DYN_CALL_ILLEGAL_CLASS'] = cx_sy_dyn_call_illegal_class;

//# sourceMappingURL=cx_sy_dyn_call_illegal_class.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_dyn_call_illegal_form.clas.mjs":
/*!*****************************************************!*\
  !*** ./output/cx_sy_dyn_call_illegal_form.clas.mjs ***!
  \*****************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_dyn_call_illegal_form": () => (/* binding */ cx_sy_dyn_call_illegal_form)
/* harmony export */ });
const {cx_sy_dyn_call_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_dyn_call_error.clas.mjs */ "./output/cx_sy_dyn_call_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_dyn_call_illegal_form.clas.abap
class cx_sy_dyn_call_illegal_form extends cx_sy_dyn_call_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_DYN_CALL_ILLEGAL_FORM';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_DYN_CALL_ILLEGAL_FORM'] = cx_sy_dyn_call_illegal_form;

//# sourceMappingURL=cx_sy_dyn_call_illegal_form.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_dyn_call_illegal_func.clas.mjs":
/*!*****************************************************!*\
  !*** ./output/cx_sy_dyn_call_illegal_func.clas.mjs ***!
  \*****************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_dyn_call_illegal_func": () => (/* binding */ cx_sy_dyn_call_illegal_func)
/* harmony export */ });
const {cx_sy_dyn_call_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_dyn_call_error.clas.mjs */ "./output/cx_sy_dyn_call_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_dyn_call_illegal_func.clas.abap
class cx_sy_dyn_call_illegal_func extends cx_sy_dyn_call_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_DYN_CALL_ILLEGAL_FUNC';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_DYN_CALL_ILLEGAL_FUNC'] = cx_sy_dyn_call_illegal_func;

//# sourceMappingURL=cx_sy_dyn_call_illegal_func.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_dyn_call_illegal_method.clas.mjs":
/*!*******************************************************!*\
  !*** ./output/cx_sy_dyn_call_illegal_method.clas.mjs ***!
  \*******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_dyn_call_illegal_method": () => (/* binding */ cx_sy_dyn_call_illegal_method)
/* harmony export */ });
const {cx_sy_dyn_call_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_dyn_call_error.clas.mjs */ "./output/cx_sy_dyn_call_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_dyn_call_illegal_method.clas.abap
class cx_sy_dyn_call_illegal_method extends cx_sy_dyn_call_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_DYN_CALL_ILLEGAL_METHOD';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {"PRIVATE_METHOD": {"type": () => {return new abap.types.Character(32, {"qualifiedName":"SOTR_CONC","ddicName":"SOTR_CONC"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"TEXTID": {"type": () => {return new abap.types.Character(32, {});}, "is_optional": " "}, "PREVIOUS": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});}, "is_optional": " "}, "CLASSNAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "METHODNAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.private_method = cx_sy_dyn_call_illegal_method.private_method;
  }
  async constructor_(INPUT) {
    let textid = new abap.types.Character(32, {});
    if (INPUT && INPUT.textid) {textid.set(INPUT.textid);}
    let previous = new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});
    if (INPUT && INPUT.previous) {previous.set(INPUT.previous);}
    let classname = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.classname) {classname.set(INPUT.classname);}
    let methodname = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.methodname) {methodname.set(INPUT.methodname);}
    await super.constructor_({previous: previous});
    return this;
  }
}
abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'] = cx_sy_dyn_call_illegal_method;
cx_sy_dyn_call_illegal_method.private_method = new abap.types.Character(32, {"qualifiedName":"SOTR_CONC","ddicName":"SOTR_CONC"});
cx_sy_dyn_call_illegal_method.private_method.set('11111111111111111111111111111111');

//# sourceMappingURL=cx_sy_dyn_call_illegal_method.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_dyn_call_param_not_found.clas.mjs":
/*!********************************************************!*\
  !*** ./output/cx_sy_dyn_call_param_not_found.clas.mjs ***!
  \********************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_dyn_call_param_not_found": () => (/* binding */ cx_sy_dyn_call_param_not_found)
/* harmony export */ });
const {cx_sy_dyn_call_parameter_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_dyn_call_parameter_error.clas.mjs */ "./output/cx_sy_dyn_call_parameter_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_dyn_call_param_not_found.clas.abap
class cx_sy_dyn_call_param_not_found extends cx_sy_dyn_call_parameter_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_DYN_CALL_PARAM_NOT_FOUND';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_DYN_CALL_PARAM_NOT_FOUND'] = cx_sy_dyn_call_param_not_found;

//# sourceMappingURL=cx_sy_dyn_call_param_not_found.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_dyn_call_parameter_error.clas.mjs":
/*!********************************************************!*\
  !*** ./output/cx_sy_dyn_call_parameter_error.clas.mjs ***!
  \********************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_dyn_call_parameter_error": () => (/* binding */ cx_sy_dyn_call_parameter_error)
/* harmony export */ });
const {cx_sy_dyn_call_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_dyn_call_error.clas.mjs */ "./output/cx_sy_dyn_call_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_dyn_call_parameter_error.clas.abap
class cx_sy_dyn_call_parameter_error extends cx_sy_dyn_call_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_DYN_CALL_PARAMETER_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {"PARAMETER": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": " ", "is_class": " "}};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.parameter = new abap.types.String({qualifiedName: "STRING"});
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_DYN_CALL_PARAMETER_ERROR'] = cx_sy_dyn_call_parameter_error;

//# sourceMappingURL=cx_sy_dyn_call_parameter_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_dynamic_osql_error.clas.mjs":
/*!**************************************************!*\
  !*** ./output/cx_sy_dynamic_osql_error.clas.mjs ***!
  \**************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_dynamic_osql_error": () => (/* binding */ cx_sy_dynamic_osql_error)
/* harmony export */ });
const {cx_sy_open_sql_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_open_sql_error.clas.mjs */ "./output/cx_sy_open_sql_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_dynamic_osql_error.clas.abap
class cx_sy_dynamic_osql_error extends cx_sy_open_sql_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_DYNAMIC_OSQL_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"SQLMSG": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    let sqlmsg = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.sqlmsg) {sqlmsg.set(INPUT.sqlmsg);}
    await super.constructor_({sqlmsg: sqlmsg});
    return this;
  }
}
abap.Classes['CX_SY_DYNAMIC_OSQL_ERROR'] = cx_sy_dynamic_osql_error;

//# sourceMappingURL=cx_sy_dynamic_osql_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_dynamic_osql_semantics.clas.mjs":
/*!******************************************************!*\
  !*** ./output/cx_sy_dynamic_osql_semantics.clas.mjs ***!
  \******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_dynamic_osql_semantics": () => (/* binding */ cx_sy_dynamic_osql_semantics)
/* harmony export */ });
const {cx_sy_dynamic_osql_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_dynamic_osql_error.clas.mjs */ "./output/cx_sy_dynamic_osql_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_dynamic_osql_semantics.clas.abap
class cx_sy_dynamic_osql_semantics extends cx_sy_dynamic_osql_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_DYNAMIC_OSQL_SEMANTICS';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"SQLMSG": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    let sqlmsg = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.sqlmsg) {sqlmsg.set(INPUT.sqlmsg);}
    await super.constructor_({sqlmsg: sqlmsg});
    return this;
  }
}
abap.Classes['CX_SY_DYNAMIC_OSQL_SEMANTICS'] = cx_sy_dynamic_osql_semantics;

//# sourceMappingURL=cx_sy_dynamic_osql_semantics.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_itab_duplicate_key.clas.mjs":
/*!**************************************************!*\
  !*** ./output/cx_sy_itab_duplicate_key.clas.mjs ***!
  \**************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_itab_duplicate_key": () => (/* binding */ cx_sy_itab_duplicate_key)
/* harmony export */ });
const {cx_sy_itab_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_itab_error.clas.mjs */ "./output/cx_sy_itab_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_itab_duplicate_key.clas.abap
class cx_sy_itab_duplicate_key extends cx_sy_itab_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_ITAB_DUPLICATE_KEY';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_ITAB_DUPLICATE_KEY'] = cx_sy_itab_duplicate_key;

//# sourceMappingURL=cx_sy_itab_duplicate_key.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_itab_error.clas.mjs":
/*!******************************************!*\
  !*** ./output/cx_sy_itab_error.clas.mjs ***!
  \******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_itab_error": () => (/* binding */ cx_sy_itab_error)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_itab_error.clas.abap
class cx_sy_itab_error extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_ITAB_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_ITAB_ERROR'] = cx_sy_itab_error;

//# sourceMappingURL=cx_sy_itab_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_itab_line_not_found.clas.mjs":
/*!***************************************************!*\
  !*** ./output/cx_sy_itab_line_not_found.clas.mjs ***!
  \***************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_itab_line_not_found": () => (/* binding */ cx_sy_itab_line_not_found)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_itab_line_not_found.clas.abap
class cx_sy_itab_line_not_found extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_ITAB_LINE_NOT_FOUND';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_ITAB_LINE_NOT_FOUND'] = cx_sy_itab_line_not_found;

//# sourceMappingURL=cx_sy_itab_line_not_found.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_message_illegal_text.clas.mjs":
/*!****************************************************!*\
  !*** ./output/cx_sy_message_illegal_text.clas.mjs ***!
  \****************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_message_illegal_text": () => (/* binding */ cx_sy_message_illegal_text)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_message_illegal_text.clas.abap
class cx_sy_message_illegal_text extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_MESSAGE_ILLEGAL_TEXT';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_MESSAGE_ILLEGAL_TEXT'] = cx_sy_message_illegal_text;

//# sourceMappingURL=cx_sy_message_illegal_text.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_move_cast_error.clas.mjs":
/*!***********************************************!*\
  !*** ./output/cx_sy_move_cast_error.clas.mjs ***!
  \***********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_move_cast_error": () => (/* binding */ cx_sy_move_cast_error)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_move_cast_error.clas.abap
class cx_sy_move_cast_error extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_MOVE_CAST_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {"IF_MESSAGE~GET_TEXT": {"visibility": "U", "parameters": {}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async if_message$get_text() {
    let result = new abap.types.String({qualifiedName: "STRING"});
    result.set(new abap.types.Character(36).set('Casting failed, types not compatible'));
    return result;
  }
}
abap.Classes['CX_SY_MOVE_CAST_ERROR'] = cx_sy_move_cast_error;

//# sourceMappingURL=cx_sy_move_cast_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_open_sql_error.clas.mjs":
/*!**********************************************!*\
  !*** ./output/cx_sy_open_sql_error.clas.mjs ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_open_sql_error": () => (/* binding */ cx_sy_open_sql_error)
/* harmony export */ });
const {cx_sy_sql_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_sql_error.clas.mjs */ "./output/cx_sy_sql_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_open_sql_error.clas.abap
class cx_sy_open_sql_error extends cx_sy_sql_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_OPEN_SQL_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"SQLMSG": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    let sqlmsg = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.sqlmsg) {sqlmsg.set(INPUT.sqlmsg);}
    await super.constructor_({sqlmsg: sqlmsg});
    return this;
  }
}
abap.Classes['CX_SY_OPEN_SQL_ERROR'] = cx_sy_open_sql_error;

//# sourceMappingURL=cx_sy_open_sql_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_range_out_of_bounds.clas.mjs":
/*!***************************************************!*\
  !*** ./output/cx_sy_range_out_of_bounds.clas.mjs ***!
  \***************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_range_out_of_bounds": () => (/* binding */ cx_sy_range_out_of_bounds)
/* harmony export */ });
const {cx_sy_data_access_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_data_access_error.clas.mjs */ "./output/cx_sy_data_access_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_range_out_of_bounds.clas.abap
class cx_sy_range_out_of_bounds extends cx_sy_data_access_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_RANGE_OUT_OF_BOUNDS';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {"IF_MESSAGE~GET_TEXT": {"visibility": "U", "parameters": {}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async if_message$get_text() {
    let result = new abap.types.String({qualifiedName: "STRING"});
    result.set(new abap.types.Character(19).set('Range out of bounds'));
    return result;
  }
}
abap.Classes['CX_SY_RANGE_OUT_OF_BOUNDS'] = cx_sy_range_out_of_bounds;

//# sourceMappingURL=cx_sy_range_out_of_bounds.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_ref_is_initial.clas.mjs":
/*!**********************************************!*\
  !*** ./output/cx_sy_ref_is_initial.clas.mjs ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_ref_is_initial": () => (/* binding */ cx_sy_ref_is_initial)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_ref_is_initial.clas.abap
class cx_sy_ref_is_initial extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_REF_IS_INITIAL';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_REF_IS_INITIAL'] = cx_sy_ref_is_initial;

//# sourceMappingURL=cx_sy_ref_is_initial.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_sql_error.clas.mjs":
/*!*****************************************!*\
  !*** ./output/cx_sy_sql_error.clas.mjs ***!
  \*****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_sql_error": () => (/* binding */ cx_sy_sql_error)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_sql_error.clas.abap
class cx_sy_sql_error extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_SQL_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {"SQLMSG": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": " ", "is_class": " "}};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"SQLMSG": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.sqlmsg = new abap.types.String({qualifiedName: "STRING"});
  }
  async constructor_(INPUT) {
    let sqlmsg = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.sqlmsg) {sqlmsg.set(INPUT.sqlmsg);}
    await super.constructor_();
    this.me.get().sqlmsg.set(sqlmsg);
    return this;
  }
}
abap.Classes['CX_SY_SQL_ERROR'] = cx_sy_sql_error;

//# sourceMappingURL=cx_sy_sql_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_strg_par_val.clas.mjs":
/*!********************************************!*\
  !*** ./output/cx_sy_strg_par_val.clas.mjs ***!
  \********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_strg_par_val": () => (/* binding */ cx_sy_strg_par_val)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_strg_par_val.clas.abap
class cx_sy_strg_par_val extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_STRG_PAR_VAL';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_STRG_PAR_VAL'] = cx_sy_strg_par_val;

//# sourceMappingURL=cx_sy_strg_par_val.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_struct_attributes.clas.mjs":
/*!*************************************************!*\
  !*** ./output/cx_sy_struct_attributes.clas.mjs ***!
  \*************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_struct_attributes": () => (/* binding */ cx_sy_struct_attributes)
/* harmony export */ });
const {cx_sy_struct_creation} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_struct_creation.clas.mjs */ "./output/cx_sy_struct_creation.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_struct_attributes.clas.abap
class cx_sy_struct_attributes extends cx_sy_struct_creation {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_STRUCT_ATTRIBUTES';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_STRUCT_ATTRIBUTES'] = cx_sy_struct_attributes;

//# sourceMappingURL=cx_sy_struct_attributes.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_struct_comp_name.clas.mjs":
/*!************************************************!*\
  !*** ./output/cx_sy_struct_comp_name.clas.mjs ***!
  \************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_struct_comp_name": () => (/* binding */ cx_sy_struct_comp_name)
/* harmony export */ });
const {cx_sy_struct_creation} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_struct_creation.clas.mjs */ "./output/cx_sy_struct_creation.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_struct_comp_name.clas.abap
class cx_sy_struct_comp_name extends cx_sy_struct_creation {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_STRUCT_COMP_NAME';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_STRUCT_COMP_NAME'] = cx_sy_struct_comp_name;

//# sourceMappingURL=cx_sy_struct_comp_name.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_struct_comp_type.clas.mjs":
/*!************************************************!*\
  !*** ./output/cx_sy_struct_comp_type.clas.mjs ***!
  \************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_struct_comp_type": () => (/* binding */ cx_sy_struct_comp_type)
/* harmony export */ });
const {cx_sy_struct_creation} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_struct_creation.clas.mjs */ "./output/cx_sy_struct_creation.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_struct_comp_type.clas.abap
class cx_sy_struct_comp_type extends cx_sy_struct_creation {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_STRUCT_COMP_TYPE';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_STRUCT_COMP_TYPE'] = cx_sy_struct_comp_type;

//# sourceMappingURL=cx_sy_struct_comp_type.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_struct_creation.clas.mjs":
/*!***********************************************!*\
  !*** ./output/cx_sy_struct_creation.clas.mjs ***!
  \***********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_struct_creation": () => (/* binding */ cx_sy_struct_creation)
/* harmony export */ });
const {cx_sy_type_creation} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_type_creation.clas.mjs */ "./output/cx_sy_type_creation.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_struct_creation.clas.abap
class cx_sy_struct_creation extends cx_sy_type_creation {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_STRUCT_CREATION';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_STRUCT_CREATION'] = cx_sy_struct_creation;

//# sourceMappingURL=cx_sy_struct_creation.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_type_creation.clas.mjs":
/*!*********************************************!*\
  !*** ./output/cx_sy_type_creation.clas.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_type_creation": () => (/* binding */ cx_sy_type_creation)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_type_creation.clas.abap
class cx_sy_type_creation extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_TYPE_CREATION';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_SY_TYPE_CREATION'] = cx_sy_type_creation;

//# sourceMappingURL=cx_sy_type_creation.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_sy_zerodivide.clas.mjs":
/*!******************************************!*\
  !*** ./output/cx_sy_zerodivide.clas.mjs ***!
  \******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_sy_zerodivide": () => (/* binding */ cx_sy_zerodivide)
/* harmony export */ });
const {cx_sy_arithmetic_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_arithmetic_error.clas.mjs */ "./output/cx_sy_arithmetic_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_sy_zerodivide.clas.abap
class cx_sy_zerodivide extends cx_sy_arithmetic_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_SY_ZERODIVIDE';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {"IF_MESSAGE~GET_TEXT": {"visibility": "U", "parameters": {}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async if_message$get_text() {
    let result = new abap.types.String({qualifiedName: "STRING"});
    result.set(new abap.types.Character(17).set('Division by zero.'));
    return result;
  }
}
abap.Classes['CX_SY_ZERODIVIDE'] = cx_sy_zerodivide;

//# sourceMappingURL=cx_sy_zerodivide.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_transformation_error.clas.mjs":
/*!*************************************************!*\
  !*** ./output/cx_transformation_error.clas.mjs ***!
  \*************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_transformation_error": () => (/* binding */ cx_transformation_error)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_transformation_error.clas.abap
class cx_transformation_error extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_TRANSFORMATION_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_TRANSFORMATION_ERROR'] = cx_transformation_error;

//# sourceMappingURL=cx_transformation_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_uuid_error.clas.mjs":
/*!***************************************!*\
  !*** ./output/cx_uuid_error.clas.mjs ***!
  \***************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_uuid_error": () => (/* binding */ cx_uuid_error)
/* harmony export */ });
const {cx_static_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_static_check.clas.mjs */ "./output/cx_static_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_uuid_error.clas.abap
class cx_uuid_error extends cx_static_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_UUID_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_UUID_ERROR'] = cx_uuid_error;

//# sourceMappingURL=cx_uuid_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_xslt_exception.clas.mjs":
/*!*******************************************!*\
  !*** ./output/cx_xslt_exception.clas.mjs ***!
  \*******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_xslt_exception": () => (/* binding */ cx_xslt_exception)
/* harmony export */ });
const {cx_transformation_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_transformation_error.clas.mjs */ "./output/cx_transformation_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_xslt_exception.clas.abap
class cx_xslt_exception extends cx_transformation_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_XSLT_EXCEPTION';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_XSLT_EXCEPTION'] = cx_xslt_exception;

//# sourceMappingURL=cx_xslt_exception.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_xslt_format_error.clas.mjs":
/*!**********************************************!*\
  !*** ./output/cx_xslt_format_error.clas.mjs ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_xslt_format_error": () => (/* binding */ cx_xslt_format_error)
/* harmony export */ });
const {cx_xslt_system_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_xslt_system_error.clas.mjs */ "./output/cx_xslt_system_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_xslt_format_error.clas.abap
class cx_xslt_format_error extends cx_xslt_system_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_XSLT_FORMAT_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_XSLT_FORMAT_ERROR'] = cx_xslt_format_error;

//# sourceMappingURL=cx_xslt_format_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_xslt_runtime_error.clas.mjs":
/*!***********************************************!*\
  !*** ./output/cx_xslt_runtime_error.clas.mjs ***!
  \***********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_xslt_runtime_error": () => (/* binding */ cx_xslt_runtime_error)
/* harmony export */ });
const {cx_transformation_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_transformation_error.clas.mjs */ "./output/cx_transformation_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_xslt_runtime_error.clas.abap
class cx_xslt_runtime_error extends cx_transformation_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_XSLT_RUNTIME_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_XSLT_RUNTIME_ERROR'] = cx_xslt_runtime_error;

//# sourceMappingURL=cx_xslt_runtime_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_xslt_serialization_error.clas.mjs":
/*!*****************************************************!*\
  !*** ./output/cx_xslt_serialization_error.clas.mjs ***!
  \*****************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_xslt_serialization_error": () => (/* binding */ cx_xslt_serialization_error)
/* harmony export */ });
const {cx_xslt_system_error} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_xslt_system_error.clas.mjs */ "./output/cx_xslt_system_error.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_xslt_serialization_error.clas.abap
class cx_xslt_serialization_error extends cx_xslt_system_error {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_XSLT_SERIALIZATION_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_XSLT_SERIALIZATION_ERROR'] = cx_xslt_serialization_error;

//# sourceMappingURL=cx_xslt_serialization_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/cx_xslt_system_error.clas.mjs":
/*!**********************************************!*\
  !*** ./output/cx_xslt_system_error.clas.mjs ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cx_xslt_system_error": () => (/* binding */ cx_xslt_system_error)
/* harmony export */ });
const {cx_xslt_exception} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_xslt_exception.clas.mjs */ "./output/cx_xslt_exception.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// cx_xslt_system_error.clas.abap
class cx_xslt_system_error extends cx_xslt_exception {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'CX_XSLT_SYSTEM_ERROR';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['CX_XSLT_SYSTEM_ERROR'] = cx_xslt_system_error;

//# sourceMappingURL=cx_xslt_system_error.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/dats.dtel.mjs":
/*!******************************!*\
  !*** ./output/dats.dtel.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["DATS"] = {
  "objectType": "DTEL",
  "type": new abap.types.Date({qualifiedName: "DATS"}),
  "domain": "DATS",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/ddfields.ttyp.mjs":
/*!**********************************!*\
  !*** ./output/ddfields.ttyp.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["DDFIELDS"] = {
  "objectType": "TTYP",
  "type": abap.types.TableFactory.construct(new abap.types.Structure({"tabname": new abap.types.Character(30, {}), "fieldname": new abap.types.Character(30, {}), "langu": new abap.types.Character(1, {}), "position": new abap.types.Numc({length: 4}), "offset": new abap.types.Numc({length: 6}), "domname": new abap.types.Character(30, {}), "rollname": new abap.types.Character(30, {}), "checktable": new abap.types.Character(1, {}), "leng": new abap.types.Numc({length: 6}), "intlen": new abap.types.Numc({length: 6}), "outputlen": new abap.types.Numc({length: 6}), "decimals": new abap.types.Numc({length: 6}), "datatype": new abap.types.Character(1, {}), "inttype": new abap.types.Character(1, {}), "reftable": new abap.types.Character(1, {}), "reffield": new abap.types.Character(1, {}), "precfield": new abap.types.Character(1, {}), "authorid": new abap.types.Character(1, {}), "memoryid": new abap.types.Character(1, {}), "logflag": new abap.types.Character(1, {}), "mask": new abap.types.Character(20, {}), "masklen": new abap.types.Character(1, {}), "convexit": new abap.types.Character(1, {}), "headlen": new abap.types.Character(1, {}), "scrlen1": new abap.types.Character(1, {}), "scrlen2": new abap.types.Character(1, {}), "scrlen3": new abap.types.Character(1, {}), "fieldtext": new abap.types.Character(1, {}), "reptext": new abap.types.Character(1, {}), "scrtext_s": new abap.types.Character(1, {}), "scrtext_m": new abap.types.Character(1, {}), "scrtext_l": new abap.types.Character(1, {}), "keyflag": new abap.types.Character(1, {}), "lowercase": new abap.types.Character(1, {}), "mac": new abap.types.Character(1, {}), "genkey": new abap.types.Character(1, {}), "noforkey": new abap.types.Character(1, {}), "valexi": new abap.types.Character(1, {}), "noauthch": new abap.types.Character(1, {}), "sign": new abap.types.Character(1, {}), "dynpfld": new abap.types.Character(1, {}), "f4availabl": new abap.types.Character(1, {}), "comptype": new abap.types.Character(1, {}), "outputstyle": new abap.types.Character(1, {}), "lfieldname": new abap.types.Character(132, {})}, "DFIES", "DFIES", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "DDFIELDS"),
};

/***/ }),

/***/ "./output/ddoption.dtel.mjs":
/*!**********************************!*\
  !*** ./output/ddoption.dtel.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["DDOPTION"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(2, {"qualifiedName":"DDOPTION","ddicName":"DDOPTION"}),
  "domain": "DDOPTION",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/ddsign.dtel.mjs":
/*!********************************!*\
  !*** ./output/ddsign.dtel.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["DDSIGN"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(1, {"qualifiedName":"DDSIGN","ddicName":"DDSIGN"}),
  "domain": "DDSIGN",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/devclass.dtel.mjs":
/*!**********************************!*\
  !*** ./output/devclass.dtel.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["DEVCLASS"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(30, {"qualifiedName":"DEVCLASS","ddicName":"DEVCLASS"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/dfies.tabl.mjs":
/*!*******************************!*\
  !*** ./output/dfies.tabl.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["DFIES"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"tabname": new abap.types.Character(30, {}), "fieldname": new abap.types.Character(30, {}), "langu": new abap.types.Character(1, {}), "position": new abap.types.Numc({length: 4}), "offset": new abap.types.Numc({length: 6}), "domname": new abap.types.Character(30, {}), "rollname": new abap.types.Character(30, {}), "checktable": new abap.types.Character(1, {}), "leng": new abap.types.Numc({length: 6}), "intlen": new abap.types.Numc({length: 6}), "outputlen": new abap.types.Numc({length: 6}), "decimals": new abap.types.Numc({length: 6}), "datatype": new abap.types.Character(1, {}), "inttype": new abap.types.Character(1, {}), "reftable": new abap.types.Character(1, {}), "reffield": new abap.types.Character(1, {}), "precfield": new abap.types.Character(1, {}), "authorid": new abap.types.Character(1, {}), "memoryid": new abap.types.Character(1, {}), "logflag": new abap.types.Character(1, {}), "mask": new abap.types.Character(20, {}), "masklen": new abap.types.Character(1, {}), "convexit": new abap.types.Character(1, {}), "headlen": new abap.types.Character(1, {}), "scrlen1": new abap.types.Character(1, {}), "scrlen2": new abap.types.Character(1, {}), "scrlen3": new abap.types.Character(1, {}), "fieldtext": new abap.types.Character(1, {}), "reptext": new abap.types.Character(1, {}), "scrtext_s": new abap.types.Character(1, {}), "scrtext_m": new abap.types.Character(1, {}), "scrtext_l": new abap.types.Character(1, {}), "keyflag": new abap.types.Character(1, {}), "lowercase": new abap.types.Character(1, {}), "mac": new abap.types.Character(1, {}), "genkey": new abap.types.Character(1, {}), "noforkey": new abap.types.Character(1, {}), "valexi": new abap.types.Character(1, {}), "noauthch": new abap.types.Character(1, {}), "sign": new abap.types.Character(1, {}), "dynpfld": new abap.types.Character(1, {}), "f4availabl": new abap.types.Character(1, {}), "comptype": new abap.types.Character(1, {}), "outputstyle": new abap.types.Character(1, {}), "lfieldname": new abap.types.Character(132, {})}, "DFIES", "DFIES", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/doku_obj.dtel.mjs":
/*!**********************************!*\
  !*** ./output/doku_obj.dtel.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["DOKU_OBJ"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(60, {"qualifiedName":"DOKU_OBJ","ddicName":"DOKU_OBJ"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/dynprofld.dtel.mjs":
/*!***********************************!*\
  !*** ./output/dynprofld.dtel.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["DYNPROFLD"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(1, {"qualifiedName":"DYNPROFLD","ddicName":"DYNPROFLD"}),
  "domain": "ABAP_BOOLEAN",
  "fixedValues": [{"description":"False","language":"E"},{"description":"True","low":"X","language":"E"}],
};

/***/ }),

/***/ "./output/file_table.tabl.mjs":
/*!************************************!*\
  !*** ./output/file_table.tabl.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["FILE_TABLE"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"filename": new abap.types.Character(1024, {})}, "FILE_TABLE", "FILE_TABLE", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/filetable.ttyp.mjs":
/*!***********************************!*\
  !*** ./output/filetable.ttyp.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["FILETABLE"] = {
  "objectType": "TTYP",
  "type": abap.types.TableFactory.construct(new abap.types.Structure({"filename": new abap.types.Character(1024, {})}, "FILE_TABLE", "FILE_TABLE", {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "FILETABLE"),
};

/***/ }),

/***/ "./output/flag.dtel.mjs":
/*!******************************!*\
  !*** ./output/flag.dtel.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["FLAG"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(1, {"qualifiedName":"FLAG","ddicName":"FLAG"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/funcname.dtel.mjs":
/*!**********************************!*\
  !*** ./output/funcname.dtel.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["FUNCNAME"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(30, {"qualifiedName":"FUNCNAME","ddicName":"FUNCNAME"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/guid.dtel.mjs":
/*!******************************!*\
  !*** ./output/guid.dtel.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["GUID"] = {
  "objectType": "DTEL",
  "type": new abap.types.Hex({length: 16}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/icon.type.mjs":
/*!******************************!*\
  !*** ./output/icon.type.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
const pool = {};
pool['icon_abap'] = new abap.types.Character(4, {});
pool['icon_abap'].set('ICON');
pool['icon_address'] = new abap.types.Character(4, {});
pool['icon_address'].set('ICON');
pool['icon_adopt'] = new abap.types.Character(4, {});
pool['icon_adopt'].set('ICON');
pool['icon_arrow_left'] = new abap.types.Character(4, {});
pool['icon_arrow_left'].set('ICON');
pool['icon_arrow_right'] = new abap.types.Character(4, {});
pool['icon_arrow_right'].set('ICON');
pool['icon_ben_current_benefits'] = new abap.types.Character(4, {});
pool['icon_ben_current_benefits'].set('ICON');
pool['icon_biw_report'] = new abap.types.Character(4, {});
pool['icon_biw_report'].set('ICON');
pool['icon_biw_source_sys_r3'] = new abap.types.Character(4, {});
pool['icon_biw_source_sys_r3'].set('ICON');
pool['icon_businav_process'] = new abap.types.Character(4, {});
pool['icon_businav_process'].set('ICON');
pool['icon_change'] = new abap.types.Character(4, {});
pool['icon_change'].set('ICON');
pool['icon_change_text'] = new abap.types.Character(4, {});
pool['icon_change_text'].set('ICON');
pool['icon_check'] = new abap.types.Character(4, {});
pool['icon_check'].set('ICON');
pool['icon_checked'] = new abap.types.Character(4, {});
pool['icon_checked'].set('ICON');
pool['icon_client_breakpoint'] = new abap.types.Character(4, {});
pool['icon_client_breakpoint'].set('ICON');
pool['icon_compare'] = new abap.types.Character(4, {});
pool['icon_compare'].set('ICON');
pool['icon_complete'] = new abap.types.Character(4, {});
pool['icon_complete'].set('ICON');
pool['icon_connect'] = new abap.types.Character(4, {});
pool['icon_connect'].set('ICON');
pool['icon_copy_object'] = new abap.types.Character(4, {});
pool['icon_copy_object'].set('ICON');
pool['icon_create'] = new abap.types.Character(4, {});
pool['icon_create'].set('ICON');
pool['icon_database_table'] = new abap.types.Character(4, {});
pool['icon_database_table'].set('ICON');
pool['icon_delete'] = new abap.types.Character(4, {});
pool['icon_delete'].set('ICON');
pool['icon_delete_favorites'] = new abap.types.Character(4, {});
pool['icon_delete_favorites'].set('ICON');
pool['icon_delete_row'] = new abap.types.Character(4, {});
pool['icon_delete_row'].set('ICON');
pool['icon_delete_template'] = new abap.types.Character(4, {});
pool['icon_delete_template'].set('ICON');
pool['icon_delivery_inbound'] = new abap.types.Character(4, {});
pool['icon_delivery_inbound'].set('ICON');
pool['icon_deselect_all'] = new abap.types.Character(4, {});
pool['icon_deselect_all'].set('ICON');
pool['icon_detail'] = new abap.types.Character(4, {});
pool['icon_detail'].set('ICON');
pool['icon_display'] = new abap.types.Character(4, {});
pool['icon_display'].set('ICON');
pool['icon_display_more'] = new abap.types.Character(4, {});
pool['icon_display_more'].set('ICON');
pool['icon_display_text'] = new abap.types.Character(4, {});
pool['icon_display_text'].set('ICON');
pool['icon_document'] = new abap.types.Character(4, {});
pool['icon_document'].set('ICON');
pool['icon_element'] = new abap.types.Character(4, {});
pool['icon_element'].set('ICON');
pool['icon_execute_object'] = new abap.types.Character(4, {});
pool['icon_execute_object'].set('ICON');
pool['icon_export'] = new abap.types.Character(4, {});
pool['icon_export'].set('ICON');
pool['icon_foreign_key'] = new abap.types.Character(4, {});
pool['icon_foreign_key'].set('ICON');
pool['icon_generate'] = new abap.types.Character(4, {});
pool['icon_generate'].set('ICON');
pool['icon_green_light'] = new abap.types.Character(4, {});
pool['icon_green_light'].set('ICON');
pool['icon_hint'] = new abap.types.Character(4, {});
pool['icon_hint'].set('ICON');
pool['icon_history'] = new abap.types.Character(4, {});
pool['icon_history'].set('ICON');
pool['icon_host'] = new abap.types.Character(4, {});
pool['icon_host'].set('ICON');
pool['icon_htm'] = new abap.types.Character(4, {});
pool['icon_htm'].set('ICON');
pool['icon_incoming_object'] = new abap.types.Character(4, {});
pool['icon_incoming_object'].set('ICON');
pool['icon_incomplete'] = new abap.types.Character(4, {});
pool['icon_incomplete'].set('ICON');
pool['icon_information'] = new abap.types.Character(4, {});
pool['icon_information'].set('ICON');
pool['icon_insert_row'] = new abap.types.Character(4, {});
pool['icon_insert_row'].set('ICON');
pool['icon_led_green'] = new abap.types.Character(4, {});
pool['icon_led_green'].set('ICON');
pool['icon_led_inactive'] = new abap.types.Character(4, {});
pool['icon_led_inactive'].set('ICON');
pool['icon_led_red'] = new abap.types.Character(4, {});
pool['icon_led_red'].set('ICON');
pool['icon_led_yellow'] = new abap.types.Character(4, {});
pool['icon_led_yellow'].set('ICON');
pool['icon_list'] = new abap.types.Character(4, {});
pool['icon_list'].set('ICON');
pool['icon_mass_change'] = new abap.types.Character(4, {});
pool['icon_mass_change'].set('ICON');
pool['icon_message_critical'] = new abap.types.Character(4, {});
pool['icon_message_critical'].set('ICON');
pool['icon_message_error_small'] = new abap.types.Character(4, {});
pool['icon_message_error_small'].set('ICON');
pool['icon_message_information'] = new abap.types.Character(4, {});
pool['icon_message_information'].set('ICON');
pool['icon_message_question'] = new abap.types.Character(4, {});
pool['icon_message_question'].set('ICON');
pool['icon_message_warning_small'] = new abap.types.Character(4, {});
pool['icon_message_warning_small'].set('ICON');
pool['icon_move'] = new abap.types.Character(4, {});
pool['icon_move'].set('ICON');
pool['icon_no_status'] = new abap.types.Character(4, {});
pool['icon_no_status'].set('ICON');
pool['icon_object_list'] = new abap.types.Character(4, {});
pool['icon_object_list'].set('ICON');
pool['icon_okay'] = new abap.types.Character(4, {});
pool['icon_okay'].set('ICON');
pool['icon_org_unit'] = new abap.types.Character(4, {});
pool['icon_org_unit'].set('ICON');
pool['icon_outgoing_object'] = new abap.types.Character(4, {});
pool['icon_outgoing_object'].set('ICON');
pool['icon_package_standard'] = new abap.types.Character(4, {});
pool['icon_package_standard'].set('ICON');
pool['icon_parameter_result'] = new abap.types.Character(4, {});
pool['icon_parameter_result'].set('ICON');
pool['icon_plant'] = new abap.types.Character(4, {});
pool['icon_plant'].set('ICON');
pool['icon_pm_insert'] = new abap.types.Character(4, {});
pool['icon_pm_insert'].set('ICON');
pool['icon_pm_press'] = new abap.types.Character(4, {});
pool['icon_pm_press'].set('ICON');
pool['icon_profit_center'] = new abap.types.Character(4, {});
pool['icon_profit_center'].set('ICON');
pool['icon_protocol'] = new abap.types.Character(4, {});
pool['icon_protocol'].set('ICON');
pool['icon_question'] = new abap.types.Character(4, {});
pool['icon_question'].set('ICON');
pool['icon_red_light'] = new abap.types.Character(4, {});
pool['icon_red_light'].set('ICON');
pool['icon_refresh'] = new abap.types.Character(4, {});
pool['icon_refresh'].set('ICON');
pool['icon_relation'] = new abap.types.Character(4, {});
pool['icon_relation'].set('ICON');
pool['icon_release'] = new abap.types.Character(4, {});
pool['icon_release'].set('ICON');
pool['icon_resubmission'] = new abap.types.Character(4, {});
pool['icon_resubmission'].set('ICON');
pool['icon_select_all'] = new abap.types.Character(4, {});
pool['icon_select_all'].set('ICON');
pool['icon_select_block'] = new abap.types.Character(4, {});
pool['icon_select_block'].set('ICON');
pool['icon_select_detail'] = new abap.types.Character(4, {});
pool['icon_select_detail'].set('ICON');
pool['icon_set_state'] = new abap.types.Character(4, {});
pool['icon_set_state'].set('ICON');
pool['icon_simulate'] = new abap.types.Character(4, {});
pool['icon_simulate'].set('ICON');
pool['icon_space'] = new abap.types.Character(4, {});
pool['icon_space'].set('ICON');
pool['icon_stack'] = new abap.types.Character(4, {});
pool['icon_stack'].set('ICON');
pool['icon_store_location'] = new abap.types.Character(4, {});
pool['icon_store_location'].set('ICON');
pool['icon_structure'] = new abap.types.Character(4, {});
pool['icon_structure'].set('ICON');
pool['icon_sym_log_server'] = new abap.types.Character(4, {});
pool['icon_sym_log_server'].set('ICON');
pool['icon_system_help'] = new abap.types.Character(4, {});
pool['icon_system_help'].set('ICON');
pool['icon_system_local_paste'] = new abap.types.Character(4, {});
pool['icon_system_local_paste'].set('ICON');
pool['icon_system_okay'] = new abap.types.Character(4, {});
pool['icon_system_okay'].set('ICON');
pool['icon_system_save'] = new abap.types.Character(4, {});
pool['icon_system_save'].set('ICON');
pool['icon_terminated_org_unit'] = new abap.types.Character(4, {});
pool['icon_terminated_org_unit'].set('ICON');
pool['icon_test'] = new abap.types.Character(4, {});
pool['icon_test'].set('ICON');
pool['icon_total_left'] = new abap.types.Character(4, {});
pool['icon_total_left'].set('ICON');
pool['icon_transport'] = new abap.types.Character(4, {});
pool['icon_transport'].set('ICON');
pool['icon_variable'] = new abap.types.Character(4, {});
pool['icon_variable'].set('ICON');
pool['icon_warehouse'] = new abap.types.Character(4, {});
pool['icon_warehouse'].set('ICON');
pool['icon_wd_context'] = new abap.types.Character(4, {});
pool['icon_wd_context'].set('ICON');
pool['icon_wd_table'] = new abap.types.Character(4, {});
pool['icon_wd_table'].set('ICON');
pool['icon_wf_workitem_completed'] = new abap.types.Character(4, {});
pool['icon_wf_workitem_completed'].set('ICON');
pool['icon_yellow_light'] = new abap.types.Character(4, {});
pool['icon_yellow_light'].set('ICON');
abap.TypePools['ICON'] = pool;
//# sourceMappingURL=icon.type.mjs.map

/***/ }),

/***/ "./output/icon_d.dtel.mjs":
/*!********************************!*\
  !*** ./output/icon_d.dtel.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["ICON_D"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(4, {"qualifiedName":"ICON_D","ddicName":"ICON_D"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/if_abap_channel_types.intf.mjs":
/*!***********************************************!*\
  !*** ./output/if_abap_channel_types.intf.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_abap_channel_types": () => (/* binding */ if_abap_channel_types)
/* harmony export */ });
// if_abap_channel_types.intf.abap
class if_abap_channel_types {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {};
}
abap.Classes['IF_ABAP_CHANNEL_TYPES'] = if_abap_channel_types;if_abap_channel_types.ty_apc_tcp_frame = new abap.types.Structure({"frame_type": new abap.types.Integer({qualifiedName: "IF_ABAP_CHANNEL_TYPES=>TY_APC_TCP_FRAME-FRAME_TYPE"}), "fixed_length": new abap.types.Integer({qualifiedName: "IF_ABAP_CHANNEL_TYPES=>TY_APC_TCP_FRAME-FIXED_LENGTH"}), "terminator": new abap.types.String({qualifiedName: "IF_ABAP_CHANNEL_TYPES=>TY_APC_TCP_FRAME-TERMINATOR"}), "length_field_length": new abap.types.Integer({qualifiedName: "IF_ABAP_CHANNEL_TYPES=>TY_APC_TCP_FRAME-LENGTH_FIELD_LENGTH"}), "length_field_offset": new abap.types.Integer({qualifiedName: "IF_ABAP_CHANNEL_TYPES=>TY_APC_TCP_FRAME-LENGTH_FIELD_OFFSET"}), "length_field_header": new abap.types.Integer({qualifiedName: "IF_ABAP_CHANNEL_TYPES=>TY_APC_TCP_FRAME-LENGTH_FIELD_HEADER"})}, "if_abap_channel_types=>ty_apc_tcp_frame", undefined, {}, {});
if_abap_channel_types.ty_tihttpnvp = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");

//# sourceMappingURL=if_abap_channel_types.intf.mjs.map

/***/ }),

/***/ "./output/if_abap_conv_in.intf.mjs":
/*!*****************************************!*\
  !*** ./output/if_abap_conv_in.intf.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_abap_conv_in": () => (/* binding */ if_abap_conv_in)
/* harmony export */ });
// if_abap_conv_in.intf.abap
class if_abap_conv_in {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"CONVERT": {"visibility": "U", "parameters": {"RESULT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "SOURCE": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_ABAP_CONV_IN'] = if_abap_conv_in;

//# sourceMappingURL=if_abap_conv_in.intf.mjs.map

/***/ }),

/***/ "./output/if_abap_conv_out.intf.mjs":
/*!******************************************!*\
  !*** ./output/if_abap_conv_out.intf.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_abap_conv_out": () => (/* binding */ if_abap_conv_out)
/* harmony export */ });
// if_abap_conv_out.intf.abap
class if_abap_conv_out {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"CONVERT": {"visibility": "U", "parameters": {"RESULT": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "SOURCE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_ABAP_CONV_OUT'] = if_abap_conv_out;

//# sourceMappingURL=if_abap_conv_out.intf.mjs.map

/***/ }),

/***/ "./output/if_abap_unit_constant.intf.mjs":
/*!***********************************************!*\
  !*** ./output/if_abap_unit_constant.intf.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_abap_unit_constant": () => (/* binding */ if_abap_unit_constant)
/* harmony export */ });
// if_abap_unit_constant.intf.abap
class if_abap_unit_constant {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"SEVERITY": {"type": () => {return new abap.types.Structure({"low": new abap.types.Integer({qualifiedName: "INT1"}), "medium": new abap.types.Integer({qualifiedName: "INT1"}), "high": new abap.types.Integer({qualifiedName: "INT1"})}, undefined, undefined, {}, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "QUIT": {"type": () => {return new abap.types.Structure({"test": new abap.types.Integer({qualifiedName: "INT1"}), "no": new abap.types.Integer({qualifiedName: "INT1"})}, undefined, undefined, {}, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {};
}
abap.Classes['IF_ABAP_UNIT_CONSTANT'] = if_abap_unit_constant;
if_abap_unit_constant.if_abap_unit_constant$severity = new abap.types.Structure({"low": new abap.types.Integer({qualifiedName: "INT1"}), "medium": new abap.types.Integer({qualifiedName: "INT1"}), "high": new abap.types.Integer({qualifiedName: "INT1"})}, undefined, undefined, {}, {});
if_abap_unit_constant.if_abap_unit_constant$severity.get().low.set(0);
if_abap_unit_constant.if_abap_unit_constant$severity.get().medium.set(1);
if_abap_unit_constant.if_abap_unit_constant$severity.get().high.set(2);
if_abap_unit_constant.if_abap_unit_constant$quit = new abap.types.Structure({"test": new abap.types.Integer({qualifiedName: "INT1"}), "no": new abap.types.Integer({qualifiedName: "INT1"})}, undefined, undefined, {}, {});
if_abap_unit_constant.if_abap_unit_constant$quit.get().test.set(1);
if_abap_unit_constant.if_abap_unit_constant$quit.get().no.set(5);

//# sourceMappingURL=if_abap_unit_constant.intf.mjs.map

/***/ }),

/***/ "./output/if_amdp_marker_hdb.intf.mjs":
/*!********************************************!*\
  !*** ./output/if_amdp_marker_hdb.intf.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_amdp_marker_hdb": () => (/* binding */ if_amdp_marker_hdb)
/* harmony export */ });
// if_amdp_marker_hdb.intf.abap
class if_amdp_marker_hdb {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {};
}
abap.Classes['IF_AMDP_MARKER_HDB'] = if_amdp_marker_hdb;

//# sourceMappingURL=if_amdp_marker_hdb.intf.mjs.map

/***/ }),

/***/ "./output/if_apc_tcp_frame_types.intf.mjs":
/*!************************************************!*\
  !*** ./output/if_apc_tcp_frame_types.intf.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_apc_tcp_frame_types": () => (/* binding */ if_apc_tcp_frame_types)
/* harmony export */ });
// if_apc_tcp_frame_types.intf.abap
class if_apc_tcp_frame_types {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"CO_FRAME_TYPE_FIXED_LENGTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_FRAME_TYPE_TERMINATOR": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_FRAME_TYPE_LENGTH_FIELD": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {};
}
abap.Classes['IF_APC_TCP_FRAME_TYPES'] = if_apc_tcp_frame_types;
if_apc_tcp_frame_types.if_apc_tcp_frame_types$co_frame_type_fixed_length = new abap.types.Integer({qualifiedName: "I"});
if_apc_tcp_frame_types.if_apc_tcp_frame_types$co_frame_type_fixed_length.set(1);
if_apc_tcp_frame_types.if_apc_tcp_frame_types$co_frame_type_terminator = new abap.types.Integer({qualifiedName: "I"});
if_apc_tcp_frame_types.if_apc_tcp_frame_types$co_frame_type_terminator.set(2);
if_apc_tcp_frame_types.if_apc_tcp_frame_types$co_frame_type_length_field = new abap.types.Integer({qualifiedName: "I"});
if_apc_tcp_frame_types.if_apc_tcp_frame_types$co_frame_type_length_field.set(3);

//# sourceMappingURL=if_apc_tcp_frame_types.intf.mjs.map

/***/ }),

/***/ "./output/if_apc_wsp_binding_manager.intf.mjs":
/*!****************************************************!*\
  !*** ./output/if_apc_wsp_binding_manager.intf.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_apc_wsp_binding_manager": () => (/* binding */ if_apc_wsp_binding_manager)
/* harmony export */ });
// if_apc_wsp_binding_manager.intf.abap
class if_apc_wsp_binding_manager {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"BIND_AMC_MESSAGE_CONSUMER": {"visibility": "U", "parameters": {"I_APPLICATION_ID": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "I_CHANNEL_ID": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}}};
}
abap.Classes['IF_APC_WSP_BINDING_MANAGER'] = if_apc_wsp_binding_manager;

//# sourceMappingURL=if_apc_wsp_binding_manager.intf.mjs.map

/***/ }),

/***/ "./output/if_apc_wsp_client.intf.mjs":
/*!*******************************************!*\
  !*** ./output/if_apc_wsp_client.intf.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_apc_wsp_client": () => (/* binding */ if_apc_wsp_client)
/* harmony export */ });
// if_apc_wsp_client.intf.abap
class if_apc_wsp_client {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"CONNECT": {"visibility": "U", "parameters": {}},
  "CLOSE": {"visibility": "U", "parameters": {}},
  "GET_MESSAGE_MANAGER": {"visibility": "U", "parameters": {"RI_MANAGER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_MESSAGE_MANAGER", RTTIName: "\\INTERFACE=IF_APC_WSP_MESSAGE_MANAGER"});}, "is_optional": " "}}}};
}
abap.Classes['IF_APC_WSP_CLIENT'] = if_apc_wsp_client;

//# sourceMappingURL=if_apc_wsp_client.intf.mjs.map

/***/ }),

/***/ "./output/if_apc_wsp_event_handler.intf.mjs":
/*!**************************************************!*\
  !*** ./output/if_apc_wsp_event_handler.intf.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_apc_wsp_event_handler": () => (/* binding */ if_apc_wsp_event_handler)
/* harmony export */ });
// if_apc_wsp_event_handler.intf.abap
class if_apc_wsp_event_handler {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"ON_OPEN": {"visibility": "U", "parameters": {}},
  "ON_MESSAGE": {"visibility": "U", "parameters": {"I_MESSAGE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_MESSAGE", RTTIName: "\\INTERFACE=IF_APC_WSP_MESSAGE"});}, "is_optional": " "}}},
  "ON_CLOSE": {"visibility": "U", "parameters": {}},
  "ON_ERROR": {"visibility": "U", "parameters": {"I_REASON": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_APC_WSP_EVENT_HANDLER'] = if_apc_wsp_event_handler;

//# sourceMappingURL=if_apc_wsp_event_handler.intf.mjs.map

/***/ }),

/***/ "./output/if_apc_wsp_extension.intf.mjs":
/*!**********************************************!*\
  !*** ./output/if_apc_wsp_extension.intf.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_apc_wsp_extension": () => (/* binding */ if_apc_wsp_extension)
/* harmony export */ });
// if_apc_wsp_extension.intf.abap
class if_apc_wsp_extension {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"ON_START": {"visibility": "U", "parameters": {"I_CONTEXT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_SERVER_CONTEXT", RTTIName: "\\INTERFACE=IF_APC_WSP_SERVER_CONTEXT"});}, "is_optional": " "}, "I_MESSAGE_MANAGER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_MESSAGE_MANAGER", RTTIName: "\\INTERFACE=IF_APC_WSP_MESSAGE_MANAGER"});}, "is_optional": " "}}},
  "ON_MESSAGE": {"visibility": "U", "parameters": {"I_MESSAGE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_MESSAGE", RTTIName: "\\INTERFACE=IF_APC_WSP_MESSAGE"});}, "is_optional": " "}, "I_MESSAGE_MANAGER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_MESSAGE_MANAGER", RTTIName: "\\INTERFACE=IF_APC_WSP_MESSAGE_MANAGER"});}, "is_optional": " "}, "I_CONTEXT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_SERVER_CONTEXT", RTTIName: "\\INTERFACE=IF_APC_WSP_SERVER_CONTEXT"});}, "is_optional": " "}}}};
}
abap.Classes['IF_APC_WSP_EXTENSION'] = if_apc_wsp_extension;

//# sourceMappingURL=if_apc_wsp_extension.intf.mjs.map

/***/ }),

/***/ "./output/if_apc_wsp_initial_request.intf.mjs":
/*!****************************************************!*\
  !*** ./output/if_apc_wsp_initial_request.intf.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_apc_wsp_initial_request": () => (/* binding */ if_apc_wsp_initial_request)
/* harmony export */ });
// if_apc_wsp_initial_request.intf.abap
class if_apc_wsp_initial_request {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"GET_FORM_FIELDS": {"visibility": "U", "parameters": {"I_FORMFIELD_ENCODING": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "C_FIELDS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");}, "is_optional": " "}}},
  "GET_HEADER_FIELDS": {"visibility": "U", "parameters": {"C_FIELDS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");}, "is_optional": " "}}}};
}
abap.Classes['IF_APC_WSP_INITIAL_REQUEST'] = if_apc_wsp_initial_request;

//# sourceMappingURL=if_apc_wsp_initial_request.intf.mjs.map

/***/ }),

/***/ "./output/if_apc_wsp_message.intf.mjs":
/*!********************************************!*\
  !*** ./output/if_apc_wsp_message.intf.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_apc_wsp_message": () => (/* binding */ if_apc_wsp_message)
/* harmony export */ });
// if_apc_wsp_message.intf.abap
class if_apc_wsp_message {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"GET_BINARY": {"visibility": "U", "parameters": {"RV_BINARY": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "SET_BINARY": {"visibility": "U", "parameters": {"IV_BINARY": {"type": () => {return new abap.types.Hex();}, "is_optional": " "}}},
  "GET_TEXT": {"visibility": "U", "parameters": {"R_MESSAGE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_APC_WSP_MESSAGE'] = if_apc_wsp_message;

//# sourceMappingURL=if_apc_wsp_message.intf.mjs.map

/***/ }),

/***/ "./output/if_apc_wsp_message_manager.intf.mjs":
/*!****************************************************!*\
  !*** ./output/if_apc_wsp_message_manager.intf.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_apc_wsp_message_manager": () => (/* binding */ if_apc_wsp_message_manager)
/* harmony export */ });
// if_apc_wsp_message_manager.intf.abap
class if_apc_wsp_message_manager {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"CREATE_MESSAGE": {"visibility": "U", "parameters": {"RI_MESSAGE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_MESSAGE", RTTIName: "\\INTERFACE=IF_APC_WSP_MESSAGE"});}, "is_optional": " "}}},
  "SEND": {"visibility": "U", "parameters": {"II_MESSAGE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_MESSAGE", RTTIName: "\\INTERFACE=IF_APC_WSP_MESSAGE"});}, "is_optional": " "}}}};
}
abap.Classes['IF_APC_WSP_MESSAGE_MANAGER'] = if_apc_wsp_message_manager;

//# sourceMappingURL=if_apc_wsp_message_manager.intf.mjs.map

/***/ }),

/***/ "./output/if_apc_wsp_server_context.intf.mjs":
/*!***************************************************!*\
  !*** ./output/if_apc_wsp_server_context.intf.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_apc_wsp_server_context": () => (/* binding */ if_apc_wsp_server_context)
/* harmony export */ });
// if_apc_wsp_server_context.intf.abap
class if_apc_wsp_server_context {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"GET_INITIAL_REQUEST": {"visibility": "U", "parameters": {"R_INITIAL_REQUEST": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_INITIAL_REQUEST", RTTIName: "\\INTERFACE=IF_APC_WSP_INITIAL_REQUEST"});}, "is_optional": " "}}},
  "GET_BINDING_MANAGER": {"visibility": "U", "parameters": {"R_BINDING_MANAGER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_APC_WSP_BINDING_MANAGER", RTTIName: "\\INTERFACE=IF_APC_WSP_BINDING_MANAGER"});}, "is_optional": " "}}}};
}
abap.Classes['IF_APC_WSP_SERVER_CONTEXT'] = if_apc_wsp_server_context;

//# sourceMappingURL=if_apc_wsp_server_context.intf.mjs.map

/***/ }),

/***/ "./output/if_aunit_constants.intf.mjs":
/*!********************************************!*\
  !*** ./output/if_aunit_constants.intf.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_aunit_constants": () => (/* binding */ if_aunit_constants)
/* harmony export */ });
// if_aunit_constants.intf.abap
class if_aunit_constants {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"NO": {"type": () => {return new abap.types.Integer({qualifiedName: "INT1"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CRITICAL": {"type": () => {return new abap.types.Integer({qualifiedName: "INT1"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "FATAL": {"type": () => {return new abap.types.Integer({qualifiedName: "INT1"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TOLERABLE": {"type": () => {return new abap.types.Integer({qualifiedName: "INT1"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "METHOD": {"type": () => {return new abap.types.Integer({qualifiedName: "INT1"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CLASS_": {"type": () => {return new abap.types.Integer({qualifiedName: "INT1"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "SEVERITY": {"type": () => {return new abap.types.Structure({"low": new abap.types.Integer({qualifiedName: "INT1"}), "medium": new abap.types.Integer({qualifiedName: "INT1"}), "high": new abap.types.Integer({qualifiedName: "INT1"})}, undefined, undefined, {}, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "QUIT": {"type": () => {return new abap.types.Structure({"no": new abap.types.Integer({qualifiedName: "INT1"}), "test": new abap.types.Integer({qualifiedName: "INT1"})}, undefined, undefined, {}, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {};
}
abap.Classes['IF_AUNIT_CONSTANTS'] = if_aunit_constants;
if_aunit_constants.if_aunit_constants$no = new abap.types.Integer({qualifiedName: "INT1"});
if_aunit_constants.if_aunit_constants$no.set(0);
if_aunit_constants.if_aunit_constants$critical = new abap.types.Integer({qualifiedName: "INT1"});
if_aunit_constants.if_aunit_constants$critical.set(1);
if_aunit_constants.if_aunit_constants$fatal = new abap.types.Integer({qualifiedName: "INT1"});
if_aunit_constants.if_aunit_constants$fatal.set(1);
if_aunit_constants.if_aunit_constants$tolerable = new abap.types.Integer({qualifiedName: "INT1"});
if_aunit_constants.if_aunit_constants$tolerable.set(1);
if_aunit_constants.if_aunit_constants$method = new abap.types.Integer({qualifiedName: "INT1"});
if_aunit_constants.if_aunit_constants$method.set(1);
if_aunit_constants.if_aunit_constants$class_ = new abap.types.Integer({qualifiedName: "INT1"});
if_aunit_constants.if_aunit_constants$class_.set(2);
if_aunit_constants.if_aunit_constants$severity = new abap.types.Structure({"low": new abap.types.Integer({qualifiedName: "INT1"}), "medium": new abap.types.Integer({qualifiedName: "INT1"}), "high": new abap.types.Integer({qualifiedName: "INT1"})}, undefined, undefined, {}, {});
if_aunit_constants.if_aunit_constants$severity.get().low.set(0);
if_aunit_constants.if_aunit_constants$severity.get().medium.set(1);
if_aunit_constants.if_aunit_constants$severity.get().high.set(2);
if_aunit_constants.if_aunit_constants$quit = new abap.types.Structure({"no": new abap.types.Integer({qualifiedName: "INT1"}), "test": new abap.types.Integer({qualifiedName: "INT1"})}, undefined, undefined, {}, {});
if_aunit_constants.if_aunit_constants$quit.get().no.set(0);
if_aunit_constants.if_aunit_constants$quit.get().test.set(1);

//# sourceMappingURL=if_aunit_constants.intf.mjs.map

/***/ }),

/***/ "./output/if_document_bcs.intf.mjs":
/*!*****************************************!*\
  !*** ./output/if_document_bcs.intf.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_document_bcs": () => (/* binding */ if_document_bcs)
/* harmony export */ });
// if_document_bcs.intf.abap
class if_document_bcs {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {};
}
abap.Classes['IF_DOCUMENT_BCS'] = if_document_bcs;

//# sourceMappingURL=if_document_bcs.intf.mjs.map

/***/ }),

/***/ "./output/if_ftd_input_arguments.intf.mjs":
/*!************************************************!*\
  !*** ./output/if_ftd_input_arguments.intf.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ftd_input_arguments": () => (/* binding */ if_ftd_input_arguments)
/* harmony export */ });
// if_ftd_input_arguments.intf.abap
class if_ftd_input_arguments {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"GET_IMPORTING_PARAMETER": {"visibility": "U", "parameters": {"RESULT": {"type": () => {return new abap.types.DataReference(new abap.types.Character(4));}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"abap_parmname"});}, "is_optional": " "}}},
  "GET_TABLE_PARAMETER": {"visibility": "U", "parameters": {"RESULT": {"type": () => {return new abap.types.DataReference(new abap.types.Character(4));}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"abap_parmname"});}, "is_optional": " "}}}};
}
abap.Classes['IF_FTD_INPUT_ARGUMENTS'] = if_ftd_input_arguments;

//# sourceMappingURL=if_ftd_input_arguments.intf.mjs.map

/***/ }),

/***/ "./output/if_ftd_input_config_setter.intf.mjs":
/*!****************************************************!*\
  !*** ./output/if_ftd_input_config_setter.intf.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ftd_input_config_setter": () => (/* binding */ if_ftd_input_config_setter)
/* harmony export */ });
// if_ftd_input_config_setter.intf.abap
class if_ftd_input_config_setter {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"IGNORE_ALL_PARAMETERS": {"visibility": "U", "parameters": {"OUTPUT_CONFIGURATION_SETTER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_FTD_OUTPUT_CONFIG_SETTER", RTTIName: "\\INTERFACE=IF_FTD_OUTPUT_CONFIG_SETTER"});}, "is_optional": " "}}}};
}
abap.Classes['IF_FTD_INPUT_CONFIG_SETTER'] = if_ftd_input_config_setter;

//# sourceMappingURL=if_ftd_input_config_setter.intf.mjs.map

/***/ }),

/***/ "./output/if_ftd_invocation_answer.intf.mjs":
/*!**************************************************!*\
  !*** ./output/if_ftd_invocation_answer.intf.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ftd_invocation_answer": () => (/* binding */ if_ftd_invocation_answer)
/* harmony export */ });
// if_ftd_invocation_answer.intf.abap
class if_ftd_invocation_answer {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"ANSWER": {"visibility": "U", "parameters": {"ARGUMENTS_": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_FTD_INPUT_ARGUMENTS", RTTIName: "\\INTERFACE=IF_FTD_INPUT_ARGUMENTS"});}, "is_optional": " "}, "RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_FTD_INVOCATION_RESULT", RTTIName: "\\INTERFACE=IF_FTD_INVOCATION_RESULT"});}, "is_optional": " "}}}};
}
abap.Classes['IF_FTD_INVOCATION_ANSWER'] = if_ftd_invocation_answer;

//# sourceMappingURL=if_ftd_invocation_answer.intf.mjs.map

/***/ }),

/***/ "./output/if_ftd_invocation_result.intf.mjs":
/*!**************************************************!*\
  !*** ./output/if_ftd_invocation_result.intf.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ftd_invocation_result": () => (/* binding */ if_ftd_invocation_result)
/* harmony export */ });
// if_ftd_invocation_result.intf.abap
class if_ftd_invocation_result {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"GET_OUTPUT_CONFIGURATION": {"visibility": "U", "parameters": {"RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_FTD_OUTPUT_CONFIGURATION", RTTIName: "\\INTERFACE=IF_FTD_OUTPUT_CONFIGURATION"});}, "is_optional": " "}}}};
}
abap.Classes['IF_FTD_INVOCATION_RESULT'] = if_ftd_invocation_result;

//# sourceMappingURL=if_ftd_invocation_result.intf.mjs.map

/***/ }),

/***/ "./output/if_ftd_output_config_setter.intf.mjs":
/*!*****************************************************!*\
  !*** ./output/if_ftd_output_config_setter.intf.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ftd_output_config_setter": () => (/* binding */ if_ftd_output_config_setter)
/* harmony export */ });
// if_ftd_output_config_setter.intf.abap
class if_ftd_output_config_setter {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"THEN_ANSWER": {"visibility": "U", "parameters": {"SELF": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_FTD_OUTPUT_CONFIG_SETTER", RTTIName: "\\INTERFACE=IF_FTD_OUTPUT_CONFIG_SETTER"});}, "is_optional": " "}, "ANSWER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_FTD_INVOCATION_ANSWER", RTTIName: "\\INTERFACE=IF_FTD_INVOCATION_ANSWER"});}, "is_optional": " "}}}};
}
abap.Classes['IF_FTD_OUTPUT_CONFIG_SETTER'] = if_ftd_output_config_setter;

//# sourceMappingURL=if_ftd_output_config_setter.intf.mjs.map

/***/ }),

/***/ "./output/if_ftd_output_configuration.intf.mjs":
/*!*****************************************************!*\
  !*** ./output/if_ftd_output_configuration.intf.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ftd_output_configuration": () => (/* binding */ if_ftd_output_configuration)
/* harmony export */ });
// if_ftd_output_configuration.intf.abap
class if_ftd_output_configuration {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"SET_EXPORTING_PARAMETER": {"visibility": "U", "parameters": {"SELF": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_FTD_OUTPUT_CONFIGURATION", RTTIName: "\\INTERFACE=IF_FTD_OUTPUT_CONFIGURATION"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"abap_parmname"});}, "is_optional": " "}, "VALUE": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "SET_TABLE_PARAMETER": {"visibility": "U", "parameters": {"SELF": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_FTD_OUTPUT_CONFIGURATION", RTTIName: "\\INTERFACE=IF_FTD_OUTPUT_CONFIGURATION"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"abap_parmname"});}, "is_optional": " "}, "VALUE": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}}};
}
abap.Classes['IF_FTD_OUTPUT_CONFIGURATION'] = if_ftd_output_configuration;

//# sourceMappingURL=if_ftd_output_configuration.intf.mjs.map

/***/ }),

/***/ "./output/if_function_test_environment.intf.mjs":
/*!******************************************************!*\
  !*** ./output/if_function_test_environment.intf.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_function_test_environment": () => (/* binding */ if_function_test_environment)
/* harmony export */ });
// if_function_test_environment.intf.abap
class if_function_test_environment {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"GET_DOUBLE": {"visibility": "U", "parameters": {"RESULT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_FUNCTION_TESTDOUBLE", RTTIName: "\\INTERFACE=IF_FUNCTION_TESTDOUBLE"});}, "is_optional": " "}, "FUNCTION_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SXCO_FM_NAME","ddicName":"SXCO_FM_NAME"});}, "is_optional": " "}}},
  "CLEAR_DOUBLES": {"visibility": "U", "parameters": {}}};
}
abap.Classes['IF_FUNCTION_TEST_ENVIRONMENT'] = if_function_test_environment;if_function_test_environment.tt_function_dependencies = abap.types.TableFactory.construct(new abap.types.Character(30, {"qualifiedName":"SXCO_FM_NAME","ddicName":"SXCO_FM_NAME"}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":["TABLE_LINE"]},"secondary":[]}, "if_function_test_environment=>tt_function_dependencies");

//# sourceMappingURL=if_function_test_environment.intf.mjs.map

/***/ }),

/***/ "./output/if_function_testdouble.intf.mjs":
/*!************************************************!*\
  !*** ./output/if_function_testdouble.intf.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_function_testdouble": () => (/* binding */ if_function_testdouble)
/* harmony export */ });
// if_function_testdouble.intf.abap
class if_function_testdouble {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"CONFIGURE_CALL": {"visibility": "U", "parameters": {"INPUT_CONFIGURATION_SETTER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_FTD_INPUT_CONFIG_SETTER", RTTIName: "\\INTERFACE=IF_FTD_INPUT_CONFIG_SETTER"});}, "is_optional": " "}}}};
}
abap.Classes['IF_FUNCTION_TESTDOUBLE'] = if_function_testdouble;

//# sourceMappingURL=if_function_testdouble.intf.mjs.map

/***/ }),

/***/ "./output/if_http_client.intf.mjs":
/*!****************************************!*\
  !*** ./output/if_http_client.intf.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_http_client": () => (/* binding */ if_http_client)
/* harmony export */ });
// if_http_client.intf.abap
class if_http_client {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"REQUEST": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_REQUEST", RTTIName: "\\INTERFACE=IF_HTTP_REQUEST"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "RESPONSE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_RESPONSE", RTTIName: "\\INTERFACE=IF_HTTP_RESPONSE"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "PROPERTYTYPE_LOGON_POPUP": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "PROPERTYTYPE_ACCEPT_COOKIE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "PROPERTYTYPE_REDIRECT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "CO_DISABLED": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_ENABLED": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_TIMEOUT_DEFAULT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"AUTHENTICATE": {"visibility": "U", "parameters": {"PROXY_AUTHENTICATION": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "USERNAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PASSWORD": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "CLOSE": {"visibility": "U", "parameters": {}},
  "SEND": {"visibility": "U", "parameters": {"TIMEOUT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "RECEIVE": {"visibility": "U", "parameters": {}},
  "SEND_SAP_LOGON_TICKET": {"visibility": "U", "parameters": {}},
  "GET_LAST_ERROR": {"visibility": "U", "parameters": {"CODE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "MESSAGE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "REFRESH_REQUEST": {"visibility": "U", "parameters": {}},
  "CREATE_ABS_URL": {"visibility": "U", "parameters": {"URL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PATH": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "ESCAPE_URL": {"visibility": "U", "parameters": {"ESCAPED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "UNESCAPED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_HTTP_CLIENT'] = if_http_client;
if_http_client.if_http_client$co_disabled = new abap.types.Integer({qualifiedName: "I"});
if_http_client.if_http_client$co_disabled.set(0);
if_http_client.if_http_client$co_enabled = new abap.types.Integer({qualifiedName: "I"});
if_http_client.if_http_client$co_enabled.set(1);
if_http_client.if_http_client$co_timeout_default = new abap.types.Integer({qualifiedName: "I"});
if_http_client.if_http_client$co_timeout_default.set(60);

//# sourceMappingURL=if_http_client.intf.mjs.map

/***/ }),

/***/ "./output/if_http_entity.intf.mjs":
/*!****************************************!*\
  !*** ./output/if_http_entity.intf.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_http_entity": () => (/* binding */ if_http_entity)
/* harmony export */ });
// if_http_entity.intf.abap
class if_http_entity {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"CO_REQUEST_METHOD_GET": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_REQUEST_METHOD_POST": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_BODY_BEFORE_QUERY_STRING": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_PROTOCOL_VERSION_1_0": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_PROTOCOL_VERSION_1_1": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_COMPRESS_BASED_ON_MIME_TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"SET_CDATA": {"visibility": "U", "parameters": {"DATA": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "OFFSET": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "LENGTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "SET_DATA": {"visibility": "U", "parameters": {"DATA": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "GET_HEADER_FIELD": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_HEADER_FIELD": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_FORM_FIELDS": {"visibility": "U", "parameters": {"FIELDS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");}, "is_optional": " "}}},
  "SET_COMPRESSION": {"visibility": "U", "parameters": {"DISABLE_EXTENDED_CHECKS": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "OPTIONS": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "ADD_MULTIPART": {"visibility": "U", "parameters": {"ENTITY": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_ENTITY", RTTIName: "\\INTERFACE=IF_HTTP_ENTITY"});}, "is_optional": " "}, "SUPPRESS_CONTENT_LENGTH": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "APPEND_CDATA": {"visibility": "U", "parameters": {"DATA": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "GET_FORM_FIELD": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_CDATA": {"visibility": "U", "parameters": {"DATA": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_CONTENT_TYPE": {"visibility": "U", "parameters": {"CONTENT_TYPE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_SERIALIZED_MESSAGE_LENGTH": {"visibility": "U", "parameters": {"BODY_LENGTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "HEADER_LENGTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "SET_CONTENT_TYPE": {"visibility": "U", "parameters": {"CONTENT_TYPE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_DATA": {"visibility": "U", "parameters": {"DATA": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "GET_HEADER_FIELDS": {"visibility": "U", "parameters": {"FIELDS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");}, "is_optional": " "}}},
  "TO_XSTRING": {"visibility": "U", "parameters": {"DATA": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "GET_COOKIES": {"visibility": "U", "parameters": {"COOKIES": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "ADD_COOKIE_FIELD": {"visibility": "U", "parameters": {"COOKIE_NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "COOKIE_PATH": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "FIELD_NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "FIELD_VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "BASE64": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "APPEND_CDATA2": {"visibility": "U", "parameters": {"DATA": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "ENCODING": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "OFFSET": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "LENGTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "APPEND_DATA": {"visibility": "U", "parameters": {"DATA": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "OFFSET": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "LENGTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "DELETE_COOKIE_SECURE": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PATH": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "DELETE_FORM_FIELD": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "DELETE_FORM_FIELD_SECURE": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "FROM_XSTRING": {"visibility": "U", "parameters": {"DATA": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "GET_COOKIE": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PATH": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "DOMAIN": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "EXPIRES": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "SECURE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_COOKIE_FIELD": {"visibility": "U", "parameters": {"FIELD_VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "COOKIE_NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "COOKIE_PATH": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "FIELD_NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "BASE64": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_DATA_LENGTH": {"visibility": "U", "parameters": {"DATA_LENGTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_FORM_FIELDS_CS": {"visibility": "U", "parameters": {"FORMFIELD_ENCODING": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "SEARCH_OPTION": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "FIELDS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");}, "is_optional": " "}}},
  "GET_FORM_FIELD_CS": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "FORMFIELD_ENCODING": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "SEARCH_OPTION": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_LAST_ERROR": {"visibility": "U", "parameters": {"RC": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_MULTIPART": {"visibility": "U", "parameters": {"ENTITY": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_ENTITY", RTTIName: "\\INTERFACE=IF_HTTP_ENTITY"});}, "is_optional": " "}, "INDEX": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_VERSION": {"visibility": "U", "parameters": {"VERSION": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "NUM_MULTIPARTS": {"visibility": "U", "parameters": {"NUM": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "SET_COOKIE": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PATH": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "DOMAIN": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "EXPIRES": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "SECURE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "SET_FORMFIELD_ENCODING": {"visibility": "U", "parameters": {"FORMFIELD_ENCODING": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "SET_FORM_FIELD": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_FORM_FIELDS": {"visibility": "U", "parameters": {"FIELDS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");}, "is_optional": " "}, "MULTIVALUE": {"type": () => {return new abap.types.Integer({qualifiedName: "INT4"});}, "is_optional": " "}}},
  "SET_HEADER_FIELDS": {"visibility": "U", "parameters": {"FIELDS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");}, "is_optional": " "}}},
  "SUPPRESS_CONTENT_TYPE": {"visibility": "U", "parameters": {"SUPPRESS": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "DELETE_COOKIE": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PATH": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "DELETE_HEADER_FIELD": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "DELETE_HEADER_FIELD_SECURE": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_HTTP_ENTITY'] = if_http_entity;
if_http_entity.if_http_entity$co_request_method_get = new abap.types.String({qualifiedName: "STRING"});
if_http_entity.if_http_entity$co_request_method_get.set('GET');
if_http_entity.if_http_entity$co_request_method_post = new abap.types.String({qualifiedName: "STRING"});
if_http_entity.if_http_entity$co_request_method_post.set('POST');
if_http_entity.if_http_entity$co_body_before_query_string = new abap.types.Integer({qualifiedName: "I"});
if_http_entity.if_http_entity$co_body_before_query_string.set(3);
if_http_entity.if_http_entity$co_protocol_version_1_0 = new abap.types.Integer({qualifiedName: "I"});
if_http_entity.if_http_entity$co_protocol_version_1_0.set(1000);
if_http_entity.if_http_entity$co_protocol_version_1_1 = new abap.types.Integer({qualifiedName: "I"});
if_http_entity.if_http_entity$co_protocol_version_1_1.set(1001);
if_http_entity.if_http_entity$co_compress_based_on_mime_type = new abap.types.Integer({qualifiedName: "I"});
if_http_entity.if_http_entity$co_compress_based_on_mime_type.set(2);

//# sourceMappingURL=if_http_entity.intf.mjs.map

/***/ }),

/***/ "./output/if_http_extension.intf.mjs":
/*!*******************************************!*\
  !*** ./output/if_http_extension.intf.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_http_extension": () => (/* binding */ if_http_extension)
/* harmony export */ });
// if_http_extension.intf.abap
class if_http_extension {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"FLOW_RC": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "CO_FLOW_OK": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_FLOW_OK_OTHERS_MAND": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"HANDLE_REQUEST": {"visibility": "U", "parameters": {"SERVER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_SERVER", RTTIName: "\\INTERFACE=IF_HTTP_SERVER"});}, "is_optional": " "}}}};
}
abap.Classes['IF_HTTP_EXTENSION'] = if_http_extension;
if_http_extension.if_http_extension$co_flow_ok = new abap.types.Integer({qualifiedName: "I"});
if_http_extension.if_http_extension$co_flow_ok.set(0);
if_http_extension.if_http_extension$co_flow_ok_others_mand = new abap.types.Integer({qualifiedName: "I"});
if_http_extension.if_http_extension$co_flow_ok_others_mand.set(2);

//# sourceMappingURL=if_http_extension.intf.mjs.map

/***/ }),

/***/ "./output/if_http_request.intf.mjs":
/*!*****************************************!*\
  !*** ./output/if_http_request.intf.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_http_request": () => (/* binding */ if_http_request)
/* harmony export */ });
// if_http_request.intf.abap
class if_http_request {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"IF_HTTP_ENTITY~CO_REQUEST_METHOD_GET": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_REQUEST_METHOD_POST": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_BODY_BEFORE_QUERY_STRING": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_PROTOCOL_VERSION_1_0": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_PROTOCOL_VERSION_1_1": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_COMPRESS_BASED_ON_MIME_TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"SET_METHOD": {"visibility": "U", "parameters": {"METHOD": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_METHOD": {"visibility": "U", "parameters": {"METH": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_VERSION": {"visibility": "U", "parameters": {"VERSION": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "SET_AUTHORIZATION": {"visibility": "U", "parameters": {"AUTH_TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "USERNAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PASSWORD": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "COPY": {"visibility": "U", "parameters": {"REQUEST": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_REQUEST", RTTIName: "\\INTERFACE=IF_HTTP_REQUEST"});}, "is_optional": " "}}},
  "GET_AUTHORIZATION": {"visibility": "U", "parameters": {"AUTH_TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "USERNAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PASSWORD": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_FORM_DATA": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "DATA": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "GET_RAW_MESSAGE": {"visibility": "U", "parameters": {"DATA": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "GET_URI_PARAMETER": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_USER_AGENT": {"visibility": "U", "parameters": {"USER_AGENT_TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "USER_AGENT_VERSION": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}}};
}
abap.Classes['IF_HTTP_REQUEST'] = if_http_request;
if_http_request.if_http_request$co_protocol_version_1_0 = new abap.types.Integer({qualifiedName: "I"});
if_http_request.if_http_entity$co_protocol_version_1_0 = if_http_request.if_http_request$co_protocol_version_1_0;
if_http_request.if_http_request$co_protocol_version_1_0.set(1000);
if_http_request.if_http_request$co_protocol_version_1_1 = new abap.types.Integer({qualifiedName: "I"});
if_http_request.if_http_entity$co_protocol_version_1_1 = if_http_request.if_http_request$co_protocol_version_1_1;
if_http_request.if_http_request$co_protocol_version_1_1.set(1001);
if_http_request.if_http_request$co_request_method_get = new abap.types.String({qualifiedName: "STRING"});
if_http_request.if_http_entity$co_request_method_get = if_http_request.if_http_request$co_request_method_get;
if_http_request.if_http_request$co_request_method_get.set('GET');
if_http_request.if_http_request$co_request_method_post = new abap.types.String({qualifiedName: "STRING"});
if_http_request.if_http_entity$co_request_method_post = if_http_request.if_http_request$co_request_method_post;
if_http_request.if_http_request$co_request_method_post.set('POST');

//# sourceMappingURL=if_http_request.intf.mjs.map

/***/ }),

/***/ "./output/if_http_response.intf.mjs":
/*!******************************************!*\
  !*** ./output/if_http_response.intf.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_http_response": () => (/* binding */ if_http_response)
/* harmony export */ });
// if_http_response.intf.abap
class if_http_response {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"IF_HTTP_ENTITY~CO_REQUEST_METHOD_GET": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_REQUEST_METHOD_POST": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_BODY_BEFORE_QUERY_STRING": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_PROTOCOL_VERSION_1_0": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_PROTOCOL_VERSION_1_1": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_ENTITY~CO_COMPRESS_BASED_ON_MIME_TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"GET_STATUS": {"visibility": "U", "parameters": {"CODE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "REASON": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_STATUS": {"visibility": "U", "parameters": {"CODE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "REASON": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "DELETE_COOKIE_AT_CLIENT": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PATH": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "DOMAIN": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "REDIRECT": {"visibility": "U", "parameters": {"URL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PERMANENTLY": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "EXPLANATION": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PROTOCOL_DEPENDENT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "COPY": {"visibility": "U", "parameters": {"RESPONSE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_RESPONSE", RTTIName: "\\INTERFACE=IF_HTTP_RESPONSE"});}, "is_optional": " "}}},
  "GET_RAW_MESSAGE": {"visibility": "U", "parameters": {"DATA": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "SERVER_CACHE_BROWSER_DEPENDENT": {"visibility": "U", "parameters": {"DEPENDENT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"BOOLEAN","ddicName":"BOOLEAN"});}, "is_optional": " "}}},
  "SERVER_CACHE_EXPIRE_ABS": {"visibility": "U", "parameters": {"EXPIRES_ABS_DATE": {"type": () => {return new abap.types.Date({qualifiedName: "D"});}, "is_optional": " "}, "EXPIRES_ABS_TIME": {"type": () => {return new abap.types.Time({qualifiedName: "T"});}, "is_optional": " "}, "ETAG": {"type": () => {return new abap.types.Character(32, {"qualifiedName":"CHAR32","ddicName":"CHAR32"});}, "is_optional": " "}, "BROWSER_DEPENDENT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"BOOLEAN","ddicName":"BOOLEAN"});}, "is_optional": " "}, "NO_UFO_CACHE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"BOOLEAN","ddicName":"BOOLEAN"});}, "is_optional": " "}}},
  "SERVER_CACHE_EXPIRE_DEFAULT": {"visibility": "U", "parameters": {"ETAG": {"type": () => {return new abap.types.Character(32, {"qualifiedName":"CHAR32","ddicName":"CHAR32"});}, "is_optional": " "}, "BROWSER_DEPENDENT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"BOOLEAN","ddicName":"BOOLEAN"});}, "is_optional": " "}, "NO_UFO_CACHE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"BOOLEAN","ddicName":"BOOLEAN"});}, "is_optional": " "}}},
  "SERVER_CACHE_EXPIRE_REL": {"visibility": "U", "parameters": {"EXPIRES_REL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "ETAG": {"type": () => {return new abap.types.Character(32, {"qualifiedName":"CHAR32","ddicName":"CHAR32"});}, "is_optional": " "}, "BROWSER_DEPENDENT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"BOOLEAN","ddicName":"BOOLEAN"});}, "is_optional": " "}, "NO_UFO_CACHE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"BOOLEAN","ddicName":"BOOLEAN"});}, "is_optional": " "}}}};
}
abap.Classes['IF_HTTP_RESPONSE'] = if_http_response;

//# sourceMappingURL=if_http_response.intf.mjs.map

/***/ }),

/***/ "./output/if_http_server.intf.mjs":
/*!****************************************!*\
  !*** ./output/if_http_server.intf.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_http_server": () => (/* binding */ if_http_server)
/* harmony export */ });
// if_http_server.intf.abap
class if_http_server {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"SESSION_ID": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": " ", "is_class": "X"},
  "AUTHENTICATION_METHOD": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": " ", "is_class": "X"},
  "AUTHENTICATED": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": " ", "is_class": "X"},
  "RESPONSE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_RESPONSE", RTTIName: "\\INTERFACE=IF_HTTP_RESPONSE"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "REQUEST": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_REQUEST", RTTIName: "\\INTERFACE=IF_HTTP_REQUEST"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "AUTHMETHOD_SERVICE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_COMPRESS_BASED_ON_MIME_TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_DISABLED": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_ENABLED": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_PAGE_ERROR_TYPE": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_RESPONSE_PAGE_OPTION": {"type": () => {return new abap.types.Character(1, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"LOGOFF": {"visibility": "U", "parameters": {"DELETE_MYSAPSSO2_COOKIE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "PROPAGATE_LOGOFF": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "REDIRECT_URL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_SESSION_STATEFUL": {"visibility": "U", "parameters": {"STATEFUL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "PATH": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "APPEND_FIELD_URL": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "URL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "CREATE_ABS_URL": {"visibility": "U", "parameters": {"URL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PROTOCOL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "POST": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PORT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PATH": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "QUERYSTRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "CREATE_REL_URL": {"visibility": "U", "parameters": {"URL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PATH": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "QUERYSTRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "DECODE_BASE64": {"visibility": "U", "parameters": {"DECODED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "ENCODED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "ENABLE_FOREIGN_SESSION_ACCESS": {"visibility": "U", "parameters": {"URL_PATH": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "USER_ID": {"type": () => {return new abap.types.Character(12, {"qualifiedName":"SYUNAME","ddicName":"SYUNAME"});}, "is_optional": " "}, "ONE_TIME_ACCESS_TOKEN": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "SESSION_ACCESS_TOKEN": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "ENCODE_BASE64": {"visibility": "U", "parameters": {"ENCODED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "UNENCODED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "ESCAPE_HTML": {"visibility": "U", "parameters": {"ESCAPED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "UNESCAPED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "ESCAPE_URL": {"visibility": "U", "parameters": {"ESCAPED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "UNESCAPED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_EXTENSION_INFO": {"visibility": "U", "parameters": {"EXTENSION_CLASS": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "URLS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "STRING_TABLE");}, "is_optional": " "}}},
  "GET_EXTENSION_URL": {"visibility": "U", "parameters": {"EXTENSION_CLASS": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "URLS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "STRING_TABLE");}, "is_optional": " "}}},
  "GET_LAST_ERROR": {"visibility": "U", "parameters": {"RC": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_LOCATION": {"visibility": "U", "parameters": {"URL_PART": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PROTOCOL": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "APPLICATION": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "FOR_DOMAIN": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "SERVER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_SERVER", RTTIName: "\\INTERFACE=IF_HTTP_SERVER"});}, "is_optional": " "}, "USE_TICKET_PROTOCOL": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "HOST": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PORT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "OUT_PROTOCOL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VH_SWITCH": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "GET_LOCATION_EXCEPTION": {"visibility": "U", "parameters": {"URL_PART": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PROTOCOL": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "APPLICATION": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "FOR_DOMAIN": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "SERVER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_SERVER", RTTIName: "\\INTERFACE=IF_HTTP_SERVER"});}, "is_optional": " "}, "USE_TICKET_PROTOCOL": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "HOST": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PORT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "OUT_PROTOCOL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VH_SWITCH": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "GET_XSRF_TOKEN": {"visibility": "U", "parameters": {"TOKEN": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SEND_PAGE": {"visibility": "U", "parameters": {}},
  "SET_COMPRESSION": {"visibility": "U", "parameters": {"OPTIONS": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "SET_PAGE": {"visibility": "U", "parameters": {"RESPONSE_PAGE_TYPE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"CHAR1","ddicName":"CHAR1"});}, "is_optional": " "}, "RESPONSE_OPTION": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"CHAR1","ddicName":"CHAR1"});}, "is_optional": " "}, "RESPONSE_OPTION_PAGE": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "RESPONSE_OPTION_REDIRECT_URL": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "SET_SESSION_STATEFUL_VIA_URL": {"visibility": "U", "parameters": {"STATEFUL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "REWRITE_URL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "UNESCAPE_URL": {"visibility": "U", "parameters": {"UNESCAPED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "ESCAPED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "VALIDATE_XSRF_TOKEN": {"visibility": "U", "parameters": {"TOKEN": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "SUCCESSFUL": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}}};
}
abap.Classes['IF_HTTP_SERVER'] = if_http_server;
if_http_server.if_http_server$authmethod_service = new abap.types.Integer({qualifiedName: "I"});
if_http_server.if_http_server$authmethod_service.set(4);
if_http_server.if_http_server$co_compress_based_on_mime_type = new abap.types.Integer({qualifiedName: "I"});
if_http_server.if_http_server$co_compress_based_on_mime_type.set(2);
if_http_server.if_http_server$co_disabled = new abap.types.Integer({qualifiedName: "I"});
if_http_server.if_http_server$co_disabled.set(0);
if_http_server.if_http_server$co_enabled = new abap.types.Integer({qualifiedName: "I"});
if_http_server.if_http_server$co_enabled.set(1);
if_http_server.if_http_server$co_page_error_type = new abap.types.Character(1, {});
if_http_server.if_http_server$co_page_error_type.set('1');
if_http_server.if_http_server$co_response_page_option = new abap.types.Character(1, {});
if_http_server.if_http_server$co_response_page_option.set(' ');

//# sourceMappingURL=if_http_server.intf.mjs.map

/***/ }),

/***/ "./output/if_http_utility.intf.mjs":
/*!*****************************************!*\
  !*** ./output/if_http_utility.intf.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_http_utility": () => (/* binding */ if_http_utility)
/* harmony export */ });
// if_http_utility.intf.abap
class if_http_utility {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"STRING_TO_FIELDS": {"visibility": "U", "parameters": {"FIELDS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");}, "is_optional": " "}, "STRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "IGNORE_PARENTHESIS": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_LAST_ERROR": {"visibility": "U", "parameters": {"RC": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "UNESCAPE_URL": {"visibility": "U", "parameters": {"UNESCAPED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "ESCAPED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "OPTIONS": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "ESCAPE_URL": {"visibility": "U", "parameters": {"ESCAPED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "UNESCAPED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "ENCODE_BASE64": {"visibility": "U", "parameters": {"ENCODED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "UNENCODED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "FIELDS_TO_STRING": {"visibility": "U", "parameters": {"STRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "FIELDS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP");}, "is_optional": " "}}},
  "DECODE_BASE64": {"visibility": "U", "parameters": {"DECODED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "ENCODED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "NORMALIZE_URL": {"visibility": "U", "parameters": {"NORMALIZED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "UNNORMALIZED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_HTTP_UTILITY'] = if_http_utility;

//# sourceMappingURL=if_http_utility.intf.mjs.map

/***/ }),

/***/ "./output/if_icf_tree.intf.mjs":
/*!*************************************!*\
  !*** ./output/if_icf_tree.intf.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_icf_tree": () => (/* binding */ if_icf_tree)
/* harmony export */ });
// if_icf_tree.intf.abap
class if_icf_tree {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"SERVICE_FROM_URL": {"visibility": "U", "parameters": {"URL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "HOSTNUMBER": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "AUTHORITY_CHECK": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "URLSUFFIX": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "ICFNODGUID": {"type": () => {return new abap.types.Character(25, {"qualifiedName":"CHAR25","ddicName":"CHAR25"});}, "is_optional": " "}, "ICF_NAME": {"type": () => {return new abap.types.Character(15, {"qualifiedName":"CHAR15","ddicName":"CHAR15"});}, "is_optional": " "}, "ICFACTIVE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "ICFALTNME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_ICF_TREE'] = if_icf_tree;

//# sourceMappingURL=if_icf_tree.intf.mjs.map

/***/ }),

/***/ "./output/if_ixml.intf.mjs":
/*!*********************************!*\
  !*** ./output/if_ixml.intf.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ixml": () => (/* binding */ if_ixml)
/* harmony export */ });
// if_ixml.intf.abap
class if_ixml {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"CREATE_DOCUMENT": {"visibility": "U", "parameters": {"DOC": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_DOCUMENT", RTTIName: "\\INTERFACE=IF_IXML_DOCUMENT"});}, "is_optional": " "}}},
  "CREATE_STREAM_FACTORY": {"visibility": "U", "parameters": {"STREAM": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_STREAM_FACTORY", RTTIName: "\\INTERFACE=IF_IXML_STREAM_FACTORY"});}, "is_optional": " "}}},
  "CREATE_RENDERER": {"visibility": "U", "parameters": {"RENDERER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_RENDERER", RTTIName: "\\INTERFACE=IF_IXML_RENDERER"});}, "is_optional": " "}, "OSTREAM": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_OSTREAM", RTTIName: "\\INTERFACE=IF_IXML_OSTREAM"});}, "is_optional": " "}, "DOCUMENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_DOCUMENT", RTTIName: "\\INTERFACE=IF_IXML_DOCUMENT"});}, "is_optional": " "}}},
  "CREATE_PARSER": {"visibility": "U", "parameters": {"PARSER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_PARSER", RTTIName: "\\INTERFACE=IF_IXML_PARSER"});}, "is_optional": " "}, "STREAM_FACTORY": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_STREAM_FACTORY", RTTIName: "\\INTERFACE=IF_IXML_STREAM_FACTORY"});}, "is_optional": " "}, "ISTREAM": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ISTREAM", RTTIName: "\\INTERFACE=IF_IXML_ISTREAM"});}, "is_optional": " "}, "DOCUMENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_DOCUMENT", RTTIName: "\\INTERFACE=IF_IXML_DOCUMENT"});}, "is_optional": " "}}},
  "CREATE_ENCODING": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ENCODING", RTTIName: "\\INTERFACE=IF_IXML_ENCODING"});}, "is_optional": " "}, "BYTE_ORDER": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "CHARACTER_SET": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_IXML'] = if_ixml;

//# sourceMappingURL=if_ixml.intf.mjs.map

/***/ }),

/***/ "./output/if_ixml_attribute.intf.mjs":
/*!*******************************************!*\
  !*** ./output/if_ixml_attribute.intf.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ixml_attribute": () => (/* binding */ if_ixml_attribute)
/* harmony export */ });
// if_ixml_attribute.intf.abap
class if_ixml_attribute {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"IF_IXML_NODE~CO_NODE_DOCUMENT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_IXML_NODE~CO_NODE_ELEMENT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_IXML_NODE~CO_NODE_TEXT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_IXML_NODE~CO_NODE_CDATA_SECTION": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"GET_VALUE": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_VALUE": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_NAME": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_IXML_ATTRIBUTE'] = if_ixml_attribute;

//# sourceMappingURL=if_ixml_attribute.intf.mjs.map

/***/ }),

/***/ "./output/if_ixml_document.intf.mjs":
/*!******************************************!*\
  !*** ./output/if_ixml_document.intf.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ixml_document": () => (/* binding */ if_ixml_document)
/* harmony export */ });
// if_ixml_document.intf.abap
class if_ixml_document {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"IF_IXML_NODE~CO_NODE_DOCUMENT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_IXML_NODE~CO_NODE_ELEMENT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_IXML_NODE~CO_NODE_TEXT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_IXML_NODE~CO_NODE_CDATA_SECTION": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"SET_ENCODING": {"visibility": "U", "parameters": {"ENCODING": {"type": () => {return new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});}, "is_optional": " "}}},
  "SET_STANDALONE": {"visibility": "U", "parameters": {"STANDALONE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "GET_STANDALONE": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "SET_NAMESPACE_PREFIX": {"visibility": "U", "parameters": {"PREFIX": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "APPEND_CHILD": {"visibility": "U", "parameters": {"NEW_CHILD": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}}},
  "GET_FIRST_CHILD": {"visibility": "U", "parameters": {"CHILD": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}}},
  "CREATE_ATTRIBUTE_NS": {"visibility": "U", "parameters": {"ELEMENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ATTRIBUTE", RTTIName: "\\INTERFACE=IF_IXML_ATTRIBUTE"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PREFIX": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "CREATE_ELEMENT_NS": {"visibility": "U", "parameters": {"ELEMENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ELEMENT", RTTIName: "\\INTERFACE=IF_IXML_ELEMENT"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PREFIX": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "URI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "CREATE_ELEMENT": {"visibility": "U", "parameters": {"ELEMENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ELEMENT", RTTIName: "\\INTERFACE=IF_IXML_ELEMENT"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "CREATE_ITERATOR_FILTERED": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_ITERATOR", RTTIName: "\\INTERFACE=IF_IXML_NODE_ITERATOR"});}, "is_optional": " "}, "FILTER": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "CREATE_FILTER_AND": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_FILTER", RTTIName: "\\INTERFACE=IF_IXML_NODE_FILTER"});}, "is_optional": " "}, "FILTER1": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "FILTER2": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "CREATE_ITERATOR": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_ITERATOR", RTTIName: "\\INTERFACE=IF_IXML_NODE_ITERATOR"});}, "is_optional": " "}}},
  "CREATE_FILTER_NODE_TYPE": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_FILTER", RTTIName: "\\INTERFACE=IF_IXML_NODE_FILTER"});}, "is_optional": " "}, "NODE_TYPES": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "CREATE_SIMPLE_ELEMENT_NS": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ELEMENT", RTTIName: "\\INTERFACE=IF_IXML_ELEMENT"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PARENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}, "PREFIX": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "CREATE_FILTER_ATTRIBUTE": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_FILTER", RTTIName: "\\INTERFACE=IF_IXML_NODE_FILTER"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "CREATE_SIMPLE_ELEMENT": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ELEMENT", RTTIName: "\\INTERFACE=IF_IXML_ELEMENT"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PARENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}, "VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "FIND_FROM_NAME": {"visibility": "U", "parameters": {"ELEMENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ELEMENT", RTTIName: "\\INTERFACE=IF_IXML_ELEMENT"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "DEPTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "NAMESPACE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "FIND_FROM_NAME_NS": {"visibility": "U", "parameters": {"ELEMENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ELEMENT", RTTIName: "\\INTERFACE=IF_IXML_ELEMENT"});}, "is_optional": " "}, "DEPTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "URI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "FIND_FROM_PATH": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ELEMENT", RTTIName: "\\INTERFACE=IF_IXML_ELEMENT"});}, "is_optional": " "}, "PATH": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_ELEMENTS_BY_TAG_NAME_NS": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_COLLECTION", RTTIName: "\\INTERFACE=IF_IXML_NODE_COLLECTION"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NAMESPACE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "URI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_ELEMENTS_BY_TAG_NAME": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_COLLECTION", RTTIName: "\\INTERFACE=IF_IXML_NODE_COLLECTION"});}, "is_optional": " "}, "DEPTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NAMESPACE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_ROOT": {"visibility": "U", "parameters": {"NODE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}}},
  "GET_ROOT_ELEMENT": {"visibility": "U", "parameters": {"ROOT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ELEMENT", RTTIName: "\\INTERFACE=IF_IXML_ELEMENT"});}, "is_optional": " "}}},
  "SET_DECLARATION": {"visibility": "U", "parameters": {"DECLARATION": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}}};
}
abap.Classes['IF_IXML_DOCUMENT'] = if_ixml_document;

//# sourceMappingURL=if_ixml_document.intf.mjs.map

/***/ }),

/***/ "./output/if_ixml_element.intf.mjs":
/*!*****************************************!*\
  !*** ./output/if_ixml_element.intf.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ixml_element": () => (/* binding */ if_ixml_element)
/* harmony export */ });
// if_ixml_element.intf.abap
class if_ixml_element {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"IF_IXML_NODE~CO_NODE_DOCUMENT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_IXML_NODE~CO_NODE_ELEMENT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_IXML_NODE~CO_NODE_TEXT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_IXML_NODE~CO_NODE_CDATA_SECTION": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"REMOVE_ATTRIBUTE_NS": {"visibility": "U", "parameters": {"FOO": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_ATTRIBUTES": {"visibility": "U", "parameters": {"ATTR": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NAMED_NODE_MAP", RTTIName: "\\INTERFACE=IF_IXML_NAMED_NODE_MAP"});}, "is_optional": " "}}},
  "GET_NEXT": {"visibility": "U", "parameters": {"NEXT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ELEMENT", RTTIName: "\\INTERFACE=IF_IXML_ELEMENT"});}, "is_optional": " "}}},
  "GET_NAME": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "APPEND_CHILD": {"visibility": "U", "parameters": {"RC": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "NEW_CHILD": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}}},
  "CLONE": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}}},
  "CREATE_FILTER_NODE_TYPE": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_FILTER", RTTIName: "\\INTERFACE=IF_IXML_NODE_FILTER"});}, "is_optional": " "}, "NODE_TYPES": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "CREATE_ITERATOR": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_ITERATOR", RTTIName: "\\INTERFACE=IF_IXML_NODE_ITERATOR"});}, "is_optional": " "}}},
  "FIND_FROM_NAME_NS": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ELEMENT", RTTIName: "\\INTERFACE=IF_IXML_ELEMENT"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NAMESPACE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "URI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "DEPTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "FIND_FROM_NAME": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ELEMENT", RTTIName: "\\INTERFACE=IF_IXML_ELEMENT"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NAMESPACE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "DEPTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_ATTRIBUTE_NODE": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ATTRIBUTE", RTTIName: "\\INTERFACE=IF_IXML_ATTRIBUTE"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_ATTRIBUTE_NS": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "URI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_ATTRIBUTE": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NAMESPACE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_CHILDREN": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_LIST", RTTIName: "\\INTERFACE=IF_IXML_NODE_LIST"});}, "is_optional": " "}}},
  "GET_ELEMENTS_BY_TAG_NAME": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_COLLECTION", RTTIName: "\\INTERFACE=IF_IXML_NODE_COLLECTION"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_ELEMENTS_BY_TAG_NAME_NS": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_COLLECTION", RTTIName: "\\INTERFACE=IF_IXML_NODE_COLLECTION"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "URI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_ATTRIBUTE_NODE_NS": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ATTRIBUTE", RTTIName: "\\INTERFACE=IF_IXML_ATTRIBUTE"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "URI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_FIRST_CHILD": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}}},
  "GET_VALUE": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "REMOVE_ATTRIBUTE": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "REMOVE_NODE": {"visibility": "U", "parameters": {}},
  "RENDER": {"visibility": "U", "parameters": {"OSTREAM": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_OSTREAM", RTTIName: "\\INTERFACE=IF_IXML_OSTREAM"});}, "is_optional": " "}}},
  "SET_ATTRIBUTE_NODE_NS": {"visibility": "U", "parameters": {"ATTR": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "SET_ATTRIBUTE": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NAMESPACE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_ATTRIBUTE_NS": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PREFIX": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_VALUE": {"visibility": "U", "parameters": {"RC": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_IXML_ELEMENT'] = if_ixml_element;

//# sourceMappingURL=if_ixml_element.intf.mjs.map

/***/ }),

/***/ "./output/if_ixml_encoding.intf.mjs":
/*!******************************************!*\
  !*** ./output/if_ixml_encoding.intf.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ixml_encoding": () => (/* binding */ if_ixml_encoding)
/* harmony export */ });
// if_ixml_encoding.intf.abap
class if_ixml_encoding {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"CO_NONE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_BIG_ENDIAN": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_PLATFORM_ENDIAN": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"GET_BYTE_ORDER": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_CHARACTER_SET": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_IXML_ENCODING'] = if_ixml_encoding;
if_ixml_encoding.if_ixml_encoding$co_none = new abap.types.Integer({qualifiedName: "I"});
if_ixml_encoding.if_ixml_encoding$co_none.set(0);
if_ixml_encoding.if_ixml_encoding$co_big_endian = new abap.types.Integer({qualifiedName: "I"});
if_ixml_encoding.if_ixml_encoding$co_big_endian.set(1);
if_ixml_encoding.if_ixml_encoding$co_platform_endian = new abap.types.Integer({qualifiedName: "I"});
if_ixml_encoding.if_ixml_encoding$co_platform_endian.set(4);

//# sourceMappingURL=if_ixml_encoding.intf.mjs.map

/***/ }),

/***/ "./output/if_ixml_istream.intf.mjs":
/*!*****************************************!*\
  !*** ./output/if_ixml_istream.intf.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ixml_istream": () => (/* binding */ if_ixml_istream)
/* harmony export */ });
// if_ixml_istream.intf.abap
class if_ixml_istream {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"DTD_ALLOWED": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "DTD_RESTRICTED": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "DTD_PROHIBITED": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"CLOSE": {"visibility": "U", "parameters": {}},
  "GET_DTD_RESTRICTION": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "SET_DTD_RESTRICTION": {"visibility": "U", "parameters": {"LEVEL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}}};
}
abap.Classes['IF_IXML_ISTREAM'] = if_ixml_istream;
if_ixml_istream.if_ixml_istream$dtd_allowed = new abap.types.Integer({qualifiedName: "I"});
if_ixml_istream.if_ixml_istream$dtd_allowed.set(0);
if_ixml_istream.if_ixml_istream$dtd_restricted = new abap.types.Integer({qualifiedName: "I"});
if_ixml_istream.if_ixml_istream$dtd_restricted.set(1);
if_ixml_istream.if_ixml_istream$dtd_prohibited = new abap.types.Integer({qualifiedName: "I"});
if_ixml_istream.if_ixml_istream$dtd_prohibited.set(2);

//# sourceMappingURL=if_ixml_istream.intf.mjs.map

/***/ }),

/***/ "./output/if_ixml_named_node_map.intf.mjs":
/*!************************************************!*\
  !*** ./output/if_ixml_named_node_map.intf.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ixml_named_node_map": () => (/* binding */ if_ixml_named_node_map)
/* harmony export */ });
// if_ixml_named_node_map.intf.abap
class if_ixml_named_node_map {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"CREATE_ITERATOR": {"visibility": "U", "parameters": {"ITERATOR": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_ITERATOR", RTTIName: "\\INTERFACE=IF_IXML_NODE_ITERATOR"});}, "is_optional": " "}}},
  "GET_LENGTH": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_NAMED_ITEM_NS": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_NAMED_ITEM": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_NAMED_ITEM_NS": {"visibility": "U", "parameters": {"NODE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}}},
  "REMOVE_NAMED_ITEM": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_IXML_NAMED_NODE_MAP'] = if_ixml_named_node_map;

//# sourceMappingURL=if_ixml_named_node_map.intf.mjs.map

/***/ }),

/***/ "./output/if_ixml_node.intf.mjs":
/*!**************************************!*\
  !*** ./output/if_ixml_node.intf.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ixml_node": () => (/* binding */ if_ixml_node)
/* harmony export */ });
// if_ixml_node.intf.abap
class if_ixml_node {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"CO_NODE_DOCUMENT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_NODE_ELEMENT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_NODE_TEXT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_NODE_CDATA_SECTION": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"APPEND_CHILD": {"visibility": "U", "parameters": {"NEW_CHILD": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}}},
  "GET_ATTRIBUTES": {"visibility": "U", "parameters": {"MAP": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NAMED_NODE_MAP", RTTIName: "\\INTERFACE=IF_IXML_NAMED_NODE_MAP"});}, "is_optional": " "}}},
  "GET_FIRST_CHILD": {"visibility": "U", "parameters": {"NODE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}}},
  "GET_CHILDREN": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_LIST", RTTIName: "\\INTERFACE=IF_IXML_NODE_LIST"});}, "is_optional": " "}}},
  "QUERY_INTERFACE": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_UNKNOWN", RTTIName: "\\INTERFACE=IF_IXML_UNKNOWN"});}, "is_optional": " "}, "IID": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "REMOVE_NODE": {"visibility": "U", "parameters": {}},
  "GET_PARENT": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}}},
  "REPLACE_CHILD": {"visibility": "U", "parameters": {"NEW_CHILD": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "OLD_CHILD": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_NAME": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_DEPTH": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "IS_LEAF": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "GET_NAMESPACE": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_VALUE": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_TYPE": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_NAME": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_NAMESPACE_PREFIX": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "REMOVE_CHILD": {"visibility": "U", "parameters": {"CHILD": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}}},
  "SET_VALUE": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_GID": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "INSERT_CHILD": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "NEW_CHILD": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}, "REF_CHILD": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}}},
  "GET_NEXT": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}}},
  "GET_NAMESPACE_PREFIX": {"visibility": "U", "parameters": {"RV_PREFIX": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_NAMESPACE_URI": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_HEIGHT": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "CREATE_FILTER_NAME_NS": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_FILTER", RTTIName: "\\INTERFACE=IF_IXML_NODE_FILTER"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NAMESPACE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_COLUMN": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "CREATE_ITERATOR_FILTERED": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_ITERATOR", RTTIName: "\\INTERFACE=IF_IXML_NODE_ITERATOR"});}, "is_optional": " "}, "FILTER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_FILTER", RTTIName: "\\INTERFACE=IF_IXML_NODE_FILTER"});}, "is_optional": " "}}},
  "CLONE": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}}}};
}
abap.Classes['IF_IXML_NODE'] = if_ixml_node;
if_ixml_node.if_ixml_node$co_node_document = new abap.types.Integer({qualifiedName: "I"});
if_ixml_node.if_ixml_node$co_node_document.set(1);
if_ixml_node.if_ixml_node$co_node_element = new abap.types.Integer({qualifiedName: "I"});
if_ixml_node.if_ixml_node$co_node_element.set(4);
if_ixml_node.if_ixml_node$co_node_text = new abap.types.Integer({qualifiedName: "I"});
if_ixml_node.if_ixml_node$co_node_text.set(16);
if_ixml_node.if_ixml_node$co_node_cdata_section = new abap.types.Integer({qualifiedName: "I"});
if_ixml_node.if_ixml_node$co_node_cdata_section.set(32);

//# sourceMappingURL=if_ixml_node.intf.mjs.map

/***/ }),

/***/ "./output/if_ixml_node_collection.intf.mjs":
/*!*************************************************!*\
  !*** ./output/if_ixml_node_collection.intf.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ixml_node_collection": () => (/* binding */ if_ixml_node_collection)
/* harmony export */ });
// if_ixml_node_collection.intf.abap
class if_ixml_node_collection {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"CREATE_ITERATOR": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_ITERATOR", RTTIName: "\\INTERFACE=IF_IXML_NODE_ITERATOR"});}, "is_optional": " "}}},
  "GET_LENGTH": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_ITEM": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}, "INDEX": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}}};
}
abap.Classes['IF_IXML_NODE_COLLECTION'] = if_ixml_node_collection;

//# sourceMappingURL=if_ixml_node_collection.intf.mjs.map

/***/ }),

/***/ "./output/if_ixml_node_filter.intf.mjs":
/*!*********************************************!*\
  !*** ./output/if_ixml_node_filter.intf.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ixml_node_filter": () => (/* binding */ if_ixml_node_filter)
/* harmony export */ });
// if_ixml_node_filter.intf.abap
class if_ixml_node_filter {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {};
}
abap.Classes['IF_IXML_NODE_FILTER'] = if_ixml_node_filter;

//# sourceMappingURL=if_ixml_node_filter.intf.mjs.map

/***/ }),

/***/ "./output/if_ixml_node_iterator.intf.mjs":
/*!***********************************************!*\
  !*** ./output/if_ixml_node_iterator.intf.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ixml_node_iterator": () => (/* binding */ if_ixml_node_iterator)
/* harmony export */ });
// if_ixml_node_iterator.intf.abap
class if_ixml_node_iterator {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"RESET": {"visibility": "U", "parameters": {}},
  "GET_NEXT": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}}}};
}
abap.Classes['IF_IXML_NODE_ITERATOR'] = if_ixml_node_iterator;

//# sourceMappingURL=if_ixml_node_iterator.intf.mjs.map

/***/ }),

/***/ "./output/if_ixml_node_list.intf.mjs":
/*!*******************************************!*\
  !*** ./output/if_ixml_node_list.intf.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ixml_node_list": () => (/* binding */ if_ixml_node_list)
/* harmony export */ });
// if_ixml_node_list.intf.abap
class if_ixml_node_list {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"GET_LENGTH": {"visibility": "U", "parameters": {"LENGTH": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "CREATE_ITERATOR": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_ITERATOR", RTTIName: "\\INTERFACE=IF_IXML_NODE_ITERATOR"});}, "is_optional": " "}}},
  "GET_ITEM": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}, "INDEX": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "CREATE_REV_ITERATOR_FILTERED": {"visibility": "U", "parameters": {"VAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_ITERATOR", RTTIName: "\\INTERFACE=IF_IXML_NODE_ITERATOR"});}, "is_optional": " "}, "FILTER": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}}};
}
abap.Classes['IF_IXML_NODE_LIST'] = if_ixml_node_list;

//# sourceMappingURL=if_ixml_node_list.intf.mjs.map

/***/ }),

/***/ "./output/if_ixml_ostream.intf.mjs":
/*!*****************************************!*\
  !*** ./output/if_ixml_ostream.intf.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ixml_ostream": () => (/* binding */ if_ixml_ostream)
/* harmony export */ });
// if_ixml_ostream.intf.abap
class if_ixml_ostream {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"WRITE_STRING": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "STRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_NUM_WRITTEN_RAW": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "SET_ENCODING": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"BOOLEAN","ddicName":"BOOLEAN"});}, "is_optional": " "}, "ENCODING": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ENCODING", RTTIName: "\\INTERFACE=IF_IXML_ENCODING"});}, "is_optional": " "}}},
  "SET_PRETTY_PRINT": {"visibility": "U", "parameters": {"PRETTY_PRINT": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "GET_PRETTY_PRINT": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"BOOLEAN","ddicName":"BOOLEAN"});}, "is_optional": " "}}},
  "GET_INDENT": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "SET_INDENT": {"visibility": "U", "parameters": {"INDENT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}}};
}
abap.Classes['IF_IXML_OSTREAM'] = if_ixml_ostream;

//# sourceMappingURL=if_ixml_ostream.intf.mjs.map

/***/ }),

/***/ "./output/if_ixml_parse_error.intf.mjs":
/*!*********************************************!*\
  !*** ./output/if_ixml_parse_error.intf.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ixml_parse_error": () => (/* binding */ if_ixml_parse_error)
/* harmony export */ });
// if_ixml_parse_error.intf.abap
class if_ixml_parse_error {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"GET_REASON": {"visibility": "U", "parameters": {"REASON": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_LINE": {"visibility": "U", "parameters": {"LINE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "GET_COLUMN": {"visibility": "U", "parameters": {"COLUMN": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}}};
}
abap.Classes['IF_IXML_PARSE_ERROR'] = if_ixml_parse_error;

//# sourceMappingURL=if_ixml_parse_error.intf.mjs.map

/***/ }),

/***/ "./output/if_ixml_parser.intf.mjs":
/*!****************************************!*\
  !*** ./output/if_ixml_parser.intf.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ixml_parser": () => (/* binding */ if_ixml_parser)
/* harmony export */ });
// if_ixml_parser.intf.abap
class if_ixml_parser {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"CO_NO_VALIDATION": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_VALIDATE_IF_DTD": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"PARSE": {"visibility": "U", "parameters": {"SUBRC": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "SET_NORMALIZING": {"visibility": "U", "parameters": {"NORMAL": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "NUM_ERRORS": {"visibility": "U", "parameters": {"ERRORS": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "ADD_STRIP_SPACE_ELEMENT": {"visibility": "U", "parameters": {}},
  "GET_ERROR": {"visibility": "U", "parameters": {"ERROR": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_PARSE_ERROR", RTTIName: "\\INTERFACE=IF_IXML_PARSE_ERROR"});}, "is_optional": " "}, "INDEX": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "SET_VALIDATING": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "MODE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}}};
}
abap.Classes['IF_IXML_PARSER'] = if_ixml_parser;
if_ixml_parser.if_ixml_parser$co_no_validation = new abap.types.Integer({qualifiedName: "I"});
if_ixml_parser.if_ixml_parser$co_no_validation.set(0);
if_ixml_parser.if_ixml_parser$co_validate_if_dtd = new abap.types.Integer({qualifiedName: "I"});
if_ixml_parser.if_ixml_parser$co_validate_if_dtd.set(2);

//# sourceMappingURL=if_ixml_parser.intf.mjs.map

/***/ }),

/***/ "./output/if_ixml_renderer.intf.mjs":
/*!******************************************!*\
  !*** ./output/if_ixml_renderer.intf.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ixml_renderer": () => (/* binding */ if_ixml_renderer)
/* harmony export */ });
// if_ixml_renderer.intf.abap
class if_ixml_renderer {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"RENDER": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "SET_NORMALIZING": {"visibility": "U", "parameters": {"NORMAL": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}}};
}
abap.Classes['IF_IXML_RENDERER'] = if_ixml_renderer;

//# sourceMappingURL=if_ixml_renderer.intf.mjs.map

/***/ }),

/***/ "./output/if_ixml_stream_factory.intf.mjs":
/*!************************************************!*\
  !*** ./output/if_ixml_stream_factory.intf.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ixml_stream_factory": () => (/* binding */ if_ixml_stream_factory)
/* harmony export */ });
// if_ixml_stream_factory.intf.abap
class if_ixml_stream_factory {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"CREATE_OSTREAM_CSTRING": {"visibility": "U", "parameters": {"STREAM": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_OSTREAM", RTTIName: "\\INTERFACE=IF_IXML_OSTREAM"});}, "is_optional": " "}, "STRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "CREATE_OSTREAM_XSTRING": {"visibility": "U", "parameters": {"STREAM": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_OSTREAM", RTTIName: "\\INTERFACE=IF_IXML_OSTREAM"});}, "is_optional": " "}, "STRING": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "CREATE_ISTREAM_STRING": {"visibility": "U", "parameters": {"STREAM": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ISTREAM", RTTIName: "\\INTERFACE=IF_IXML_ISTREAM"});}, "is_optional": " "}, "STRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "CREATE_ISTREAM_XSTRING": {"visibility": "U", "parameters": {"STREAM": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ISTREAM", RTTIName: "\\INTERFACE=IF_IXML_ISTREAM"});}, "is_optional": " "}, "STRING": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "CREATE_OSTREAM_ITABLE": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_OSTREAM", RTTIName: "\\INTERFACE=IF_IXML_OSTREAM"});}, "is_optional": " "}, "TABLE": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Character(4), {"withHeader":false,"keyType":"DEFAULT"});}, "is_optional": " "}}},
  "CREATE_ISTREAM_CSTRING": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ISTREAM", RTTIName: "\\INTERFACE=IF_IXML_ISTREAM"});}, "is_optional": " "}, "STRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_IXML_STREAM_FACTORY'] = if_ixml_stream_factory;

//# sourceMappingURL=if_ixml_stream_factory.intf.mjs.map

/***/ }),

/***/ "./output/if_ixml_unknown.intf.mjs":
/*!*****************************************!*\
  !*** ./output/if_ixml_unknown.intf.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_ixml_unknown": () => (/* binding */ if_ixml_unknown)
/* harmony export */ });
// if_ixml_unknown.intf.abap
class if_ixml_unknown {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"QUERY_INTERFACE": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_UNKNOWN", RTTIName: "\\INTERFACE=IF_IXML_UNKNOWN"});}, "is_optional": " "}, "IID": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}}};
}
abap.Classes['IF_IXML_UNKNOWN'] = if_ixml_unknown;

//# sourceMappingURL=if_ixml_unknown.intf.mjs.map

/***/ }),

/***/ "./output/if_message.intf.mjs":
/*!************************************!*\
  !*** ./output/if_message.intf.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_message": () => (/* binding */ if_message)
/* harmony export */ });
// if_message.intf.abap
class if_message {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"GET_TEXT": {"visibility": "U", "parameters": {"RESULT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_LONGTEXT": {"visibility": "U", "parameters": {"RESULT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PRESERVE_NEWLINES": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}}};
}
abap.Classes['IF_MESSAGE'] = if_message;

//# sourceMappingURL=if_message.intf.mjs.map

/***/ }),

/***/ "./output/if_mr_api.intf.mjs":
/*!***********************************!*\
  !*** ./output/if_mr_api.intf.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_mr_api": () => (/* binding */ if_mr_api)
/* harmony export */ });
// if_mr_api.intf.abap
class if_mr_api {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"GET_API": {"visibility": "U", "parameters": {"R_MR_API": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_MR_API", RTTIName: "\\INTERFACE=IF_MR_API"});}, "is_optional": " "}, "I_PREFIX": {"type": () => {return new abap.types.Character();}, "is_optional": " "}}},
  "GET": {"visibility": "U", "parameters": {"I_URL": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "I_CHECK_AUTHORITY": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "E_IS_FOLDER": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "E_CONTENT": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "E_MIME_TYPE": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "E_LOIO": {"type": () => {return new abap.types.Structure({"objtype": new abap.types.Character(1, {"qualifiedName":"SKWF_IOTY","ddicName":"SKWF_IOTY"}), "object": new abap.types.Structure({"class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SDOKOBJECT", "SDOKOBJECT", {}, {}), "class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SKWF_IO", "SKWF_IO", {}, {});}, "is_optional": " "}, "C_LANGUAGE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"LANGU","ddicName":"LANGU"});}, "is_optional": " "}}},
  "CREATE_FOLDER": {"visibility": "U", "parameters": {"I_URL": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "I_LANGUAGE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"LANGU","ddicName":"LANGU"});}, "is_optional": " "}, "I_DESCRIPTION": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "I_CHECK_AUTHORITY": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "I_SUPPRESS_PACKAGE_DIALOG": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "I_DEV_PACKAGE": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"DEVCLASS","ddicName":"DEVCLASS"});}, "is_optional": " "}, "I_GENFLAG": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "I_CORR_NUMBER": {"type": () => {return new abap.types.Character(20, {"qualifiedName":"TRKORR","ddicName":"TRKORR"});}, "is_optional": " "}, "I_FOLDER_LOIO": {"type": () => {return new abap.types.Structure({"objtype": new abap.types.Character(1, {"qualifiedName":"SKWF_IOTY","ddicName":"SKWF_IOTY"}), "object": new abap.types.Structure({"class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SDOKOBJECT", "SDOKOBJECT", {}, {}), "class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SKWF_IO", "SKWF_IO", {}, {});}, "is_optional": " "}, "I_SUPPRESS_DIALOGS": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "E_FOLDER_IO": {"type": () => {return new abap.types.Structure({"objtype": new abap.types.Character(1, {"qualifiedName":"SKWF_IOTY","ddicName":"SKWF_IOTY"}), "object": new abap.types.Structure({"class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SDOKOBJECT", "SDOKOBJECT", {}, {}), "class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SKWF_IO", "SKWF_IO", {}, {});}, "is_optional": " "}}},
  "PUT": {"visibility": "U", "parameters": {"I_URL": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "I_CONTENT": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "I_LANGUAGE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"LANGU","ddicName":"LANGU"});}, "is_optional": " "}, "I_DESCRIPTION": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "I_CHECK_AUTHORITY": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "I_SUPPRESS_PACKAGE_DIALOG": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "I_DEV_PACKAGE": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"DEVCLASS","ddicName":"DEVCLASS"});}, "is_optional": " "}, "I_GENFLAG": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "I_CORR_NUMBER": {"type": () => {return new abap.types.Character(20, {"qualifiedName":"TRKORR","ddicName":"TRKORR"});}, "is_optional": " "}, "I_NEW_LOIO": {"type": () => {return new abap.types.Structure({"objtype": new abap.types.Character(1, {"qualifiedName":"SKWF_IOTY","ddicName":"SKWF_IOTY"}), "object": new abap.types.Structure({"class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SDOKOBJECT", "SDOKOBJECT", {}, {}), "class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SKWF_IO", "SKWF_IO", {}, {});}, "is_optional": " "}, "I_SUPPRESS_DIALOGS": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "DELETE": {"visibility": "U", "parameters": {"I_URL": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "I_DELETE_CHILDREN": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "I_CHECK_AUTHORITY": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "I_CORR_NUMBER": {"type": () => {return new abap.types.Character(20, {"qualifiedName":"TRKORR","ddicName":"TRKORR"});}, "is_optional": " "}, "I_SUPPRESS_DIALOGS": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "FILE_LIST": {"visibility": "U", "parameters": {"I_URL": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "I_RECURSIVE_CALL": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "I_CHECK_AUTHORITY": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "E_FILES": {"type": () => {return abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "STRING_TABLE");}, "is_optional": " "}}},
  "PROPERTIES": {"visibility": "U", "parameters": {"I_URL": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "I_CHECK_AUTHORITY": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "E_IS_FOLDER": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "E_MIME_TYPE": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "E_NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "E_SIZE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "E_BIN_DATA": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "E_LOIO": {"type": () => {return new abap.types.Structure({"objtype": new abap.types.Character(1, {"qualifiedName":"SKWF_IOTY","ddicName":"SKWF_IOTY"}), "object": new abap.types.Structure({"class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SDOKOBJECT", "SDOKOBJECT", {}, {}), "class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SKWF_IO", "SKWF_IO", {}, {});}, "is_optional": " "}, "E_PHIO": {"type": () => {return new abap.types.Structure({"objtype": new abap.types.Character(1, {"qualifiedName":"SKWF_IOTY","ddicName":"SKWF_IOTY"}), "object": new abap.types.Structure({"class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SDOKOBJECT", "SDOKOBJECT", {}, {}), "class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SKWF_IO", "SKWF_IO", {}, {});}, "is_optional": " "}, "E_LANGUAGE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"LANGU","ddicName":"LANGU"});}, "is_optional": " "}, "E_PHIO_LAST_CHANGED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_IO_FOR_URL": {"visibility": "U", "parameters": {"I_URL": {"type": () => {return new abap.types.Character();}, "is_optional": " "}, "E_IS_FOLDER": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "E_LOIO": {"type": () => {return new abap.types.Structure({"objtype": new abap.types.Character(1, {"qualifiedName":"SKWF_IOTY","ddicName":"SKWF_IOTY"}), "object": new abap.types.Structure({"class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SDOKOBJECT", "SDOKOBJECT", {}, {}), "class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SKWF_IO", "SKWF_IO", {}, {});}, "is_optional": " "}}}};
}
abap.Classes['IF_MR_API'] = if_mr_api;

//# sourceMappingURL=if_mr_api.intf.mjs.map

/***/ }),

/***/ "./output/if_oauth2_client.intf.mjs":
/*!******************************************!*\
  !*** ./output/if_oauth2_client.intf.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_oauth2_client": () => (/* binding */ if_oauth2_client)
/* harmony export */ });
// if_oauth2_client.intf.abap
class if_oauth2_client {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"EXECUTE_CC_FLOW": {"visibility": "U", "parameters": {}},
  "SET_TOKEN": {"visibility": "U", "parameters": {"II_HTTP_CLIENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_HTTP_CLIENT", RTTIName: "\\INTERFACE=IF_HTTP_CLIENT"});}, "is_optional": " "}}}};
}
abap.Classes['IF_OAUTH2_CLIENT'] = if_oauth2_client;

//# sourceMappingURL=if_oauth2_client.intf.mjs.map

/***/ }),

/***/ "./output/if_oo_adt_classrun.intf.mjs":
/*!********************************************!*\
  !*** ./output/if_oo_adt_classrun.intf.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_oo_adt_classrun": () => (/* binding */ if_oo_adt_classrun)
/* harmony export */ });
// if_oo_adt_classrun.intf.abap
class if_oo_adt_classrun {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"MAIN": {"visibility": "U", "parameters": {"OUT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_OO_ADT_CLASSRUN_OUT", RTTIName: "\\INTERFACE=IF_OO_ADT_CLASSRUN_OUT"});}, "is_optional": " "}}}};
}
abap.Classes['IF_OO_ADT_CLASSRUN'] = if_oo_adt_classrun;

//# sourceMappingURL=if_oo_adt_classrun.intf.mjs.map

/***/ }),

/***/ "./output/if_oo_adt_classrun_out.intf.mjs":
/*!************************************************!*\
  !*** ./output/if_oo_adt_classrun_out.intf.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_oo_adt_classrun_out": () => (/* binding */ if_oo_adt_classrun_out)
/* harmony export */ });
// if_oo_adt_classrun_out.intf.abap
class if_oo_adt_classrun_out {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"WRITE": {"visibility": "U", "parameters": {"OUTPUT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_OO_ADT_CLASSRUN_OUT", RTTIName: "\\INTERFACE=IF_OO_ADT_CLASSRUN_OUT"});}, "is_optional": " "}, "DATA": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET": {"visibility": "U", "parameters": {"OUTPUT": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "DATA": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_OO_ADT_CLASSRUN_OUT'] = if_oo_adt_classrun_out;

//# sourceMappingURL=if_oo_adt_classrun_out.intf.mjs.map

/***/ }),

/***/ "./output/if_oo_clif_source.intf.mjs":
/*!*******************************************!*\
  !*** ./output/if_oo_clif_source.intf.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_oo_clif_source": () => (/* binding */ if_oo_clif_source)
/* harmony export */ });
// if_oo_clif_source.intf.abap
class if_oo_clif_source {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"GET_SOURCE": {"visibility": "U", "parameters": {"SOURCE": {"type": () => {return abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "STRING_TABLE");}, "is_optional": " "}}}};
}
abap.Classes['IF_OO_CLIF_SOURCE'] = if_oo_clif_source;

//# sourceMappingURL=if_oo_clif_source.intf.mjs.map

/***/ }),

/***/ "./output/if_osql_test_environment.intf.mjs":
/*!**************************************************!*\
  !*** ./output/if_osql_test_environment.intf.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_osql_test_environment": () => (/* binding */ if_osql_test_environment)
/* harmony export */ });
// if_osql_test_environment.intf.abap
class if_osql_test_environment {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"CLEAR_DOUBLES": {"visibility": "U", "parameters": {}},
  "DESTROY": {"visibility": "U", "parameters": {}},
  "INSERT_TEST_DATA": {"visibility": "U", "parameters": {"I_DATA": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Character(4), {"withHeader":false,"keyType":"DEFAULT"});}, "is_optional": " "}}}};
}
abap.Classes['IF_OSQL_TEST_ENVIRONMENT'] = if_osql_test_environment;if_osql_test_environment.ty_s_sobjname = new abap.types.Character(30, {"qualifiedName":"abap_compname"});
if_osql_test_environment.ty_t_sobjnames = abap.types.TableFactory.construct(new abap.types.Character(30, {"qualifiedName":"abap_compname"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "if_osql_test_environment=>ty_t_sobjnames");

//# sourceMappingURL=if_osql_test_environment.intf.mjs.map

/***/ }),

/***/ "./output/if_recipient_bcs.intf.mjs":
/*!******************************************!*\
  !*** ./output/if_recipient_bcs.intf.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_recipient_bcs": () => (/* binding */ if_recipient_bcs)
/* harmony export */ });
// if_recipient_bcs.intf.abap
class if_recipient_bcs {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {};
}
abap.Classes['IF_RECIPIENT_BCS'] = if_recipient_bcs;

//# sourceMappingURL=if_recipient_bcs.intf.mjs.map

/***/ }),

/***/ "./output/if_salv_c_aggregation.intf.mjs":
/*!***********************************************!*\
  !*** ./output/if_salv_c_aggregation.intf.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_salv_c_aggregation": () => (/* binding */ if_salv_c_aggregation)
/* harmony export */ });
// if_salv_c_aggregation.intf.abap
class if_salv_c_aggregation {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"NONE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "TOTAL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "MINIMUM": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "MAXIMUM": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "AVERAGE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {};
}
abap.Classes['IF_SALV_C_AGGREGATION'] = if_salv_c_aggregation;
if_salv_c_aggregation.if_salv_c_aggregation$none = new abap.types.Integer({qualifiedName: "I"});
if_salv_c_aggregation.if_salv_c_aggregation$none.set(0);
if_salv_c_aggregation.if_salv_c_aggregation$total = new abap.types.Integer({qualifiedName: "I"});
if_salv_c_aggregation.if_salv_c_aggregation$total.set(1);
if_salv_c_aggregation.if_salv_c_aggregation$minimum = new abap.types.Integer({qualifiedName: "I"});
if_salv_c_aggregation.if_salv_c_aggregation$minimum.set(2);
if_salv_c_aggregation.if_salv_c_aggregation$maximum = new abap.types.Integer({qualifiedName: "I"});
if_salv_c_aggregation.if_salv_c_aggregation$maximum.set(3);
if_salv_c_aggregation.if_salv_c_aggregation$average = new abap.types.Integer({qualifiedName: "I"});
if_salv_c_aggregation.if_salv_c_aggregation$average.set(4);

//# sourceMappingURL=if_salv_c_aggregation.intf.mjs.map

/***/ }),

/***/ "./output/if_salv_c_bool_sap.intf.mjs":
/*!********************************************!*\
  !*** ./output/if_salv_c_bool_sap.intf.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_salv_c_bool_sap": () => (/* binding */ if_salv_c_bool_sap)
/* harmony export */ });
// if_salv_c_bool_sap.intf.abap
class if_salv_c_bool_sap {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"TRUE_": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "FALSE_": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {};
}
abap.Classes['IF_SALV_C_BOOL_SAP'] = if_salv_c_bool_sap;
if_salv_c_bool_sap.if_salv_c_bool_sap$true_ = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
if_salv_c_bool_sap.if_salv_c_bool_sap$true_.set(abap.builtin.abap_true);
if_salv_c_bool_sap.if_salv_c_bool_sap$false_ = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
if_salv_c_bool_sap.if_salv_c_bool_sap$false_.set(abap.builtin.abap_false);

//# sourceMappingURL=if_salv_c_bool_sap.intf.mjs.map

/***/ }),

/***/ "./output/if_salv_c_selection_mode.intf.mjs":
/*!**************************************************!*\
  !*** ./output/if_salv_c_selection_mode.intf.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_salv_c_selection_mode": () => (/* binding */ if_salv_c_selection_mode)
/* harmony export */ });
// if_salv_c_selection_mode.intf.abap
class if_salv_c_selection_mode {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"CELL": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "MULTIPLE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "NONE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "ROW_COLUMN": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "SINGLE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {};
}
abap.Classes['IF_SALV_C_SELECTION_MODE'] = if_salv_c_selection_mode;
if_salv_c_selection_mode.if_salv_c_selection_mode$cell = new abap.types.Integer({qualifiedName: "I"});
if_salv_c_selection_mode.if_salv_c_selection_mode$cell.set(1);
if_salv_c_selection_mode.if_salv_c_selection_mode$multiple = new abap.types.Integer({qualifiedName: "I"});
if_salv_c_selection_mode.if_salv_c_selection_mode$multiple.set(2);
if_salv_c_selection_mode.if_salv_c_selection_mode$none = new abap.types.Integer({qualifiedName: "I"});
if_salv_c_selection_mode.if_salv_c_selection_mode$none.set(3);
if_salv_c_selection_mode.if_salv_c_selection_mode$row_column = new abap.types.Integer({qualifiedName: "I"});
if_salv_c_selection_mode.if_salv_c_selection_mode$row_column.set(4);
if_salv_c_selection_mode.if_salv_c_selection_mode$single = new abap.types.Integer({qualifiedName: "I"});
if_salv_c_selection_mode.if_salv_c_selection_mode$single.set(5);

//# sourceMappingURL=if_salv_c_selection_mode.intf.mjs.map

/***/ }),

/***/ "./output/if_sender_bcs.intf.mjs":
/*!***************************************!*\
  !*** ./output/if_sender_bcs.intf.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_sender_bcs": () => (/* binding */ if_sender_bcs)
/* harmony export */ });
// if_sender_bcs.intf.abap
class if_sender_bcs {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {};
}
abap.Classes['IF_SENDER_BCS'] = if_sender_bcs;

//# sourceMappingURL=if_sender_bcs.intf.mjs.map

/***/ }),

/***/ "./output/if_serializable_object.intf.mjs":
/*!************************************************!*\
  !*** ./output/if_serializable_object.intf.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_serializable_object": () => (/* binding */ if_serializable_object)
/* harmony export */ });
// if_serializable_object.intf.abap
class if_serializable_object {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {};
}
abap.Classes['IF_SERIALIZABLE_OBJECT'] = if_serializable_object;

//# sourceMappingURL=if_serializable_object.intf.mjs.map

/***/ }),

/***/ "./output/if_shm_build_instance.intf.mjs":
/*!***********************************************!*\
  !*** ./output/if_shm_build_instance.intf.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_shm_build_instance": () => (/* binding */ if_shm_build_instance)
/* harmony export */ });
// if_shm_build_instance.intf.abap
class if_shm_build_instance {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"BUILD": {"visibility": "U", "parameters": {"INST_NAME": {"type": () => {return new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});}, "is_optional": " "}, "INVOCATION_MODE": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_CONSTR_INVOCATION_MODE"});}, "is_optional": " "}}}};
}
abap.Classes['IF_SHM_BUILD_INSTANCE'] = if_shm_build_instance;

//# sourceMappingURL=if_shm_build_instance.intf.mjs.map

/***/ }),

/***/ "./output/if_shm_trace.intf.mjs":
/*!**************************************!*\
  !*** ./output/if_shm_trace.intf.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_shm_trace": () => (/* binding */ if_shm_trace)
/* harmony export */ });
// if_shm_trace.intf.abap
class if_shm_trace {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"VARIANT": {"type": () => {return new abap.types.Structure({"def_name": new abap.types.Character(32, {"qualifiedName":"SHMM_TRC_VARIANT_NAME","ddicName":"SHMM_TRC_VARIANT_NAME"}), "attach_for_upd": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "attach_for_read": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "free_area": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "detach_area": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "set_root": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "invalidate_inst": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "get_instance_inf": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "free_instance": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "invalidate_area": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "build": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "attach_for_write": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "get_root": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"})}, undefined, undefined, {}, {});}, "visibility": "U", "is_constant": " ", "is_class": " "}};
  static METHODS = {"TRIN_ATTACH_FOR_WRITE": {"visibility": "U", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "INST_NAME": {"type": () => {return new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"});}, "is_optional": " "}, "MODE": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_ATTACH_MODE"});}, "is_optional": " "}, "WAIT_TIME": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "TRCX_ATTACH_FOR_WRITE": {"visibility": "U", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "INST_NAME": {"type": () => {return new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"});}, "is_optional": " "}, "MODE": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_ATTACH_MODE"});}, "is_optional": " "}, "WAIT_TIME": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "CX": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});}, "is_optional": " "}}},
  "TRIN_ATTACH_FOR_UPDATE": {"visibility": "U", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "INST_NAME": {"type": () => {return new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"});}, "is_optional": " "}, "MODE": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_ATTACH_MODE"});}, "is_optional": " "}, "WAIT_TIME": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}},
  "TRCX_ATTACH_FOR_UPDATE": {"visibility": "U", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "INST_NAME": {"type": () => {return new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"});}, "is_optional": " "}, "MODE": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_ATTACH_MODE"});}, "is_optional": " "}, "WAIT_TIME": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "CX": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});}, "is_optional": " "}}},
  "TRIN_ATTACH_FOR_READ": {"visibility": "U", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "INST_NAME": {"type": () => {return new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"});}, "is_optional": " "}}},
  "TRCX_ATTACH_FOR_READ": {"visibility": "U", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "INST_NAME": {"type": () => {return new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"});}, "is_optional": " "}, "CX": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});}, "is_optional": " "}}},
  "TRIN_BUILD": {"visibility": "U", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "INST_NAME": {"type": () => {return new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});}, "is_optional": " "}}},
  "TRCX_BUILD": {"visibility": "U", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "INST_NAME": {"type": () => {return new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});}, "is_optional": " "}, "CX": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});}, "is_optional": " "}}},
  "TRIN_SET_ROOT": {"visibility": "U", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "INST_NAME": {"type": () => {return new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});}, "is_optional": " "}, "ROOT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});}, "is_optional": " "}}},
  "TRCX_SET_ROOT": {"visibility": "U", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "INST_NAME": {"type": () => {return new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});}, "is_optional": " "}, "ROOT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});}, "is_optional": " "}, "CX": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});}, "is_optional": " "}}},
  "TRIN_DETACH_AREA": {"visibility": "U", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"});}, "is_optional": " "}, "RC": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_RC"});}, "is_optional": " "}}},
  "TRIN_FREE_AREA": {"visibility": "U", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"});}, "is_optional": " "}, "TERMINATE_CHANGER": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "AFFECT_SERVER": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_AFFECT_SERVER"});}, "is_optional": " "}, "RC": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_RC"});}, "is_optional": " "}}},
  "TRIN_FREE_INSTANCE": {"visibility": "U", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "INST_NAME": {"type": () => {return new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"});}, "is_optional": " "}, "TERMINATE_CHANGER": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "AFFECT_SERVER": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_AFFECT_SERVER"});}, "is_optional": " "}, "RC": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_RC"});}, "is_optional": " "}}},
  "TRIN_GET_INSTANCE_INFOS": {"visibility": "U", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "INST_NAME": {"type": () => {return new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"});}, "is_optional": " "}, "INFOS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"client": new abap.types.Character(3, {"qualifiedName":"MANDT","ddicName":"MANDT"}), "name": new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"})}, "SHM_INST_INFO", "SHM_INST_INFO", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SHM_INST_INFOS");}, "is_optional": " "}}},
  "TRIN_INVALIDATE_AREA": {"visibility": "U", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"});}, "is_optional": " "}, "RC": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_RC"});}, "is_optional": " "}, "AFFECT_SERVER": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_AFFECT_SERVER"});}, "is_optional": " "}, "TERMINATE_CHANGER": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "TRIN_INVALIDATE_INSTANCE": {"visibility": "U", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "INST_NAME": {"type": () => {return new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"});}, "is_optional": " "}, "CLIENT": {"type": () => {return new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"});}, "is_optional": " "}, "TERMINATE_CHANGER": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}, "AFFECT_SERVER": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_AFFECT_SERVER"});}, "is_optional": " "}, "RC": {"type": () => {return new abap.types.Integer({qualifiedName: "SHM_RC"});}, "is_optional": " "}}},
  "TRIN_GET_ROOT": {"visibility": "U", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}}},
  "TRCX_GET_ROOT": {"visibility": "U", "parameters": {"AREA_NAME": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"});}, "is_optional": " "}, "CX": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});}, "is_optional": " "}}}};
}
abap.Classes['IF_SHM_TRACE'] = if_shm_trace;

//# sourceMappingURL=if_shm_trace.intf.mjs.map

/***/ }),

/***/ "./output/if_sxml.intf.mjs":
/*!*********************************!*\
  !*** ./output/if_sxml.intf.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_sxml": () => (/* binding */ if_sxml)
/* harmony export */ });
// if_sxml.intf.abap
class if_sxml {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"CO_XT_XML10": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML=>XML_STREAM_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_XT_BINARY": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML=>XML_STREAM_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_XT_XOP": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML=>XML_STREAM_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_XT_JSON": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML=>XML_STREAM_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {};
}
abap.Classes['IF_SXML'] = if_sxml;
if_sxml.if_sxml$co_xt_xml10 = new abap.types.Integer({qualifiedName: "IF_SXML=>XML_STREAM_TYPE"});
if_sxml.if_sxml$co_xt_xml10.set(1);
if_sxml.if_sxml$co_xt_binary = new abap.types.Integer({qualifiedName: "IF_SXML=>XML_STREAM_TYPE"});
if_sxml.if_sxml$co_xt_binary.set(2);
if_sxml.if_sxml$co_xt_xop = new abap.types.Integer({qualifiedName: "IF_SXML=>XML_STREAM_TYPE"});
if_sxml.if_sxml$co_xt_xop.set(3);
if_sxml.if_sxml$co_xt_json = new abap.types.Integer({qualifiedName: "IF_SXML=>XML_STREAM_TYPE"});
if_sxml.if_sxml$co_xt_json.set(4);
if_sxml.xml_stream_type = new abap.types.Integer({qualifiedName: "IF_SXML=>XML_STREAM_TYPE"});

//# sourceMappingURL=if_sxml.intf.mjs.map

/***/ }),

/***/ "./output/if_sxml_attribute.intf.mjs":
/*!*******************************************!*\
  !*** ./output/if_sxml_attribute.intf.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_sxml_attribute": () => (/* binding */ if_sxml_attribute)
/* harmony export */ });
// if_sxml_attribute.intf.abap
class if_sxml_attribute {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"QNAME": {"type": () => {return new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "namespace": new abap.types.String({qualifiedName: "STRING"})}, undefined, undefined, {}, {});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "PREFIX": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "VALUE_TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_VALUE=>VALUE_TYPE"});}, "visibility": "U", "is_constant": " ", "is_class": " "}};
  static METHODS = {"GET_VALUE": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_SXML_ATTRIBUTE'] = if_sxml_attribute;
if_sxml_attribute.attributes = abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: "IF_SXML_ATTRIBUTE", RTTIName: "\\INTERFACE=IF_SXML_ATTRIBUTE"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "if_sxml_attribute=>attributes");

//# sourceMappingURL=if_sxml_attribute.intf.mjs.map

/***/ }),

/***/ "./output/if_sxml_close_element.intf.mjs":
/*!***********************************************!*\
  !*** ./output/if_sxml_close_element.intf.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_sxml_close_element": () => (/* binding */ if_sxml_close_element)
/* harmony export */ });
// if_sxml_close_element.intf.abap
class if_sxml_close_element {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"QNAME": {"type": () => {return new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "namespace": new abap.types.String({qualifiedName: "STRING"})}, undefined, undefined, {}, {});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "IF_SXML_NODE~TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "IF_SXML_NODE~CO_NT_INITIAL": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_NODE~CO_NT_ELEMENT_OPEN": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_NODE~CO_NT_ELEMENT_CLOSE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_NODE~CO_NT_VALUE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_NODE~CO_NT_ATTRIBUTE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_NODE~CO_NT_FINAL": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {};
}
abap.Classes['IF_SXML_CLOSE_ELEMENT'] = if_sxml_close_element;

//# sourceMappingURL=if_sxml_close_element.intf.mjs.map

/***/ }),

/***/ "./output/if_sxml_named.intf.mjs":
/*!***************************************!*\
  !*** ./output/if_sxml_named.intf.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_sxml_named": () => (/* binding */ if_sxml_named)
/* harmony export */ });
// if_sxml_named.intf.abap
class if_sxml_named {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"CO_USE_DEFAULT_XMLNS": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {};
}
abap.Classes['IF_SXML_NAMED'] = if_sxml_named;
if_sxml_named.if_sxml_named$co_use_default_xmlns = new abap.types.String({qualifiedName: "STRING"});
if_sxml_named.if_sxml_named$co_use_default_xmlns.set(':');
if_sxml_named.pathnode = new abap.types.Structure({"qname": new abap.types.Structure({"name": new abap.types.String({qualifiedName: "IF_SXML_NAMED=>PATHNODE-QNAME-NAME"}), "namespace": new abap.types.String({qualifiedName: "IF_SXML_NAMED=>PATHNODE-QNAME-NAMESPACE"})}, "if_sxml_named=>pathnode-qname", undefined, {}, {}), "prefix": new abap.types.String({qualifiedName: "IF_SXML_NAMED=>PATHNODE-PREFIX"}), "child_position": new abap.types.Integer({qualifiedName: "IF_SXML_NAMED=>PATHNODE-CHILD_POSITION"})}, "if_sxml_named=>pathnode", undefined, {}, {});
if_sxml_named.path = abap.types.TableFactory.construct(new abap.types.Structure({"qname": new abap.types.Structure({"name": new abap.types.String({qualifiedName: "IF_SXML_NAMED=>PATHNODE-QNAME-NAME"}), "namespace": new abap.types.String({qualifiedName: "IF_SXML_NAMED=>PATHNODE-QNAME-NAMESPACE"})}, "if_sxml_named=>pathnode-qname", undefined, {}, {}), "prefix": new abap.types.String({qualifiedName: "IF_SXML_NAMED=>PATHNODE-PREFIX"}), "child_position": new abap.types.Integer({qualifiedName: "IF_SXML_NAMED=>PATHNODE-CHILD_POSITION"})}, "if_sxml_named=>pathnode", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "if_sxml_named=>path");
if_sxml_named.nsbinding = new abap.types.Structure({"prefix": new abap.types.String({qualifiedName: "IF_SXML_NAMED=>NSBINDING-PREFIX"}), "nsuri": new abap.types.String({qualifiedName: "IF_SXML_NAMED=>NSBINDING-NSURI"})}, "if_sxml_named=>nsbinding", undefined, {}, {});
if_sxml_named.nsbindings = abap.types.TableFactory.construct(new abap.types.Structure({"prefix": new abap.types.String({qualifiedName: "IF_SXML_NAMED=>NSBINDING-PREFIX"}), "nsuri": new abap.types.String({qualifiedName: "IF_SXML_NAMED=>NSBINDING-NSURI"})}, "if_sxml_named=>nsbinding", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"HASHED","isUnique":true,"keyFields":["PREFIX"]},"secondary":[]}, "if_sxml_named=>nsbindings");

//# sourceMappingURL=if_sxml_named.intf.mjs.map

/***/ }),

/***/ "./output/if_sxml_node.intf.mjs":
/*!**************************************!*\
  !*** ./output/if_sxml_node.intf.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_sxml_node": () => (/* binding */ if_sxml_node)
/* harmony export */ });
// if_sxml_node.intf.abap
class if_sxml_node {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "CO_NT_INITIAL": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_NT_ELEMENT_OPEN": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_NT_ELEMENT_CLOSE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_NT_VALUE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_NT_ATTRIBUTE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_NT_FINAL": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {};
}
abap.Classes['IF_SXML_NODE'] = if_sxml_node;
if_sxml_node.if_sxml_node$co_nt_initial = new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});
if_sxml_node.if_sxml_node$co_nt_initial.set(0);
if_sxml_node.if_sxml_node$co_nt_element_open = new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});
if_sxml_node.if_sxml_node$co_nt_element_open.set(1);
if_sxml_node.if_sxml_node$co_nt_element_close = new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});
if_sxml_node.if_sxml_node$co_nt_element_close.set(2);
if_sxml_node.if_sxml_node$co_nt_value = new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});
if_sxml_node.if_sxml_node$co_nt_value.set(4);
if_sxml_node.if_sxml_node$co_nt_attribute = new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});
if_sxml_node.if_sxml_node$co_nt_attribute.set(32);
if_sxml_node.if_sxml_node$co_nt_final = new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});
if_sxml_node.if_sxml_node$co_nt_final.set(128);
if_sxml_node.node_type = new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});

//# sourceMappingURL=if_sxml_node.intf.mjs.map

/***/ }),

/***/ "./output/if_sxml_open_element.intf.mjs":
/*!**********************************************!*\
  !*** ./output/if_sxml_open_element.intf.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_sxml_open_element": () => (/* binding */ if_sxml_open_element)
/* harmony export */ });
// if_sxml_open_element.intf.abap
class if_sxml_open_element {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"QNAME": {"type": () => {return new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "namespace": new abap.types.String({qualifiedName: "STRING"})}, undefined, undefined, {}, {});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "PREFIX": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "IF_SXML_NODE~TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "IF_SXML_NODE~CO_NT_INITIAL": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_NODE~CO_NT_ELEMENT_OPEN": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_NODE~CO_NT_ELEMENT_CLOSE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_NODE~CO_NT_VALUE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_NODE~CO_NT_ATTRIBUTE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_NODE~CO_NT_FINAL": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"GET_ATTRIBUTES": {"visibility": "U", "parameters": {"ATTR": {"type": () => {return abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: "IF_SXML_ATTRIBUTE", RTTIName: "\\INTERFACE=IF_SXML_ATTRIBUTE"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "if_sxml_attribute=>attributes");}, "is_optional": " "}}},
  "SET_ATTRIBUTE": {"visibility": "U", "parameters": {"ATTRIBUTE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_SXML_ATTRIBUTE", RTTIName: "\\INTERFACE=IF_SXML_ATTRIBUTE"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NSURI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PREFIX": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_ATTRIBUTES": {"visibility": "U", "parameters": {"ATTRIBUTES": {"type": () => {return abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: "IF_SXML_ATTRIBUTE", RTTIName: "\\INTERFACE=IF_SXML_ATTRIBUTE"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "if_sxml_attribute=>attributes");}, "is_optional": " "}}},
  "SET_PREFIX": {"visibility": "U", "parameters": {"PREFIX": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_ATTRIBUTE_VALUE": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_SXML_VALUE", RTTIName: "\\INTERFACE=IF_SXML_VALUE"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NSURI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_SXML_OPEN_ELEMENT'] = if_sxml_open_element;

//# sourceMappingURL=if_sxml_open_element.intf.mjs.map

/***/ }),

/***/ "./output/if_sxml_reader.intf.mjs":
/*!****************************************!*\
  !*** ./output/if_sxml_reader.intf.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_sxml_reader": () => (/* binding */ if_sxml_reader)
/* harmony export */ });
// if_sxml_reader.intf.abap
class if_sxml_reader {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"NODE_TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "VALUE_TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_VALUE=>VALUE_TYPE"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "VALUE_RAW": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "CO_OPT_NORMALIZING": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_OPT_KEEP_WHITESPACE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_OPT_ASXML": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_OPT_SEP_MEMBER": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"READ_NEXT_NODE": {"visibility": "U", "parameters": {"NODE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_SXML_NODE", RTTIName: "\\INTERFACE=IF_SXML_NODE"});}, "is_optional": " "}}},
  "NEXT_NODE": {"visibility": "U", "parameters": {"VALUE_TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_VALUE=>VALUE_TYPE"});}, "is_optional": " "}}},
  "NEXT_ATTRIBUTE": {"visibility": "U", "parameters": {"VALUE_TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_VALUE=>VALUE_TYPE"});}, "is_optional": " "}}},
  "SKIP_NODE": {"visibility": "U", "parameters": {"WRITER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_SXML_WRITER", RTTIName: "\\INTERFACE=IF_SXML_WRITER"});}, "is_optional": " "}}},
  "SET_OPTION": {"visibility": "U", "parameters": {"OPTION": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "VALUE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "GET_NSURI_BY_PREFIX": {"visibility": "U", "parameters": {"NSURI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PREFIX": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_PREFIX_BY_NSURI": {"visibility": "U", "parameters": {"PREFIX": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NSURI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_NSBINDINGS": {"visibility": "U", "parameters": {"NSBINDINGS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"prefix": new abap.types.String({qualifiedName: "IF_SXML_NAMED=>NSBINDING-PREFIX"}), "nsuri": new abap.types.String({qualifiedName: "IF_SXML_NAMED=>NSBINDING-NSURI"})}, "if_sxml_named=>nsbinding", undefined, {}, {}), {"withHeader":false,"keyType":"USER","primaryKey":{"name":"primary_key","type":"HASHED","isUnique":true,"keyFields":["PREFIX"]},"secondary":[]}, "if_sxml_named=>nsbindings");}, "is_optional": " "}}},
  "GET_PATH": {"visibility": "U", "parameters": {"PATH": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"qname": new abap.types.Structure({"name": new abap.types.String({qualifiedName: "IF_SXML_NAMED=>PATHNODE-QNAME-NAME"}), "namespace": new abap.types.String({qualifiedName: "IF_SXML_NAMED=>PATHNODE-QNAME-NAMESPACE"})}, "if_sxml_named=>pathnode-qname", undefined, {}, {}), "prefix": new abap.types.String({qualifiedName: "IF_SXML_NAMED=>PATHNODE-PREFIX"}), "child_position": new abap.types.Integer({qualifiedName: "IF_SXML_NAMED=>PATHNODE-CHILD_POSITION"})}, "if_sxml_named=>pathnode", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "if_sxml_named=>path");}, "is_optional": " "}}},
  "CURRENT_NODE": {"visibility": "U", "parameters": {}},
  "READ_CURRENT_NODE": {"visibility": "U", "parameters": {"NODE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_SXML_NODE", RTTIName: "\\INTERFACE=IF_SXML_NODE"});}, "is_optional": " "}}}};
}
abap.Classes['IF_SXML_READER'] = if_sxml_reader;
if_sxml_reader.if_sxml_reader$co_opt_normalizing = new abap.types.Integer({qualifiedName: "I"});
if_sxml_reader.if_sxml_reader$co_opt_normalizing.set(1);
if_sxml_reader.if_sxml_reader$co_opt_keep_whitespace = new abap.types.Integer({qualifiedName: "I"});
if_sxml_reader.if_sxml_reader$co_opt_keep_whitespace.set(2);
if_sxml_reader.if_sxml_reader$co_opt_asxml = new abap.types.Integer({qualifiedName: "I"});
if_sxml_reader.if_sxml_reader$co_opt_asxml.set(3);
if_sxml_reader.if_sxml_reader$co_opt_sep_member = new abap.types.Integer({qualifiedName: "I"});
if_sxml_reader.if_sxml_reader$co_opt_sep_member.set(4);

//# sourceMappingURL=if_sxml_reader.intf.mjs.map

/***/ }),

/***/ "./output/if_sxml_value.intf.mjs":
/*!***************************************!*\
  !*** ./output/if_sxml_value.intf.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_sxml_value": () => (/* binding */ if_sxml_value)
/* harmony export */ });
// if_sxml_value.intf.abap
class if_sxml_value {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_VALUE=>VALUE_TYPE"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "CO_VT_TEXT": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_VALUE=>VALUE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"GET_VALUE": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_VALUE_RAW": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "SET_VALUE": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_VALUE_RAW": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_SXML_VALUE'] = if_sxml_value;
if_sxml_value.if_sxml_value$co_vt_text = new abap.types.Integer({qualifiedName: "IF_SXML_VALUE=>VALUE_TYPE"});
if_sxml_value.if_sxml_value$co_vt_text.set(2);
if_sxml_value.value_type = new abap.types.Integer({qualifiedName: "IF_SXML_VALUE=>VALUE_TYPE"});

//# sourceMappingURL=if_sxml_value.intf.mjs.map

/***/ }),

/***/ "./output/if_sxml_value_node.intf.mjs":
/*!********************************************!*\
  !*** ./output/if_sxml_value_node.intf.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_sxml_value_node": () => (/* binding */ if_sxml_value_node)
/* harmony export */ });
// if_sxml_value_node.intf.abap
class if_sxml_value_node {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"IF_SXML_NODE~TYPE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "IF_SXML_NODE~CO_NT_INITIAL": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_NODE~CO_NT_ELEMENT_OPEN": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_NODE~CO_NT_ELEMENT_CLOSE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_NODE~CO_NT_VALUE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_NODE~CO_NT_ATTRIBUTE": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_SXML_NODE~CO_NT_FINAL": {"type": () => {return new abap.types.Integer({qualifiedName: "IF_SXML_NODE=>NODE_TYPE"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"GET_VALUE": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "GET_VALUE_RAW": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "SET_VALUE": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_VALUE_RAW": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_SXML_VALUE_NODE'] = if_sxml_value_node;

//# sourceMappingURL=if_sxml_value_node.intf.mjs.map

/***/ }),

/***/ "./output/if_sxml_writer.intf.mjs":
/*!****************************************!*\
  !*** ./output/if_sxml_writer.intf.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_sxml_writer": () => (/* binding */ if_sxml_writer)
/* harmony export */ });
// if_sxml_writer.intf.abap
class if_sxml_writer {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"CO_OPT_NORMALIZING": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_OPT_NO_EMPTY": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_OPT_IGNORE_CONV_ERRROS": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_OPT_LINEBREAKS": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_OPT_INDENT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_OPT_ILLEGAL_CHAR_REJECT": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_OPT_ILLEGAL_CHAR_REPLACE": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_OPT_ILLEGAL_CHAR_REPLACE_BY": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "CO_OPT_BASE64_NO_LF": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"OPEN_ELEMENT": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NSURI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PREFIX": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "CLOSE_ELEMENT": {"visibility": "U", "parameters": {}},
  "NEW_CLOSE_ELEMENT": {"visibility": "U", "parameters": {"ELEMENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_SXML_CLOSE_ELEMENT", RTTIName: "\\INTERFACE=IF_SXML_CLOSE_ELEMENT"});}, "is_optional": " "}}},
  "WRITE_ATTRIBUTE": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NSURI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PREFIX": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "WRITE_ATTRIBUTE_RAW": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NSURI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PREFIX": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "VALUE": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "WRITE_VALUE": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SET_OPTION": {"visibility": "U", "parameters": {"OPTION": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "VALUE": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});}, "is_optional": " "}}},
  "NEW_OPEN_ELEMENT": {"visibility": "U", "parameters": {"ELEMENT": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_SXML_OPEN_ELEMENT", RTTIName: "\\INTERFACE=IF_SXML_OPEN_ELEMENT"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NSURI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PREFIX": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "NEW_VALUE": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_SXML_VALUE_NODE", RTTIName: "\\INTERFACE=IF_SXML_VALUE_NODE"});}, "is_optional": " "}}},
  "WRITE_NAMESPACE_DECLARATION": {"visibility": "U", "parameters": {"NSURI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PREFIX": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "WRITE_NODE": {"visibility": "U", "parameters": {"NODE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_SXML_NODE", RTTIName: "\\INTERFACE=IF_SXML_NODE"});}, "is_optional": " "}}},
  "WRITE_VALUE_RAW": {"visibility": "U", "parameters": {"VALUE": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_SXML_WRITER'] = if_sxml_writer;
if_sxml_writer.if_sxml_writer$co_opt_normalizing = new abap.types.Integer({qualifiedName: "I"});
if_sxml_writer.if_sxml_writer$co_opt_normalizing.set(1);
if_sxml_writer.if_sxml_writer$co_opt_no_empty = new abap.types.Integer({qualifiedName: "I"});
if_sxml_writer.if_sxml_writer$co_opt_no_empty.set(2);
if_sxml_writer.if_sxml_writer$co_opt_ignore_conv_errros = new abap.types.Integer({qualifiedName: "I"});
if_sxml_writer.if_sxml_writer$co_opt_ignore_conv_errros.set(3);
if_sxml_writer.if_sxml_writer$co_opt_linebreaks = new abap.types.Integer({qualifiedName: "I"});
if_sxml_writer.if_sxml_writer$co_opt_linebreaks.set(4);
if_sxml_writer.if_sxml_writer$co_opt_indent = new abap.types.Integer({qualifiedName: "I"});
if_sxml_writer.if_sxml_writer$co_opt_indent.set(5);
if_sxml_writer.if_sxml_writer$co_opt_illegal_char_reject = new abap.types.Integer({qualifiedName: "I"});
if_sxml_writer.if_sxml_writer$co_opt_illegal_char_reject.set(6);
if_sxml_writer.if_sxml_writer$co_opt_illegal_char_replace = new abap.types.Integer({qualifiedName: "I"});
if_sxml_writer.if_sxml_writer$co_opt_illegal_char_replace.set(7);
if_sxml_writer.if_sxml_writer$co_opt_illegal_char_replace_by = new abap.types.Integer({qualifiedName: "I"});
if_sxml_writer.if_sxml_writer$co_opt_illegal_char_replace_by.set(8);
if_sxml_writer.if_sxml_writer$co_opt_base64_no_lf = new abap.types.Integer({qualifiedName: "I"});
if_sxml_writer.if_sxml_writer$co_opt_base64_no_lf.set(9);

//# sourceMappingURL=if_sxml_writer.intf.mjs.map

/***/ }),

/***/ "./output/if_sxmlp_factory.intf.mjs":
/*!******************************************!*\
  !*** ./output/if_sxmlp_factory.intf.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_sxmlp_factory": () => (/* binding */ if_sxmlp_factory)
/* harmony export */ });
// if_sxmlp_factory.intf.abap
class if_sxmlp_factory {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"CREATE_LIST": {"visibility": "U", "parameters": {"RVAL": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_SXMLP_LIST", RTTIName: "\\INTERFACE=IF_SXMLP_LIST"});}, "is_optional": " "}, "NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "NSURI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PREFIX": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
}
abap.Classes['IF_SXMLP_FACTORY'] = if_sxmlp_factory;

//# sourceMappingURL=if_sxmlp_factory.intf.mjs.map

/***/ }),

/***/ "./output/if_sxmlp_list.intf.mjs":
/*!***************************************!*\
  !*** ./output/if_sxmlp_list.intf.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_sxmlp_list": () => (/* binding */ if_sxmlp_list)
/* harmony export */ });
// if_sxmlp_list.intf.abap
class if_sxmlp_list {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"ADD_PART": {"visibility": "U", "parameters": {"PART": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_SXMLP_PART", RTTIName: "\\INTERFACE=IF_SXMLP_PART"});}, "is_optional": " "}}}};
}
abap.Classes['IF_SXMLP_LIST'] = if_sxmlp_list;

//# sourceMappingURL=if_sxmlp_list.intf.mjs.map

/***/ }),

/***/ "./output/if_sxmlp_part.intf.mjs":
/*!***************************************!*\
  !*** ./output/if_sxmlp_part.intf.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_sxmlp_part": () => (/* binding */ if_sxmlp_part)
/* harmony export */ });
// if_sxmlp_part.intf.abap
class if_sxmlp_part {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"SERIALIZE": {"visibility": "U", "parameters": {"WRITER": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_SXML_WRITER", RTTIName: "\\INTERFACE=IF_SXML_WRITER"});}, "is_optional": " "}}}};
}
abap.Classes['IF_SXMLP_PART'] = if_sxmlp_part;

//# sourceMappingURL=if_sxmlp_part.intf.mjs.map

/***/ }),

/***/ "./output/if_sxmlp_simple.intf.mjs":
/*!*****************************************!*\
  !*** ./output/if_sxmlp_simple.intf.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_sxmlp_simple": () => (/* binding */ if_sxmlp_simple)
/* harmony export */ });
// if_sxmlp_simple.intf.abap
class if_sxmlp_simple {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {};
}
abap.Classes['IF_SXMLP_SIMPLE'] = if_sxmlp_simple;

//# sourceMappingURL=if_sxmlp_simple.intf.mjs.map

/***/ }),

/***/ "./output/if_system_uuid_rfc4122_static.intf.mjs":
/*!*******************************************************!*\
  !*** ./output/if_system_uuid_rfc4122_static.intf.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_system_uuid_rfc4122_static": () => (/* binding */ if_system_uuid_rfc4122_static)
/* harmony export */ });
// if_system_uuid_rfc4122_static.intf.abap
class if_system_uuid_rfc4122_static {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"CREATE_UUID_C36_BY_VERSION": {"visibility": "U", "parameters": {"UUID": {"type": () => {return new abap.types.Character(36, {"qualifiedName":"SYSUUID_C36","ddicName":"SYSUUID_C36"});}, "is_optional": " "}, "VERSION": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}}}};
}
abap.Classes['IF_SYSTEM_UUID_RFC4122_STATIC'] = if_system_uuid_rfc4122_static;

//# sourceMappingURL=if_system_uuid_rfc4122_static.intf.mjs.map

/***/ }),

/***/ "./output/if_system_uuid_static.intf.mjs":
/*!***********************************************!*\
  !*** ./output/if_system_uuid_static.intf.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_system_uuid_static": () => (/* binding */ if_system_uuid_static)
/* harmony export */ });
// if_system_uuid_static.intf.abap
class if_system_uuid_static {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {};
  static METHODS = {"CREATE_UUID_X16": {"visibility": "U", "parameters": {"UUID": {"type": () => {return new abap.types.Hex({length: 16});}, "is_optional": " "}}},
  "CREATE_UUID_C32": {"visibility": "U", "parameters": {"UUID": {"type": () => {return new abap.types.Character(32, {"qualifiedName":"SYSUUID_C32","ddicName":"SYSUUID_C32"});}, "is_optional": " "}}},
  "CREATE_UUID_C22": {"visibility": "U", "parameters": {"UUID": {"type": () => {return new abap.types.Character(22, {"qualifiedName":"SYSUUID_C22","ddicName":"SYSUUID_C22"});}, "is_optional": " "}}}};
}
abap.Classes['IF_SYSTEM_UUID_STATIC'] = if_system_uuid_static;

//# sourceMappingURL=if_system_uuid_static.intf.mjs.map

/***/ }),

/***/ "./output/if_t100_dyn_msg.intf.mjs":
/*!*****************************************!*\
  !*** ./output/if_t100_dyn_msg.intf.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_t100_dyn_msg": () => (/* binding */ if_t100_dyn_msg)
/* harmony export */ });
// if_t100_dyn_msg.intf.abap
class if_t100_dyn_msg {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"MSGTY": {"type": () => {return new abap.types.Character(1, {"qualifiedName":"SYMSGTY","ddicName":"SYMSGTY"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "MSGV1": {"type": () => {return new abap.types.Character(50, {"qualifiedName":"SYMSGV","ddicName":"SYMSGV"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "MSGV2": {"type": () => {return new abap.types.Character(50, {"qualifiedName":"SYMSGV","ddicName":"SYMSGV"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "MSGV3": {"type": () => {return new abap.types.Character(50, {"qualifiedName":"SYMSGV","ddicName":"SYMSGV"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "MSGV4": {"type": () => {return new abap.types.Character(50, {"qualifiedName":"SYMSGV","ddicName":"SYMSGV"});}, "visibility": "U", "is_constant": " ", "is_class": " "}};
  static METHODS = {};
}
abap.Classes['IF_T100_DYN_MSG'] = if_t100_dyn_msg;

//# sourceMappingURL=if_t100_dyn_msg.intf.mjs.map

/***/ }),

/***/ "./output/if_t100_message.intf.mjs":
/*!*****************************************!*\
  !*** ./output/if_t100_message.intf.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "if_t100_message": () => (/* binding */ if_t100_message)
/* harmony export */ });
// if_t100_message.intf.abap
class if_t100_message {
  static INTERNAL_TYPE = 'INTF';
  static ATTRIBUTES = {"T100KEY": {"type": () => {return new abap.types.Structure({"msgid": new abap.types.Character(20, {}), "msgno": new abap.types.Numc({length: 3}), "attr1": new abap.types.Character(255, {}), "attr2": new abap.types.Character(255, {}), "attr3": new abap.types.Character(255, {}), "attr4": new abap.types.Character(255, {})}, "SCX_T100KEY", "SCX_T100KEY", {}, {});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "DEFAULT_TEXTID": {"type": () => {return new abap.types.Structure({"msgid": new abap.types.Character(20, {"qualifiedName":"SYMSGID","ddicName":"SYMSGID"}), "msgno": new abap.types.Numc({length: 3, qualifiedName: "SYMSGNO"}), "attr1": new abap.types.String({qualifiedName: "SCX_ATTRNAME"}), "attr2": new abap.types.String({qualifiedName: "SCX_ATTRNAME"}), "attr3": new abap.types.String({qualifiedName: "SCX_ATTRNAME"}), "attr4": new abap.types.String({qualifiedName: "SCX_ATTRNAME"})}, undefined, undefined, {}, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {};
}
abap.Classes['IF_T100_MESSAGE'] = if_t100_message;
if_t100_message.if_t100_message$default_textid = new abap.types.Structure({"msgid": new abap.types.Character(20, {"qualifiedName":"SYMSGID","ddicName":"SYMSGID"}), "msgno": new abap.types.Numc({length: 3, qualifiedName: "SYMSGNO"}), "attr1": new abap.types.String({qualifiedName: "SCX_ATTRNAME"}), "attr2": new abap.types.String({qualifiedName: "SCX_ATTRNAME"}), "attr3": new abap.types.String({qualifiedName: "SCX_ATTRNAME"}), "attr4": new abap.types.String({qualifiedName: "SCX_ATTRNAME"})}, undefined, undefined, {}, {});
if_t100_message.if_t100_message$default_textid.get().msgid.set('AB');
if_t100_message.if_t100_message$default_textid.get().msgno.set('123');
if_t100_message.if_t100_message$default_textid.get().attr1.set('');
if_t100_message.if_t100_message$default_textid.get().attr2.set('');
if_t100_message.if_t100_message$default_textid.get().attr3.set('');
if_t100_message.if_t100_message$default_textid.get().attr4.set('');

//# sourceMappingURL=if_t100_message.intf.mjs.map

/***/ }),

/***/ "./output/ihttpnvp.tabl.mjs":
/*!**********************************!*\
  !*** ./output/ihttpnvp.tabl.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["IHTTPNVP"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/int1.dtel.mjs":
/*!******************************!*\
  !*** ./output/int1.dtel.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["INT1"] = {
  "objectType": "DTEL",
  "type": new abap.types.Integer({qualifiedName: "INT1"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/int2.dtel.mjs":
/*!******************************!*\
  !*** ./output/int2.dtel.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["INT2"] = {
  "objectType": "DTEL",
  "type": new abap.types.Integer({qualifiedName: "INT2"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/int4.dtel.mjs":
/*!******************************!*\
  !*** ./output/int4.dtel.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["INT4"] = {
  "objectType": "DTEL",
  "type": new abap.types.Integer({qualifiedName: "INT4"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/kernel_authority_check.clas.mjs":
/*!************************************************!*\
  !*** ./output/kernel_authority_check.clas.mjs ***!
  \************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "kernel_authority_check": () => (/* binding */ kernel_authority_check)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// kernel_authority_check.clas.abap
class kernel_authority_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'KERNEL_AUTHORITY_CHECK';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"CALL": {"visibility": "U", "parameters": {}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async call() {
    return kernel_authority_check.call();
  }
  static async call() {
    abap.builtin.sy.get().subrc.set(abap.IntegerFactory.get(0));
  }
}
abap.Classes['KERNEL_AUTHORITY_CHECK'] = kernel_authority_check;

//# sourceMappingURL=kernel_authority_check.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/kernel_call.clas.mjs":
/*!*************************************!*\
  !*** ./output/kernel_call.clas.mjs ***!
  \*************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "kernel_call": () => (/* binding */ kernel_call)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// kernel_call.clas.abap
class kernel_call {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'KERNEL_CALL';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"CALL": {"visibility": "U", "parameters": {"INPUT": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async call(INPUT) {
    return kernel_call.call(INPUT);
  }
  static async call(INPUT) {
    let input = INPUT?.input;
    let uuid = new abap.types.Hex({length: 16});
    let name = new abap.types.String({qualifiedName: "STRING"});
    name.set(INPUT.name);
    if (abap.compare.eq(name, new abap.types.Character(10).set('RFCControl'))) {
      uuid.set((await abap.Classes['CL_SYSTEM_UUID'].if_system_uuid_static$create_uuid_x16()));
      INPUT.uuid.set(uuid);
    }
  }
}
abap.Classes['KERNEL_CALL'] = kernel_call;

//# sourceMappingURL=kernel_call.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/kernel_call_transformation.clas.mjs":
/*!****************************************************!*\
  !*** ./output/kernel_call_transformation.clas.mjs ***!
  \****************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "kernel_call_transformation": () => (/* binding */ kernel_call_transformation)
/* harmony export */ });
await __webpack_require__.e(/*! import() */ "output_kernel_call_transformation_clas_locals_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./kernel_call_transformation.clas.locals.mjs */ "./output/kernel_call_transformation.clas.locals.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// kernel_call_transformation.clas.abap
class kernel_call_transformation {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'KERNEL_CALL_TRANSFORMATION';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"MI_DOC": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_DOCUMENT", RTTIName: "\\INTERFACE=IF_IXML_DOCUMENT"});}, "visibility": "I", "is_constant": " ", "is_class": "X"},
  "MS_OPTIONS": {"type": () => {return new abap.types.Structure({"initial_components": new abap.types.String({qualifiedName: "KERNEL_CALL_TRANSFORMATION=>TY_OPTIONS-INITIAL_COMPONENTS"})}, "kernel_call_transformation=>ty_options", undefined, {}, {});}, "visibility": "I", "is_constant": " ", "is_class": "X"},
  "GC_OPTIONS": {"type": () => {return new abap.types.Structure({"suppress": new abap.types.String({qualifiedName: "STRING"})}, undefined, undefined, {}, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"PARSE_XML": {"visibility": "I", "parameters": {"IV_XML": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "PARSE_OPTIONS": {"visibility": "I", "parameters": {"OPTIONS": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "CALL": {"visibility": "U", "parameters": {"NAME": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}, "OPTIONS": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.mi_doc = kernel_call_transformation.mi_doc;
    this.ms_options = kernel_call_transformation.ms_options;
    this.gc_options = kernel_call_transformation.gc_options;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async call(INPUT) {
    return kernel_call_transformation.call(INPUT);
  }
  static async call(INPUT) {
    let name = INPUT?.name;
    let options = INPUT?.options;
    let lv_name = new abap.types.String({qualifiedName: "STRING"});
    let lv_source = new abap.types.String({qualifiedName: "STRING"});
    let lv_result = new abap.types.String({qualifiedName: "STRING"});
    let result = new abap.types.DataReference(new abap.types.Character(4));
    let lt_rtab = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "value": new abap.types.DataReference(new abap.types.Character(4))}, "abap_trans_srcbind", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_trans_srcbind_tab");
    let ls_rtab = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "value": new abap.types.DataReference(new abap.types.Character(4))}, "abap_trans_srcbind", undefined, {}, {});
    let lv_type = new abap.types.String({qualifiedName: "STRING"});
    let lv_dummy = new abap.types.String({qualifiedName: "STRING"});
    let li_writer = new abap.types.ABAPObject({qualifiedName: "IF_SXML_WRITER", RTTIName: "\\INTERFACE=IF_SXML_WRITER"});
    let li_doc = new abap.types.ABAPObject({qualifiedName: "IF_IXML_DOCUMENT", RTTIName: "\\INTERFACE=IF_IXML_DOCUMENT"});
    abap.statements.clear(kernel_call_transformation.mi_doc);
    lv_name.set(INPUT.name.toUpperCase());
    abap.statements.assert(abap.compare.eq(lv_name, new abap.types.Character(2).set('ID')));
    await this.parse_options({options: options});
    if (INPUT.sourceXML?.constructor.name === "ABAPObject") this.mi_doc.set(INPUT.sourceXML);
    if (INPUT.sourceXML?.constructor.name === "String") lv_source.set(INPUT.sourceXML);
    if (abap.compare.initial(lv_source) === false) {
      if (abap.compare.eq(lv_source.getOffset({length: 1}), new abap.types.Character(1).set('<'))) {
        lv_type.set(new abap.types.Character(3).set('XML'));
        await this.parse_xml({iv_xml: lv_source});
      } else if (abap.compare.eq(lv_source.getOffset({length: 1}), new abap.types.Character(1).set('{')) || abap.compare.eq(lv_source.getOffset({length: 1}), new abap.types.Character(1).set('['))) {
        lv_type.set(new abap.types.Character(4).set('JSON'));
        kernel_call_transformation.mi_doc.set((await abap.Classes['KERNEL_JSON_TO_IXML'].build({iv_json: lv_source})));
      } else {
        const unique83 = await (new abap.Classes['CX_XSLT_FORMAT_ERROR']()).constructor_();
        unique83.EXTRA_CX = {"INTERNAL_FILENAME": "kernel_call_transformation.clas.abap","INTERNAL_LINE": 67};
        throw unique83;
      }
    }
    if (typeof INPUT.source === "object"
        && INPUT.resultXML?.constructor.name === "ABAPObject"
        && INPUT.resultXML?.qualifiedName === "IF_IXML_DOCUMENT") {
        li_doc.set(INPUT.resultXML);
        lv_dummy = INPUT.source;
    }
    if (abap.compare.initial(li_doc) === false) {
      await abap.Classes['CLAS-KERNEL_CALL_TRANSFORMATION-LCL_OBJECT_TO_IXML'].run({ii_doc: li_doc, source: lv_dummy});
      return;
    }
    if (typeof INPUT.source === "object"
        && INPUT.resultXML?.constructor.name === "ABAPObject") {
        li_writer.set(INPUT.resultXML);
        lv_dummy = INPUT.source;
    }
    if (abap.compare.initial(li_writer) === false) {
      await abap.Classes['CLAS-KERNEL_CALL_TRANSFORMATION-LCL_OBJECT_TO_SXML'].run({ii_writer: li_writer, source: lv_dummy});
      return;
    }
    if (INPUT.resultXML && INPUT.resultXML.constructor.name === "String") {
        lv_result.set("X");
        lv_dummy = INPUT.source;
    }
    if (abap.compare.eq(lv_result, abap.builtin.abap_true)) {
      lv_result.set((await abap.Classes['CLAS-KERNEL_CALL_TRANSFORMATION-LCL_OBJECT_TO_STRING'].run({is_options: kernel_call_transformation.ms_options, source: lv_dummy})));
        INPUT.resultXML.set(lv_result);
      return;
    }
    if (abap.compare.initial(lv_source) && abap.compare.initial(kernel_call_transformation.mi_doc)) {
      const unique84 = await (new abap.Classes['CX_XSLT_RUNTIME_ERROR']()).constructor_();
      unique84.EXTRA_CX = {"INTERNAL_FILENAME": "kernel_call_transformation.clas.abap","INTERNAL_LINE": 112};
      throw unique84;
    }
    if (INPUT.result.constructor.name === "Table") {
      lt_rtab = INPUT.result;
      for await (const unique85 of abap.statements.loop(lt_rtab)) {
        ls_rtab.set(unique85);
        await abap.Classes['KERNEL_IXML_XML_TO_DATA'].build({iv_name: ls_rtab.get().name, iv_ref: ls_rtab.get().value, ii_doc: kernel_call_transformation.mi_doc});
      }
    } else {
      for (const name in INPUT.result) {
          lv_name.set(name.toUpperCase());
          if (INPUT.result[name].constructor.name === "FieldSymbol") {
              result.assign(INPUT.result[name].getPointer());
            } else {
                result.assign(INPUT.result[name]);
              }
            if (abap.compare.eq(lv_type, new abap.types.Character(4).set('JSON'))) {
              await abap.Classes['KERNEL_IXML_JSON_TO_DATA'].build({iv_name: lv_name, iv_ref: result, ii_doc: kernel_call_transformation.mi_doc});
            } else {
              await abap.Classes['KERNEL_IXML_XML_TO_DATA'].build({iv_name: lv_name, iv_ref: result, ii_doc: kernel_call_transformation.mi_doc});
            }
          }
        }
      }
      async parse_options(INPUT) {
        return kernel_call_transformation.parse_options(INPUT);
      }
      static async parse_options(INPUT) {
        let options = INPUT?.options;
        let lv_name = new abap.types.String({qualifiedName: "STRING"});
        let lv_value = new abap.types.String({qualifiedName: "STRING"});
        let fs_lv_field_ = new abap.types.FieldSymbol(new abap.types.String({qualifiedName: "STRING"}));
        for (const name in INPUT.options || {}) {
            lv_name.set(name);
            lv_value.set(INPUT.options[name]);
          abap.statements.assign({component: lv_name, target: fs_lv_field_, source: kernel_call_transformation.ms_options});
          if (abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
            fs_lv_field_.set(lv_value);
          }
        }
      }
      async parse_xml(INPUT) {
        return kernel_call_transformation.parse_xml(INPUT);
      }
      static async parse_xml(INPUT) {
        let iv_xml = INPUT?.iv_xml;
        if (iv_xml?.getQualifiedName === undefined || iv_xml.getQualifiedName() !== "STRING") { iv_xml = undefined; }
        if (iv_xml === undefined) { iv_xml = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.iv_xml); }
        let li_factory = new abap.types.ABAPObject({qualifiedName: "IF_IXML_STREAM_FACTORY", RTTIName: "\\INTERFACE=IF_IXML_STREAM_FACTORY"});
        let li_istream = new abap.types.ABAPObject({qualifiedName: "IF_IXML_ISTREAM", RTTIName: "\\INTERFACE=IF_IXML_ISTREAM"});
        let li_parser = new abap.types.ABAPObject({qualifiedName: "IF_IXML_PARSER", RTTIName: "\\INTERFACE=IF_IXML_PARSER"});
        let li_ixml = new abap.types.ABAPObject({qualifiedName: "IF_IXML", RTTIName: "\\INTERFACE=IF_IXML"});
        let lv_subrc = new abap.types.Integer({qualifiedName: "I"});
        li_ixml.set((await abap.Classes['CL_IXML'].create()));
        kernel_call_transformation.mi_doc.set((await li_ixml.get().if_ixml$create_document()));
        li_factory.set((await li_ixml.get().if_ixml$create_stream_factory()));
        li_istream.set((await li_factory.get().if_ixml_stream_factory$create_istream_string({string: iv_xml})));
        li_parser.set((await li_ixml.get().if_ixml$create_parser({stream_factory: li_factory, istream: li_istream, document: kernel_call_transformation.mi_doc})));
        await li_parser.get().if_ixml_parser$add_strip_space_element();
        lv_subrc.set((await li_parser.get().if_ixml_parser$parse()));
        await li_istream.get().if_ixml_istream$close();
        abap.statements.assert(abap.compare.eq(lv_subrc, abap.IntegerFactory.get(0)));
      }
    }
    abap.Classes['KERNEL_CALL_TRANSFORMATION'] = kernel_call_transformation;
    kernel_call_transformation.mi_doc = new abap.types.ABAPObject({qualifiedName: "IF_IXML_DOCUMENT", RTTIName: "\\INTERFACE=IF_IXML_DOCUMENT"});
    kernel_call_transformation.ms_options = new abap.types.Structure({"initial_components": new abap.types.String({qualifiedName: "KERNEL_CALL_TRANSFORMATION=>TY_OPTIONS-INITIAL_COMPONENTS"})}, "kernel_call_transformation=>ty_options", undefined, {}, {});
    kernel_call_transformation.gc_options = new abap.types.Structure({"suppress": new abap.types.String({qualifiedName: "STRING"})}, undefined, undefined, {}, {});
    kernel_call_transformation.gc_options.get().suppress.set('suppress');
    kernel_call_transformation.ty_options = new abap.types.Structure({"initial_components": new abap.types.String({qualifiedName: "KERNEL_CALL_TRANSFORMATION=>TY_OPTIONS-INITIAL_COMPONENTS"})}, "kernel_call_transformation=>ty_options", undefined, {}, {});

//# sourceMappingURL=kernel_call_transformation.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/kernel_create_data_handle.clas.mjs":
/*!***************************************************!*\
  !*** ./output/kernel_create_data_handle.clas.mjs ***!
  \***************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "kernel_create_data_handle": () => (/* binding */ kernel_create_data_handle)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// kernel_create_data_handle.clas.abap
class kernel_create_data_handle {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'KERNEL_CREATE_DATA_HANDLE';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"ELEM": {"visibility": "I", "parameters": {"HANDLE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"});}, "is_optional": " "}, "DREF": {"type": () => {return new abap.types.DataReference(new abap.types.Character(4));}, "is_optional": " "}}},
  "STRUCT": {"visibility": "I", "parameters": {"HANDLE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"});}, "is_optional": " "}, "DREF": {"type": () => {return new abap.types.DataReference(new abap.types.Character(4));}, "is_optional": " "}}},
  "TABLE": {"visibility": "I", "parameters": {"HANDLE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"});}, "is_optional": " "}, "DREF": {"type": () => {return new abap.types.DataReference(new abap.types.Character(4));}, "is_optional": " "}}},
  "REF": {"visibility": "I", "parameters": {"HANDLE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"});}, "is_optional": " "}, "DREF": {"type": () => {return new abap.types.DataReference(new abap.types.Character(4));}, "is_optional": " "}}},
  "CALL": {"visibility": "U", "parameters": {"HANDLE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"});}, "is_optional": " "}, "DREF": {"type": () => {return new abap.types.DataReference(new abap.types.Character(4));}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async call(INPUT) {
    return kernel_create_data_handle.call(INPUT);
  }
  static async call(INPUT) {
    let handle = INPUT?.handle;
    if (handle?.getQualifiedName === undefined || handle.getQualifiedName() !== "CL_ABAP_DATADESCR") { handle = undefined; }
    if (handle === undefined) { handle = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}).set(INPUT.handle); }
    let dref = new abap.types.DataReference(new abap.types.Character(4));
    if (INPUT && INPUT.dref) {dref = INPUT.dref;}
    abap.statements.assert(abap.compare.initial(handle) === false);
    if (dref.constructor.name === "FieldSymbol") {
        dref = dref.getPointer();
    }
    let unique99 = handle.get().kind;
    if (abap.compare.eq(unique99, abap.Classes['CL_ABAP_TYPEDESCR'].kind_elem)) {
      await this.elem({handle: handle, dref: dref});
    } else if (abap.compare.eq(unique99, abap.Classes['CL_ABAP_TYPEDESCR'].kind_struct)) {
      await this.struct({handle: handle, dref: dref});
    } else if (abap.compare.eq(unique99, abap.Classes['CL_ABAP_TYPEDESCR'].kind_table)) {
      await this.table({handle: handle, dref: dref});
    } else if (abap.compare.eq(unique99, abap.Classes['CL_ABAP_TYPEDESCR'].kind_ref)) {
      await this.ref({handle: handle, dref: dref});
    } else {
      console.dir(handle);
      abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    }
  }
  async ref(INPUT) {
    return kernel_create_data_handle.ref(INPUT);
  }
  static async ref(INPUT) {
    let handle = INPUT?.handle;
    if (handle?.getQualifiedName === undefined || handle.getQualifiedName() !== "CL_ABAP_DATADESCR") { handle = undefined; }
    if (handle === undefined) { handle = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}).set(INPUT.handle); }
    let dref = new abap.types.DataReference(new abap.types.Character(4));
    if (INPUT && INPUT.dref) {dref = INPUT.dref;}
    let lo_ref = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_REFDESCR", RTTIName: "\\CLASS=CL_ABAP_REFDESCR"});
    let lo_data = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"});
    let field = new abap.types.DataReference(new abap.types.Character(4));
    await abap.statements.cast(lo_ref, handle);
    await abap.statements.cast(lo_data, (await lo_ref.get().get_referenced_type()));
    await this.call({handle: lo_data, dref: field});
    dref.assign(new abap.types.DataReference(field.getPointer()));
  }
  async struct(INPUT) {
    return kernel_create_data_handle.struct(INPUT);
  }
  static async struct(INPUT) {
    let handle = INPUT?.handle;
    if (handle?.getQualifiedName === undefined || handle.getQualifiedName() !== "CL_ABAP_DATADESCR") { handle = undefined; }
    if (handle === undefined) { handle = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}).set(INPUT.handle); }
    let dref = new abap.types.DataReference(new abap.types.Character(4));
    if (INPUT && INPUT.dref) {dref = INPUT.dref;}
    let lo_struct = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_STRUCTDESCR", RTTIName: "\\CLASS=CL_ABAP_STRUCTDESCR"});
    let lt_components = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_component_tab");
    let field = new abap.types.DataReference(new abap.types.Character(4));
    let lv_name = new abap.types.String({qualifiedName: "STRING"});
    let fs_ls_component_ = new abap.types.FieldSymbol(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {}));
    await abap.statements.cast(lo_struct, handle);
    lt_components.set((await lo_struct.get().get_components()));
    let obj = {};
    for await (const unique100 of abap.statements.loop(lt_components)) {
      fs_ls_component_.assign(unique100);
      await this.call({handle: (await lo_struct.get().get_component_type({p_name: fs_ls_component_.get().name})), dref: field});
      lv_name.set(abap.builtin.to_lower({val: fs_ls_component_.get().name}));
      obj[lv_name.get()] = field.getPointer();
    }
    dref.assign(new abap.types.Structure(obj));
  }
  async table(INPUT) {
    return kernel_create_data_handle.table(INPUT);
  }
  static async table(INPUT) {
    let handle = INPUT?.handle;
    if (handle?.getQualifiedName === undefined || handle.getQualifiedName() !== "CL_ABAP_DATADESCR") { handle = undefined; }
    if (handle === undefined) { handle = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}).set(INPUT.handle); }
    let dref = new abap.types.DataReference(new abap.types.Character(4));
    if (INPUT && INPUT.dref) {dref = INPUT.dref;}
    let lo_table = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TABLEDESCR", RTTIName: "\\CLASS=CL_ABAP_TABLEDESCR"});
    let lt_keys = abap.types.TableFactory.construct(new abap.types.Structure({"components": abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"})}, "abap_table_keycompdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_table_keydescr-components"), "name": new abap.types.String({qualifiedName: "NAME"}), "is_primary": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "access_kind": new abap.types.String({qualifiedName: "ACCESS_KIND"}), "is_unique": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "key_kind": new abap.types.String({qualifiedName: "KEY_KIND"})}, "abap_table_keydescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_table_keydescr_tab");
    let lv_component = new abap.types.String({qualifiedName: "STRING"});
    let field = new abap.types.DataReference(new abap.types.Character(4));
    let fs_ls_key_ = new abap.types.FieldSymbol(new abap.types.Structure({"components": abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"})}, "abap_table_keycompdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_table_keydescr-components"), "name": new abap.types.String({qualifiedName: "NAME"}), "is_primary": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "access_kind": new abap.types.String({qualifiedName: "ACCESS_KIND"}), "is_unique": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "key_kind": new abap.types.String({qualifiedName: "KEY_KIND"})}, "abap_table_keydescr", undefined, {}, {}));
    await abap.statements.cast(lo_table, handle);
    await this.call({handle: (await lo_table.get().get_table_line_type()), dref: field});
    let options = {primaryKey: undefined, keyType: "DEFAULT", withHeader: false};
    options.primaryKey = {name: "primary_key", type: "STANDARD", keyFields: [], isUnique: false};
    lt_keys.set((await lo_table.get().get_keys()));
    for await (const unique101 of abap.statements.loop(lt_keys,{where: async (I) => {return abap.compare.eq(I.is_primary, abap.builtin.abap_true);},topEquals: {"is_primary": abap.builtin.abap_true}})) {
      fs_ls_key_.assign(unique101);
      if (abap.compare.eq(fs_ls_key_.get().access_kind, abap.Classes['CL_ABAP_TABLEDESCR'].tablekind_sorted)) {
        options.primaryKey.type = "SORTED";
      } else if (abap.compare.eq(fs_ls_key_.get().access_kind, abap.Classes['CL_ABAP_TABLEDESCR'].tablekind_hashed)) {
        options.primaryKey.type = "HASHED";
      }
      if (abap.compare.eq(fs_ls_key_.get().is_unique, abap.builtin.abap_true)) {
        options.primaryKey.isUnique = true;
      }
      for await (const unique102 of abap.statements.loop(fs_ls_key_.get().components)) {
        lv_component.set(unique102);
        options.primaryKey.keyFields.push(lv_component.get().toLowerCase());
      }
    }
    dref.assign(abap.types.TableFactory.construct(field.getPointer(), options));
  }
  async elem(INPUT) {
    return kernel_create_data_handle.elem(INPUT);
  }
  static async elem(INPUT) {
    let handle = INPUT?.handle;
    if (handle?.getQualifiedName === undefined || handle.getQualifiedName() !== "CL_ABAP_DATADESCR") { handle = undefined; }
    if (handle === undefined) { handle = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}).set(INPUT.handle); }
    let dref = new abap.types.DataReference(new abap.types.Character(4));
    if (INPUT && INPUT.dref) {dref = INPUT.dref;}
    let lv_half = new abap.types.Integer({qualifiedName: "I"});
    let unique103 = handle.get().type_kind;
    if (abap.compare.eq(unique103, abap.Classes['CL_ABAP_TYPEDESCR'].typekind_float)) {
      abap.statements.createData(dref,{"typeName": "F"});
    } else if (abap.compare.eq(unique103, abap.Classes['CL_ABAP_TYPEDESCR'].typekind_string)) {
      abap.statements.createData(dref,{"typeName": "STRING"});
    } else if (abap.compare.eq(unique103, abap.Classes['CL_ABAP_TYPEDESCR'].typekind_xstring)) {
      abap.statements.createData(dref,{"typeName": "XSTRING"});
    } else if (abap.compare.eq(unique103, abap.Classes['CL_ABAP_TYPEDESCR'].typekind_int)) {
      abap.statements.createData(dref,{"typeName": "I"});
    } else if (abap.compare.eq(unique103, abap.Classes['CL_ABAP_TYPEDESCR'].typekind_date)) {
      abap.statements.createData(dref,{"typeName": "D"});
    } else if (abap.compare.eq(unique103, abap.Classes['CL_ABAP_TYPEDESCR'].typekind_hex)) {
      abap.statements.createData(dref,{"typeName": "X","length": handle.get().length});
    } else if (abap.compare.eq(unique103, abap.Classes['CL_ABAP_TYPEDESCR'].typekind_packed)) {
      abap.statements.createData(dref,{"typeName": "P","length": handle.get().length,"decimals": handle.get().decimals});
    } else if (abap.compare.eq(unique103, abap.Classes['CL_ABAP_TYPEDESCR'].typekind_char)) {
      lv_half.set(abap.operators.divide(handle.get().length,abap.IntegerFactory.get(2)));
      abap.statements.createData(dref,{"typeName": "C","length": lv_half});
      dref.getPointer().extra = {"qualifiedName": handle.get().relative_name};
    } else if (abap.compare.eq(unique103, abap.Classes['CL_ABAP_TYPEDESCR'].typekind_num)) {
      lv_half.set(abap.operators.divide(handle.get().length,abap.IntegerFactory.get(2)));
      abap.statements.createData(dref,{"typeName": "N","length": lv_half});
    } else if (abap.compare.eq(unique103, abap.Classes['CL_ABAP_TYPEDESCR'].typekind_time)) {
      abap.statements.createData(dref,{"typeName": "T"});
    } else if (abap.compare.eq(unique103, abap.Classes['CL_ABAP_TYPEDESCR'].typekind_int8)) {
      abap.statements.createData(dref,{"typeName": "INT8"});
    } else {
      console.dir(handle);
      abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    }
  }
}
abap.Classes['KERNEL_CREATE_DATA_HANDLE'] = kernel_create_data_handle;

//# sourceMappingURL=kernel_create_data_handle.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/kernel_cx_assert.clas.mjs":
/*!******************************************!*\
  !*** ./output/kernel_cx_assert.clas.mjs ***!
  \******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "kernel_cx_assert": () => (/* binding */ kernel_cx_assert)
/* harmony export */ });
const {cx_dynamic_check} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ "./output/cx_dynamic_check.clas.mjs"));
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// kernel_cx_assert.clas.abap
class kernel_cx_assert extends cx_dynamic_check {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'KERNEL_CX_ASSERT';
  static IMPLEMENTED_INTERFACES = ["IF_MESSAGE","IF_MESSAGE"];
  static ATTRIBUTES = {"ACTUAL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "EXPECTED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "MSG": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": " ", "is_class": " "}};
  static METHODS = {"CONSTRUCTOR": {"visibility": "U", "parameters": {"MSG": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "PREVIOUS": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});}, "is_optional": " "}, "EXPECTED": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "ACTUAL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    super();
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.actual = new abap.types.String({qualifiedName: "STRING"});
    this.expected = new abap.types.String({qualifiedName: "STRING"});
    this.msg = new abap.types.String({qualifiedName: "STRING"});
  }
  async constructor_(INPUT) {
    let msg = INPUT?.msg;
    if (msg?.getQualifiedName === undefined || msg.getQualifiedName() !== "STRING") { msg = undefined; }
    if (msg === undefined) { msg = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.msg); }
    let previous = new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});
    if (INPUT && INPUT.previous) {previous.set(INPUT.previous);}
    let expected = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.expected) {expected.set(INPUT.expected);}
    let actual = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.actual) {actual.set(INPUT.actual);}
    await super.constructor_({previous: previous});
    this.me.get().expected.set(expected);
    this.me.get().actual.set(actual);
    this.me.get().msg.set(msg);
    if (abap.compare.initial(this.me.get().msg)) {
      this.me.get().msg.set(new abap.types.String().set(`Unit test assertion failed`));
    }
    return this;
  }
}
abap.Classes['KERNEL_CX_ASSERT'] = kernel_cx_assert;

//# sourceMappingURL=kernel_cx_assert.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/kernel_fugr_test.clas.mjs":
/*!******************************************!*\
  !*** ./output/kernel_fugr_test.clas.mjs ***!
  \******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "kernel_fugr_test": () => (/* binding */ kernel_fugr_test)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// kernel_fugr_test.clas.abap
class kernel_fugr_test {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'KERNEL_FUGR_TEST';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
}
abap.Classes['KERNEL_FUGR_TEST'] = kernel_fugr_test;

//# sourceMappingURL=kernel_fugr_test.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/kernel_internal_name.clas.mjs":
/*!**********************************************!*\
  !*** ./output/kernel_internal_name.clas.mjs ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "kernel_internal_name": () => (/* binding */ kernel_internal_name)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// kernel_internal_name.clas.abap
class kernel_internal_name {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'KERNEL_INTERNAL_NAME';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"INTERNAL_TO_RTTI": {"visibility": "U", "parameters": {"RV_RTTI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "IV_INTERNAL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "RTTI_TO_INTERNAL": {"visibility": "U", "parameters": {"RV_INTERNAL": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "IV_RTTI": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async internal_to_rtti(INPUT) {
    return kernel_internal_name.internal_to_rtti(INPUT);
  }
  static async internal_to_rtti(INPUT) {
    let rv_rtti = new abap.types.String({qualifiedName: "STRING"});
    let iv_internal = INPUT?.iv_internal;
    if (iv_internal?.getQualifiedName === undefined || iv_internal.getQualifiedName() !== "STRING") { iv_internal = undefined; }
    if (iv_internal === undefined) { iv_internal = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.iv_internal); }
    rv_rtti.set(iv_internal);
    if (abap.compare.cp(rv_rtti, new abap.types.Character(7).set('*CLAS-*'))) {
      abap.statements.replace({target: rv_rtti, all: false, with: new abap.types.Character(12).set('\\CLASS#POOL='), of: new abap.types.Character(5).set('CLAS-')});
      abap.statements.replace({target: rv_rtti, all: false, with: new abap.types.Character(7).set('\\CLASS='), of: new abap.types.Character(1).set('-')});
      abap.statements.replace({target: rv_rtti, all: false, with: new abap.types.Character(1).set('-'), of: new abap.types.Character(1).set('#')});
    } else {
      rv_rtti.set(abap.operators.concat(new abap.types.Character(7).set('\\CLASS='),rv_rtti));
    }
    return rv_rtti;
  }
  async rtti_to_internal(INPUT) {
    return kernel_internal_name.rtti_to_internal(INPUT);
  }
  static async rtti_to_internal(INPUT) {
    let rv_internal = new abap.types.String({qualifiedName: "STRING"});
    let iv_rtti = INPUT?.iv_rtti;
    if (iv_rtti?.getQualifiedName === undefined || iv_rtti.getQualifiedName() !== "STRING") { iv_rtti = undefined; }
    if (iv_rtti === undefined) { iv_rtti = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.iv_rtti); }
    rv_internal.set(iv_rtti);
    if (abap.compare.cp(rv_internal, new abap.types.Character(8).set('\\CLASS=*'))) {
      abap.statements.replace({target: rv_internal, all: false, with: new abap.types.Character(1).set(''), of: new abap.types.Character(7).set('\\CLASS=')});
    } else if (abap.compare.cp(rv_internal, new abap.types.Character(13).set('\\CLASS-POOL=*'))) {
      abap.statements.replace({target: rv_internal, all: false, with: new abap.types.Character(5).set('CLAS-'), of: new abap.types.Character(12).set('\\CLASS-POOL=')});
      abap.statements.replace({target: rv_internal, all: false, with: new abap.types.Character(1).set('-'), of: new abap.types.Character(7).set('\\CLASS=')});
      abap.statements.replace({target: rv_internal, all: false, with: new abap.types.Character(1).set('-'), of: new abap.types.Character(11).set('\\INTERFACE=')});
    }
    return rv_internal;
  }
}
abap.Classes['KERNEL_INTERNAL_NAME'] = kernel_internal_name;

//# sourceMappingURL=kernel_internal_name.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/kernel_ixml_json_to_data.clas.mjs":
/*!**************************************************!*\
  !*** ./output/kernel_ixml_json_to_data.clas.mjs ***!
  \**************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "kernel_ixml_json_to_data": () => (/* binding */ kernel_ixml_json_to_data)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// kernel_ixml_json_to_data.clas.abap
class kernel_ixml_json_to_data {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'KERNEL_IXML_JSON_TO_DATA';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"GET_FIELD_NAME": {"visibility": "I", "parameters": {"RV_NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "II_NODE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}}},
  "TRAVERSE": {"visibility": "I", "parameters": {"II_NODE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}, "IV_REF": {"type": () => {return new abap.types.DataReference(new abap.types.Character(4));}, "is_optional": " "}}},
  "BUILD": {"visibility": "U", "parameters": {"IV_NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "IV_REF": {"type": () => {return new abap.types.DataReference(new abap.types.Character(4));}, "is_optional": " "}, "II_DOC": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_DOCUMENT", RTTIName: "\\INTERFACE=IF_IXML_DOCUMENT"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async get_field_name(INPUT) {
    return kernel_ixml_json_to_data.get_field_name(INPUT);
  }
  static async get_field_name(INPUT) {
    let rv_name = new abap.types.String({qualifiedName: "STRING"});
    let ii_node = INPUT?.ii_node;
    if (ii_node?.getQualifiedName === undefined || ii_node.getQualifiedName() !== "IF_IXML_NODE") { ii_node = undefined; }
    if (ii_node === undefined) { ii_node = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"}).set(INPUT.ii_node); }
    let li_aiterator = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_ITERATOR", RTTIName: "\\INTERFACE=IF_IXML_NODE_ITERATOR"});
    let li_anode = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});
    let attr = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NAMED_NODE_MAP", RTTIName: "\\INTERFACE=IF_IXML_NAMED_NODE_MAP"});
    attr.set((await ii_node.get().if_ixml_node$get_attributes()));
    if (abap.compare.initial(attr) === false) {
      li_aiterator.set((await attr.get().if_ixml_named_node_map$create_iterator()));
      const indexBackup1 = abap.builtin.sy.get().index.get();
      let unique86 = 1;
      while (true) {
        abap.builtin.sy.get().index.set(unique86++);
        li_anode.set((await li_aiterator.get().if_ixml_node_iterator$get_next()));
        if (abap.compare.initial(li_anode)) {
          break;
        }
        rv_name.set((await li_anode.get().if_ixml_node$get_value()));
        abap.builtin.sy.get().index.set(indexBackup1);
        return rv_name;
      }
      abap.builtin.sy.get().index.set(indexBackup1);
    }
    return rv_name;
  }
  async build(INPUT) {
    return kernel_ixml_json_to_data.build(INPUT);
  }
  static async build(INPUT) {
    let iv_name = INPUT?.iv_name;
    if (iv_name?.getQualifiedName === undefined || iv_name.getQualifiedName() !== "STRING") { iv_name = undefined; }
    if (iv_name === undefined) { iv_name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.iv_name); }
    let iv_ref = INPUT?.iv_ref;
    if (iv_ref === undefined) { iv_ref = new abap.types.DataReference(new abap.types.Character(4)).set(INPUT.iv_ref); }
    let ii_doc = INPUT?.ii_doc;
    if (ii_doc?.getQualifiedName === undefined || ii_doc.getQualifiedName() !== "IF_IXML_DOCUMENT") { ii_doc = undefined; }
    if (ii_doc === undefined) { ii_doc = new abap.types.ABAPObject({qualifiedName: "IF_IXML_DOCUMENT", RTTIName: "\\INTERFACE=IF_IXML_DOCUMENT"}).set(INPUT.ii_doc); }
    let li_first = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});
    let li_node = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});
    let lv_name = new abap.types.String({qualifiedName: "STRING"});
    let li_iterator = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_ITERATOR", RTTIName: "\\INTERFACE=IF_IXML_NODE_ITERATOR"});
    li_first.set((await (await ii_doc.get().if_ixml_document$get_root()).get().if_ixml_node$get_first_child()));
    abap.statements.assert(abap.compare.eq((await li_first.get().if_ixml_node$get_name()), new abap.types.Character(6).set('object')));
    li_iterator.set((await (await li_first.get().if_ixml_node$get_children()).get().if_ixml_node_list$create_iterator()));
    const indexBackup1 = abap.builtin.sy.get().index.get();
    let unique87 = 1;
    while (true) {
      abap.builtin.sy.get().index.set(unique87++);
      li_node.set((await li_iterator.get().if_ixml_node_iterator$get_next()));
      if (abap.compare.initial(li_node)) {
        break;
      }
      lv_name.set((await this.get_field_name({ii_node: li_node})));
      if (abap.compare.eq(lv_name, iv_name)) {
        await this.traverse({iv_ref: iv_ref, ii_node: li_node});
        abap.builtin.sy.get().index.set(indexBackup1);
        return;
      }
    }
    abap.builtin.sy.get().index.set(indexBackup1);
  }
  async traverse(INPUT) {
    return kernel_ixml_json_to_data.traverse(INPUT);
  }
  static async traverse(INPUT) {
    let ii_node = INPUT?.ii_node;
    if (ii_node?.getQualifiedName === undefined || ii_node.getQualifiedName() !== "IF_IXML_NODE") { ii_node = undefined; }
    if (ii_node === undefined) { ii_node = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"}).set(INPUT.ii_node); }
    let iv_ref = INPUT?.iv_ref;
    if (iv_ref === undefined) { iv_ref = new abap.types.DataReference(new abap.types.Character(4)).set(INPUT.iv_ref); }
    let lo_type = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});
    let li_child = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});
    let lv_name = new abap.types.String({qualifiedName: "STRING"});
    let li_iterator = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_ITERATOR", RTTIName: "\\INTERFACE=IF_IXML_NODE_ITERATOR"});
    let lv_ref = new abap.types.DataReference(new abap.types.Character(4));
    let fs_any_ = new abap.types.FieldSymbol(new abap.types.Character(4));
    let fs_field_ = new abap.types.FieldSymbol(new abap.types.Character(4));
    let fs_tab_ = new abap.types.FieldSymbol(abap.types.TableFactory.construct(new abap.types.Character(4), {"withHeader":false,"keyType":"DEFAULT"}));
    lo_type.set((await abap.Classes['CL_ABAP_TYPEDESCR'].describe_by_data({p_data: (iv_ref).dereference()})));
    let unique88 = lo_type.get().kind;
    if (abap.compare.eq(unique88, abap.Classes['CL_ABAP_TYPEDESCR'].kind_struct)) {
      abap.statements.assert(abap.compare.eq((await ii_node.get().if_ixml_node$get_name()), new abap.types.Character(6).set('object')));
      abap.statements.assign({target: fs_any_, source: (iv_ref).dereference()});
      li_iterator.set((await (await ii_node.get().if_ixml_node$get_children()).get().if_ixml_node_list$create_iterator()));
      const indexBackup1 = abap.builtin.sy.get().index.get();
      let unique89 = 1;
      while (true) {
        abap.builtin.sy.get().index.set(unique89++);
        li_child.set((await li_iterator.get().if_ixml_node_iterator$get_next()));
        if (abap.compare.initial(li_child)) {
          break;
        }
        lv_name.set((await this.get_field_name({ii_node: li_child})));
        abap.statements.assign({component: lv_name, target: fs_field_, source: fs_any_});
        if (abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
          lv_ref.assign(fs_field_.getPointer());
          await this.traverse({ii_node: li_child, iv_ref: lv_ref});
        }
      }
      abap.builtin.sy.get().index.set(indexBackup1);
    } else if (abap.compare.eq(unique88, abap.Classes['CL_ABAP_TYPEDESCR'].kind_elem)) {
      li_child.set((await ii_node.get().if_ixml_node$get_first_child()));
      abap.statements.assert(abap.compare.eq((await li_child.get().if_ixml_node$get_name()), new abap.types.Character(5).set('#text')));
      abap.statements.assign({target: fs_any_, source: (iv_ref).dereference()});
      fs_any_.set((await li_child.get().if_ixml_node$get_value()));
      if (abap.compare.eq(lo_type.get().type_kind, abap.Classes['CL_ABAP_TYPEDESCR'].typekind_char) || abap.compare.eq(lo_type.get().type_kind, abap.Classes['CL_ABAP_TYPEDESCR'].typekind_clike) || abap.compare.eq(lo_type.get().type_kind, abap.Classes['CL_ABAP_TYPEDESCR'].typekind_string)) {
        abap.statements.replace({target: fs_any_, all: true, with: new abap.types.Character(1).set('"'), of: new abap.types.Character(2).set('\\"')});
      }
    } else if (abap.compare.eq(unique88, abap.Classes['CL_ABAP_TYPEDESCR'].kind_table)) {
      abap.statements.assert(abap.compare.eq((await ii_node.get().if_ixml_node$get_name()), new abap.types.Character(5).set('array')));
      abap.statements.assign({target: fs_tab_, source: (iv_ref).dereference()});
      li_iterator.set((await (await ii_node.get().if_ixml_node$get_children()).get().if_ixml_node_list$create_iterator()));
      const indexBackup2 = abap.builtin.sy.get().index.get();
      let unique90 = 1;
      while (true) {
        abap.builtin.sy.get().index.set(unique90++);
        li_child.set((await li_iterator.get().if_ixml_node_iterator$get_next()));
        if (abap.compare.initial(li_child)) {
          break;
        }
        abap.statements.createData(lv_ref,{"likeLineOf": fs_tab_});
        abap.statements.assign({target: fs_any_, source: (lv_ref).dereference()});
        await this.traverse({ii_node: li_child, iv_ref: lv_ref});
        abap.statements.insertInternal({data: fs_any_, table: fs_tab_});
      }
      abap.builtin.sy.get().index.set(indexBackup2);
    } else {
      console.dir(lo_type.get().kind.get());
      abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
    }
  }
}
abap.Classes['KERNEL_IXML_JSON_TO_DATA'] = kernel_ixml_json_to_data;

//# sourceMappingURL=kernel_ixml_json_to_data.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/kernel_ixml_xml_to_data.clas.mjs":
/*!*************************************************!*\
  !*** ./output/kernel_ixml_xml_to_data.clas.mjs ***!
  \*************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "kernel_ixml_xml_to_data": () => (/* binding */ kernel_ixml_xml_to_data)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// kernel_ixml_xml_to_data.clas.abap
class kernel_ixml_xml_to_data {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'KERNEL_IXML_XML_TO_DATA';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"MI_HEAP": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_ELEMENT", RTTIName: "\\INTERFACE=IF_IXML_ELEMENT"});}, "visibility": "I", "is_constant": " ", "is_class": "X"}};
  static METHODS = {"TRAVERSE": {"visibility": "I", "parameters": {"II_NODE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}, "IV_REF": {"type": () => {return new abap.types.DataReference(new abap.types.Character(4));}, "is_optional": " "}}},
  "FIND_HREF_IN_HEAP": {"visibility": "I", "parameters": {"RI_NODE": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});}, "is_optional": " "}, "IV_HREF": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "BUILD": {"visibility": "U", "parameters": {"IV_NAME": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "IV_REF": {"type": () => {return new abap.types.DataReference(new abap.types.Character(4));}, "is_optional": " "}, "II_DOC": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_DOCUMENT", RTTIName: "\\INTERFACE=IF_IXML_DOCUMENT"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.mi_heap = kernel_ixml_xml_to_data.mi_heap;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async build(INPUT) {
    return kernel_ixml_xml_to_data.build(INPUT);
  }
  static async build(INPUT) {
    let iv_name = INPUT?.iv_name;
    if (iv_name?.getQualifiedName === undefined || iv_name.getQualifiedName() !== "STRING") { iv_name = undefined; }
    if (iv_name === undefined) { iv_name = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.iv_name); }
    let iv_ref = INPUT?.iv_ref;
    if (iv_ref === undefined) { iv_ref = new abap.types.DataReference(new abap.types.Character(4)).set(INPUT.iv_ref); }
    let ii_doc = INPUT?.ii_doc;
    if (ii_doc?.getQualifiedName === undefined || ii_doc.getQualifiedName() !== "IF_IXML_DOCUMENT") { ii_doc = undefined; }
    if (ii_doc === undefined) { ii_doc = new abap.types.ABAPObject({qualifiedName: "IF_IXML_DOCUMENT", RTTIName: "\\INTERFACE=IF_IXML_DOCUMENT"}).set(INPUT.ii_doc); }
    let li_first = new abap.types.ABAPObject({qualifiedName: "IF_IXML_ELEMENT", RTTIName: "\\INTERFACE=IF_IXML_ELEMENT"});
    let li_node = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});
    let lv_name = new abap.types.String({qualifiedName: "STRING"});
    let li_iterator = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_ITERATOR", RTTIName: "\\INTERFACE=IF_IXML_NODE_ITERATOR"});
    kernel_ixml_xml_to_data.mi_heap.set((await ii_doc.get().if_ixml_document$find_from_name_ns({name: new abap.types.Character(4).set('heap')})));
    await abap.statements.cast(li_first, (await (await ii_doc.get().if_ixml_document$get_root()).get().if_ixml_node$get_first_child()));
    li_node.set((await li_first.get().if_ixml_element$find_from_name_ns({name: iv_name, depth: abap.IntegerFactory.get(0), namespace: new abap.types.Character(1).set('')})));
    if (abap.compare.initial(li_node) === false) {
      await this.traverse({ii_node: li_node, iv_ref: iv_ref});
    }
  }
  async find_href_in_heap(INPUT) {
    return kernel_ixml_xml_to_data.find_href_in_heap(INPUT);
  }
  static async find_href_in_heap(INPUT) {
    let ri_node = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});
    let iv_href = new abap.types.String({qualifiedName: "STRING"});
    if (INPUT && INPUT.iv_href) {iv_href.set(INPUT.iv_href);}
    let li_iterator = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_ITERATOR", RTTIName: "\\INTERFACE=IF_IXML_NODE_ITERATOR"});
    let li_child = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});
    let lv_id = new abap.types.String({qualifiedName: "STRING"});
    abap.statements.replace({target: iv_href, all: false, with: new abap.types.Character(1).set(''), of: new abap.types.Character(1).set('#')});
    abap.statements.assert(abap.compare.initial(kernel_ixml_xml_to_data.mi_heap) === false);
    abap.statements.assert(abap.compare.initial(iv_href) === false);
    li_iterator.set((await (await kernel_ixml_xml_to_data.mi_heap.get().if_ixml_element$get_children()).get().if_ixml_node_list$create_iterator()));
    const indexBackup1 = abap.builtin.sy.get().index.get();
    let unique91 = 1;
    while (true) {
      abap.builtin.sy.get().index.set(unique91++);
      li_child.set((await li_iterator.get().if_ixml_node_iterator$get_next()));
      if (abap.compare.initial(li_child)) {
        break;
      }
      lv_id.set((await (await (await li_child.get().if_ixml_node$get_attributes()).get().if_ixml_named_node_map$get_named_item_ns({name: new abap.types.Character(2).set('id')})).get().if_ixml_node$get_value()));
      if (abap.compare.eq(lv_id, iv_href)) {
        ri_node.set(li_child);
        abap.builtin.sy.get().index.set(indexBackup1);
        return ri_node;
      }
    }
    abap.builtin.sy.get().index.set(indexBackup1);
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(17).set('not found in heap')));
    return ri_node;
  }
  async traverse(INPUT) {
    return kernel_ixml_xml_to_data.traverse(INPUT);
  }
  static async traverse(INPUT) {
    let ii_node = INPUT?.ii_node;
    if (ii_node?.getQualifiedName === undefined || ii_node.getQualifiedName() !== "IF_IXML_NODE") { ii_node = undefined; }
    if (ii_node === undefined) { ii_node = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"}).set(INPUT.ii_node); }
    let iv_ref = INPUT?.iv_ref;
    if (iv_ref === undefined) { iv_ref = new abap.types.DataReference(new abap.types.Character(4)).set(INPUT.iv_ref); }
    let lo_type = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_TYPEDESCR", RTTIName: "\\CLASS=CL_ABAP_TYPEDESCR"});
    let li_child = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});
    let li_heap = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});
    let li_iname = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});
    let lv_name = new abap.types.String({qualifiedName: "STRING"});
    let li_iterator = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE_ITERATOR", RTTIName: "\\INTERFACE=IF_IXML_NODE_ITERATOR"});
    let lv_ref = new abap.types.DataReference(new abap.types.Character(4));
    let lv_value = new abap.types.String({qualifiedName: "STRING"});
    let li_href = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});
    let fs_any_ = new abap.types.FieldSymbol(new abap.types.Character(4));
    let fs_field_ = new abap.types.FieldSymbol(new abap.types.Character(4));
    let fs_tab_ = new abap.types.FieldSymbol(abap.types.TableFactory.construct(new abap.types.Character(4), {"withHeader":false,"keyType":"DEFAULT"}));
    lo_type.set((await abap.Classes['CL_ABAP_TYPEDESCR'].describe_by_data({p_data: (iv_ref).dereference()})));
    let unique92 = lo_type.get().kind;
    if (abap.compare.eq(unique92, abap.Classes['CL_ABAP_TYPEDESCR'].kind_struct)) {
      abap.statements.assign({target: fs_any_, source: (iv_ref).dereference()});
      li_iterator.set((await (await ii_node.get().if_ixml_node$get_children()).get().if_ixml_node_list$create_iterator()));
      const indexBackup1 = abap.builtin.sy.get().index.get();
      let unique93 = 1;
      while (true) {
        abap.builtin.sy.get().index.set(unique93++);
        li_child.set((await li_iterator.get().if_ixml_node_iterator$get_next()));
        if (abap.compare.initial(li_child)) {
          break;
        }
        lv_name.set((await li_child.get().if_ixml_node$get_name()));
        abap.statements.assign({component: lv_name, target: fs_field_, source: fs_any_});
        if (abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
          lv_ref.assign(fs_field_.getPointer());
          await this.traverse({ii_node: li_child, iv_ref: lv_ref});
        }
      }
      abap.builtin.sy.get().index.set(indexBackup1);
    } else if (abap.compare.eq(unique92, abap.Classes['CL_ABAP_TYPEDESCR'].kind_elem)) {
      li_child.set((await ii_node.get().if_ixml_node$get_first_child()));
      if (abap.compare.initial(li_child) === false) {
        abap.statements.assign({target: fs_any_, source: (iv_ref).dereference()});
        fs_any_.set((await li_child.get().if_ixml_node$get_value()));
      }
    } else if (abap.compare.eq(unique92, abap.Classes['CL_ABAP_TYPEDESCR'].kind_table)) {
      abap.statements.assign({target: fs_tab_, source: (iv_ref).dereference()});
      li_iterator.set((await (await ii_node.get().if_ixml_node$get_children()).get().if_ixml_node_list$create_iterator()));
      const indexBackup2 = abap.builtin.sy.get().index.get();
      let unique94 = 1;
      while (true) {
        abap.builtin.sy.get().index.set(unique94++);
        li_child.set((await li_iterator.get().if_ixml_node_iterator$get_next()));
        if (abap.compare.initial(li_child)) {
          break;
        }
        abap.statements.createData(lv_ref,{"likeLineOf": fs_tab_});
        abap.statements.assign({target: fs_any_, source: (lv_ref).dereference()});
        await this.traverse({ii_node: li_child, iv_ref: lv_ref});
        abap.statements.insertInternal({data: fs_any_, table: fs_tab_});
      }
      abap.builtin.sy.get().index.set(indexBackup2);
    } else if (abap.compare.eq(unique92, abap.Classes['CL_ABAP_TYPEDESCR'].kind_ref)) {
      abap.statements.assign({target: fs_any_, source: (iv_ref).dereference()});
      if (abap.compare.initial(fs_any_)) {
        li_href.set((await (await ii_node.get().if_ixml_node$get_attributes()).get().if_ixml_named_node_map$get_named_item_ns({name: new abap.types.Character(4).set('href')})));
        if (abap.compare.initial(li_href)) {
          return;
        }
        lv_value.set((await li_href.get().if_ixml_node$get_value()));
        abap.statements.assert(abap.compare.initial(lv_value) === false);
        li_heap.set((await this.find_href_in_heap({iv_href: lv_value})));
        li_iname.set((await (await li_heap.get().if_ixml_node$get_attributes()).get().if_ixml_named_node_map$get_named_item_ns({name: new abap.types.Character(12).set('internalName')})));
        if (abap.compare.initial(li_iname) && abap.compare.eq(lv_value.getOffset({length: 2}), new abap.types.Character(2).set('#o'))) {
          return;
        }
        if (abap.compare.eq(lv_value.getOffset({length: 2}), new abap.types.Character(2).set('#o'))) {
          lv_value.set((await li_iname.get().if_ixml_node$get_value()));
          abap.statements.assert(abap.compare.initial(lv_value) === false);
          fs_any_.pointer.value = new abap.Classes[lv_value.get()]();
          li_iterator.set((await (await (await li_heap.get().if_ixml_node$get_first_child()).get().if_ixml_node$get_children()).get().if_ixml_node_list$create_iterator()));
          const indexBackup3 = abap.builtin.sy.get().index.get();
          let unique95 = 1;
          while (true) {
            abap.builtin.sy.get().index.set(unique95++);
            li_child.set((await li_iterator.get().if_ixml_node_iterator$get_next()));
            if (abap.compare.initial(li_child)) {
              break;
            }
            lv_name.set((await li_child.get().if_ixml_node$get_name()));
            abap.statements.replace({target: lv_name, all: false, with: new abap.types.Character(1).set('~'), of: new abap.types.Character(1).set('.')});
            abap.statements.assign({target: fs_field_, dynamicName: '<any>' + '->' + lv_name.get(), dynamicSource: (() => {
                        try { return fs_any_; } catch {}
                        try { return this.fs_any_; } catch {}
                      })()});
              if (abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
                lv_ref.assign(fs_field_.getPointer());
                await this.traverse({ii_node: li_child, iv_ref: lv_ref});
              }
            }
            abap.builtin.sy.get().index.set(indexBackup3);
          } else {
            abap.statements.createData(fs_any_);
            li_child.set((await li_heap.get().if_ixml_node$get_first_child()));
            lv_ref.assign(fs_any_.getPointer());
            await this.traverse({ii_node: li_child, iv_ref: (lv_ref).dereference()});
          }
        } else {
          abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(9).set('todo_ref2')));
        }
      } else {
        console.dir(lo_type.get().kind.get());
        abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
      }
    }
  }
  abap.Classes['KERNEL_IXML_XML_TO_DATA'] = kernel_ixml_xml_to_data;
  kernel_ixml_xml_to_data.mi_heap = new abap.types.ABAPObject({qualifiedName: "IF_IXML_ELEMENT", RTTIName: "\\INTERFACE=IF_IXML_ELEMENT"});

//# sourceMappingURL=kernel_ixml_xml_to_data.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/kernel_json_to_ixml.clas.mjs":
/*!*********************************************!*\
  !*** ./output/kernel_json_to_ixml.clas.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "kernel_json_to_ixml": () => (/* binding */ kernel_json_to_ixml)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// kernel_json_to_ixml.clas.abap
class kernel_json_to_ixml {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'KERNEL_JSON_TO_IXML';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"BUILD": {"visibility": "U", "parameters": {"RI_DOC": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "IF_IXML_DOCUMENT", RTTIName: "\\INTERFACE=IF_IXML_DOCUMENT"});}, "is_optional": " "}, "IV_JSON": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async build(INPUT) {
    return kernel_json_to_ixml.build(INPUT);
  }
  static async build(INPUT) {
    let ri_doc = new abap.types.ABAPObject({qualifiedName: "IF_IXML_DOCUMENT", RTTIName: "\\INTERFACE=IF_IXML_DOCUMENT"});
    let iv_json = INPUT?.iv_json;
    if (iv_json?.getQualifiedName === undefined || iv_json.getQualifiedName() !== "STRING") { iv_json = undefined; }
    if (iv_json === undefined) { iv_json = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.iv_json); }
    let li_reader = new abap.types.ABAPObject({qualifiedName: "IF_SXML_READER", RTTIName: "\\INTERFACE=IF_SXML_READER"});
    let li_node = new abap.types.ABAPObject({qualifiedName: "IF_SXML_NODE", RTTIName: "\\INTERFACE=IF_SXML_NODE"});
    let li_close = new abap.types.ABAPObject({qualifiedName: "IF_SXML_CLOSE_ELEMENT", RTTIName: "\\INTERFACE=IF_SXML_CLOSE_ELEMENT"});
    let li_open = new abap.types.ABAPObject({qualifiedName: "IF_SXML_OPEN_ELEMENT", RTTIName: "\\INTERFACE=IF_SXML_OPEN_ELEMENT"});
    let li_value = new abap.types.ABAPObject({qualifiedName: "IF_SXML_VALUE_NODE", RTTIName: "\\INTERFACE=IF_SXML_VALUE_NODE"});
    let lt_attributes = abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: "IF_SXML_ATTRIBUTE", RTTIName: "\\INTERFACE=IF_SXML_ATTRIBUTE"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "if_sxml_attribute=>attributes");
    let li_attribute = new abap.types.ABAPObject({qualifiedName: "IF_SXML_ATTRIBUTE", RTTIName: "\\INTERFACE=IF_SXML_ATTRIBUTE"});
    let li_current = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});
    let lv_name = new abap.types.String({qualifiedName: "STRING"});
    let li_map = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NAMED_NODE_MAP", RTTIName: "\\INTERFACE=IF_IXML_NAMED_NODE_MAP"});
    let li_new = new abap.types.ABAPObject({qualifiedName: "IF_IXML_NODE", RTTIName: "\\INTERFACE=IF_IXML_NODE"});
    let li_element = new abap.types.ABAPObject({qualifiedName: "IF_IXML_ELEMENT", RTTIName: "\\INTERFACE=IF_IXML_ELEMENT"});
    li_reader.set((await abap.Classes['CL_SXML_STRING_READER'].create({input: (await abap.Classes['CL_ABAP_CODEPAGE'].convert_to({source: iv_json}))})));
    ri_doc.set((await (await abap.Classes['CL_IXML'].create()).get().if_ixml$create_document()));
    li_current.set((await ri_doc.get().if_ixml_document$get_root()));
    const indexBackup1 = abap.builtin.sy.get().index.get();
    let unique96 = 1;
    while (true) {
      abap.builtin.sy.get().index.set(unique96++);
      li_node.set((await li_reader.get().if_sxml_reader$read_next_node()));
      if (abap.compare.initial(li_node)) {
        break;
      }
      let unique97 = li_node.get().if_sxml_node$type;
      if (abap.compare.eq(unique97, abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open)) {
        await abap.statements.cast(li_open, li_node);
        abap.statements.clear(lv_name);
        lt_attributes.set((await li_open.get().if_sxml_open_element$get_attributes()));
        for await (const unique98 of abap.statements.loop(lt_attributes)) {
          li_attribute.set(unique98);
          lv_name.set((await li_attribute.get().if_sxml_attribute$get_value()));
        }
        li_element.set((await ri_doc.get().if_ixml_document$create_element_ns({name: li_open.get().if_sxml_open_element$qname.get().name})));
        await abap.statements.cast(li_new, li_element);
        await li_current.get().if_ixml_node$append_child({new_child: li_new});
        li_current.set(li_new);
        if (abap.compare.initial(lv_name) === false) {
          li_element.set((await ri_doc.get().if_ixml_document$create_element_ns({name: new abap.types.Character(4).set('name')})));
          await abap.statements.cast(li_new, li_element);
          await li_new.get().if_ixml_node$set_value({value: lv_name});
          li_map.set((await li_current.get().if_ixml_node$get_attributes()));
          await li_map.get().if_ixml_named_node_map$set_named_item_ns({node: li_new});
        }
      } else if (abap.compare.eq(unique97, abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close)) {
        await abap.statements.cast(li_close, li_node);
        li_current.set((await li_current.get().if_ixml_node$get_parent()));
      } else if (abap.compare.eq(unique97, abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_value)) {
        await abap.statements.cast(li_value, li_node);
        li_element.set((await ri_doc.get().if_ixml_document$create_element_ns({name: new abap.types.Character(5).set('#text')})));
        await li_element.get().if_ixml_element$set_value({value: (await li_value.get().if_sxml_value_node$get_value())});
        await abap.statements.cast(li_new, li_element);
        await li_current.get().if_ixml_node$append_child({new_child: li_new});
      }
    }
    abap.builtin.sy.get().index.set(indexBackup1);
    return ri_doc;
  }
}
abap.Classes['KERNEL_JSON_TO_IXML'] = kernel_json_to_ixml;

//# sourceMappingURL=kernel_json_to_ixml.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/kernel_lock.clas.mjs":
/*!*************************************!*\
  !*** ./output/kernel_lock.clas.mjs ***!
  \*************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "kernel_lock": () => (/* binding */ kernel_lock)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// kernel_lock.clas.abap
class kernel_lock {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'KERNEL_LOCK';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"ENQUEUE": {"visibility": "U", "parameters": {"INPUT": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}},
  "DEQUEUE": {"visibility": "U", "parameters": {"INPUT": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async enqueue(INPUT) {
    return kernel_lock.enqueue(INPUT);
  }
  static async enqueue(INPUT) {
    let input = INPUT?.input;
    abap.builtin.sy.get().subrc.set(abap.IntegerFactory.get(0));
    abap.builtin.sy.get().subrc.set(0);
  }
  async dequeue(INPUT) {
    return kernel_lock.dequeue(INPUT);
  }
  static async dequeue(INPUT) {
    let input = INPUT?.input;
    abap.builtin.sy.get().subrc.set(abap.IntegerFactory.get(0));
  }
}
abap.Classes['KERNEL_LOCK'] = kernel_lock;

//# sourceMappingURL=kernel_lock.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/kernel_numberrange.clas.mjs":
/*!********************************************!*\
  !*** ./output/kernel_numberrange.clas.mjs ***!
  \********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "kernel_numberrange": () => (/* binding */ kernel_numberrange)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// kernel_numberrange.clas.abap
class kernel_numberrange {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'KERNEL_NUMBERRANGE';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"STATUS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"nr_range_nr": new abap.types.Character(2, {"qualifiedName":"cl_numberrange_runtime=>nr_interval"}), "object": new abap.types.Character(10, {"qualifiedName":"cl_numberrange_runtime=>nr_object"}), "number": new abap.types.Numc({length: 20, qualifiedName: "cl_numberrange_runtime=>nr_number"})}, "kernel_numberrange=>ty_status", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "");}, "visibility": "I", "is_constant": " ", "is_class": "X"}};
  static METHODS = {"NUMBER_GET": {"visibility": "U", "parameters": {"NR_RANGE_NR": {"type": () => {return new abap.types.Character(2, {"qualifiedName":"cl_numberrange_runtime=>nr_interval"});}, "is_optional": " "}, "OBJECT": {"type": () => {return new abap.types.Character(10, {"qualifiedName":"cl_numberrange_runtime=>nr_object"});}, "is_optional": " "}, "NUMBER": {"type": () => {return new abap.types.Numc({length: 20, qualifiedName: "cl_numberrange_runtime=>nr_number"});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.status = kernel_numberrange.status;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async number_get(INPUT) {
    return kernel_numberrange.number_get(INPUT);
  }
  static async number_get(INPUT) {
    let nr_range_nr = INPUT?.nr_range_nr;
    if (nr_range_nr?.getQualifiedName === undefined || nr_range_nr.getQualifiedName() !== "CL_NUMBERRANGE_RUNTIME=>NR_INTERVAL") { nr_range_nr = undefined; }
    if (nr_range_nr === undefined) { nr_range_nr = new abap.types.Character(2, {"qualifiedName":"cl_numberrange_runtime=>nr_interval"}).set(INPUT.nr_range_nr); }
    let object = INPUT?.object;
    if (object?.getQualifiedName === undefined || object.getQualifiedName() !== "CL_NUMBERRANGE_RUNTIME=>NR_OBJECT") { object = undefined; }
    if (object === undefined) { object = new abap.types.Character(10, {"qualifiedName":"cl_numberrange_runtime=>nr_object"}).set(INPUT.object); }
    let number = INPUT?.number || new abap.types.Numc({length: 20, qualifiedName: "cl_numberrange_runtime=>nr_number"});
    let fs_row_ = new abap.types.FieldSymbol(new abap.types.Structure({"nr_range_nr": new abap.types.Character(2, {"qualifiedName":"cl_numberrange_runtime=>nr_interval"}), "object": new abap.types.Character(10, {"qualifiedName":"cl_numberrange_runtime=>nr_object"}), "number": new abap.types.Numc({length: 20, qualifiedName: "cl_numberrange_runtime=>nr_number"})}, "kernel_numberrange=>ty_status", undefined, {}, {}));
    abap.statements.readTable(kernel_numberrange.status,{assigning: fs_row_,
      withKey: (i) => {return abap.compare.eq(i.nr_range_nr, nr_range_nr) && abap.compare.eq(i.object, object);},
      withKeyValue: [{key: (i) => {return i.nr_range_nr}, value: nr_range_nr},{key: (i) => {return i.object}, value: object}],
      usesTableLine: false,
      withKeySimple: {"nr_range_nr": nr_range_nr,"object": object}});
    if (abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))) {
      fs_row_.get().number.set(abap.operators.add(fs_row_.get().number,abap.IntegerFactory.get(1)));
    } else {
      fs_row_.assign(kernel_numberrange.status.appendInitial());
      fs_row_.get().nr_range_nr.set(nr_range_nr);
      fs_row_.get().object.set(object);
      fs_row_.get().number.set(abap.IntegerFactory.get(1));
    }
    number.set(fs_row_.get().number);
  }
}
abap.Classes['KERNEL_NUMBERRANGE'] = kernel_numberrange;
kernel_numberrange.status = abap.types.TableFactory.construct(new abap.types.Structure({"nr_range_nr": new abap.types.Character(2, {"qualifiedName":"cl_numberrange_runtime=>nr_interval"}), "object": new abap.types.Character(10, {"qualifiedName":"cl_numberrange_runtime=>nr_object"}), "number": new abap.types.Numc({length: 20, qualifiedName: "cl_numberrange_runtime=>nr_number"})}, "kernel_numberrange=>ty_status", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "");
kernel_numberrange.ty_status = new abap.types.Structure({"nr_range_nr": new abap.types.Character(2, {"qualifiedName":"cl_numberrange_runtime=>nr_interval"}), "object": new abap.types.Character(10, {"qualifiedName":"cl_numberrange_runtime=>nr_object"}), "number": new abap.types.Numc({length: 20, qualifiedName: "cl_numberrange_runtime=>nr_number"})}, "kernel_numberrange=>ty_status", undefined, {}, {});

//# sourceMappingURL=kernel_numberrange.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/kernel_push_channels.clas.mjs":
/*!**********************************************!*\
  !*** ./output/kernel_push_channels.clas.mjs ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "kernel_push_channels": () => (/* binding */ kernel_push_channels)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// kernel_push_channels.clas.abap
class kernel_push_channels {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'KERNEL_PUSH_CHANNELS';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {};
  static METHODS = {"WAIT": {"visibility": "U", "parameters": {"SECONDS": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "is_optional": " "}, "COND": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async wait(INPUT) {
    return kernel_push_channels.wait(INPUT);
  }
  static async wait(INPUT) {
    let seconds = INPUT?.seconds;
    if (seconds?.getQualifiedName === undefined || seconds.getQualifiedName() !== "I") { seconds = undefined; }
    if (seconds === undefined) { seconds = new abap.types.Integer({qualifiedName: "I"}).set(INPUT.seconds); }
    let cond = INPUT?.cond;
    let lv_seconds = new abap.types.Integer({qualifiedName: "I"});
    let lv_condition = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    lv_seconds.set(abap.operators.multiply(seconds,new abap.types.Integer().set(1000)));
    abap.statements.assert(abap.compare.gt(lv_seconds, abap.IntegerFactory.get(0)));
    const indexBackup1 = abap.builtin.sy.get().index.get();
    let unique104 = 1;
    while (abap.compare.gt(lv_seconds, abap.IntegerFactory.get(0))) {
      abap.builtin.sy.get().index.set(unique104++);
      await new Promise(resolve => setTimeout(resolve, 100));
      lv_condition = cond() ? "X" : " ";
      if (abap.compare.eq(lv_condition, abap.builtin.abap_true)) {
        abap.builtin.sy.get().subrc.set(abap.IntegerFactory.get(0));
        abap.builtin.sy.get().index.set(indexBackup1);
        return;
      }
      lv_seconds.set(abap.operators.minus(lv_seconds,abap.IntegerFactory.get(100)));
    }
    abap.builtin.sy.get().index.set(indexBackup1);
    abap.builtin.sy.get().subrc.set(abap.IntegerFactory.get(4));
  }
}
abap.Classes['KERNEL_PUSH_CHANNELS'] = kernel_push_channels;

//# sourceMappingURL=kernel_push_channels.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/kernel_scan_abap_source.clas.mjs":
/*!*************************************************!*\
  !*** ./output/kernel_scan_abap_source.clas.mjs ***!
  \*************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "kernel_scan_abap_source": () => (/* binding */ kernel_scan_abap_source)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// kernel_scan_abap_source.clas.abap
class kernel_scan_abap_source {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'KERNEL_SCAN_ABAP_SOURCE';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"GC_TOKEN": {"type": () => {return new abap.types.Structure({"comment": new abap.types.Character(1, {}), "identifier": new abap.types.Character(1, {}), "list": new abap.types.Character(1, {}), "literal": new abap.types.Character(1, {}), "pragma": new abap.types.Character(1, {})}, undefined, undefined, {}, {});}, "visibility": "I", "is_constant": "X", "is_class": "X"},
  "GC_STATEMENT": {"type": () => {return new abap.types.Structure({"comment": new abap.types.Character(1, {}), "comment_in_stmnt": new abap.types.Character(1, {}), "compute_direct": new abap.types.Character(1, {}), "empty": new abap.types.Character(1, {}), "macro_call": new abap.types.Character(1, {}), "macro_definition": new abap.types.Character(1, {}), "method_direct": new abap.types.Character(1, {}), "native_sql": new abap.types.Character(1, {}), "pragma": new abap.types.Character(1, {}), "standard": new abap.types.Character(1, {})}, undefined, undefined, {}, {});}, "visibility": "I", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"CALL_INTERNAL": {"visibility": "I", "parameters": {"SOURCE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "ET_STOKESX": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"str": new abap.types.String({qualifiedName: "STRING"}), "row": new abap.types.Integer({qualifiedName: "I"}), "off2": new abap.types.Integer({qualifiedName: "I"}), "off3": new abap.types.Integer({qualifiedName: "I"}), "col": new abap.types.Integer({qualifiedName: "I"}), "len1": new abap.types.Integer({qualifiedName: "I"}), "len2": new abap.types.Integer({qualifiedName: "I"}), "len3": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {})}, "STOKESX", "STOKESX", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_scan_abap_source=>ty_stokesx");}, "is_optional": " "}, "ET_SSTMNT": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"level": new abap.types.Integer({qualifiedName: "I"}), "struc": new abap.types.Integer({qualifiedName: "I"}), "from": new abap.types.Integer({qualifiedName: "I"}), "to": new abap.types.Integer({qualifiedName: "I"}), "number": new abap.types.Integer({qualifiedName: "I"}), "colonrow": new abap.types.Integer({qualifiedName: "I"}), "trow": new abap.types.Integer({qualifiedName: "I"}), "coloncol": new abap.types.Integer({qualifiedName: "I"}), "tcol": new abap.types.Integer({qualifiedName: "I"}), "prefixlen": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {}), "terminator": new abap.types.Character(1, {}), "enhmt": new abap.types.Integer({qualifiedName: "I"})}, "SSTMNT", "SSTMNT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_scan_abap_source=>ty_sstmnt");}, "is_optional": " "}}},
  "PASS1": {"visibility": "I", "parameters": {"SOURCE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "ET_TOKENS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"str": new abap.types.String({qualifiedName: "STRING"}), "row": new abap.types.Integer({qualifiedName: "I"}), "off2": new abap.types.Integer({qualifiedName: "I"}), "off3": new abap.types.Integer({qualifiedName: "I"}), "col": new abap.types.Integer({qualifiedName: "I"}), "len1": new abap.types.Integer({qualifiedName: "I"}), "len2": new abap.types.Integer({qualifiedName: "I"}), "len3": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {})}, "STOKESX", "STOKESX", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_scan_abap_source=>ty_stokesx");}, "is_optional": " "}, "ET_STATEMENTS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"level": new abap.types.Integer({qualifiedName: "I"}), "struc": new abap.types.Integer({qualifiedName: "I"}), "from": new abap.types.Integer({qualifiedName: "I"}), "to": new abap.types.Integer({qualifiedName: "I"}), "number": new abap.types.Integer({qualifiedName: "I"}), "colonrow": new abap.types.Integer({qualifiedName: "I"}), "trow": new abap.types.Integer({qualifiedName: "I"}), "coloncol": new abap.types.Integer({qualifiedName: "I"}), "tcol": new abap.types.Integer({qualifiedName: "I"}), "prefixlen": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {}), "terminator": new abap.types.Character(1, {}), "enhmt": new abap.types.Integer({qualifiedName: "I"})}, "SSTMNT", "SSTMNT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_scan_abap_source=>ty_sstmnt");}, "is_optional": " "}}},
  "PASS2": {"visibility": "I", "parameters": {"CT_TOKENS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"str": new abap.types.String({qualifiedName: "STRING"}), "row": new abap.types.Integer({qualifiedName: "I"}), "off2": new abap.types.Integer({qualifiedName: "I"}), "off3": new abap.types.Integer({qualifiedName: "I"}), "col": new abap.types.Integer({qualifiedName: "I"}), "len1": new abap.types.Integer({qualifiedName: "I"}), "len2": new abap.types.Integer({qualifiedName: "I"}), "len3": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {})}, "STOKESX", "STOKESX", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_scan_abap_source=>ty_stokesx");}, "is_optional": " "}, "CT_STATEMENTS": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"level": new abap.types.Integer({qualifiedName: "I"}), "struc": new abap.types.Integer({qualifiedName: "I"}), "from": new abap.types.Integer({qualifiedName: "I"}), "to": new abap.types.Integer({qualifiedName: "I"}), "number": new abap.types.Integer({qualifiedName: "I"}), "colonrow": new abap.types.Integer({qualifiedName: "I"}), "trow": new abap.types.Integer({qualifiedName: "I"}), "coloncol": new abap.types.Integer({qualifiedName: "I"}), "tcol": new abap.types.Integer({qualifiedName: "I"}), "prefixlen": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {}), "terminator": new abap.types.Character(1, {}), "enhmt": new abap.types.Integer({qualifiedName: "I"})}, "SSTMNT", "SSTMNT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_scan_abap_source=>ty_sstmnt");}, "is_optional": " "}}},
  "CALL": {"visibility": "U", "parameters": {"INPUT": {"type": () => {return new abap.types.Character(4);}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.gc_token = kernel_scan_abap_source.gc_token;
    this.gc_statement = kernel_scan_abap_source.gc_statement;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async call(INPUT) {
    return kernel_scan_abap_source.call(INPUT);
  }
  static async call(INPUT) {
    let input = INPUT?.input;
    let lt_sstmnt = abap.types.TableFactory.construct(new abap.types.Structure({"level": new abap.types.Integer({qualifiedName: "I"}), "struc": new abap.types.Integer({qualifiedName: "I"}), "from": new abap.types.Integer({qualifiedName: "I"}), "to": new abap.types.Integer({qualifiedName: "I"}), "number": new abap.types.Integer({qualifiedName: "I"}), "colonrow": new abap.types.Integer({qualifiedName: "I"}), "trow": new abap.types.Integer({qualifiedName: "I"}), "coloncol": new abap.types.Integer({qualifiedName: "I"}), "tcol": new abap.types.Integer({qualifiedName: "I"}), "prefixlen": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {}), "terminator": new abap.types.Character(1, {}), "enhmt": new abap.types.Integer({qualifiedName: "I"})}, "SSTMNT", "SSTMNT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_scan_abap_source=>ty_sstmnt");
    let lt_stokes = abap.types.TableFactory.construct(new abap.types.Structure({"str": new abap.types.String({qualifiedName: "STRING"}), "row": new abap.types.Integer({qualifiedName: "I"}), "col": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {})}, "STOKES", "STOKES", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "STOKES_TAB");
    let ls_stokes = new abap.types.Structure({"str": new abap.types.String({qualifiedName: "STRING"}), "row": new abap.types.Integer({qualifiedName: "I"}), "col": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {})}, "STOKES", "STOKES", {}, {});
    let lt_stokesx = abap.types.TableFactory.construct(new abap.types.Structure({"str": new abap.types.String({qualifiedName: "STRING"}), "row": new abap.types.Integer({qualifiedName: "I"}), "off2": new abap.types.Integer({qualifiedName: "I"}), "off3": new abap.types.Integer({qualifiedName: "I"}), "col": new abap.types.Integer({qualifiedName: "I"}), "len1": new abap.types.Integer({qualifiedName: "I"}), "len2": new abap.types.Integer({qualifiedName: "I"}), "len3": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {})}, "STOKESX", "STOKESX", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_scan_abap_source=>ty_stokesx");
    let ls_stokesx = new abap.types.Structure({"str": new abap.types.String({qualifiedName: "STRING"}), "row": new abap.types.Integer({qualifiedName: "I"}), "off2": new abap.types.Integer({qualifiedName: "I"}), "off3": new abap.types.Integer({qualifiedName: "I"}), "col": new abap.types.Integer({qualifiedName: "I"}), "len1": new abap.types.Integer({qualifiedName: "I"}), "len2": new abap.types.Integer({qualifiedName: "I"}), "len3": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {})}, "STOKESX", "STOKESX", {}, {});
    let lv_source = new abap.types.String({qualifiedName: "STRING"});
    lv_source.set(INPUT.scan_abap_source.array ? INPUT.scan_abap_source.array().map(e => e.get()).join("\n") : INPUT.scan_abap_source.get());
    await this.call_internal({source: lv_source, et_stokesx: lt_stokesx, et_sstmnt: lt_sstmnt});
    for await (const unique105 of abap.statements.loop(lt_stokesx)) {
      ls_stokesx.set(unique105);
      abap.statements.clear(ls_stokes);
      abap.statements.moveCorresponding(ls_stokesx, ls_stokes);
      abap.statements.append({source: ls_stokes, target: lt_stokes});
    }
    const len = Object.keys(INPUT.tokens_into.getRowType().get()).length;
    INPUT.tokens_into.set(len == 4 ? lt_stokes : lt_stokesx);
    INPUT.statements_into.set(lt_sstmnt);
  }
  async call_internal(INPUT) {
    return kernel_scan_abap_source.call_internal(INPUT);
  }
  static async call_internal(INPUT) {
    let source = INPUT?.source;
    if (source?.getQualifiedName === undefined || source.getQualifiedName() !== "STRING") { source = undefined; }
    if (source === undefined) { source = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.source); }
    let et_stokesx = INPUT?.et_stokesx || abap.types.TableFactory.construct(new abap.types.Structure({"str": new abap.types.String({qualifiedName: "STRING"}), "row": new abap.types.Integer({qualifiedName: "I"}), "off2": new abap.types.Integer({qualifiedName: "I"}), "off3": new abap.types.Integer({qualifiedName: "I"}), "col": new abap.types.Integer({qualifiedName: "I"}), "len1": new abap.types.Integer({qualifiedName: "I"}), "len2": new abap.types.Integer({qualifiedName: "I"}), "len3": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {})}, "STOKESX", "STOKESX", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_scan_abap_source=>ty_stokesx");
    let et_sstmnt = INPUT?.et_sstmnt || abap.types.TableFactory.construct(new abap.types.Structure({"level": new abap.types.Integer({qualifiedName: "I"}), "struc": new abap.types.Integer({qualifiedName: "I"}), "from": new abap.types.Integer({qualifiedName: "I"}), "to": new abap.types.Integer({qualifiedName: "I"}), "number": new abap.types.Integer({qualifiedName: "I"}), "colonrow": new abap.types.Integer({qualifiedName: "I"}), "trow": new abap.types.Integer({qualifiedName: "I"}), "coloncol": new abap.types.Integer({qualifiedName: "I"}), "tcol": new abap.types.Integer({qualifiedName: "I"}), "prefixlen": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {}), "terminator": new abap.types.Character(1, {}), "enhmt": new abap.types.Integer({qualifiedName: "I"})}, "SSTMNT", "SSTMNT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_scan_abap_source=>ty_sstmnt");
    await this.pass1({source: source, et_tokens: et_stokesx, et_statements: et_sstmnt});
    await this.pass2({ct_tokens: et_stokesx, ct_statements: et_sstmnt});
  }
  async pass1(INPUT) {
    return kernel_scan_abap_source.pass1(INPUT);
  }
  static async pass1(INPUT) {
    let source = INPUT?.source;
    if (source?.getQualifiedName === undefined || source.getQualifiedName() !== "STRING") { source = undefined; }
    if (source === undefined) { source = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.source); }
    let et_tokens = INPUT?.et_tokens || abap.types.TableFactory.construct(new abap.types.Structure({"str": new abap.types.String({qualifiedName: "STRING"}), "row": new abap.types.Integer({qualifiedName: "I"}), "off2": new abap.types.Integer({qualifiedName: "I"}), "off3": new abap.types.Integer({qualifiedName: "I"}), "col": new abap.types.Integer({qualifiedName: "I"}), "len1": new abap.types.Integer({qualifiedName: "I"}), "len2": new abap.types.Integer({qualifiedName: "I"}), "len3": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {})}, "STOKESX", "STOKESX", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_scan_abap_source=>ty_stokesx");
    let et_statements = INPUT?.et_statements || abap.types.TableFactory.construct(new abap.types.Structure({"level": new abap.types.Integer({qualifiedName: "I"}), "struc": new abap.types.Integer({qualifiedName: "I"}), "from": new abap.types.Integer({qualifiedName: "I"}), "to": new abap.types.Integer({qualifiedName: "I"}), "number": new abap.types.Integer({qualifiedName: "I"}), "colonrow": new abap.types.Integer({qualifiedName: "I"}), "trow": new abap.types.Integer({qualifiedName: "I"}), "coloncol": new abap.types.Integer({qualifiedName: "I"}), "tcol": new abap.types.Integer({qualifiedName: "I"}), "prefixlen": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {}), "terminator": new abap.types.Character(1, {}), "enhmt": new abap.types.Integer({qualifiedName: "I"})}, "SSTMNT", "SSTMNT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_scan_abap_source=>ty_sstmnt");
    let c_mode = new abap.types.Structure({"normal": new abap.types.Integer({qualifiedName: "I"}), "comment": new abap.types.Integer({qualifiedName: "I"})}, undefined, undefined, {}, {});
    c_mode.get().normal.set(abap.IntegerFactory.get(1));
    c_mode.get().comment.set(abap.IntegerFactory.get(2));
    let character = new abap.types.Character(1, {});
    let row = new abap.types.Integer({qualifiedName: "I"});
    row.set(1);
    let column = new abap.types.Integer({qualifiedName: "I"});
    let index = new abap.types.Integer({qualifiedName: "I"});
    let sfrom = new abap.types.Integer({qualifiedName: "I"});
    sfrom.set(1);
    let mode = new abap.types.Integer({qualifiedName: "I"});
    let chain_tokens = abap.types.TableFactory.construct(new abap.types.Structure({"str": new abap.types.String({qualifiedName: "STRING"}), "row": new abap.types.Integer({qualifiedName: "I"}), "off2": new abap.types.Integer({qualifiedName: "I"}), "off3": new abap.types.Integer({qualifiedName: "I"}), "col": new abap.types.Integer({qualifiedName: "I"}), "len1": new abap.types.Integer({qualifiedName: "I"}), "len2": new abap.types.Integer({qualifiedName: "I"}), "len3": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {})}, "STOKESX", "STOKESX", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_scan_abap_source=>ty_stokesx");
    let fs_trow_ = new abap.types.FieldSymbol(new abap.types.Structure({"str": new abap.types.String({qualifiedName: "STRING"}), "row": new abap.types.Integer({qualifiedName: "I"}), "off2": new abap.types.Integer({qualifiedName: "I"}), "off3": new abap.types.Integer({qualifiedName: "I"}), "col": new abap.types.Integer({qualifiedName: "I"}), "len1": new abap.types.Integer({qualifiedName: "I"}), "len2": new abap.types.Integer({qualifiedName: "I"}), "len3": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {})}, "STOKESX", "STOKESX", {}, {}));
    let fs_srow_ = new abap.types.FieldSymbol(new abap.types.Structure({"level": new abap.types.Integer({qualifiedName: "I"}), "struc": new abap.types.Integer({qualifiedName: "I"}), "from": new abap.types.Integer({qualifiedName: "I"}), "to": new abap.types.Integer({qualifiedName: "I"}), "number": new abap.types.Integer({qualifiedName: "I"}), "colonrow": new abap.types.Integer({qualifiedName: "I"}), "trow": new abap.types.Integer({qualifiedName: "I"}), "coloncol": new abap.types.Integer({qualifiedName: "I"}), "tcol": new abap.types.Integer({qualifiedName: "I"}), "prefixlen": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {}), "terminator": new abap.types.Character(1, {}), "enhmt": new abap.types.Integer({qualifiedName: "I"})}, "SSTMNT", "SSTMNT", {}, {}));
    mode.set(c_mode.get().normal);
    const indexBackup1 = abap.builtin.sy.get().index.get();
    let unique106 = 1;
    while (abap.compare.initial(source) === false) {
      abap.builtin.sy.get().index.set(unique106++);
      character.set(source.getOffset({length: 1}));
      source.set(source.getOffset({offset: 1}));
      if (abap.compare.assigned(fs_trow_) === false && abap.compare.ne(character, new abap.types.Character(1).set('')) && abap.compare.ne(character, new abap.types.String().set(`\n`))) {
        fs_trow_.assign(et_tokens.appendInitial());
        fs_trow_.get().row.set(row);
        fs_trow_.get().col.set(column);
        fs_trow_.get().type.set(kernel_scan_abap_source.gc_token.get().identifier);
      } else if (abap.compare.eq(mode, c_mode.get().normal) && (abap.compare.eq(character, new abap.types.Character(1).set('')) || abap.compare.ca(character, new abap.types.String().set(`.,`)))) {
        fs_trow_.unassign();
      } else if (abap.compare.eq(mode, c_mode.get().normal) && abap.compare.eq(character, new abap.types.Character(1).set(':'))) {
        abap.statements.clear(chain_tokens);
        abap.statements.append({source: et_tokens, from: sfrom, lines: true, target: chain_tokens});
        await abap.statements.deleteInternal(chain_tokens,{where: (I) => {return abap.compare.eq(I.type, kernel_scan_abap_source.gc_token.get().comment);}});
      }
      if ((abap.compare.eq(mode, c_mode.get().normal) && abap.compare.ca(character, new abap.types.String().set(`.,`))) || abap.compare.eq(source, new abap.types.Character(1).set(''))) {
        fs_srow_.assign(et_statements.appendInitial());
        fs_srow_.get().terminator.set(character);
        fs_srow_.get().from.set(sfrom);
        fs_srow_.get().to.set(abap.builtin.lines({val: et_tokens}));
        sfrom.set(abap.operators.add(fs_srow_.get().to,abap.IntegerFactory.get(1)));
        if (abap.compare.eq(character, new abap.types.Character(1).set(','))) {
          abap.statements.append({source: chain_tokens, lines: true, target: et_tokens});
        }
      }
      if (abap.compare.eq(character, new abap.types.String().set(`\n`))) {
        mode.set(c_mode.get().normal);
        fs_trow_.unassign();
        row.set(abap.operators.add(row,abap.IntegerFactory.get(1)));
        column.set(abap.IntegerFactory.get(0));
      } else {
        if (abap.compare.assigned(fs_trow_)) {
          if ((abap.compare.eq(character, new abap.types.Character(1).set('*')) && abap.compare.eq(column, abap.IntegerFactory.get(0))) || abap.compare.eq(character, new abap.types.Character(1).set('"'))) {
            mode.set(c_mode.get().comment);
            fs_trow_.get().type.set(kernel_scan_abap_source.gc_token.get().comment);
          }
          if (abap.compare.eq(mode, c_mode.get().comment)) {
            fs_trow_.get().type.set(kernel_scan_abap_source.gc_token.get().comment);
            abap.statements.concatenate({source: [fs_trow_.get().str, character], target: fs_trow_.get().str, respectingBlanks: true});
          } else if (abap.compare.ne(character, new abap.types.Character(1).set(':'))) {
            fs_trow_.get().str.set(abap.operators.concat(fs_trow_.get().str,abap.builtin.to_upper({val: new abap.types.String().set(`${abap.templateFormatting(character)}`)})));
          }
        }
        column.set(abap.operators.add(column,abap.IntegerFactory.get(1)));
      }
    }
    abap.builtin.sy.get().index.set(indexBackup1);
  }
  async pass2(INPUT) {
    return kernel_scan_abap_source.pass2(INPUT);
  }
  static async pass2(INPUT) {
    let ct_tokens = abap.types.TableFactory.construct(new abap.types.Structure({"str": new abap.types.String({qualifiedName: "STRING"}), "row": new abap.types.Integer({qualifiedName: "I"}), "off2": new abap.types.Integer({qualifiedName: "I"}), "off3": new abap.types.Integer({qualifiedName: "I"}), "col": new abap.types.Integer({qualifiedName: "I"}), "len1": new abap.types.Integer({qualifiedName: "I"}), "len2": new abap.types.Integer({qualifiedName: "I"}), "len3": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {})}, "STOKESX", "STOKESX", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_scan_abap_source=>ty_stokesx");
    if (INPUT && INPUT.ct_tokens) {ct_tokens = INPUT.ct_tokens;}
    let ct_statements = abap.types.TableFactory.construct(new abap.types.Structure({"level": new abap.types.Integer({qualifiedName: "I"}), "struc": new abap.types.Integer({qualifiedName: "I"}), "from": new abap.types.Integer({qualifiedName: "I"}), "to": new abap.types.Integer({qualifiedName: "I"}), "number": new abap.types.Integer({qualifiedName: "I"}), "colonrow": new abap.types.Integer({qualifiedName: "I"}), "trow": new abap.types.Integer({qualifiedName: "I"}), "coloncol": new abap.types.Integer({qualifiedName: "I"}), "tcol": new abap.types.Integer({qualifiedName: "I"}), "prefixlen": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {}), "terminator": new abap.types.Character(1, {}), "enhmt": new abap.types.Integer({qualifiedName: "I"})}, "SSTMNT", "SSTMNT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_scan_abap_source=>ty_sstmnt");
    if (INPUT && INPUT.ct_statements) {ct_statements = INPUT.ct_statements;}
    let fs_ls_statement_ = new abap.types.FieldSymbol(new abap.types.Structure({"level": new abap.types.Integer({qualifiedName: "I"}), "struc": new abap.types.Integer({qualifiedName: "I"}), "from": new abap.types.Integer({qualifiedName: "I"}), "to": new abap.types.Integer({qualifiedName: "I"}), "number": new abap.types.Integer({qualifiedName: "I"}), "colonrow": new abap.types.Integer({qualifiedName: "I"}), "trow": new abap.types.Integer({qualifiedName: "I"}), "coloncol": new abap.types.Integer({qualifiedName: "I"}), "tcol": new abap.types.Integer({qualifiedName: "I"}), "prefixlen": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {}), "terminator": new abap.types.Character(1, {}), "enhmt": new abap.types.Integer({qualifiedName: "I"})}, "SSTMNT", "SSTMNT", {}, {}));
    let ls_statement = new abap.types.Structure({"level": new abap.types.Integer({qualifiedName: "I"}), "struc": new abap.types.Integer({qualifiedName: "I"}), "from": new abap.types.Integer({qualifiedName: "I"}), "to": new abap.types.Integer({qualifiedName: "I"}), "number": new abap.types.Integer({qualifiedName: "I"}), "colonrow": new abap.types.Integer({qualifiedName: "I"}), "trow": new abap.types.Integer({qualifiedName: "I"}), "coloncol": new abap.types.Integer({qualifiedName: "I"}), "tcol": new abap.types.Integer({qualifiedName: "I"}), "prefixlen": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {}), "terminator": new abap.types.Character(1, {}), "enhmt": new abap.types.Integer({qualifiedName: "I"})}, "SSTMNT", "SSTMNT", {}, {});
    let ls_token = new abap.types.Structure({"str": new abap.types.String({qualifiedName: "STRING"}), "row": new abap.types.Integer({qualifiedName: "I"}), "off2": new abap.types.Integer({qualifiedName: "I"}), "off3": new abap.types.Integer({qualifiedName: "I"}), "col": new abap.types.Integer({qualifiedName: "I"}), "len1": new abap.types.Integer({qualifiedName: "I"}), "len2": new abap.types.Integer({qualifiedName: "I"}), "len3": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {})}, "STOKESX", "STOKESX", {}, {});
    let contains_comment = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    let contains_normal = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    let lv_count = new abap.types.Integer({qualifiedName: "I"});
    let lv_statement_index = new abap.types.Integer({qualifiedName: "I"});
    let lt_insert = abap.types.TableFactory.construct(new abap.types.Structure({"str": new abap.types.String({qualifiedName: "STRING"}), "row": new abap.types.Integer({qualifiedName: "I"}), "off2": new abap.types.Integer({qualifiedName: "I"}), "off3": new abap.types.Integer({qualifiedName: "I"}), "col": new abap.types.Integer({qualifiedName: "I"}), "len1": new abap.types.Integer({qualifiedName: "I"}), "len2": new abap.types.Integer({qualifiedName: "I"}), "len3": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {})}, "STOKESX", "STOKESX", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_scan_abap_source=>ty_stokesx");
    let lt_delete = abap.types.TableFactory.construct(new abap.types.Integer({qualifiedName: "I"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "");
    let lv_index = new abap.types.Integer({qualifiedName: "I"});
    for await (const unique107 of abap.statements.loop(ct_statements)) {
      fs_ls_statement_.assign(unique107);
      lv_statement_index.set(abap.builtin.sy.get().tabix);
      contains_comment.set(abap.builtin.abap_false);
      contains_normal.set(abap.builtin.abap_false);
      for await (const unique108 of abap.statements.loop(ct_tokens,{from: fs_ls_statement_.get().from,to: fs_ls_statement_.get().to})) {
        ls_token.set(unique108);
        if (abap.compare.eq(ls_token.get().type, kernel_scan_abap_source.gc_token.get().comment)) {
          contains_comment.set(abap.builtin.abap_true);
        } else {
          contains_normal.set(abap.builtin.abap_true);
        }
      }
      if (abap.compare.eq(contains_comment, abap.builtin.abap_true) && abap.compare.eq(contains_normal, abap.builtin.abap_true)) {
        lv_count.set(abap.IntegerFactory.get(0));
        abap.statements.clear(lt_insert);
        abap.statements.clear(lt_delete);
        for await (const unique109 of abap.statements.loop(ct_tokens,{from: fs_ls_statement_.get().from,to: fs_ls_statement_.get().to})) {
          ls_token.set(unique109);
          if (abap.compare.eq(ls_token.get().type, kernel_scan_abap_source.gc_token.get().comment)) {
            abap.statements.insertInternal({data: abap.builtin.sy.get().tabix, index: abap.IntegerFactory.get(1), table: lt_delete});
            abap.statements.insertInternal({data: ls_token, index: abap.IntegerFactory.get(1), table: lt_insert});
            lv_count.set(abap.operators.add(lv_count,abap.IntegerFactory.get(1)));
          }
        }
        for await (const unique110 of abap.statements.loop(lt_delete)) {
          lv_index.set(unique110);
          await abap.statements.deleteInternal(ct_tokens,{index: lv_index});
        }
        for await (const unique111 of abap.statements.loop(lt_insert)) {
          ls_token.set(unique111);
          abap.statements.insertInternal({data: ls_token, index: fs_ls_statement_.get().from, table: ct_tokens});
        }
        abap.statements.clear(ls_statement);
        ls_statement.get().from.set(fs_ls_statement_.get().from);
        ls_statement.get().to.set(abap.operators.minus(abap.operators.add(fs_ls_statement_.get().from,lv_count),abap.IntegerFactory.get(1)));
        ls_statement.get().type.set(kernel_scan_abap_source.gc_statement.get().comment);
        fs_ls_statement_.get().from.set(abap.operators.add(fs_ls_statement_.get().from,lv_count));
        abap.statements.insertInternal({data: ls_statement, index: lv_statement_index, table: ct_statements});
      } else if (abap.compare.eq(contains_comment, abap.builtin.abap_true)) {
        fs_ls_statement_.get().type.set(kernel_scan_abap_source.gc_statement.get().comment);
      } else {
        fs_ls_statement_.get().type.set(kernel_scan_abap_source.gc_statement.get().standard);
      }
    }
  }
}
abap.Classes['KERNEL_SCAN_ABAP_SOURCE'] = kernel_scan_abap_source;
kernel_scan_abap_source.gc_token = new abap.types.Structure({"comment": new abap.types.Character(1, {}), "identifier": new abap.types.Character(1, {}), "list": new abap.types.Character(1, {}), "literal": new abap.types.Character(1, {}), "pragma": new abap.types.Character(1, {})}, undefined, undefined, {}, {});
kernel_scan_abap_source.gc_token.get().comment.set('C');
kernel_scan_abap_source.gc_token.get().identifier.set('I');
kernel_scan_abap_source.gc_token.get().list.set('L');
kernel_scan_abap_source.gc_token.get().literal.set('S');
kernel_scan_abap_source.gc_token.get().pragma.set('P');
kernel_scan_abap_source.gc_statement = new abap.types.Structure({"comment": new abap.types.Character(1, {}), "comment_in_stmnt": new abap.types.Character(1, {}), "compute_direct": new abap.types.Character(1, {}), "empty": new abap.types.Character(1, {}), "macro_call": new abap.types.Character(1, {}), "macro_definition": new abap.types.Character(1, {}), "method_direct": new abap.types.Character(1, {}), "native_sql": new abap.types.Character(1, {}), "pragma": new abap.types.Character(1, {}), "standard": new abap.types.Character(1, {})}, undefined, undefined, {}, {});
kernel_scan_abap_source.gc_statement.get().comment.set('P');
kernel_scan_abap_source.gc_statement.get().comment_in_stmnt.set('S');
kernel_scan_abap_source.gc_statement.get().compute_direct.set('C');
kernel_scan_abap_source.gc_statement.get().empty.set('N');
kernel_scan_abap_source.gc_statement.get().macro_call.set('D');
kernel_scan_abap_source.gc_statement.get().macro_definition.set('M');
kernel_scan_abap_source.gc_statement.get().method_direct.set('A');
kernel_scan_abap_source.gc_statement.get().native_sql.set('E');
kernel_scan_abap_source.gc_statement.get().pragma.set('G');
kernel_scan_abap_source.gc_statement.get().standard.set('K');
kernel_scan_abap_source.ty_stokesx = abap.types.TableFactory.construct(new abap.types.Structure({"str": new abap.types.String({qualifiedName: "STRING"}), "row": new abap.types.Integer({qualifiedName: "I"}), "off2": new abap.types.Integer({qualifiedName: "I"}), "off3": new abap.types.Integer({qualifiedName: "I"}), "col": new abap.types.Integer({qualifiedName: "I"}), "len1": new abap.types.Integer({qualifiedName: "I"}), "len2": new abap.types.Integer({qualifiedName: "I"}), "len3": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {})}, "STOKESX", "STOKESX", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_scan_abap_source=>ty_stokesx");
kernel_scan_abap_source.ty_sstmnt = abap.types.TableFactory.construct(new abap.types.Structure({"level": new abap.types.Integer({qualifiedName: "I"}), "struc": new abap.types.Integer({qualifiedName: "I"}), "from": new abap.types.Integer({qualifiedName: "I"}), "to": new abap.types.Integer({qualifiedName: "I"}), "number": new abap.types.Integer({qualifiedName: "I"}), "colonrow": new abap.types.Integer({qualifiedName: "I"}), "trow": new abap.types.Integer({qualifiedName: "I"}), "coloncol": new abap.types.Integer({qualifiedName: "I"}), "tcol": new abap.types.Integer({qualifiedName: "I"}), "prefixlen": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {}), "terminator": new abap.types.Character(1, {}), "enhmt": new abap.types.Integer({qualifiedName: "I"})}, "SSTMNT", "SSTMNT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_scan_abap_source=>ty_sstmnt");

//# sourceMappingURL=kernel_scan_abap_source.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/kernel_unit_runner.clas.mjs":
/*!********************************************!*\
  !*** ./output/kernel_unit_runner.clas.mjs ***!
  \********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "kernel_unit_runner": () => (/* binding */ kernel_unit_runner)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// kernel_unit_runner.clas.abap
class kernel_unit_runner {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'KERNEL_UNIT_RUNNER';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"MV_CONSOLE": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "visibility": "U", "is_constant": " ", "is_class": "X"},
  "GC_STATUS": {"type": () => {return new abap.types.Structure({"success": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_STATUS"}), "failed": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_STATUS"}), "skipped": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_STATUS"})}, undefined, undefined, {}, {});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {"UNIQUE_CLASSES": {"visibility": "I", "parameters": {"RT_CLASSES": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_class_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_class_item-testclass_name"})}, "kernel_unit_runner=>ty_class_item", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_unit_runner=>ty_classes");}, "is_optional": " "}, "IT_INPUT": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-testclass_name"}), "method_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-method_name"})}, "kernel_unit_runner=>ty_input_item", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_unit_runner=>ty_input");}, "is_optional": " "}}},
  "TO_JSON": {"visibility": "I", "parameters": {"RV_JSON": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "IT_LIST": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-testclass_name"}), "method_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-method_name"}), "expected": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-EXPECTED"}), "actual": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-ACTUAL"}), "status": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_STATUS"}), "runtime": new abap.types.Integer({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-RUNTIME"}), "message": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-MESSAGE"}), "js_location": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-JS_LOCATION"}), "console": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-CONSOLE"})}, "kernel_unit_runner=>ty_result_item", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_unit_runner=>ty_result-list");}, "is_optional": " "}}},
  "GET_LOCATION": {"visibility": "I", "parameters": {"RV_LOCATION": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "IX_ERROR": {"type": () => {return new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});}, "is_optional": " "}}},
  "RUN": {"visibility": "U", "parameters": {"RS_RESULT": {"type": () => {return new abap.types.Structure({"list": abap.types.TableFactory.construct(new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-testclass_name"}), "method_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-method_name"}), "expected": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-EXPECTED"}), "actual": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-ACTUAL"}), "status": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_STATUS"}), "runtime": new abap.types.Integer({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-RUNTIME"}), "message": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-MESSAGE"}), "js_location": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-JS_LOCATION"}), "console": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-CONSOLE"})}, "kernel_unit_runner=>ty_result_item", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_unit_runner=>ty_result-list"), "json": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT-JSON"})}, "kernel_unit_runner=>ty_result", undefined, {}, {});}, "is_optional": " "}, "IT_INPUT": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-testclass_name"}), "method_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-method_name"})}, "kernel_unit_runner=>ty_input_item", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_unit_runner=>ty_input");}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.mv_console = kernel_unit_runner.mv_console;
    this.gc_status = kernel_unit_runner.gc_status;
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async get_location(INPUT) {
    return kernel_unit_runner.get_location(INPUT);
  }
  static async get_location(INPUT) {
    let rv_location = new abap.types.String({qualifiedName: "STRING"});
    let ix_error = INPUT?.ix_error;
    if (ix_error?.getQualifiedName === undefined || ix_error.getQualifiedName() !== "CX_ROOT") { ix_error = undefined; }
    if (ix_error === undefined) { ix_error = new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"}).set(INPUT.ix_error); }
    let lv_stack = new abap.types.String({qualifiedName: "STRING"});
    let lt_lines = abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "");
    let lv_found = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    lv_stack.set(INPUT.ix_error.get().stack);
    abap.statements.split({source: lv_stack, at: new abap.types.String().set(`\n`), table: lt_lines});
    for await (const unique171 of abap.statements.loop(lt_lines)) {
      lv_stack.set(unique171);
      if (abap.compare.cp(lv_stack, new abap.types.Character(21).set('*cl_abap_unit_assert*'))) {
        lv_found.set(abap.builtin.abap_true);
        continue;
      } else if (abap.compare.eq(lv_found, abap.builtin.abap_true)) {
        abap.statements.replace({target: lv_stack, all: false, with: new abap.types.Character(1).set(''), of: new abap.types.String().set(`at `)});
        rv_location.set(abap.builtin.condense({val: lv_stack}));
        break;
      }
    }
    return rv_location;
  }
  async to_json(INPUT) {
    return kernel_unit_runner.to_json(INPUT);
  }
  static async to_json(INPUT) {
    let rv_json = new abap.types.String({qualifiedName: "STRING"});
    let it_list = INPUT?.it_list;
    if (it_list?.getQualifiedName === undefined || it_list.getQualifiedName() !== "KERNEL_UNIT_RUNNER=>TY_RESULT-LIST") { it_list = undefined; }
    if (it_list === undefined) { it_list = abap.types.TableFactory.construct(new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-testclass_name"}), "method_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-method_name"}), "expected": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-EXPECTED"}), "actual": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-ACTUAL"}), "status": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_STATUS"}), "runtime": new abap.types.Integer({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-RUNTIME"}), "message": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-MESSAGE"}), "js_location": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-JS_LOCATION"}), "console": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-CONSOLE"})}, "kernel_unit_runner=>ty_result_item", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_unit_runner=>ty_result-list").set(INPUT.it_list); }
    let ls_list = new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-testclass_name"}), "method_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-method_name"}), "expected": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-EXPECTED"}), "actual": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-ACTUAL"}), "status": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_STATUS"}), "runtime": new abap.types.Integer({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-RUNTIME"}), "message": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-MESSAGE"}), "js_location": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-JS_LOCATION"}), "console": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-CONSOLE"})}, "kernel_unit_runner=>ty_result_item", undefined, {}, {});
    let lt_strings = abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "");
    let lv_string = new abap.types.String({qualifiedName: "STRING"});
    let lv_message = new abap.types.String({qualifiedName: "STRING"});
    for await (const unique172 of abap.statements.loop(it_list)) {
      ls_list.set(unique172);
      lv_message.set(ls_list.get().message);
      abap.statements.replace({target: lv_message, all: true, with: new abap.types.String().set(`\"`), of: new abap.types.String().set(`"`)});
      abap.statements.replace({target: lv_message, all: true, with: new abap.types.String().set(`\\n`), of: new abap.types.String().set(`\n`)});
      abap.statements.replace({target: ls_list.get().expected, all: true, with: new abap.types.String().set(`\"`), of: new abap.types.String().set(`"`)});
      abap.statements.replace({target: ls_list.get().expected, all: true, with: new abap.types.String().set(`\\n`), of: new abap.types.String().set(`\n`)});
      abap.statements.replace({target: ls_list.get().actual, all: true, with: new abap.types.String().set(`\"`), of: new abap.types.String().set(`"`)});
      abap.statements.replace({target: ls_list.get().actual, all: true, with: new abap.types.String().set(`\\n`), of: new abap.types.String().set(`\n`)});
      abap.statements.replace({target: ls_list.get().console, all: true, with: new abap.types.String().set(`\"`), of: new abap.types.String().set(`"`)});
      abap.statements.replace({target: ls_list.get().console, all: true, with: new abap.types.String().set(`\\n`), of: new abap.types.String().set(`\n`)});
      lv_string.set(new abap.types.String().set(`\{"class_name": "${abap.templateFormatting(ls_list.get().class_name)}","testclass_name": "${abap.templateFormatting(ls_list.get().testclass_name)}","method_name": "${abap.templateFormatting(ls_list.get().method_name)}","expected": "${abap.templateFormatting(ls_list.get().expected)}","actual": "${abap.templateFormatting(ls_list.get().actual)}","status": "${abap.templateFormatting(ls_list.get().status)}","runtime": ${abap.templateFormatting(ls_list.get().runtime)},"console": "${abap.templateFormatting(ls_list.get().console)}","message": "${abap.templateFormatting(lv_message)}","js_location": "${abap.templateFormatting(ls_list.get().js_location)}"\}`));
      abap.statements.append({source: lv_string, target: lt_strings});
    }
    abap.statements.concatenate({source: [lt_strings], target: rv_json, separatedBy: new abap.types.Character(1).set(','), lines: true});
    rv_json.set(abap.operators.concat(new abap.types.Character(1).set('['),abap.operators.concat(rv_json,new abap.types.Character(1).set(']'))));
    return rv_json;
  }
  async unique_classes(INPUT) {
    return kernel_unit_runner.unique_classes(INPUT);
  }
  static async unique_classes(INPUT) {
    let rt_classes = abap.types.TableFactory.construct(new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_class_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_class_item-testclass_name"})}, "kernel_unit_runner=>ty_class_item", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_unit_runner=>ty_classes");
    let it_input = INPUT?.it_input;
    if (it_input?.getQualifiedName === undefined || it_input.getQualifiedName() !== "KERNEL_UNIT_RUNNER=>TY_INPUT") { it_input = undefined; }
    if (it_input === undefined) { it_input = abap.types.TableFactory.construct(new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-testclass_name"}), "method_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-method_name"})}, "kernel_unit_runner=>ty_input_item", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_unit_runner=>ty_input").set(INPUT.it_input); }
    let ls_input = new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-testclass_name"}), "method_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-method_name"})}, "kernel_unit_runner=>ty_input_item", undefined, {}, {});
    let ls_class = new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_class_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_class_item-testclass_name"})}, "kernel_unit_runner=>ty_class_item", undefined, {}, {});
    for await (const unique173 of abap.statements.loop(it_input)) {
      ls_input.set(unique173);
      abap.statements.moveCorresponding(ls_input, ls_class);
      abap.statements.insertInternal({data: ls_class, table: rt_classes});
    }
    abap.statements.sort(rt_classes,{});
    await abap.statements.deleteInternal(rt_classes,{adjacent: true});
    return rt_classes;
  }
  async run(INPUT) {
    return kernel_unit_runner.run(INPUT);
  }
  static async run(INPUT) {
    let rs_result = new abap.types.Structure({"list": abap.types.TableFactory.construct(new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-testclass_name"}), "method_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-method_name"}), "expected": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-EXPECTED"}), "actual": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-ACTUAL"}), "status": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_STATUS"}), "runtime": new abap.types.Integer({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-RUNTIME"}), "message": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-MESSAGE"}), "js_location": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-JS_LOCATION"}), "console": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-CONSOLE"})}, "kernel_unit_runner=>ty_result_item", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_unit_runner=>ty_result-list"), "json": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT-JSON"})}, "kernel_unit_runner=>ty_result", undefined, {}, {});
    let it_input = INPUT?.it_input;
    if (it_input?.getQualifiedName === undefined || it_input.getQualifiedName() !== "KERNEL_UNIT_RUNNER=>TY_INPUT") { it_input = undefined; }
    if (it_input === undefined) { it_input = abap.types.TableFactory.construct(new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-testclass_name"}), "method_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-method_name"})}, "kernel_unit_runner=>ty_input_item", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_unit_runner=>ty_input").set(INPUT.it_input); }
    let ls_input = new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-testclass_name"}), "method_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-method_name"})}, "kernel_unit_runner=>ty_input_item", undefined, {}, {});
    let lv_time = new abap.types.Integer({qualifiedName: "I"});
    let lo_obj = new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});
    let lv_name = new abap.types.String({qualifiedName: "STRING"});
    let lt_classes = abap.types.TableFactory.construct(new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_class_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_class_item-testclass_name"})}, "kernel_unit_runner=>ty_class_item", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_unit_runner=>ty_classes");
    let ls_class = new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_class_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_class_item-testclass_name"})}, "kernel_unit_runner=>ty_class_item", undefined, {}, {});
    let lx_root = new abap.types.ABAPObject({qualifiedName: "CX_ROOT", RTTIName: "\\CLASS=CX_ROOT"});
    let lx_assert = new abap.types.ABAPObject({qualifiedName: "KERNEL_CX_ASSERT", RTTIName: "\\CLASS=KERNEL_CX_ASSERT"});
    let fs_ls_result_ = new abap.types.FieldSymbol(new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-testclass_name"}), "method_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-method_name"}), "expected": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-EXPECTED"}), "actual": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-ACTUAL"}), "status": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_STATUS"}), "runtime": new abap.types.Integer({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-RUNTIME"}), "message": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-MESSAGE"}), "js_location": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-JS_LOCATION"}), "console": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-CONSOLE"})}, "kernel_unit_runner=>ty_result_item", undefined, {}, {}));
    lt_classes.set((await this.unique_classes({it_input: it_input})));
    for await (const unique174 of abap.statements.loop(lt_classes)) {
      ls_class.set(unique174);
      lv_name.set(new abap.types.String().set(`CLAS-${abap.templateFormatting(ls_class.get().class_name)}-${abap.templateFormatting(ls_class.get().testclass_name)}`));
      let unique175 = abap.Classes["CLAS-KERNEL_UNIT_RUNNER-"+lv_name.get().trimEnd()];
      if (unique175 === undefined) { unique175 = abap.Classes[lv_name.get().trimEnd()]; }
      if (unique175 === undefined) { throw new abap.Classes['CX_SY_CREATE_OBJECT_ERROR']; }
      lo_obj.set(await (new unique175()).constructor_());
      try {
        if (lo_obj.get().class_setup === undefined && abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()] === undefined) { throw "CX_SY_DYN_CALL_ILLEGAL_METHOD not found"; }
        if (lo_obj.get().class_setup === undefined) { throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()](); }
        await lo_obj.get().class_setup();
      } catch (e) {
        if ((abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'] && e instanceof abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'])) {
        } else {
          throw e;
        }
      }
      for await (const unique176 of abap.statements.loop(it_input,{where: async (I) => {return abap.compare.eq(I.class_name, ls_class.get().class_name) && abap.compare.eq(I.testclass_name, ls_class.get().testclass_name);},topEquals: {"class_name": ls_class.get().class_name,"testclass_name": ls_class.get().testclass_name}})) {
        ls_input.set(unique176);
        fs_ls_result_.assign(rs_result.get().list.appendInitial());
        abap.statements.moveCorresponding(ls_input, fs_ls_result_);
        try {
          if (lo_obj.get().setup === undefined && abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()] === undefined) { throw "CX_SY_DYN_CALL_ILLEGAL_METHOD not found"; }
          if (lo_obj.get().setup === undefined) { throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()](); }
          await lo_obj.get().setup();
        } catch (e) {
          if ((abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'] && e instanceof abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'])) {
          } else {
            throw e;
          }
        }
        abap.statements.getRunTime(lv_time);
        abap.statements.clear(kernel_unit_runner.mv_console);
        try {
          if (lo_obj.get()[ls_input.get().method_name.get().toLowerCase().trimEnd()] === undefined && abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()] === undefined) { throw "CX_SY_DYN_CALL_ILLEGAL_METHOD not found"; }
          if (lo_obj.get()[ls_input.get().method_name.get().toLowerCase().trimEnd()] === undefined) { throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()](); }
          await lo_obj.get()[ls_input.get().method_name.get().toLowerCase().trimEnd()]();
          fs_ls_result_.get().status.set(kernel_unit_runner.gc_status.get().success);
          fs_ls_result_.get().console.set(kernel_unit_runner.mv_console);
        } catch (e) {
          if ((abap.Classes['KERNEL_CX_ASSERT'] && e instanceof abap.Classes['KERNEL_CX_ASSERT'])) {
            lx_assert.set(e);
            fs_ls_result_.get().status.set(kernel_unit_runner.gc_status.get().failed);
            fs_ls_result_.get().actual.set(lx_assert.get().actual);
            fs_ls_result_.get().expected.set(lx_assert.get().expected);
            fs_ls_result_.get().message.set(lx_assert.get().msg);
            fs_ls_result_.get().js_location.set((await this.get_location({ix_error: lx_assert})));
            fs_ls_result_.get().console.set(kernel_unit_runner.mv_console);
          } else if ((abap.Classes['CX_ROOT'] && e instanceof abap.Classes['CX_ROOT'])) {
            lx_root.set(e);
            fs_ls_result_.get().status.set(kernel_unit_runner.gc_status.get().failed);
            fs_ls_result_.get().message.set(new abap.types.String().set(`Some exception raised`));
            fs_ls_result_.get().js_location.set((await this.get_location({ix_error: lx_root})));
            fs_ls_result_.get().console.set(kernel_unit_runner.mv_console);
          } else {
            throw e;
          }
        }
        abap.statements.getRunTime(lv_time);
        fs_ls_result_.get().runtime.set(lv_time);
        try {
          if (lo_obj.get().teardown === undefined && abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()] === undefined) { throw "CX_SY_DYN_CALL_ILLEGAL_METHOD not found"; }
          if (lo_obj.get().teardown === undefined) { throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()](); }
          await lo_obj.get().teardown();
        } catch (e) {
          if ((abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'] && e instanceof abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'])) {
          } else {
            throw e;
          }
        }
      }
      try {
        if (lo_obj.get().class_teardown === undefined && abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()] === undefined) { throw "CX_SY_DYN_CALL_ILLEGAL_METHOD not found"; }
        if (lo_obj.get().class_teardown === undefined) { throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()](); }
        await lo_obj.get().class_teardown();
      } catch (e) {
        if ((abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'] && e instanceof abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'])) {
        } else {
          throw e;
        }
      }
    }
    rs_result.get().json.set((await this.to_json({it_list: rs_result.get().list})));
    return rs_result;
  }
}
abap.Classes['KERNEL_UNIT_RUNNER'] = kernel_unit_runner;
kernel_unit_runner.mv_console = new abap.types.String({qualifiedName: "STRING"});
kernel_unit_runner.gc_status = new abap.types.Structure({"success": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_STATUS"}), "failed": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_STATUS"}), "skipped": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_STATUS"})}, undefined, undefined, {}, {});
kernel_unit_runner.gc_status.get().success.set('SUCCESS');
kernel_unit_runner.gc_status.get().failed.set('FAILED');
kernel_unit_runner.gc_status.get().skipped.set('SKIPPED');
kernel_unit_runner.ty_input_item = new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-testclass_name"}), "method_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-method_name"})}, "kernel_unit_runner=>ty_input_item", undefined, {}, {});
kernel_unit_runner.ty_input = abap.types.TableFactory.construct(new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-testclass_name"}), "method_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-method_name"})}, "kernel_unit_runner=>ty_input_item", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_unit_runner=>ty_input");
kernel_unit_runner.ty_status = new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_STATUS"});
kernel_unit_runner.ty_result_item = new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-testclass_name"}), "method_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-method_name"}), "expected": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-EXPECTED"}), "actual": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-ACTUAL"}), "status": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_STATUS"}), "runtime": new abap.types.Integer({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-RUNTIME"}), "message": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-MESSAGE"}), "js_location": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-JS_LOCATION"}), "console": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-CONSOLE"})}, "kernel_unit_runner=>ty_result_item", undefined, {}, {});
kernel_unit_runner.ty_result = new abap.types.Structure({"list": abap.types.TableFactory.construct(new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-testclass_name"}), "method_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_input_item-method_name"}), "expected": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-EXPECTED"}), "actual": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-ACTUAL"}), "status": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_STATUS"}), "runtime": new abap.types.Integer({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-RUNTIME"}), "message": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-MESSAGE"}), "js_location": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-JS_LOCATION"}), "console": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT_ITEM-CONSOLE"})}, "kernel_unit_runner=>ty_result_item", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_unit_runner=>ty_result-list"), "json": new abap.types.String({qualifiedName: "KERNEL_UNIT_RUNNER=>TY_RESULT-JSON"})}, "kernel_unit_runner=>ty_result", undefined, {}, {});
kernel_unit_runner.ty_class_item = new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_class_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_class_item-testclass_name"})}, "kernel_unit_runner=>ty_class_item", undefined, {}, {});
kernel_unit_runner.ty_classes = abap.types.TableFactory.construct(new abap.types.Structure({"class_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_class_item-class_name"}), "testclass_name": new abap.types.Character(30, {"qualifiedName":"kernel_unit_runner=>ty_class_item-testclass_name"})}, "kernel_unit_runner=>ty_class_item", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "kernel_unit_runner=>ty_classes");

//# sourceMappingURL=kernel_unit_runner.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/laiso.dtel.mjs":
/*!*******************************!*\
  !*** ./output/laiso.dtel.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["LAISO"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(2, {"qualifiedName":"LAISO","ddicName":"LAISO"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/land1.dtel.mjs":
/*!*******************************!*\
  !*** ./output/land1.dtel.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["LAND1"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(3, {"qualifiedName":"LAND1","ddicName":"LAND1"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/langu.dtel.mjs":
/*!*******************************!*\
  !*** ./output/langu.dtel.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["LANGU"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(1, {"qualifiedName":"LANGU","ddicName":"LANGU"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/lvc_nokeyc.dtel.mjs":
/*!************************************!*\
  !*** ./output/lvc_nokeyc.dtel.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["LVC_NOKEYC"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(1, {"qualifiedName":"LVC_NOKEYC","ddicName":"LVC_NOKEYC"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/mandt.dtel.mjs":
/*!*******************************!*\
  !*** ./output/mandt.dtel.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["MANDT"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(3, {"qualifiedName":"MANDT","ddicName":"MANDT"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/match_result.tabl.mjs":
/*!**************************************!*\
  !*** ./output/match_result.tabl.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["MATCH_RESULT"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"line": new abap.types.Integer({qualifiedName: "I"}), "offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"}), "submatches": abap.types.TableFactory.construct(new abap.types.Structure({"offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"})}, "SUBMATCH_RESULT", "SUBMATCH_RESULT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SUBMATCH_RESULT_TAB")}, "MATCH_RESULT", "MATCH_RESULT", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/match_result_tab.ttyp.mjs":
/*!******************************************!*\
  !*** ./output/match_result_tab.ttyp.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["MATCH_RESULT_TAB"] = {
  "objectType": "TTYP",
  "type": abap.types.TableFactory.construct(new abap.types.Structure({"line": new abap.types.Integer({qualifiedName: "I"}), "offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"}), "submatches": abap.types.TableFactory.construct(new abap.types.Structure({"offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"})}, "SUBMATCH_RESULT", "SUBMATCH_RESULT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SUBMATCH_RESULT_TAB")}, "MATCH_RESULT", "MATCH_RESULT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "MATCH_RESULT_TAB"),
};

/***/ }),

/***/ "./output/matnr.dtel.mjs":
/*!*******************************!*\
  !*** ./output/matnr.dtel.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["MATNR"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(40, {"qualifiedName":"MATNR","ddicName":"MATNR"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/meins.dtel.mjs":
/*!*******************************!*\
  !*** ./output/meins.dtel.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["MEINS"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(3, {"qualifiedName":"MEINS","ddicName":"MEINS"}),
  "domain": "MEINS",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/menge_d.dtel.mjs":
/*!*********************************!*\
  !*** ./output/menge_d.dtel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["MENGE_D"] = {
  "objectType": "DTEL",
  "type": new abap.types.Packed({length: 13, decimals: 3, qualifiedName: "MENGE_D"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/msehi.dtel.mjs":
/*!*******************************!*\
  !*** ./output/msehi.dtel.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["MSEHI"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(3, {"qualifiedName":"MSEHI","ddicName":"MSEHI"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/number_get_next.fugr.number_get_next.mjs":
/*!*********************************************************!*\
  !*** ./output/number_get_next.fugr.number_get_next.mjs ***!
  \*********************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// number_get_next.fugr.number_get_next.abap
async function number_get_next(INPUT) {
  // importing NR_RANGE_NR undefined false
  let nr_range_nr = INPUT.exporting?.nr_range_nr;
  // importing OBJECT undefined false
  let object = INPUT.exporting?.object;
  // exporting NUMBER undefined true
  let number = INPUT.importing?.number;
  if (number === undefined) {
      number = new abap.types.Character(4);
  }
  await abap.Classes['KERNEL_NUMBERRANGE'].number_get({nr_range_nr: nr_range_nr, object: object, number: number});
  abap.builtin.sy.get().subrc.set(abap.IntegerFactory.get(0));
}
abap.FunctionModules['NUMBER_GET_NEXT'] = number_get_next;
//# sourceMappingURL=number_get_next.fugr.number_get_next.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/numc4.dtel.mjs":
/*!*******************************!*\
  !*** ./output/numc4.dtel.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["NUMC4"] = {
  "objectType": "DTEL",
  "type": new abap.types.Numc({length: 4, qualifiedName: "NUMC4"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/openabap.fugr.call_v1_ping.mjs":
/*!***********************************************!*\
  !*** ./output/openabap.fugr.call_v1_ping.mjs ***!
  \***********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// openabap.fugr.call_v1_ping.abap
async function call_v1_ping(INPUT) {
}
abap.FunctionModules['CALL_V1_PING'] = call_v1_ping;
//# sourceMappingURL=openabap.fugr.call_v1_ping.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/openabap.fugr.conversion_exit_alpha_input.mjs":
/*!**************************************************************!*\
  !*** ./output/openabap.fugr.conversion_exit_alpha_input.mjs ***!
  \**************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// openabap.fugr.conversion_exit_alpha_input.abap
async function conversion_exit_alpha_input(INPUT) {
  // importing INPUT CLIKE false
  let input = INPUT.exporting?.input;
  // exporting OUTPUT CLIKE true
  let output = INPUT.importing?.output;
  if (output === undefined) {
      output = new abap.types.Character();
  }
  let lv_len = new abap.types.Integer({qualifiedName: "I"});
  let lv_type = new abap.types.Character(1, {});
  let lv_tmp = new abap.types.String({qualifiedName: "STRING"});
  lv_tmp.set(input);
  abap.statements.condense(lv_tmp, {nogaps: false});
  abap.statements.describe({field: input, type: lv_type});
  if (abap.compare.eq(lv_type, new abap.types.Character(1).set('g')) || abap.compare.eq(lv_type, new abap.types.Character(1).set('D'))) {
    abap.statements.describe({field: output, type: lv_type});
    if (abap.compare.eq(lv_type, new abap.types.Character(1).set('g')) || abap.compare.eq(lv_type, new abap.types.Character(1).set('D'))) {
      output.set(input);
      return;
    }
    abap.statements.describe({field: output, length: lv_len, mode: 'CHARACTER'});
  } else {
    abap.statements.describe({field: input, length: lv_len, mode: 'CHARACTER'});
  }
  if (abap.compare.initial(lv_tmp)) {
    abap.statements.clear(output);
    return;
  }
  const indexBackup1 = abap.builtin.sy.get().index.get();
  const unique32 = abap.operators.minus(lv_len.get(),abap.builtin.strlen({val: lv_tmp}).get()).get();
  for (let unique33 = 0; unique33 < unique32; unique33++) {
    abap.builtin.sy.get().index.set(unique33 + 1);
    lv_tmp.set(abap.operators.concat(new abap.types.String().set(`0`),lv_tmp));
  }
  abap.builtin.sy.get().index.set(indexBackup1);
  output.set(lv_tmp);
}
abap.FunctionModules['CONVERSION_EXIT_ALPHA_INPUT'] = conversion_exit_alpha_input;
//# sourceMappingURL=openabap.fugr.conversion_exit_alpha_input.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/openabap.fugr.conversion_exit_alpha_output.mjs":
/*!***************************************************************!*\
  !*** ./output/openabap.fugr.conversion_exit_alpha_output.mjs ***!
  \***************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// openabap.fugr.conversion_exit_alpha_output.abap
async function conversion_exit_alpha_output(INPUT) {
  // importing INPUT CLIKE false
  let input = INPUT.exporting?.input;
  // exporting OUTPUT CLIKE true
  let output = INPUT.importing?.output;
  if (output === undefined) {
      output = new abap.types.Character();
  }
  output.set(input);
  abap.statements.shift(output, {direction: 'LEFT',deletingLeading: new abap.types.Character(1).set('0')});
  const indexBackup1 = abap.builtin.sy.get().index.get();
  const unique34 = abap.operators.minus(abap.builtin.strlen({val: input}),abap.builtin.strlen({val: output}).get()).get();
  for (let unique35 = 0; unique35 < unique34; unique35++) {
    abap.builtin.sy.get().index.set(unique35 + 1);
    output.set(abap.operators.concat(output,new abap.types.String().set(` `)));
  }
  abap.builtin.sy.get().index.set(indexBackup1);
}
abap.FunctionModules['CONVERSION_EXIT_ALPHA_OUTPUT'] = conversion_exit_alpha_output;
//# sourceMappingURL=openabap.fugr.conversion_exit_alpha_output.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/openabap.fugr.conversion_exit_isola_input.mjs":
/*!**************************************************************!*\
  !*** ./output/openabap.fugr.conversion_exit_isola_input.mjs ***!
  \**************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// openabap.fugr.conversion_exit_isola_input.abap
async function conversion_exit_isola_input(INPUT) {
  // importing INPUT undefined false
  let input = INPUT.exporting?.input;
  // exporting OUTPUT undefined true
  let output = INPUT.importing?.output;
  if (output === undefined) {
      output = new abap.types.Character(4);
  }
  output.set((await abap.Classes['CL_I18N_LANGUAGES'].sap2_to_sap1({im_lang_sap2: input})));
  if (abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(1))) {
    throw new abap.ClassicError({classic: "unknown_language"});
  }
}
abap.FunctionModules['CONVERSION_EXIT_ISOLA_INPUT'] = conversion_exit_isola_input;
//# sourceMappingURL=openabap.fugr.conversion_exit_isola_input.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/openabap.fugr.conversion_exit_isola_output.mjs":
/*!***************************************************************!*\
  !*** ./output/openabap.fugr.conversion_exit_isola_output.mjs ***!
  \***************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// openabap.fugr.conversion_exit_isola_output.abap
async function conversion_exit_isola_output(INPUT) {
  // importing INPUT undefined false
  let input = INPUT.exporting?.input;
  // exporting OUTPUT undefined true
  let output = INPUT.importing?.output;
  if (output === undefined) {
      output = new abap.types.Character(4);
  }
  try {
    output.set(await abap.Classes['CL_I18N_LANGUAGES'].sap1_to_sap2({im_lang_sap1: input}));
    abap.builtin.sy.get().subrc.set(0);
  } catch (e) {
    if (e.classic) {
        switch (e.classic.toUpperCase()) {
        case "NO_ASSIGNMENT": abap.builtin.sy.get().subrc.set(1); break;
        default: abap.builtin.sy.get().subrc.set(2); break;
          }
      } else {
          throw e;
      }
    }
  }
  abap.FunctionModules['CONVERSION_EXIT_ISOLA_OUTPUT'] = conversion_exit_isola_output;
//# sourceMappingURL=openabap.fugr.conversion_exit_isola_output.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/openabap.fugr.convert_itf_to_stream_text.mjs":
/*!*************************************************************!*\
  !*** ./output/openabap.fugr.convert_itf_to_stream_text.mjs ***!
  \*************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// openabap.fugr.convert_itf_to_stream_text.abap
async function convert_itf_to_stream_text(INPUT) {
  // importing LF undefined false
  let lf = INPUT.exporting?.lf;
  // exporting STREAM_LINES STRING_TABLE true
  let stream_lines = INPUT.importing?.stream_lines;
  if (stream_lines === undefined) {
      stream_lines = abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "STRING_TABLE");
  }
  // tables ITF_TEXT TLINE false
  let itf_text = INPUT.tables?.itf_text;
  // tables TEXT_STREAM undefined true
  let text_stream = INPUT.tables?.text_stream;
  if (text_stream === undefined) {
      text_stream = abap.types.TableFactory.construct(new abap.types.Character(4), {"withHeader":true,"keyType":"DEFAULT"});
  }
  abap.statements.clear(stream_lines);
  abap.statements.clear(text_stream);
  if (abap.compare.eq(abap.builtin.lines({val: itf_text}), abap.IntegerFactory.get(0))) {
    return;
  }
  abap.statements.assert(abap.compare.eq(new abap.types.Character(4).set('todo'), abap.IntegerFactory.get(1)));
}
abap.FunctionModules['CONVERT_ITF_TO_STREAM_TEXT'] = convert_itf_to_stream_text;
//# sourceMappingURL=openabap.fugr.convert_itf_to_stream_text.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/openabap.fugr.docu_get.mjs":
/*!*******************************************!*\
  !*** ./output/openabap.fugr.docu_get.mjs ***!
  \*******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// openabap.fugr.docu_get.abap
async function docu_get(INPUT) {
  // importing ID undefined false
  let id = INPUT.exporting?.id;
  // importing LANGU undefined false
  let langu = INPUT.exporting?.langu;
  // importing OBJECT undefined false
  let object = INPUT.exporting?.object;
  // importing TYP undefined false
  let typ = INPUT.exporting?.typ;
  // tables LINE TLINE false
  let line = INPUT.tables?.line;
  abap.statements.clear(line);
  if (abap.compare.eq(id, new abap.types.Character(2).set('NA')) && abap.compare.eq(object, new abap.types.Character(5).set('00001'))) {
    return;
  }
  console.dir(INPUT);
  abap.statements.assert(abap.compare.eq(new abap.types.Character(4).set('todo'), abap.IntegerFactory.get(1)));
}
abap.FunctionModules['DOCU_GET'] = docu_get;
//# sourceMappingURL=openabap.fugr.docu_get.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/openabap.fugr.function_exists.mjs":
/*!**************************************************!*\
  !*** ./output/openabap.fugr.function_exists.mjs ***!
  \**************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// openabap.fugr.function_exists.abap
async function function_exists(INPUT) {
  // importing FUNCNAME CHAR30 false
  let funcname = INPUT.exporting?.funcname;
  let lv_name = new abap.types.String({qualifiedName: "STRING"});
  let lv_exists = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
  lv_name.set(funcname);
  abap.statements.condense(lv_name, {nogaps: false});
  lv_exists.set(abap.FunctionModules[lv_name.get()] === undefined ? " " : "X");
  if (abap.compare.eq(lv_exists, abap.builtin.abap_false)) {
    throw new abap.ClassicError({classic: "function_not_exist"});
  }
}
abap.FunctionModules['FUNCTION_EXISTS'] = function_exists;
//# sourceMappingURL=openabap.fugr.function_exists.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/openabap.fugr.generate_sec_random.mjs":
/*!******************************************************!*\
  !*** ./output/openabap.fugr.generate_sec_random.mjs ***!
  \******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// openabap.fugr.generate_sec_random.abap
async function generate_sec_random(INPUT) {
  // importing LENGTH I false
  let length = INPUT.exporting?.length;
  // exporting RANDOM XSTRING true
  let random = INPUT.importing?.random;
  if (random === undefined) {
      random = new abap.types.XString({qualifiedName: "XSTRING"});
  }
  abap.statements.assert(abap.compare.gt(length, abap.IntegerFactory.get(0)));
  const crypto = await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_crypto-browserify_index_js"), __webpack_require__.e("_d546-_8131-_3fc0-_cd53-_4068-_e7e4-_7bec-_0aec-_dbd9-_fbf1-_75ad-_6552-_1dfd-_ed1b-_b483-_d1-da8ac5")]).then(__webpack_require__.t.bind(__webpack_require__, /*! crypto */ "./node_modules/crypto-browserify/index.js", 19));
  random.set(crypto.randomBytes(length.get()).toString("hex").toUpperCase());
}
abap.FunctionModules['GENERATE_SEC_RANDOM'] = generate_sec_random;
//# sourceMappingURL=openabap.fugr.generate_sec_random.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/openabap.fugr.get_system_timezone.mjs":
/*!******************************************************!*\
  !*** ./output/openabap.fugr.get_system_timezone.mjs ***!
  \******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// openabap.fugr.get_system_timezone.abap
async function get_system_timezone(INPUT) {
  // exporting TIMEZONE TIMEZONE true
  let timezone = INPUT.importing?.timezone;
  if (timezone === undefined) {
      timezone = new abap.types.Character(6, {"qualifiedName":"TIMEZONE","ddicName":"TIMEZONE"});
  }
  timezone.set(new abap.types.Character(3).set('UTC'));
}
abap.FunctionModules['GET_SYSTEM_TIMEZONE'] = get_system_timezone;
//# sourceMappingURL=openabap.fugr.get_system_timezone.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/openabap.fugr.system_callstack.mjs":
/*!***************************************************!*\
  !*** ./output/openabap.fugr.system_callstack.mjs ***!
  \***************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// openabap.fugr.system_callstack.abap
async function system_callstack(INPUT) {
  // exporting CALLSTACK ABAP_CALLSTACK true
  let callstack = INPUT.importing?.callstack;
  if (callstack === undefined) {
      callstack = abap.types.TableFactory.construct(new abap.types.Structure({"mainprogram": new abap.types.Character(40, {}), "include": new abap.types.Character(40, {}), "line": new abap.types.Integer({qualifiedName: "I"}), "blocktype": new abap.types.Character(12, {}), "blockname": new abap.types.String({qualifiedName: "STRING"})}, "ABAP_CALLSTACK_LINE", "ABAP_CALLSTACK_LINE", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "ABAP_CALLSTACK");
  }
  let fs_fs_ = new abap.types.FieldSymbol(new abap.types.Structure({"mainprogram": new abap.types.Character(40, {}), "include": new abap.types.Character(40, {}), "line": new abap.types.Integer({qualifiedName: "I"}), "blocktype": new abap.types.Character(12, {}), "blockname": new abap.types.String({qualifiedName: "STRING"})}, "ABAP_CALLSTACK_LINE", "ABAP_CALLSTACK_LINE", {}, {}));
  fs_fs_.assign(callstack.appendInitial());
  fs_fs_.get().mainprogram.set(new abap.types.Character(5).set('ZTODO'));
  fs_fs_.get().include.set(new abap.types.Character(5).set('ZTODO'));
  fs_fs_.get().line.set(new abap.types.Character(3).set('123'));
}
abap.FunctionModules['SYSTEM_CALLSTACK'] = system_callstack;
//# sourceMappingURL=openabap.fugr.system_callstack.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/openabap.fugr.system_installed_languages.mjs":
/*!*************************************************************!*\
  !*** ./output/openabap.fugr.system_installed_languages.mjs ***!
  \*************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// openabap.fugr.system_installed_languages.abap
async function system_installed_languages(INPUT) {
  // exporting LANGUAGES undefined true
  let languages = INPUT.importing?.languages;
  if (languages === undefined) {
      languages = new abap.types.Character(4);
  }
  languages.set(abap.builtin.sy.get().langu);
  abap.builtin.sy.get().subrc.set(abap.IntegerFactory.get(0));
}
abap.FunctionModules['SYSTEM_INSTALLED_LANGUAGES'] = system_installed_languages;
//# sourceMappingURL=openabap.fugr.system_installed_languages.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/openabap.fugr.text_split.mjs":
/*!*********************************************!*\
  !*** ./output/openabap.fugr.text_split.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// openabap.fugr.text_split.abap
async function text_split(INPUT) {
  // importing LENGTH undefined false
  let length = INPUT.exporting?.length;
  // importing TEXT undefined false
  let text = INPUT.exporting?.text;
  // exporting LINE undefined true
  let line = INPUT.importing?.line;
  if (line === undefined) {
      line = new abap.types.Character(4);
  }
  // exporting REST undefined true
  let rest = INPUT.importing?.rest;
  if (rest === undefined) {
      rest = new abap.types.Character(4);
  }
  if (abap.compare.lt(abap.builtin.strlen({val: text}), abap.IntegerFactory.get(50))) {
    line.set(text);
    rest.set(new abap.types.Character(1).set(''));
  } else {
    line.set(text.getOffset({length: 50}));
    rest.set(text.getOffset({offset: 50}));
    abap.statements.condense(rest, {nogaps: false});
  }
}
abap.FunctionModules['TEXT_SPLIT'] = text_split;
//# sourceMappingURL=openabap.fugr.text_split.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/openabap.fugr.unit_conversion_simple.mjs":
/*!*********************************************************!*\
  !*** ./output/openabap.fugr.unit_conversion_simple.mjs ***!
  \*********************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// openabap.fugr.unit_conversion_simple.abap
async function unit_conversion_simple(INPUT) {
  // importing INPUT undefined false
  let input = INPUT.exporting?.input;
  // importing UNIT_IN MSEHI true
  let unit_in = INPUT.exporting?.unit_in;
  if (unit_in === undefined) {
      unit_in = new abap.types.Character(3, {"qualifiedName":"MSEHI","ddicName":"MSEHI"});
  }
  // importing UNIT_OUT MSEHI true
  let unit_out = INPUT.exporting?.unit_out;
  if (unit_out === undefined) {
      unit_out = new abap.types.Character(3, {"qualifiedName":"MSEHI","ddicName":"MSEHI"});
  }
  // exporting OUTPUT undefined true
  let output = INPUT.importing?.output;
  if (output === undefined) {
      output = new abap.types.Character(4);
  }
  let lv_float = new abap.types.Float({qualifiedName: "F"});
  if (abap.compare.eq(unit_in, unit_out)) {
    output.set(input);
  } else if (abap.compare.eq(unit_in, new abap.types.Character(1).set('G')) && abap.compare.eq(unit_out, new abap.types.Character(2).set('KG'))) {
    output.set(abap.operators.divide(input,new abap.types.Integer().set(1000)));
  } else if (abap.compare.eq(unit_in, new abap.types.Character(2).set('M3')) && abap.compare.eq(unit_out, new abap.types.Character(3).set('CDM'))) {
    output.set(abap.operators.multiply(input,new abap.types.Integer().set(1000)));
  } else if (abap.compare.eq(unit_in, new abap.types.Character(2).set('LB')) && abap.compare.eq(unit_out, new abap.types.Character(2).set('KG'))) {
    lv_float.set(new abap.types.Character(10).set('0.45359237'));
    output.set(abap.operators.multiply(input,lv_float));
  } else if (abap.compare.eq(unit_in, new abap.types.Character(3).set('CCM')) && abap.compare.eq(unit_out, new abap.types.Character(3).set('CDM'))) {
    output.set(abap.operators.divide(input,new abap.types.Integer().set(1000)));
  } else if (abap.compare.eq(unit_in, new abap.types.Character(3).set('FT3')) && abap.compare.eq(unit_out, new abap.types.Character(3).set('CDM'))) {
    lv_float.set(new abap.types.Character(14).set('28.31684660923'));
    output.set(abap.operators.multiply(input,lv_float));
  } else {
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), abap.IntegerFactory.get(2)));
  }
}
abap.FunctionModules['UNIT_CONVERSION_SIMPLE'] = unit_conversion_simple;
//# sourceMappingURL=openabap.fugr.unit_conversion_simple.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/reposrc.tabl.mjs":
/*!*********************************!*\
  !*** ./output/reposrc.tabl.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["REPOSRC"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"progname": new abap.types.Character(40, {}), "data": new abap.types.String({qualifiedName: "STRING"}), "unam": new abap.types.Character(12, {}), "udat": new abap.types.Date(), "utime": new abap.types.Time()}, "REPOSRC", "REPOSRC", {}, {}),
  "keyFields": ["PROGNAME"],
};

/***/ }),

/***/ "./output/rfcdest.dtel.mjs":
/*!*********************************!*\
  !*** ./output/rfcdest.dtel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["RFCDEST"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(32, {"qualifiedName":"RFCDEST","ddicName":"RFCDEST"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/scrtext_l.dtel.mjs":
/*!***********************************!*\
  !*** ./output/scrtext_l.dtel.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SCRTEXT_L"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(40, {"qualifiedName":"SCRTEXT_L","ddicName":"SCRTEXT_L"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/scrtext_m.dtel.mjs":
/*!***********************************!*\
  !*** ./output/scrtext_m.dtel.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SCRTEXT_M"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(20, {"qualifiedName":"SCRTEXT_M","ddicName":"SCRTEXT_M"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/scrtext_s.dtel.mjs":
/*!***********************************!*\
  !*** ./output/scrtext_s.dtel.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SCRTEXT_S"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(10, {"qualifiedName":"SCRTEXT_S","ddicName":"SCRTEXT_S"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/scx_attrname.dtel.mjs":
/*!**************************************!*\
  !*** ./output/scx_attrname.dtel.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SCX_ATTRNAME"] = {
  "objectType": "DTEL",
  "type": new abap.types.String({qualifiedName: "SCX_ATTRNAME"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/scx_t100key.tabl.mjs":
/*!*************************************!*\
  !*** ./output/scx_t100key.tabl.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SCX_T100KEY"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"msgid": new abap.types.Character(20, {}), "msgno": new abap.types.Numc({length: 3}), "attr1": new abap.types.Character(255, {}), "attr2": new abap.types.Character(255, {}), "attr3": new abap.types.Character(255, {}), "attr4": new abap.types.Character(255, {})}, "SCX_T100KEY", "SCX_T100KEY", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/sdok_class.dtel.mjs":
/*!************************************!*\
  !*** ./output/sdok_class.dtel.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SDOK_CLASS"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}),
  "domain": "SDOK_CLASS",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/sdok_docid.dtel.mjs":
/*!************************************!*\
  !*** ./output/sdok_docid.dtel.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SDOK_DOCID"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"}),
  "domain": "SDOK_DOCID",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/sdokobject.tabl.mjs":
/*!************************************!*\
  !*** ./output/sdokobject.tabl.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SDOKOBJECT"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SDOKOBJECT", "SDOKOBJECT", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/seoclsname.dtel.mjs":
/*!************************************!*\
  !*** ./output/seoclsname.dtel.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SEOCLSNAME"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(30, {"qualifiedName":"SEOCLSNAME","ddicName":"SEOCLSNAME"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/shm_affect_server.dtel.mjs":
/*!*******************************************!*\
  !*** ./output/shm_affect_server.dtel.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SHM_AFFECT_SERVER"] = {
  "objectType": "DTEL",
  "type": new abap.types.Integer({qualifiedName: "SHM_AFFECT_SERVER"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/shm_area_name.dtel.mjs":
/*!***************************************!*\
  !*** ./output/shm_area_name.dtel.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SHM_AREA_NAME"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/shm_attach_mode.dtel.mjs":
/*!*****************************************!*\
  !*** ./output/shm_attach_mode.dtel.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SHM_ATTACH_MODE"] = {
  "objectType": "DTEL",
  "type": new abap.types.Integer({qualifiedName: "SHM_ATTACH_MODE"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/shm_auto_build_class_name.dtel.mjs":
/*!***************************************************!*\
  !*** ./output/shm_auto_build_class_name.dtel.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SHM_AUTO_BUILD_CLASS_NAME"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(30, {"qualifiedName":"SHM_AUTO_BUILD_CLASS_NAME","ddicName":"SHM_AUTO_BUILD_CLASS_NAME"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/shm_client.dtel.mjs":
/*!************************************!*\
  !*** ./output/shm_client.dtel.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SHM_CLIENT"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(3, {"qualifiedName":"SHM_CLIENT","ddicName":"SHM_CLIENT"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/shm_constr_invocation_mode.dtel.mjs":
/*!****************************************************!*\
  !*** ./output/shm_constr_invocation_mode.dtel.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SHM_CONSTR_INVOCATION_MODE"] = {
  "objectType": "DTEL",
  "type": new abap.types.Integer({qualifiedName: "SHM_CONSTR_INVOCATION_MODE"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/shm_inst_info.tabl.mjs":
/*!***************************************!*\
  !*** ./output/shm_inst_info.tabl.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SHM_INST_INFO"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"client": new abap.types.Character(3, {"qualifiedName":"MANDT","ddicName":"MANDT"}), "name": new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"})}, "SHM_INST_INFO", "SHM_INST_INFO", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/shm_inst_infos.ttyp.mjs":
/*!****************************************!*\
  !*** ./output/shm_inst_infos.ttyp.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SHM_INST_INFOS"] = {
  "objectType": "TTYP",
  "type": abap.types.TableFactory.construct(new abap.types.Structure({"client": new abap.types.Character(3, {"qualifiedName":"MANDT","ddicName":"MANDT"}), "name": new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"})}, "SHM_INST_INFO", "SHM_INST_INFO", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SHM_INST_INFOS"),
};

/***/ }),

/***/ "./output/shm_inst_name.dtel.mjs":
/*!***************************************!*\
  !*** ./output/shm_inst_name.dtel.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SHM_INST_NAME"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(80, {"qualifiedName":"SHM_INST_NAME","ddicName":"SHM_INST_NAME"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/shm_life_context.dtel.mjs":
/*!******************************************!*\
  !*** ./output/shm_life_context.dtel.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SHM_LIFE_CONTEXT"] = {
  "objectType": "DTEL",
  "type": new abap.types.Integer({qualifiedName: "SHM_LIFE_CONTEXT"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/shm_properties.tabl.mjs":
/*!****************************************!*\
  !*** ./output/shm_properties.tabl.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SHM_PROPERTIES"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"auto_build": new abap.types.Character(1, {}), "has_versions": new abap.types.Character(1, {})}, "SHM_PROPERTIES", "SHM_PROPERTIES", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/shm_rc.dtel.mjs":
/*!********************************!*\
  !*** ./output/shm_rc.dtel.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SHM_RC"] = {
  "objectType": "DTEL",
  "type": new abap.types.Integer({qualifiedName: "SHM_RC"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/shma_attributes.tabl.mjs":
/*!*****************************************!*\
  !*** ./output/shma_attributes.tabl.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SHMA_ATTRIBUTES"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"area_name": new abap.types.Character(30, {"qualifiedName":"SHM_AREA_NAME","ddicName":"SHM_AREA_NAME"}), "properties": new abap.types.Structure({"auto_build": new abap.types.Character(1, {}), "has_versions": new abap.types.Character(1, {})}, "SHM_PROPERTIES", "SHM_PROPERTIES", {}, {}), "auto_build": new abap.types.Character(1, {}), "has_versions": new abap.types.Character(1, {})}, "SHMA_ATTRIBUTES", "SHMA_ATTRIBUTES", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/shma_client.dtel.mjs":
/*!*************************************!*\
  !*** ./output/shma_client.dtel.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SHMA_CLIENT"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(3, {"qualifiedName":"SHMA_CLIENT","ddicName":"SHMA_CLIENT"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/shmm_trc_variant_name.dtel.mjs":
/*!***********************************************!*\
  !*** ./output/shmm_trc_variant_name.dtel.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SHMM_TRC_VARIANT_NAME"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(32, {"qualifiedName":"SHMM_TRC_VARIANT_NAME","ddicName":"SHMM_TRC_VARIANT_NAME"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/skwf_io.tabl.mjs":
/*!*********************************!*\
  !*** ./output/skwf_io.tabl.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SKWF_IO"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"objtype": new abap.types.Character(1, {"qualifiedName":"SKWF_IOTY","ddicName":"SKWF_IOTY"}), "object": new abap.types.Structure({"class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SDOKOBJECT", "SDOKOBJECT", {}, {}), "class": new abap.types.Character(10, {"qualifiedName":"SDOK_CLASS","ddicName":"SDOK_CLASS"}), "objid": new abap.types.Character(32, {"qualifiedName":"SDOK_DOCID","ddicName":"SDOK_DOCID"})}, "SKWF_IO", "SKWF_IO", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/skwf_ioty.dtel.mjs":
/*!***********************************!*\
  !*** ./output/skwf_ioty.dtel.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SKWF_IOTY"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(1, {"qualifiedName":"SKWF_IOTY","ddicName":"SKWF_IOTY"}),
  "domain": "SKWF_IOTY",
  "fixedValues": [{"description":"Undefined (= all)","language":"E"},{"description":"Directory","low":"F","language":"E"},{"description":"LOIO","low":"L","language":"E"},{"description":"PHIO","low":"P","language":"E"},{"description":"Relationship","low":"R","language":"E"}],
};

/***/ }),

/***/ "./output/so_raw255.dtel.mjs":
/*!***********************************!*\
  !*** ./output/so_raw255.dtel.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SO_RAW255"] = {
  "objectType": "DTEL",
  "type": new abap.types.Hex({length: 255}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/so_text255.dtel.mjs":
/*!************************************!*\
  !*** ./output/so_text255.dtel.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SO_TEXT255"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(255, {"qualifiedName":"SO_TEXT255","ddicName":"SO_TEXT255"}),
  "domain": "SO_TEXT255",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/soli.tabl.mjs":
/*!******************************!*\
  !*** ./output/soli.tabl.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SOLI"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"line": new abap.types.Character(255, {"qualifiedName":"SO_TEXT255","ddicName":"SO_TEXT255"})}, "SOLI", "SOLI", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/soli_tab.ttyp.mjs":
/*!**********************************!*\
  !*** ./output/soli_tab.ttyp.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SOLI_TAB"] = {
  "objectType": "TTYP",
  "type": abap.types.TableFactory.construct(new abap.types.Structure({"line": new abap.types.Character(255, {"qualifiedName":"SO_TEXT255","ddicName":"SO_TEXT255"})}, "SOLI", "SOLI", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SOLI_TAB"),
};

/***/ }),

/***/ "./output/solix.tabl.mjs":
/*!*******************************!*\
  !*** ./output/solix.tabl.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SOLIX"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"line": new abap.types.Hex({length: 255})}, "SOLIX", "SOLIX", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/solix_tab.ttyp.mjs":
/*!***********************************!*\
  !*** ./output/solix_tab.ttyp.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SOLIX_TAB"] = {
  "objectType": "TTYP",
  "type": abap.types.TableFactory.construct(new abap.types.Structure({"line": new abap.types.Hex({length: 255})}, "SOLIX", "SOLIX", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SOLIX_TAB"),
};

/***/ }),

/***/ "./output/sotr_conc.dtel.mjs":
/*!***********************************!*\
  !*** ./output/sotr_conc.dtel.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SOTR_CONC"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(32, {"qualifiedName":"SOTR_CONC","ddicName":"SOTR_CONC"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/spras.dtel.mjs":
/*!*******************************!*\
  !*** ./output/spras.dtel.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SPRAS"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(1, {"qualifiedName":"SPRAS","ddicName":"SPRAS"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/ssfapplssl.dtel.mjs":
/*!************************************!*\
  !*** ./output/ssfapplssl.dtel.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SSFAPPLSSL"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(6, {"qualifiedName":"SSFAPPLSSL","ddicName":"SSFAPPLSSL"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/sstmnt.tabl.mjs":
/*!********************************!*\
  !*** ./output/sstmnt.tabl.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SSTMNT"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"level": new abap.types.Integer({qualifiedName: "I"}), "struc": new abap.types.Integer({qualifiedName: "I"}), "from": new abap.types.Integer({qualifiedName: "I"}), "to": new abap.types.Integer({qualifiedName: "I"}), "number": new abap.types.Integer({qualifiedName: "I"}), "colonrow": new abap.types.Integer({qualifiedName: "I"}), "trow": new abap.types.Integer({qualifiedName: "I"}), "coloncol": new abap.types.Integer({qualifiedName: "I"}), "tcol": new abap.types.Integer({qualifiedName: "I"}), "prefixlen": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {}), "terminator": new abap.types.Character(1, {}), "enhmt": new abap.types.Integer({qualifiedName: "I"})}, "SSTMNT", "SSTMNT", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/sstmnt_tab.ttyp.mjs":
/*!************************************!*\
  !*** ./output/sstmnt_tab.ttyp.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SSTMNT_TAB"] = {
  "objectType": "TTYP",
  "type": abap.types.TableFactory.construct(new abap.types.Structure({"level": new abap.types.Integer({qualifiedName: "I"}), "struc": new abap.types.Integer({qualifiedName: "I"}), "from": new abap.types.Integer({qualifiedName: "I"}), "to": new abap.types.Integer({qualifiedName: "I"}), "number": new abap.types.Integer({qualifiedName: "I"}), "colonrow": new abap.types.Integer({qualifiedName: "I"}), "trow": new abap.types.Integer({qualifiedName: "I"}), "coloncol": new abap.types.Integer({qualifiedName: "I"}), "tcol": new abap.types.Integer({qualifiedName: "I"}), "prefixlen": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {}), "terminator": new abap.types.Character(1, {}), "enhmt": new abap.types.Integer({qualifiedName: "I"})}, "SSTMNT", "SSTMNT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SSTMNT_TAB"),
};

/***/ }),

/***/ "./output/sstruc.tabl.mjs":
/*!********************************!*\
  !*** ./output/sstruc.tabl.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SSTRUC"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"type": new abap.types.Character(1, {}), "stmnt_type": new abap.types.Character(1, {}), "key_start": new abap.types.Character(1, {}), "key_end": new abap.types.Character(1, {}), "stmnt_from": new abap.types.Integer({qualifiedName: "I"}), "stmnt_to": new abap.types.Integer({qualifiedName: "I"}), "struc_from": new abap.types.Integer({qualifiedName: "I"}), "struc_to": new abap.types.Integer({qualifiedName: "I"}), "back": new abap.types.Integer({qualifiedName: "I"})}, "SSTRUC", "SSTRUC", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/sstruc_tab.ttyp.mjs":
/*!************************************!*\
  !*** ./output/sstruc_tab.ttyp.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SSTRUC_TAB"] = {
  "objectType": "TTYP",
  "type": abap.types.TableFactory.construct(new abap.types.Structure({"type": new abap.types.Character(1, {}), "stmnt_type": new abap.types.Character(1, {}), "key_start": new abap.types.Character(1, {}), "key_end": new abap.types.Character(1, {}), "stmnt_from": new abap.types.Integer({qualifiedName: "I"}), "stmnt_to": new abap.types.Integer({qualifiedName: "I"}), "struc_from": new abap.types.Integer({qualifiedName: "I"}), "struc_to": new abap.types.Integer({qualifiedName: "I"}), "back": new abap.types.Integer({qualifiedName: "I"})}, "SSTRUC", "SSTRUC", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SSTRUC_TAB"),
};

/***/ }),

/***/ "./output/stokes.tabl.mjs":
/*!********************************!*\
  !*** ./output/stokes.tabl.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["STOKES"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"str": new abap.types.String({qualifiedName: "STRING"}), "row": new abap.types.Integer({qualifiedName: "I"}), "col": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {})}, "STOKES", "STOKES", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/stokes_tab.ttyp.mjs":
/*!************************************!*\
  !*** ./output/stokes_tab.ttyp.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["STOKES_TAB"] = {
  "objectType": "TTYP",
  "type": abap.types.TableFactory.construct(new abap.types.Structure({"str": new abap.types.String({qualifiedName: "STRING"}), "row": new abap.types.Integer({qualifiedName: "I"}), "col": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {})}, "STOKES", "STOKES", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "STOKES_TAB"),
};

/***/ }),

/***/ "./output/stokesx.tabl.mjs":
/*!*********************************!*\
  !*** ./output/stokesx.tabl.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["STOKESX"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"str": new abap.types.String({qualifiedName: "STRING"}), "row": new abap.types.Integer({qualifiedName: "I"}), "off2": new abap.types.Integer({qualifiedName: "I"}), "off3": new abap.types.Integer({qualifiedName: "I"}), "col": new abap.types.Integer({qualifiedName: "I"}), "len1": new abap.types.Integer({qualifiedName: "I"}), "len2": new abap.types.Integer({qualifiedName: "I"}), "len3": new abap.types.Integer({qualifiedName: "I"}), "type": new abap.types.Character(1, {})}, "STOKESX", "STOKESX", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/string_table.ttyp.mjs":
/*!**************************************!*\
  !*** ./output/string_table.ttyp.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["STRING_TABLE"] = {
  "objectType": "TTYP",
  "type": abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "STRING_TABLE"),
};

/***/ }),

/***/ "./output/stringtab.ttyp.mjs":
/*!***********************************!*\
  !*** ./output/stringtab.ttyp.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["STRINGTAB"] = {
  "objectType": "TTYP",
  "type": abap.types.TableFactory.construct(new abap.types.String({qualifiedName: "STRING"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "STRINGTAB"),
};

/***/ }),

/***/ "./output/submatch_result.tabl.mjs":
/*!*****************************************!*\
  !*** ./output/submatch_result.tabl.mjs ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SUBMATCH_RESULT"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"})}, "SUBMATCH_RESULT", "SUBMATCH_RESULT", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/submatch_result_tab.ttyp.mjs":
/*!*********************************************!*\
  !*** ./output/submatch_result_tab.ttyp.mjs ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SUBMATCH_RESULT_TAB"] = {
  "objectType": "TTYP",
  "type": abap.types.TableFactory.construct(new abap.types.Structure({"offset": new abap.types.Integer({qualifiedName: "I"}), "length": new abap.types.Integer({qualifiedName: "I"})}, "SUBMATCH_RESULT", "SUBMATCH_RESULT", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "SUBMATCH_RESULT_TAB"),
};

/***/ }),

/***/ "./output/sxco_fm_name.dtel.mjs":
/*!**************************************!*\
  !*** ./output/sxco_fm_name.dtel.mjs ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SXCO_FM_NAME"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(30, {"qualifiedName":"SXCO_FM_NAME","ddicName":"SXCO_FM_NAME"}),
  "domain": "",
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/sxco_transport.dtel.mjs":
/*!****************************************!*\
  !*** ./output/sxco_transport.dtel.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SXCO_TRANSPORT"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(20, {"qualifiedName":"SXCO_TRANSPORT","ddicName":"SXCO_TRANSPORT"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/sydate.dtel.mjs":
/*!********************************!*\
  !*** ./output/sydate.dtel.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SYDATE"] = {
  "objectType": "DTEL",
  "type": new abap.types.Date({qualifiedName: "SYDATE"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/symsg.tabl.mjs":
/*!*******************************!*\
  !*** ./output/symsg.tabl.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SYMSG"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"msgty": new abap.types.Character(1, {}), "msgid": new abap.types.Character(20, {}), "msgno": new abap.types.Numc({length: 3}), "msgv1": new abap.types.Character(50, {}), "msgv2": new abap.types.Character(50, {}), "msgv3": new abap.types.Character(50, {}), "msgv4": new abap.types.Character(50, {})}, "SYMSG", "SYMSG", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/symsgid.dtel.mjs":
/*!*********************************!*\
  !*** ./output/symsgid.dtel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SYMSGID"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(20, {"qualifiedName":"SYMSGID","ddicName":"SYMSGID"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/symsgno.dtel.mjs":
/*!*********************************!*\
  !*** ./output/symsgno.dtel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SYMSGNO"] = {
  "objectType": "DTEL",
  "type": new abap.types.Numc({length: 3, qualifiedName: "SYMSGNO"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/symsgty.dtel.mjs":
/*!*********************************!*\
  !*** ./output/symsgty.dtel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SYMSGTY"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(1, {"qualifiedName":"SYMSGTY","ddicName":"SYMSGTY"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/symsgv.dtel.mjs":
/*!********************************!*\
  !*** ./output/symsgv.dtel.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SYMSGV"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(50, {"qualifiedName":"SYMSGV","ddicName":"SYMSGV"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/syrepid.dtel.mjs":
/*!*********************************!*\
  !*** ./output/syrepid.dtel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SYREPID"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(40, {"qualifiedName":"SYREPID","ddicName":"SYREPID"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/syst_host.dtel.mjs":
/*!***********************************!*\
  !*** ./output/syst_host.dtel.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SYST_HOST"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(32, {"qualifiedName":"SYST_HOST","ddicName":"SYST_HOST"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/sysubrc.dtel.mjs":
/*!*********************************!*\
  !*** ./output/sysubrc.dtel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SYSUBRC"] = {
  "objectType": "DTEL",
  "type": new abap.types.Integer({qualifiedName: "SYSUBRC"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/sysuuid_c22.dtel.mjs":
/*!*************************************!*\
  !*** ./output/sysuuid_c22.dtel.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SYSUUID_C22"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(22, {"qualifiedName":"SYSUUID_C22","ddicName":"SYSUUID_C22"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/sysuuid_c32.dtel.mjs":
/*!*************************************!*\
  !*** ./output/sysuuid_c32.dtel.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SYSUUID_C32"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(32, {"qualifiedName":"SYSUUID_C32","ddicName":"SYSUUID_C32"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/sysuuid_c36.dtel.mjs":
/*!*************************************!*\
  !*** ./output/sysuuid_c36.dtel.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SYSUUID_C36"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(36, {"qualifiedName":"SYSUUID_C36","ddicName":"SYSUUID_C36"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/sysuuid_x16.dtel.mjs":
/*!*************************************!*\
  !*** ./output/sysuuid_x16.dtel.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SYSUUID_X16"] = {
  "objectType": "DTEL",
  "type": new abap.types.Hex({length: 16}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/syuname.dtel.mjs":
/*!*********************************!*\
  !*** ./output/syuname.dtel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["SYUNAME"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(12, {"qualifiedName":"SYUNAME","ddicName":"SYUNAME"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/t000.tabl.mjs":
/*!******************************!*\
  !*** ./output/t000.tabl.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["T000"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"mandt": new abap.types.Character(3, {}), "cccategory": new abap.types.Character(1, {}), "ccnocliind": new abap.types.Character(1, {}), "mtext": new abap.types.Character(25, {})}, "T000", "T000", {}, {}),
  "keyFields": ["MANDT"],
};

/***/ }),

/***/ "./output/t100.tabl.mjs":
/*!******************************!*\
  !*** ./output/t100.tabl.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["T100"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"sprsl": new abap.types.Character(1, {}), "arbgb": new abap.types.Character(20, {}), "msgnr": new abap.types.Character(3, {}), "text": new abap.types.Character(73, {})}, "T100", "T100", {}, {}),
  "keyFields": ["SPRSL","ARBGB","MSGNR"],
};

/***/ }),

/***/ "./output/tabfdpos.dtel.mjs":
/*!**********************************!*\
  !*** ./output/tabfdpos.dtel.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TABFDPOS"] = {
  "objectType": "DTEL",
  "type": new abap.types.Numc({length: 4, qualifiedName: "TABFDPOS"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/tabname.dtel.mjs":
/*!*********************************!*\
  !*** ./output/tabname.dtel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TABNAME"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(30, {"qualifiedName":"TABNAME","ddicName":"TABNAME"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/tadir.tabl.mjs":
/*!*******************************!*\
  !*** ./output/tadir.tabl.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TADIR"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"pgmid": new abap.types.Character(4, {}), "object": new abap.types.Character(4, {}), "obj_name": new abap.types.Character(40, {}), "devclass": new abap.types.Character(30, {"qualifiedName":"DEVCLASS","ddicName":"DEVCLASS"}), "korrnum": new abap.types.Character(10, {}), "delflag": new abap.types.Character(1, {}), "genflag": new abap.types.Character(1, {}), "srcsystem": new abap.types.Character(5, {}), "edtflag": new abap.types.Character(1, {}), "masterlang": new abap.types.Character(1, {})}, "TADIR", "TADIR", {}, {}),
  "keyFields": ["PGMID","OBJECT","OBJ_NAME"],
};

/***/ }),

/***/ "./output/tdevc.tabl.mjs":
/*!*******************************!*\
  !*** ./output/tdevc.tabl.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TDEVC"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"devclass": new abap.types.Character(30, {"qualifiedName":"DEVCLASS","ddicName":"DEVCLASS"}), "dlvunit": new abap.types.Character(30, {}), "component": new abap.types.Character(20, {}), "parentcl": new abap.types.Character(30, {}), "as4user": new abap.types.Character(12, {}), "created_by": new abap.types.Character(12, {}), "created_on": new abap.types.Date(), "ctext": new abap.types.Character(60, {}), "changed_by": new abap.types.Character(12, {}), "changed_on": new abap.types.Date(), "namespace": new abap.types.Character(10, {})}, "TDEVC", "TDEVC", {}, {}),
  "keyFields": ["DEVCLASS"],
};

/***/ }),

/***/ "./output/tdline.dtel.mjs":
/*!********************************!*\
  !*** ./output/tdline.dtel.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TDLINE"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(132, {"qualifiedName":"TDLINE","ddicName":"TDLINE"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/text20.dtel.mjs":
/*!********************************!*\
  !*** ./output/text20.dtel.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TEXT20"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(20, {"qualifiedName":"TEXT20","ddicName":"TEXT20"}),
  "domain": "TEXT20",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/text200.dtel.mjs":
/*!*********************************!*\
  !*** ./output/text200.dtel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TEXT200"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(200, {"qualifiedName":"TEXT200","ddicName":"TEXT200"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/text255.dtel.mjs":
/*!*********************************!*\
  !*** ./output/text255.dtel.mjs ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TEXT255"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(255, {"qualifiedName":"TEXT255","ddicName":"TEXT255"}),
  "domain": "TEXT255",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/text30.dtel.mjs":
/*!********************************!*\
  !*** ./output/text30.dtel.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TEXT30"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(30, {"qualifiedName":"TEXT30","ddicName":"TEXT30"}),
  "domain": "TEXT30",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/text80.dtel.mjs":
/*!********************************!*\
  !*** ./output/text80.dtel.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TEXT80"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(80, {"qualifiedName":"TEXT80","ddicName":"TEXT80"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/textpool.tabl.mjs":
/*!**********************************!*\
  !*** ./output/textpool.tabl.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TEXTPOOL"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"id": new abap.types.Character(1, {}), "key": new abap.types.Character(8, {}), "entry": new abap.types.Character(255, {}), "length": new abap.types.Integer({qualifiedName: "I"})}, "TEXTPOOL", "TEXTPOOL", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/tfdir.tabl.mjs":
/*!*******************************!*\
  !*** ./output/tfdir.tabl.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TFDIR"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"funcname": new abap.types.Character(30, {})}, "TFDIR", "TFDIR", {}, {}),
  "keyFields": ["FUNCNAME"],
};

/***/ }),

/***/ "./output/tihttpnvp.ttyp.mjs":
/*!***********************************!*\
  !*** ./output/tihttpnvp.ttyp.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TIHTTPNVP"] = {
  "objectType": "TTYP",
  "type": abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "STRING"}), "value": new abap.types.String({qualifiedName: "STRING"})}, "IHTTPNVP", "IHTTPNVP", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TIHTTPNVP"),
};

/***/ }),

/***/ "./output/timestamp.dtel.mjs":
/*!***********************************!*\
  !*** ./output/timestamp.dtel.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TIMESTAMP"] = {
  "objectType": "DTEL",
  "type": new abap.types.Packed({length: 15, decimals: 0, qualifiedName: "TIMESTAMP"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/timestampl.dtel.mjs":
/*!************************************!*\
  !*** ./output/timestampl.dtel.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TIMESTAMPL"] = {
  "objectType": "DTEL",
  "type": new abap.types.Packed({length: 21, decimals: 7, qualifiedName: "TIMESTAMPL"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/timezone.dtel.mjs":
/*!**********************************!*\
  !*** ./output/timezone.dtel.mjs ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TIMEZONE"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(6, {"qualifiedName":"TIMEZONE","ddicName":"TIMEZONE"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/timn.dtel.mjs":
/*!******************************!*\
  !*** ./output/timn.dtel.mjs ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TIMN"] = {
  "objectType": "DTEL",
  "type": new abap.types.Time({qualifiedName: "TIMN"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/tline.tabl.mjs":
/*!*******************************!*\
  !*** ./output/tline.tabl.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TLINE"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"tdformat": new abap.types.Character(2, {}), "tdline": new abap.types.Character(132, {})}, "TLINE", "TLINE", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/tline_tab.ttyp.mjs":
/*!***********************************!*\
  !*** ./output/tline_tab.ttyp.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TLINE_TAB"] = {
  "objectType": "TTYP",
  "type": abap.types.TableFactory.construct(new abap.types.Structure({"tdformat": new abap.types.Character(2, {}), "tdline": new abap.types.Character(132, {})}, "TLINE", "TLINE", {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"isUnique":false,"type":"STANDARD","keyFields":[],"name":"primary_key"},"secondary":[]}, "TLINE_TAB"),
};

/***/ }),

/***/ "./output/trfunction.dtel.mjs":
/*!************************************!*\
  !*** ./output/trfunction.dtel.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TRFUNCTION"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(1, {"qualifiedName":"TRFUNCTION","ddicName":"TRFUNCTION"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/trkorr.dtel.mjs":
/*!********************************!*\
  !*** ./output/trkorr.dtel.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TRKORR"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(20, {"qualifiedName":"TRKORR","ddicName":"TRKORR"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/tzntstmpl.dtel.mjs":
/*!***********************************!*\
  !*** ./output/tzntstmpl.dtel.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TZNTSTMPL"] = {
  "objectType": "DTEL",
  "type": new abap.types.Packed({length: 21, decimals: 7, qualifiedName: "TZNTSTMPL"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/tzntstmps.dtel.mjs":
/*!***********************************!*\
  !*** ./output/tzntstmps.dtel.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["TZNTSTMPS"] = {
  "objectType": "DTEL",
  "type": new abap.types.Packed({length: 15, decimals: 0, qualifiedName: "TZNTSTMPS"}),
  "domain": "TZNTSTMPS",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/uname.dtel.mjs":
/*!*******************************!*\
  !*** ./output/uname.dtel.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["UNAME"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(12, {"qualifiedName":"UNAME","ddicName":"UNAME"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/usnam.dtel.mjs":
/*!*******************************!*\
  !*** ./output/usnam.dtel.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["USNAM"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(12, {"qualifiedName":"USNAM","ddicName":"USNAM"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/w3mime.tabl.mjs":
/*!********************************!*\
  !*** ./output/w3mime.tabl.mjs ***!
  \********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["W3MIME"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"line": new abap.types.Hex({length: 255})}, "W3MIME", "W3MIME", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/waers.dtel.mjs":
/*!*******************************!*\
  !*** ./output/waers.dtel.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["WAERS"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(5, {"qualifiedName":"WAERS","ddicName":"WAERS"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/waers_curc.dtel.mjs":
/*!************************************!*\
  !*** ./output/waers_curc.dtel.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["WAERS_CURC"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(5, {"qualifiedName":"WAERS_CURC","ddicName":"WAERS_CURC"}),
  "domain": "WAERS",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/wwwdatatab.tabl.mjs":
/*!************************************!*\
  !*** ./output/wwwdatatab.tabl.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["WWWDATATAB"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"relid": new abap.types.Character(2, {}), "objid": new abap.types.Character(40, {})}, "WWWDATATAB", "WWWDATATAB", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/wwwparams.tabl.mjs":
/*!***********************************!*\
  !*** ./output/wwwparams.tabl.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["WWWPARAMS"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"relid": new abap.types.Character(2, {}), "objid": new abap.types.Character(40, {}), "name": new abap.types.Character(50, {}), "value": new abap.types.Character(250, {})}, "WWWPARAMS", "WWWPARAMS", {}, {}),
  "keyFields": [],
};

/***/ }),

/***/ "./output/xfeld.dtel.mjs":
/*!*******************************!*\
  !*** ./output/xfeld.dtel.mjs ***!
  \*******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["XFELD"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(1, {"qualifiedName":"XFELD","ddicName":"XFELD"}),
  "domain": undefined,
  "fixedValues": undefined,
};

/***/ }),

/***/ "./output/xsdboolean.dtel.mjs":
/*!************************************!*\
  !*** ./output/xsdboolean.dtel.mjs ***!
  \************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["XSDBOOLEAN"] = {
  "objectType": "DTEL",
  "type": new abap.types.Character(1, {"qualifiedName":"XSDBOOLEAN","ddicName":"XSDBOOLEAN"}),
  "domain": "XSDBOOLEAN",
  "fixedValues": [{"description":"True","low":"X","language":"E"},{"description":"False","language":"E"}],
};

/***/ }),

/***/ "./output/xsddatetime_z.dtel.mjs":
/*!***************************************!*\
  !*** ./output/xsddatetime_z.dtel.mjs ***!
  \***************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["XSDDATETIME_Z"] = {
  "objectType": "DTEL",
  "type": new abap.types.Packed({length: 15, decimals: 0, qualifiedName: "XSDDATETIME_Z"}),
  "domain": "XSDDATETIME_Z",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/xsdtime_t.dtel.mjs":
/*!***********************************!*\
  !*** ./output/xsdtime_t.dtel.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["XSDTIME_T"] = {
  "objectType": "DTEL",
  "type": new abap.types.Time({qualifiedName: "XSDTIME_T"}),
  "domain": "XSDTIME_T",
  "fixedValues": [],
};

/***/ }),

/***/ "./output/zcl_http_handler.clas.mjs":
/*!******************************************!*\
  !*** ./output/zcl_http_handler.clas.mjs ***!
  \******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "zcl_http_handler": () => (/* binding */ zcl_http_handler)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// zcl_http_handler.clas.abap
class zcl_http_handler {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'ZCL_HTTP_HANDLER';
  static IMPLEMENTED_INTERFACES = ["IF_HTTP_EXTENSION"];
  static ATTRIBUTES = {"IF_HTTP_EXTENSION~FLOW_RC": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": " ", "is_class": " "},
  "IF_HTTP_EXTENSION~CO_FLOW_OK": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"},
  "IF_HTTP_EXTENSION~CO_FLOW_OK_OTHERS_MAND": {"type": () => {return new abap.types.Integer({qualifiedName: "I"});}, "visibility": "U", "is_constant": "X", "is_class": "X"}};
  static METHODS = {};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.if_http_extension$co_flow_ok = abap.Classes['IF_HTTP_EXTENSION'].if_http_extension$co_flow_ok;
    this.if_http_extension$co_flow_ok_others_mand = abap.Classes['IF_HTTP_EXTENSION'].if_http_extension$co_flow_ok_others_mand;
    if (this.if_http_extension$flow_rc === undefined) this.if_http_extension$flow_rc = new abap.types.Integer({qualifiedName: "I"});
  }
  async constructor_(INPUT) {
    if (super.constructor_) { await super.constructor_(INPUT); }
    return this;
  }
  async if_http_extension$handle_request(INPUT) {
    let server = INPUT?.server;
    if (server?.getQualifiedName === undefined || server.getQualifiedName() !== "IF_HTTP_SERVER") { server = undefined; }
    if (server === undefined) { server = new abap.types.ABAPObject({qualifiedName: "IF_HTTP_SERVER", RTTIName: "\\INTERFACE=IF_HTTP_SERVER"}).set(INPUT.server); }
    let temp1 = new abap.types.Structure({"method": new abap.types.String({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_REQUEST-METHOD"}), "path": new abap.types.String({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_REQUEST-PATH"}), "body": new abap.types.XString({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_REQUEST-BODY"})}, "zcl_otm_table_maintenance=>ty_request", undefined, {}, {});
    let result = new abap.types.Structure({"status": new abap.types.Integer({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_HTTP-STATUS"}), "content_type": new abap.types.String({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_HTTP-CONTENT_TYPE"}), "body": new abap.types.XString({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_HTTP-BODY"})}, "zcl_otm_table_maintenance=>ty_http", undefined, {}, {});
    let temp3 = new abap.types.ABAPObject({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE", RTTIName: "\\CLASS=ZCL_OTM_TABLE_MAINTENANCE"});
    let temp2 = new abap.types.String({qualifiedName: "STRING"});
    abap.statements.clear(temp1);
    temp1.get().method.set((await server.get().if_http_server$request.get().if_http_request$get_method()));
    temp1.get().path.set((await server.get().if_http_server$request.get().if_http_entity$get_header_field({name: new abap.types.Character(5).set('~path')})));
    temp1.get().body.set((await server.get().if_http_server$request.get().if_http_entity$get_data()));
    temp3.set(await (new abap.Classes['ZCL_OTM_TABLE_MAINTENANCE']()).constructor_({iv_table: new abap.types.Character(9).set('ZOPENTEST')}));
    result.set((await temp3.get().serve({is_request: temp1})));
    await server.get().if_http_server$response.get().if_http_entity$set_data({data: result.get().body});
    await server.get().if_http_server$response.get().if_http_entity$set_content_type({content_type: result.get().content_type});
    temp2.set(result.get().status);
    await server.get().if_http_server$response.get().if_http_response$set_status({code: result.get().status, reason: temp2});
  }
}
abap.Classes['ZCL_HTTP_HANDLER'] = zcl_http_handler;
zcl_http_handler.if_http_extension$co_flow_ok = new abap.types.Integer({qualifiedName: "I"});
zcl_http_handler.if_http_extension$co_flow_ok.set(0);
zcl_http_handler.if_http_extension$co_flow_ok_others_mand = new abap.types.Integer({qualifiedName: "I"});
zcl_http_handler.if_http_extension$co_flow_ok_others_mand.set(2);

//# sourceMappingURL=zcl_http_handler.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/zcl_otm_table_maintenance.clas.mjs":
/*!***************************************************!*\
  !*** ./output/zcl_otm_table_maintenance.clas.mjs ***!
  \***************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "zcl_otm_table_maintenance": () => (/* binding */ zcl_otm_table_maintenance)
/* harmony export */ });
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// zcl_otm_table_maintenance.clas.abap
class zcl_otm_table_maintenance {
  static INTERNAL_TYPE = 'CLAS';
  static INTERNAL_NAME = 'ZCL_OTM_TABLE_MAINTENANCE';
  static IMPLEMENTED_INTERFACES = [];
  static ATTRIBUTES = {"MV_TABLE": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"TABNAME","ddicName":"TABNAME"});}, "visibility": "I", "is_constant": " ", "is_class": " "}};
  static METHODS = {"FROM_XSTRING": {"visibility": "I", "parameters": {"STRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "XSTRING": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}}},
  "GET_HTML": {"visibility": "I", "parameters": {"RV_HTML": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "READ_TABLE": {"visibility": "I", "parameters": {"RV_JSON": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "SAVE_TABLE": {"visibility": "I", "parameters": {"IV_JSON": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "TO_JSON": {"visibility": "I", "parameters": {"RV_JSON": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}, "REF": {"type": () => {return new abap.types.DataReference(new abap.types.Character(4));}, "is_optional": " "}}},
  "TO_XSTRING": {"visibility": "I", "parameters": {"XSTRING": {"type": () => {return new abap.types.XString({qualifiedName: "XSTRING"});}, "is_optional": " "}, "STRING": {"type": () => {return new abap.types.String({qualifiedName: "STRING"});}, "is_optional": " "}}},
  "LIST_KEY_FIELDS": {"visibility": "I", "parameters": {"NAMES": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Character(30, {"qualifiedName":"abap_compname"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "zcl_otm_table_maintenance=>ty_names");}, "is_optional": " "}}},
  "BUILD_METADATA": {"visibility": "I", "parameters": {"RT_METADATA": {"type": () => {return abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_compname"}), "key": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "length": new abap.types.Integer({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_FIELDDATA-LENGTH"}), "fixvalues": abap.types.TableFactory.construct(new abap.types.Structure({"low": new abap.types.Character(10, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-low"}), "high": new abap.types.Character(10, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-high"}), "option": new abap.types.Character(2, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-option"}), "ddlanguage": new abap.types.Character(1, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-ddlanguage"}), "ddtext": new abap.types.Character(60, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-ddtext"})}, "zcl_otm_table_maintenance=>ty_fixvalue", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "zcl_otm_table_maintenance=>ty_fixvalues")}, "zcl_otm_table_maintenance=>ty_fielddata", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "zcl_otm_table_maintenance=>ty_metadata");}, "is_optional": " "}}},
  "CONSTRUCTOR": {"visibility": "U", "parameters": {"IV_TABLE": {"type": () => {return new abap.types.Character(30, {"qualifiedName":"TABNAME","ddicName":"TABNAME"});}, "is_optional": " "}}},
  "SERVE": {"visibility": "U", "parameters": {"RS_HTTP": {"type": () => {return new abap.types.Structure({"status": new abap.types.Integer({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_HTTP-STATUS"}), "content_type": new abap.types.String({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_HTTP-CONTENT_TYPE"}), "body": new abap.types.XString({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_HTTP-BODY"})}, "zcl_otm_table_maintenance=>ty_http", undefined, {}, {});}, "is_optional": " "}, "IS_REQUEST": {"type": () => {return new abap.types.Structure({"method": new abap.types.String({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_REQUEST-METHOD"}), "path": new abap.types.String({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_REQUEST-PATH"}), "body": new abap.types.XString({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_REQUEST-BODY"})}, "zcl_otm_table_maintenance=>ty_request", undefined, {}, {});}, "is_optional": " "}}}};
  constructor() {
    this.me = new abap.types.ABAPObject();
    this.me.set(this);
    this.mv_table = new abap.types.Character(30, {"qualifiedName":"TABNAME","ddicName":"TABNAME"});
  }
  async build_metadata() {
    let rt_metadata = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_compname"}), "key": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "length": new abap.types.Integer({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_FIELDDATA-LENGTH"}), "fixvalues": abap.types.TableFactory.construct(new abap.types.Structure({"low": new abap.types.Character(10, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-low"}), "high": new abap.types.Character(10, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-high"}), "option": new abap.types.Character(2, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-option"}), "ddlanguage": new abap.types.Character(1, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-ddlanguage"}), "ddtext": new abap.types.Character(60, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-ddtext"})}, "zcl_otm_table_maintenance=>ty_fixvalue", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "zcl_otm_table_maintenance=>ty_fixvalues")}, "zcl_otm_table_maintenance=>ty_fielddata", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "zcl_otm_table_maintenance=>ty_metadata");
    let lv_key = new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"});
    let lo_element = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_ELEMDESCR", RTTIName: "\\CLASS=CL_ABAP_ELEMDESCR"});
    let lt_values = abap.types.TableFactory.construct(new abap.types.Structure({"low": new abap.types.Character(10, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-low"}), "high": new abap.types.Character(10, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-high"}), "option": new abap.types.Character(2, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-option"}), "ddlanguage": new abap.types.Character(1, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-ddlanguage"}), "ddtext": new abap.types.Character(60, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-ddtext"})}, "zcl_otm_table_maintenance=>ty_fixvalue", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "zcl_otm_table_maintenance=>ty_fixvalues");
    let lt_key_fields = abap.types.TableFactory.construct(new abap.types.Character(30, {"qualifiedName":"abap_compname"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "zcl_otm_table_maintenance=>ty_names");
    let temp1 = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_STRUCTDESCR", RTTIName: "\\CLASS=CL_ABAP_STRUCTDESCR"});
    let lt_components = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "abap_component_tab");
    let ls_component = new abap.types.Structure({"name": new abap.types.String({qualifiedName: "NAME"}), "type": new abap.types.ABAPObject({qualifiedName: "CL_ABAP_DATADESCR", RTTIName: "\\CLASS=CL_ABAP_DATADESCR"}), "as_include": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "suffix": new abap.types.String({qualifiedName: "SUFFIX"})}, "abap_componentdescr", undefined, {}, {});
    let temp2 = new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_compname"}), "key": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "length": new abap.types.Integer({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_FIELDDATA-LENGTH"}), "fixvalues": abap.types.TableFactory.construct(new abap.types.Structure({"low": new abap.types.Character(10, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-low"}), "high": new abap.types.Character(10, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-high"}), "option": new abap.types.Character(2, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-option"}), "ddlanguage": new abap.types.Character(1, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-ddlanguage"}), "ddtext": new abap.types.Character(60, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-ddtext"})}, "zcl_otm_table_maintenance=>ty_fixvalue", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "zcl_otm_table_maintenance=>ty_fixvalues")}, "zcl_otm_table_maintenance=>ty_fielddata", undefined, {}, {});
    lt_key_fields.set((await this.list_key_fields()));
    await abap.statements.cast(temp1, (await abap.Classes['CL_ABAP_TYPEDESCR'].describe_by_name({p_name: this.mv_table})));
    lt_components.set((await temp1.get().get_components()));
    for await (const unique1 of abap.statements.loop(lt_components)) {
      ls_component.set(unique1);
      await abap.statements.cast(lo_element, ls_component.get().type);
      lt_values.set((await lo_element.get().get_ddic_fixed_values()));
      abap.statements.readTable(lt_key_fields,{withKey: (i) => {return abap.compare.eq(i.table_line, ls_component.get().name);},
        withKeyValue: [{key: (i) => {return i.table_line}, value: ls_component.get().name}],
        usesTableLine: true,
        withKeySimple: {"table_line": ls_component.get().name}});
      lv_key.set(abap.builtin.boolc(abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0))));
      abap.statements.clear(temp2);
      temp2.get().name.set(ls_component.get().name);
      temp2.get().key.set(lv_key);
      temp2.get().type_kind.set(ls_component.get().type.get().type_kind);
      temp2.get().length.set(ls_component.get().type.get().length);
      temp2.get().fixvalues.set(lt_values);
      abap.statements.append({source: temp2, target: rt_metadata});
    }
    return rt_metadata;
  }
  async constructor_(INPUT) {
    let iv_table = INPUT?.iv_table;
    if (iv_table?.getQualifiedName === undefined || iv_table.getQualifiedName() !== "TABNAME") { iv_table = undefined; }
    if (iv_table === undefined) { iv_table = new abap.types.Character(30, {"qualifiedName":"TABNAME","ddicName":"TABNAME"}).set(INPUT.iv_table); }
    abap.statements.assert(abap.compare.initial(iv_table) === false);
    this.mv_table.set(iv_table);
    return this;
  }
  async from_xstring(INPUT) {
    let string = new abap.types.String({qualifiedName: "STRING"});
    let xstring = INPUT?.xstring;
    if (xstring?.getQualifiedName === undefined || xstring.getQualifiedName() !== "XSTRING") { xstring = undefined; }
    if (xstring === undefined) { xstring = new abap.types.XString({qualifiedName: "XSTRING"}).set(INPUT.xstring); }
    let conv = new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});
    let conv_in_class = new abap.types.Character(18, {});
    try {
      if (abap.Classes['CL_ABAP_CONV_CODEPAGE'.trimEnd()] === undefined) { if (abap.Classes['CX_SY_DYN_CALL_ILLEGAL_CLASS'.trimEnd()] === undefined) { throw "CX_SY_DYN_CALL_ILLEGAL_CLASS not found"; } else {throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_CLASS'.trimEnd()](); } }
      if (abap.Classes['CL_ABAP_CONV_CODEPAGE'.trimEnd()].create_in === undefined && abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()] === undefined) { throw "CX_SY_DYN_CALL_ILLEGAL_METHOD not found"; }
      if (abap.Classes['CL_ABAP_CONV_CODEPAGE'.trimEnd()].create_in === undefined) { throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()](); }
      conv.set(await abap.Classes['CL_ABAP_CONV_CODEPAGE'.trimEnd()].create_in());
      if (conv.get().if_abap_conv_in$convert === undefined && abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()] === undefined) { throw "CX_SY_DYN_CALL_ILLEGAL_METHOD not found"; }
      if (conv.get().if_abap_conv_in$convert === undefined) { throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()](); }
      string.set(await conv.get().if_abap_conv_in$convert({source: xstring}));
    } catch (e) {
      if ((abap.Classes['CX_SY_DYN_CALL_ILLEGAL_CLASS'] && e instanceof abap.Classes['CX_SY_DYN_CALL_ILLEGAL_CLASS'])) {
        conv_in_class.set(new abap.types.Character(18).set('CL_ABAP_CONV_IN_CE'));
        if (abap.Classes[conv_in_class.get().trimEnd()] === undefined) { if (abap.Classes['CX_SY_DYN_CALL_ILLEGAL_CLASS'.trimEnd()] === undefined) { throw "CX_SY_DYN_CALL_ILLEGAL_CLASS not found"; } else {throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_CLASS'.trimEnd()](); } }
        conv.set(await abap.Classes[conv_in_class.get().trimEnd()].create({encoding: new abap.types.Character(5).set('UTF-8')}));
        if (conv.get().convert === undefined && abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()] === undefined) { throw "CX_SY_DYN_CALL_ILLEGAL_METHOD not found"; }
        if (conv.get().convert === undefined) { throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()](); }
        await conv.get().convert({input: xstring,data: string});
      } else {
        throw e;
      }
    }
    return string;
  }
  async get_html() {
    let rv_html = new abap.types.String({qualifiedName: "STRING"});
    rv_html.set(abap.operators.concat(new abap.types.String().set(`<!DOCTYPE html>\n`),abap.operators.concat(new abap.types.String().set(`<html>\n`),abap.operators.concat(new abap.types.String().set(`<head>\n`),abap.operators.concat(new abap.types.String().set(`<title>open-table-maintenance</title>\n`),abap.operators.concat(new abap.types.String().set(`<script src="https://bossanova.uk/jspreadsheet/v4/jexcel.js" async></script>\n`),abap.operators.concat(new abap.types.String().set(`<script src="https://jsuites.net/v4/jsuites.js" async></script>\n`),abap.operators.concat(new abap.types.String().set(`<link rel="stylesheet" href="https://jsuites.net/v4/jsuites.css" type="text/css" />\n`),abap.operators.concat(new abap.types.String().set(`<link rel="stylesheet" href="https://bossanova.uk/jspreadsheet/v4/jexcel.css" type="text/css" />\n`),abap.operators.concat(new abap.types.String().set(`<script>\n`),abap.operators.concat(new abap.types.Character(11).set('let jtable;'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(16).set('let columnNames;'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(47).set('const url = window.location.pathname + "/rest";'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(16).set('function run() {'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(33).set('  fetch(url).then((response) => {'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(27).set('    return response.json();'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(25).set('    }).then((parsed) => {'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(53).set('    document.getElementById("tablename").innerHTML = '),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(85).set('      "<h1 style=\\"display:inline\\">hello " + parsed.TABLENAME + "</h1>&nbsp;<tt>" + '),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(57).set('       parsed.SY.SYSID + "-" + parsed.SY.MANDT + "</tt>";'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(29).set('    const data = parsed.DATA;'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(29).set('    if (data.length === 0) { '),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(22).set('       const obj = {};'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(41).set('       obj[parsed.META[0]["NAME"]] = "_";'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(22).set('       data.push(obj);'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(5).set('    }'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(47).set('    columnNames = parsed.META.map(n => n.NAME);'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(54).set('    document.getElementById("content").innerHTML = "";'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(55).set('    let columnSettings = parsed.META.map(n => {return {'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(62).set('      "type": n.FIXVALUES.length > 0 ? "dropdown" : undefined,'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(22).set('      "title": n.NAME,'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(44).set('      "source": n.FIXVALUES.map(f => f.LOW),'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(43).set('      "width": Math.min(200, n.LENGTH * 20)'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(9).set('    };});'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(63).set('    jtable = jspreadsheet(document.getElementById("content"), {'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(29).set('      defaultColAlign:"left",'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(26).set('      allowInsertRow:true,'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(32).set('      allowManualInsertRow:true,'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(30).set('      allowInsertColumn:false,'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(36).set('      allowManualInsertColumn:false,'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(26).set('      allowDeleteRow:true,'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(30).set('      allowRenameColumn:false,'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(30).set('      allowDeleteColumn:false,'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(17).set('      data: data,'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(34).set('      onload: function(instance) {'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(71).set('        const keyCount = parsed.META.filter(n => n.KEY === "X").length;'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(44).set('        for (let i = 0; i < keyCount; i++) {'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(70).set('          instance.jexcel.colgroup[i].style.backgroundColor="#F8F8F8";'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(9).set('        }'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(8).set('      },'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(32).set('      columns: columnSettings});'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(5).set('  });'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(1).set('}'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(24).set('function toObject(row) {'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(15).set('  let ret = {};'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(48).set('  for (let i = 0; i < columnNames.length; i++) {'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(33).set('    ret[columnNames[i]] = row[i];'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(3).set('  }'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(13).set('  return ret;'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(1).set('}'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(17).set('function save() {'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(56).set('  const body = {"DATA": jtable.getData().map(toObject)};'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(94).set('  fetch(url, {method: "POST", body: JSON.stringify(body)}).then(() => {alert("data saved");});'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.Character(1).set('}'),abap.operators.concat(new abap.types.String().set(`\n`),abap.operators.concat(new abap.types.String().set(`</script>\n`),abap.operators.concat(new abap.types.String().set(`</head>\n`),abap.operators.concat(new abap.types.String().set(`<body onload="run()">\n`),abap.operators.concat(new abap.types.String().set(`<div id="tablename"><h1>open-table-maintenance</h1></div>\n`),abap.operators.concat(new abap.types.String().set(`<button type="button" onclick="save()">Save</button><br>\n`),abap.operators.concat(new abap.types.String().set(`<div id="content">loading</div><br>\n`),abap.operators.concat(new abap.types.String().set(`</body>\n`),new abap.types.String().set(`</html>`))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))));
    return rv_html;
  }
  async list_key_fields() {
    let names = abap.types.TableFactory.construct(new abap.types.Character(30, {"qualifiedName":"abap_compname"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "zcl_otm_table_maintenance=>ty_names");
    let obj = new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});
    let lv_tabname = new abap.types.Character(16, {});
    let lr_ddfields = new abap.types.DataReference(new abap.types.Character(4));
    let fs_any_ = new abap.types.FieldSymbol(new abap.types.Character(4));
    let fs_field_ = new abap.types.FieldSymbol(new abap.types.Character());
    let fs_ddfields_ = new abap.types.FieldSymbol(abap.types.TableFactory.construct(new abap.types.Character(4), {"withHeader":false,"keyType":"DEFAULT"}));
    let workaround = new abap.types.Character(8, {});
    let temp3 = new abap.types.ABAPObject({qualifiedName: "CL_ABAP_STRUCTDESCR", RTTIName: "\\CLASS=CL_ABAP_STRUCTDESCR"});
    lv_tabname.set(this.mv_table);
    try {
      if (abap.Classes['XCO_CP_ABAP_DICTIONARY'.trimEnd()] === undefined) { if (abap.Classes['CX_SY_DYN_CALL_ILLEGAL_CLASS'.trimEnd()] === undefined) { throw "CX_SY_DYN_CALL_ILLEGAL_CLASS not found"; } else {throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_CLASS'.trimEnd()](); } }
      if (abap.Classes['XCO_CP_ABAP_DICTIONARY'.trimEnd()].database_table === undefined && abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()] === undefined) { throw "CX_SY_DYN_CALL_ILLEGAL_METHOD not found"; }
      if (abap.Classes['XCO_CP_ABAP_DICTIONARY'.trimEnd()].database_table === undefined) { throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()](); }
      obj.set(await abap.Classes['XCO_CP_ABAP_DICTIONARY'.trimEnd()].database_table({iv_name: lv_tabname}));
      abap.statements.assign({target: fs_any_, dynamicName: 'obj' + '->' + 'IF_XCO_DATABASE_TABLE~FIELDS->IF_XCO_DBT_FIELDS_FACTORY~KEY', dynamicSource: (() => {
                  try { return obj; } catch {}
                  try { return this.obj; } catch {}
                })()});
        abap.statements.assert(abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0)));
        obj.set(fs_any_);
        if (obj.get().if_xco_dbt_fields$get_names === undefined && abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()] === undefined) { throw "CX_SY_DYN_CALL_ILLEGAL_METHOD not found"; }
        if (obj.get().if_xco_dbt_fields$get_names === undefined) { throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()](); }
        names.set(await obj.get().if_xco_dbt_fields$get_names());
      } catch (e) {
        if ((abap.Classes['CX_SY_DYN_CALL_ILLEGAL_CLASS'] && e instanceof abap.Classes['CX_SY_DYN_CALL_ILLEGAL_CLASS'])) {
          workaround.set(new abap.types.Character(8).set('DDFIELDS'));
          abap.statements.createData(lr_ddfields,{"name": workaround.get()});
          abap.statements.assign({target: fs_ddfields_, source: (lr_ddfields).dereference()});
          abap.statements.assert(abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0)));
          await abap.statements.cast(temp3, (await abap.Classes['CL_ABAP_TYPEDESCR'].describe_by_name({p_name: lv_tabname})));
          fs_ddfields_.set((await temp3.get().get_ddic_field_list()));
          for await (const unique2 of abap.statements.loop(fs_ddfields_)) {
            fs_any_.assign(unique2);
            abap.statements.assign({component: new abap.types.Character(7).set('KEYFLAG'), target: fs_field_, source: fs_any_});
            if (abap.compare.ne(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0)) || abap.compare.ne(fs_field_, abap.builtin.abap_true)) {
              continue;
            }
            abap.statements.assign({component: new abap.types.Character(9).set('FIELDNAME'), target: fs_field_, source: fs_any_});
            abap.statements.assert(abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0)));
            abap.statements.append({source: fs_field_, target: names});
          }
        } else {
          throw e;
        }
      }
      return names;
    }
    async read_table() {
      let rv_json = new abap.types.String({qualifiedName: "STRING"});
      let fs_fs_ = new abap.types.FieldSymbol(abap.types.TableFactory.construct(new abap.types.Character(4), {"withHeader":false,"keyType":"DEFAULT"}));
      let dref = new abap.types.DataReference(new abap.types.Character(4));
      abap.statements.createData(dref,{"name": this.mv_table.get(),"table": true});
      abap.statements.assign({target: fs_fs_, source: (dref).dereference()});
      abap.statements.assert(abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0)));
      await abap.statements.select(fs_fs_, {select: "SELECT * FROM " + abap.buildDbTableName(this.mv_table.get().trimEnd().toLowerCase()) + " ORDER BY PRIMARY KEY"});
      rv_json.set((await this.to_json({ref: dref})));
      return rv_json;
    }
    async save_table(INPUT) {
      let iv_json = INPUT?.iv_json;
      if (iv_json?.getQualifiedName === undefined || iv_json.getQualifiedName() !== "STRING") { iv_json = undefined; }
      if (iv_json === undefined) { iv_json = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.iv_json); }
      let fs_fs_ = new abap.types.FieldSymbol(abap.types.TableFactory.construct(new abap.types.Character(4), {"withHeader":false,"keyType":"DEFAULT"}));
      let dref = new abap.types.DataReference(new abap.types.Character(4));
      abap.statements.createData(dref,{"name": this.mv_table.get(),"table": true});
      abap.statements.assign({target: fs_fs_, source: (dref).dereference()});
      abap.statements.assert(abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0)));
      if (abap.Classes['KERNEL_CALL_TRANSFORMATION'] === undefined) throw new Error("CallTransformation, kernel class missing");
      await abap.Classes['KERNEL_CALL_TRANSFORMATION'].call({name: "id",sourceXML: iv_json,result: {data:fs_fs_}});
      await abap.statements.modifyDatabase(this.mv_table.get().trimEnd().toLowerCase(), {"table": fs_fs_});
    }
    async serve(INPUT) {
      let rs_http = new abap.types.Structure({"status": new abap.types.Integer({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_HTTP-STATUS"}), "content_type": new abap.types.String({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_HTTP-CONTENT_TYPE"}), "body": new abap.types.XString({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_HTTP-BODY"})}, "zcl_otm_table_maintenance=>ty_http", undefined, {}, {});
      let is_request = INPUT?.is_request;
      if (is_request?.getQualifiedName === undefined || is_request.getQualifiedName() !== "ZCL_OTM_TABLE_MAINTENANCE=>TY_REQUEST") { is_request = undefined; }
      if (is_request === undefined) { is_request = new abap.types.Structure({"method": new abap.types.String({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_REQUEST-METHOD"}), "path": new abap.types.String({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_REQUEST-PATH"}), "body": new abap.types.XString({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_REQUEST-BODY"})}, "zcl_otm_table_maintenance=>ty_request", undefined, {}, {}).set(INPUT.is_request); }
      let lv_body = new abap.types.String({qualifiedName: "STRING"});
      try {
        rs_http.get().status.set(abap.IntegerFactory.get(200));
        if (abap.compare.cp(is_request.get().path, new abap.types.Character(6).set('*/rest'))) {
          if (abap.compare.eq(is_request.get().method, new abap.types.Character(3).set('GET'))) {
            lv_body.set((await this.read_table()));
            rs_http.get().content_type.set(new abap.types.Character(16).set('application/json'));
          } else if (abap.compare.eq(is_request.get().method, new abap.types.Character(4).set('POST'))) {
            await this.save_table({iv_json: (await this.from_xstring({xstring: is_request.get().body}))});
          } else {
            abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), abap.IntegerFactory.get(2)));
          }
        } else {
          lv_body.set((await this.get_html()));
          rs_http.get().content_type.set(new abap.types.Character(9).set('text/html'));
        }
        rs_http.get().body.set((await this.to_xstring({string: lv_body})));
      } catch (e) {
        if ((abap.Classes['CX_ROOT'] && e instanceof abap.Classes['CX_ROOT'])) {
          rs_http.get().status.set(new abap.types.Integer().set(500));
          rs_http.get().body.set((await this.to_xstring({string: new abap.types.String().set(`Exception occurred`)})));
        } else {
          throw e;
        }
      }
      return rs_http;
    }
    async to_json(INPUT) {
      let rv_json = new abap.types.String({qualifiedName: "STRING"});
      let ref = INPUT?.ref;
      if (ref === undefined) { ref = new abap.types.DataReference(new abap.types.Character(4)).set(INPUT.ref); }
      let fs_fs_ = new abap.types.FieldSymbol(abap.types.TableFactory.construct(new abap.types.Character(4), {"withHeader":false,"keyType":"DEFAULT"}));
      let meta = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_compname"}), "key": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "length": new abap.types.Integer({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_FIELDDATA-LENGTH"}), "fixvalues": abap.types.TableFactory.construct(new abap.types.Structure({"low": new abap.types.Character(10, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-low"}), "high": new abap.types.Character(10, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-high"}), "option": new abap.types.Character(2, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-option"}), "ddlanguage": new abap.types.Character(1, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-ddlanguage"}), "ddtext": new abap.types.Character(60, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-ddtext"})}, "zcl_otm_table_maintenance=>ty_fixvalue", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "zcl_otm_table_maintenance=>ty_fixvalues")}, "zcl_otm_table_maintenance=>ty_fielddata", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "zcl_otm_table_maintenance=>ty_metadata");
      let writer = new abap.types.ABAPObject({qualifiedName: "CL_SXML_STRING_WRITER", RTTIName: "\\CLASS=CL_SXML_STRING_WRITER"});
      abap.statements.assign({target: fs_fs_, source: (ref).dereference()});
      abap.statements.assert(abap.compare.eq(abap.builtin.sy.get().subrc, abap.IntegerFactory.get(0)));
      meta.set((await this.build_metadata()));
      writer.set((await abap.Classes['CL_SXML_STRING_WRITER'].create({type: abap.Classes['IF_SXML'].if_sxml$co_xt_json})));
      if (abap.Classes['KERNEL_CALL_TRANSFORMATION'] === undefined) throw new Error("CallTransformation, kernel class missing");
      await abap.Classes['KERNEL_CALL_TRANSFORMATION'].call({name: "id",resultXML: writer,source: {data:fs_fs_,meta:meta,tablename:this.mv_table,sy:abap.builtin.sy}});
      rv_json.set((await this.from_xstring({xstring: (await writer.get().get_output())})));
      return rv_json;
    }
    async to_xstring(INPUT) {
      let xstring = new abap.types.XString({qualifiedName: "XSTRING"});
      let string = INPUT?.string;
      if (string?.getQualifiedName === undefined || string.getQualifiedName() !== "STRING") { string = undefined; }
      if (string === undefined) { string = new abap.types.String({qualifiedName: "STRING"}).set(INPUT.string); }
      let conv = new abap.types.ABAPObject({qualifiedName: undefined, RTTIName: undefined});
      let conv_out_class = new abap.types.Character(19, {});
      try {
        if (abap.Classes['CL_ABAP_CONV_CODEPAGE'.trimEnd()] === undefined) { if (abap.Classes['CX_SY_DYN_CALL_ILLEGAL_CLASS'.trimEnd()] === undefined) { throw "CX_SY_DYN_CALL_ILLEGAL_CLASS not found"; } else {throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_CLASS'.trimEnd()](); } }
        if (abap.Classes['CL_ABAP_CONV_CODEPAGE'.trimEnd()].create_out === undefined && abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()] === undefined) { throw "CX_SY_DYN_CALL_ILLEGAL_METHOD not found"; }
        if (abap.Classes['CL_ABAP_CONV_CODEPAGE'.trimEnd()].create_out === undefined) { throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()](); }
        conv.set(await abap.Classes['CL_ABAP_CONV_CODEPAGE'.trimEnd()].create_out());
        if (conv.get().if_abap_conv_out$convert === undefined && abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()] === undefined) { throw "CX_SY_DYN_CALL_ILLEGAL_METHOD not found"; }
        if (conv.get().if_abap_conv_out$convert === undefined) { throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()](); }
        xstring.set(await conv.get().if_abap_conv_out$convert({source: string}));
      } catch (e) {
        if ((abap.Classes['CX_SY_DYN_CALL_ILLEGAL_CLASS'] && e instanceof abap.Classes['CX_SY_DYN_CALL_ILLEGAL_CLASS'])) {
          conv_out_class.set(new abap.types.Character(19).set('CL_ABAP_CONV_OUT_CE'));
          if (abap.Classes[conv_out_class.get().trimEnd()] === undefined) { if (abap.Classes['CX_SY_DYN_CALL_ILLEGAL_CLASS'.trimEnd()] === undefined) { throw "CX_SY_DYN_CALL_ILLEGAL_CLASS not found"; } else {throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_CLASS'.trimEnd()](); } }
          conv.set(await abap.Classes[conv_out_class.get().trimEnd()].create({encoding: new abap.types.Character(5).set('UTF-8')}));
          if (conv.get().convert === undefined && abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()] === undefined) { throw "CX_SY_DYN_CALL_ILLEGAL_METHOD not found"; }
          if (conv.get().convert === undefined) { throw new abap.Classes['CX_SY_DYN_CALL_ILLEGAL_METHOD'.trimEnd()](); }
          await conv.get().convert({data: string,buffer: xstring});
        } else {
          throw e;
        }
      }
      return xstring;
    }
  }
  abap.Classes['ZCL_OTM_TABLE_MAINTENANCE'] = zcl_otm_table_maintenance;
  zcl_otm_table_maintenance.ty_request = new abap.types.Structure({"method": new abap.types.String({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_REQUEST-METHOD"}), "path": new abap.types.String({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_REQUEST-PATH"}), "body": new abap.types.XString({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_REQUEST-BODY"})}, "zcl_otm_table_maintenance=>ty_request", undefined, {}, {});
  zcl_otm_table_maintenance.ty_http = new abap.types.Structure({"status": new abap.types.Integer({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_HTTP-STATUS"}), "content_type": new abap.types.String({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_HTTP-CONTENT_TYPE"}), "body": new abap.types.XString({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_HTTP-BODY"})}, "zcl_otm_table_maintenance=>ty_http", undefined, {}, {});
  zcl_otm_table_maintenance.ty_names = abap.types.TableFactory.construct(new abap.types.Character(30, {"qualifiedName":"abap_compname"}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "zcl_otm_table_maintenance=>ty_names");
  zcl_otm_table_maintenance.ty_fixvalue = new abap.types.Structure({"low": new abap.types.Character(10, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-low"}), "high": new abap.types.Character(10, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-high"}), "option": new abap.types.Character(2, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-option"}), "ddlanguage": new abap.types.Character(1, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-ddlanguage"}), "ddtext": new abap.types.Character(60, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-ddtext"})}, "zcl_otm_table_maintenance=>ty_fixvalue", undefined, {}, {});
  zcl_otm_table_maintenance.ty_fixvalues = abap.types.TableFactory.construct(new abap.types.Structure({"low": new abap.types.Character(10, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-low"}), "high": new abap.types.Character(10, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-high"}), "option": new abap.types.Character(2, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-option"}), "ddlanguage": new abap.types.Character(1, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-ddlanguage"}), "ddtext": new abap.types.Character(60, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-ddtext"})}, "zcl_otm_table_maintenance=>ty_fixvalue", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "zcl_otm_table_maintenance=>ty_fixvalues");
  zcl_otm_table_maintenance.ty_fielddata = new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_compname"}), "key": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "length": new abap.types.Integer({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_FIELDDATA-LENGTH"}), "fixvalues": abap.types.TableFactory.construct(new abap.types.Structure({"low": new abap.types.Character(10, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-low"}), "high": new abap.types.Character(10, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-high"}), "option": new abap.types.Character(2, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-option"}), "ddlanguage": new abap.types.Character(1, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-ddlanguage"}), "ddtext": new abap.types.Character(60, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-ddtext"})}, "zcl_otm_table_maintenance=>ty_fixvalue", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "zcl_otm_table_maintenance=>ty_fixvalues")}, "zcl_otm_table_maintenance=>ty_fielddata", undefined, {}, {});
  zcl_otm_table_maintenance.ty_metadata = abap.types.TableFactory.construct(new abap.types.Structure({"name": new abap.types.Character(30, {"qualifiedName":"abap_compname"}), "key": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOL","ddicName":"ABAP_BOOL"}), "type_kind": new abap.types.Character(1, {"qualifiedName":"abap_typekind"}), "length": new abap.types.Integer({qualifiedName: "ZCL_OTM_TABLE_MAINTENANCE=>TY_FIELDDATA-LENGTH"}), "fixvalues": abap.types.TableFactory.construct(new abap.types.Structure({"low": new abap.types.Character(10, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-low"}), "high": new abap.types.Character(10, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-high"}), "option": new abap.types.Character(2, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-option"}), "ddlanguage": new abap.types.Character(1, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-ddlanguage"}), "ddtext": new abap.types.Character(60, {"qualifiedName":"zcl_otm_table_maintenance=>ty_fixvalue-ddtext"})}, "zcl_otm_table_maintenance=>ty_fixvalue", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "zcl_otm_table_maintenance=>ty_fixvalues")}, "zcl_otm_table_maintenance=>ty_fielddata", undefined, {}, {}), {"withHeader":false,"keyType":"DEFAULT","primaryKey":{"name":"primary_key","type":"STANDARD","isUnique":false,"keyFields":[]},"secondary":[]}, "zcl_otm_table_maintenance=>ty_metadata");

//# sourceMappingURL=zcl_otm_table_maintenance.clas.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/zopentest.tabl.mjs":
/*!***********************************!*\
  !*** ./output/zopentest.tabl.mjs ***!
  \***********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
abap.DDIC["ZOPENTEST"] = {
  "objectType": "TABL",
  "type": new abap.types.Structure({"keyfield": new abap.types.Character(4, {}), "valuefield": new abap.types.Character(10, {}), "boolean": new abap.types.Character(1, {"qualifiedName":"ABAP_BOOLEAN","ddicName":"ABAP_BOOLEAN"})}, "ZOPENTEST", "ZOPENTEST", {}, {}),
  "keyFields": ["KEYFIELD"],
};

/***/ }),

/***/ "./output/zw3mi.fugr.wwwdata_export.mjs":
/*!**********************************************!*\
  !*** ./output/zw3mi.fugr.wwwdata_export.mjs ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// zw3mi.fugr.wwwdata_export.abap
async function wwwdata_export(INPUT) {
  // importing KEY WWWDATATAB false
  let key = INPUT.exporting?.key;
  // tables MIME W3MIME true
  let mime = INPUT.tables?.mime;
  if (mime === undefined) {
      mime = abap.types.TableFactory.construct(new abap.types.Structure({"line": new abap.types.Hex({length: 255})}, "W3MIME", "W3MIME", {}, {}), {"withHeader":true,"keyType":"DEFAULT"});
  }
  abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
}
abap.FunctionModules['WWWDATA_EXPORT'] = wwwdata_export;
//# sourceMappingURL=zw3mi.fugr.wwwdata_export.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/zw3mi.fugr.wwwdata_import.mjs":
/*!**********************************************!*\
  !*** ./output/zw3mi.fugr.wwwdata_import.mjs ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// zw3mi.fugr.wwwdata_import.abap
async function wwwdata_import(INPUT) {
  // importing KEY WWWDATATAB false
  let key = INPUT.exporting?.key;
  // tables MIME W3MIME true
  let mime = INPUT.tables?.mime;
  if (mime === undefined) {
      mime = abap.types.TableFactory.construct(new abap.types.Structure({"line": new abap.types.Hex({length: 255})}, "W3MIME", "W3MIME", {}, {}), {"withHeader":true,"keyType":"DEFAULT"});
  }
  let filename = new abap.types.String({qualifiedName: "STRING"});
  let xstr = new abap.types.XString({qualifiedName: "XSTRING"});
  let row = new abap.types.Structure({"line": new abap.types.Hex({length: 255})}, "W3MIME", "W3MIME", {}, {});
  let len = new abap.types.Integer({qualifiedName: "I"});
  abap.statements.clear(mime);
  filename.set(abap.W3MI[key.get().objid.get().trimEnd()].filename);
  const fs = await __webpack_require__.e(/*! import() */ "_a787").then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ "?a787", 19));
  const path = await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_path-browserify_index_js"), __webpack_require__.e("_ce59")]).then(__webpack_require__.t.bind(__webpack_require__, /*! path */ "./node_modules/path-browserify/index.js", 19));
  const url = await __webpack_require__.e(/*! import() */ "_8823").then(__webpack_require__.t.bind(__webpack_require__, /*! url */ "?8823", 19));
  const __filename = url.fileURLToPath("file:///home/runner/work/open-table-maintenance/open-table-maintenance/output/zw3mi.fugr.wwwdata_import.mjs");
  const __dirname = path.dirname(__filename);
  xstr.set(fs.readFileSync(__dirname + path.sep + filename.get()).toString("hex").toUpperCase());
  const indexBackup1 = abap.builtin.sy.get().index.get();
  let unique180 = 1;
  while (abap.compare.gt(abap.builtin.xstrlen({val: xstr}), abap.IntegerFactory.get(0))) {
    abap.builtin.sy.get().index.set(unique180++);
    len.set(new abap.types.Integer().set(255));
    if (abap.compare.lt(abap.builtin.xstrlen({val: xstr}), len)) {
      len.set(abap.builtin.xstrlen({val: xstr}));
    }
    row.get().line.set(xstr.getOffset({length: len}));
    abap.statements.append({source: row, target: mime});
    xstr.set(xstr.getOffset({offset: len}));
  }
  abap.builtin.sy.get().index.set(indexBackup1);
  abap.builtin.sy.get().subrc.set(abap.IntegerFactory.get(0));
}
abap.FunctionModules['WWWDATA_IMPORT'] = wwwdata_import;
//# sourceMappingURL=zw3mi.fugr.wwwdata_import.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/zw3mi.fugr.wwwparams_insert.mjs":
/*!************************************************!*\
  !*** ./output/zw3mi.fugr.wwwparams_insert.mjs ***!
  \************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// zw3mi.fugr.wwwparams_insert.abap
async function wwwparams_insert(INPUT) {
  // importing PARAMS WWWPARAMS false
  let params = INPUT.exporting?.params;
  abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
}
abap.FunctionModules['WWWPARAMS_INSERT'] = wwwparams_insert;
//# sourceMappingURL=zw3mi.fugr.wwwparams_insert.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./output/zw3mi.fugr.wwwparams_read.mjs":
/*!**********************************************!*\
  !*** ./output/zw3mi.fugr.wwwparams_read.mjs ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
const {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ "./output/cx_root.clas.mjs"));
// zw3mi.fugr.wwwparams_read.abap
async function wwwparams_read(INPUT) {
  // importing RELID WWWPARAMS-RELID false
  let relid = INPUT.exporting?.relid;
  // importing OBJID WWWPARAMS-OBJID false
  let objid = INPUT.exporting?.objid;
  // importing NAME C false
  let name = INPUT.exporting?.name;
  // exporting VALUE C true
  let value = INPUT.importing?.value;
  if (value === undefined) {
      value = new abap.types.Character(1, {});
  }
  let filename = new abap.types.String({qualifiedName: "STRING"});
  let filesize = new abap.types.Integer({qualifiedName: "I"});
  filename.set(abap.W3MI[objid.get().trimEnd()].filename);
  const fs = await __webpack_require__.e(/*! import() */ "_a787").then(__webpack_require__.t.bind(__webpack_require__, /*! fs */ "?a787", 19));
  const path = await Promise.all(/*! import() */[__webpack_require__.e("vendors-node_modules_path-browserify_index_js"), __webpack_require__.e("_ce59")]).then(__webpack_require__.t.bind(__webpack_require__, /*! path */ "./node_modules/path-browserify/index.js", 19));
  const url = await __webpack_require__.e(/*! import() */ "_8823").then(__webpack_require__.t.bind(__webpack_require__, /*! url */ "?8823", 19));
  const __filename = url.fileURLToPath("file:///home/runner/work/open-table-maintenance/open-table-maintenance/output/zw3mi.fugr.wwwparams_read.mjs");
  const __dirname = path.dirname(__filename);
  const buf = fs.readFileSync(__dirname + path.sep + filename.get());
  if (abap.compare.eq(name, new abap.types.Character(8).set('filesize'))) {
    filesize.set(buf.length);
    value.set(filesize);
    abap.statements.condense(value, {nogaps: false});
  } else {
    abap.statements.assert(abap.compare.eq(abap.IntegerFactory.get(1), new abap.types.Character(4).set('todo')));
  }
  abap.builtin.sy.get().subrc.set(abap.IntegerFactory.get(0));
}
abap.FunctionModules['WWWPARAMS_READ'] = wwwparams_read;
//# sourceMappingURL=zw3mi.fugr.wwwparams_read.mjs.map
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./test/web.mjs":
/*!**********************!*\
  !*** ./test/web.mjs ***!
  \**********************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _output_init_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../output/_init.mjs */ "./output/_init.mjs");
/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_output_init_mjs__WEBPACK_IMPORTED_MODULE_0__]);
_output_init_mjs__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];

await (0,_output_init_mjs__WEBPACK_IMPORTED_MODULE_0__.initializeABAP)();

async function redirectFetch(url, options) {
  let data = "";

  let res = {
    append: (d) => {
      console.dir("append2: " + d); },
    send: (d) => {
      console.dir("send2");
      data = Buffer.from(d).toString();
    },
    status: (status) => {
      console.dir("status2: " + status);
      return res; },
  }

  const method = options?.method || "GET";
  const body = options?.body || "";

  const req = {
    body: Buffer.from(body).toString("hex"),
    method: method,
    path: url,
    url: url,
  };
  console.dir(req);
  await abap.Classes["CL_EXPRESS_ICF_SHIM"].run({req: req, res, class: "ZCL_HTTP_HANDLER"})
  console.log("redirectFetch RESPONSE,");
  console.dir(data);
  return { json: async () => JSON.parse(data)};
}

async function run() {
  let res = {
    append: (data) => {
      console.dir("append: " + data); },
    send: (data) => {
      console.dir("send");
      let r = Buffer.from(data).toString();

      // document.write() doesnt work when loaded from async script
      document.documentElement.innerHTML = r;

      // and setting innerHTML does not automatically load/initialize the scripts
      const scripts = Array.from(document.getElementsByTagName("script"));
{
      var myScript = document.createElement('script');
      myScript.src = scripts[0].src;
      document.head.appendChild(myScript);
}
{
      var myScript = document.createElement('script');
      myScript.src = scripts[1].src;
      document.head.appendChild(myScript);
}
{
      var myScript = document.createElement('script');
      myScript.textContent = scripts[2].textContent;
      document.head.appendChild(myScript);
}

      globalThis.fetch = redirectFetch;

      setTimeout(() => {
        console.dir("dispatch load");
        window.dispatchEvent(new Event("load"));
      }, 1000);
    },
    status: (status) => {
      console.dir("status: " + status);
      return res; },
  }

  await abap.Classes["CL_EXPRESS_ICF_SHIM"].run({req: {body: "", method: "GET", path: "", url: ""}, res, class: "ZCL_HTTP_HANDLER"});
}

run();

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && !queue.d) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = 1);
/******/ 			if(queue) queue.moduleId = module.id;
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			promise.moduleId = module.id;
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".bundle.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/load script */
/******/ 	(() => {
/******/ 		var inProgress = {};
/******/ 		var dataWebpackPrefix = "open-table-maintenance:";
/******/ 		// loadScript function to load a script via script tag
/******/ 		__webpack_require__.l = (url, done, key, chunkId) => {
/******/ 			if(inProgress[url]) { inProgress[url].push(done); return; }
/******/ 			var script, needAttach;
/******/ 			if(key !== undefined) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				for(var i = 0; i < scripts.length; i++) {
/******/ 					var s = scripts[i];
/******/ 					if(s.getAttribute("src") == url || s.getAttribute("data-webpack") == dataWebpackPrefix + key) { script = s; break; }
/******/ 				}
/******/ 			}
/******/ 			if(!script) {
/******/ 				needAttach = true;
/******/ 				script = document.createElement('script');
/******/ 		
/******/ 				script.charset = 'utf-8';
/******/ 				script.timeout = 120;
/******/ 				if (__webpack_require__.nc) {
/******/ 					script.setAttribute("nonce", __webpack_require__.nc);
/******/ 				}
/******/ 				script.setAttribute("data-webpack", dataWebpackPrefix + key);
/******/ 				script.src = url;
/******/ 			}
/******/ 			inProgress[url] = [done];
/******/ 			var onScriptComplete = (prev, event) => {
/******/ 				// avoid mem leaks in IE.
/******/ 				script.onerror = script.onload = null;
/******/ 				clearTimeout(timeout);
/******/ 				var doneFns = inProgress[url];
/******/ 				delete inProgress[url];
/******/ 				script.parentNode && script.parentNode.removeChild(script);
/******/ 				doneFns && doneFns.forEach((fn) => (fn(event)));
/******/ 				if(prev) return prev(event);
/******/ 			}
/******/ 			;
/******/ 			var timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);
/******/ 			script.onerror = onScriptComplete.bind(null, script.onerror);
/******/ 			script.onload = onScriptComplete.bind(null, script.onload);
/******/ 			needAttach && document.head.appendChild(script);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"app": 0
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.f.j = (chunkId, promises) => {
/******/ 				// JSONP chunk loading for javascript
/******/ 				var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;
/******/ 				if(installedChunkData !== 0) { // 0 means "already installed".
/******/ 		
/******/ 					// a Promise means "currently loading".
/******/ 					if(installedChunkData) {
/******/ 						promises.push(installedChunkData[2]);
/******/ 					} else {
/******/ 						if(true) { // all chunks have JS
/******/ 							// setup Promise in chunk cache
/******/ 							var promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));
/******/ 							promises.push(installedChunkData[2] = promise);
/******/ 		
/******/ 							// start chunk loading
/******/ 							var url = __webpack_require__.p + __webpack_require__.u(chunkId);
/******/ 							// create error before stack unwound to get useful stacktrace later
/******/ 							var error = new Error();
/******/ 							var loadingEnded = (event) => {
/******/ 								if(__webpack_require__.o(installedChunks, chunkId)) {
/******/ 									installedChunkData = installedChunks[chunkId];
/******/ 									if(installedChunkData !== 0) installedChunks[chunkId] = undefined;
/******/ 									if(installedChunkData) {
/******/ 										var errorType = event && (event.type === 'load' ? 'missing' : event.type);
/******/ 										var realSrc = event && event.target && event.target.src;
/******/ 										error.message = 'Loading chunk ' + chunkId + ' failed.\n(' + errorType + ': ' + realSrc + ')';
/******/ 										error.name = 'ChunkLoadError';
/******/ 										error.type = errorType;
/******/ 										error.request = realSrc;
/******/ 										installedChunkData[1](error);
/******/ 									}
/******/ 								}
/******/ 							};
/******/ 							__webpack_require__.l(url, loadingEnded, "chunk-" + chunkId, chunkId);
/******/ 						} else installedChunks[chunkId] = 0;
/******/ 					}
/******/ 				}
/******/ 		};
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 		
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkopen_table_maintenance"] = self["webpackChunkopen_table_maintenance"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module used 'module' so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./test/web.mjs");
/******/ 	
/******/ })()
;
//# sourceMappingURL=app.bundle.js.map