"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkopen_table_maintenance"] = self["webpackChunkopen_table_maintenance"] || []).push([["output_cl_sxml_string_reader_clas_locals_mjs"],{

/***/ "./output/cl_sxml_string_reader.clas.locals.mjs":
/*!******************************************************!*\
  !*** ./output/cl_sxml_string_reader.clas.locals.mjs ***!
  \******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"lcl_attribute\": () => (/* binding */ lcl_attribute),\n/* harmony export */   \"lcl_close_node\": () => (/* binding */ lcl_close_node),\n/* harmony export */   \"lcl_json_parser\": () => (/* binding */ lcl_json_parser),\n/* harmony export */   \"lcl_open_node\": () => (/* binding */ lcl_open_node),\n/* harmony export */   \"lcl_reader\": () => (/* binding */ lcl_reader),\n/* harmony export */   \"lcl_value_node\": () => (/* binding */ lcl_value_node)\n/* harmony export */ });\nconst {cx_root} = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ \"./output/cx_root.clas.mjs\"));\n// cl_sxml_string_reader.clas.locals_imp.abap\nclass lcl_json_parser {\n  static INTERNAL_TYPE = 'CLAS';\n  static INTERNAL_NAME = 'CLAS-CL_SXML_STRING_READER-LCL_JSON_PARSER';\n  static IMPLEMENTED_INTERFACES = [];\n  static ATTRIBUTES = {\"MT_NODES\": {\"type\": () => {return abap.types.TableFactory.construct(new abap.types.Structure({\"type\": new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"}), \"name\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-NAME\"}), \"key\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-KEY\"}), \"value\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-VALUE\"})}, \"lcl_json_parser=>ty_node\"), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_json_parser=>ty_nodes\");}, \"visibility\": \"I\", \"is_constant\": \" \", \"is_class\": \" \"}};\n  constructor() {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mt_nodes = abap.types.TableFactory.construct(new abap.types.Structure({\"type\": new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"}), \"name\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-NAME\"}), \"key\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-KEY\"}), \"value\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-VALUE\"})}, \"lcl_json_parser=>ty_node\"), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_json_parser=>ty_nodes\");\n  }\n  async constructor_(INPUT) {\n    if (super.constructor_) { await super.constructor_(INPUT); }\n    return this;\n  }\n  async parse(INPUT) {\n    let rt_nodes = abap.types.TableFactory.construct(new abap.types.Structure({\"type\": new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"}), \"name\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-NAME\"}), \"key\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-KEY\"}), \"value\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-VALUE\"})}, \"lcl_json_parser=>ty_node\"), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_json_parser=>ty_nodes\");\n    let iv_json = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.iv_json) {iv_json.set(INPUT.iv_json);}\n    let lv_error = new abap.types.Character(1, {\"qualifiedName\":\"ABAP_BOOL\",\"ddicName\":\"ABAP_BOOL\"});\n    let lv_error_message = new abap.types.String({qualifiedName: \"STRING\"});\n    let lv_xml_offset = new abap.types.Integer({qualifiedName: \"I\"});\n    let lv_json = new abap.types.Integer({qualifiedName: \"I\"});\n    try {\n        lv_json = {value: JSON.parse(iv_json.get())};\n    } catch(e) {\n        lv_error_message.set(e.message);\n        lv_error.set(\"X\")\n    }\n    if (abap.compare.eq(lv_error, abap.builtin.abap_true)) {\n      abap.statements.find(lv_error_message, {regex: new abap.types.Character(15).set(' position (\\\\d+)'), submatches: [lv_xml_offset]});\n      const unique110 = await (new abap.Classes['CX_SXML_PARSE_ERROR']()).constructor_({xml_offset: lv_xml_offset});\n      unique110.EXTRA_CX = {\"INTERNAL_FILENAME\": \"cl_sxml_string_reader.clas.locals_imp.abap\",\"INTERNAL_LINE\": 68};\n      throw unique110;\n    }\n    abap.statements.clear(this.mt_nodes);\n    await this.traverse({iv_json: lv_json});\n    rt_nodes.set(this.mt_nodes);\n    return rt_nodes;\n  }\n  async append(INPUT) {\n    let iv_type = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\n    if (INPUT && INPUT.iv_type) {iv_type.set(INPUT.iv_type);}\n    let iv_name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.iv_name) {iv_name.set(INPUT.iv_name);}\n    let iv_key = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.iv_key) {iv_key.set(INPUT.iv_key);}\n    let iv_value = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.iv_value) {iv_value.set(INPUT.iv_value);}\n    let ls_node = new abap.types.Structure({\"type\": new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"}), \"name\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-NAME\"}), \"key\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-KEY\"}), \"value\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-VALUE\"})}, \"lcl_json_parser=>ty_node\");\n    ls_node.get().type.set(iv_type);\n    ls_node.get().name.set(iv_name);\n    ls_node.get().key.set(iv_key);\n    ls_node.get().value.set(iv_value);\n    abap.statements.append({source: ls_node, target: this.mt_nodes});\n  }\n  async traverse(INPUT) {\n    let iv_json = new abap.types.Character(4);\n    if (INPUT && INPUT.iv_json) {iv_json = INPUT.iv_json;}\n    let iv_key = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.iv_key) {iv_key.set(INPUT.iv_key);}\n    let lv_type = new abap.types.String({qualifiedName: \"STRING\"});\n    lv_type.set(Array.isArray(iv_json.value) ? \"array\" : typeof iv_json.value);\n    if (iv_json.value === null) lv_type.set(\"null\");\n    let unique111 = lv_type;\n    if (abap.compare.eq(unique111, new abap.types.Character(6).set('object'))) {\n      await this.traverse_object({iv_json: iv_json, iv_key: iv_key});\n    } else if (abap.compare.eq(unique111, new abap.types.Character(5).set('array'))) {\n      await this.traverse_array({iv_json: iv_json, iv_key: iv_key});\n    } else if (abap.compare.eq(unique111, new abap.types.Character(6).set('string')) || abap.compare.eq(unique111, new abap.types.Character(7).set('boolean')) || abap.compare.eq(unique111, new abap.types.Character(6).set('number')) || abap.compare.eq(unique111, new abap.types.Character(4).set('null'))) {\n      await this.traverse_basic({iv_json: iv_json, iv_key: iv_key});\n    } else {\n      abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(2), new abap.types.Character(4).set('todo')));\n    }\n  }\n  async traverse_basic(INPUT) {\n    let iv_json = new abap.types.Character(4);\n    if (INPUT && INPUT.iv_json) {iv_json = INPUT.iv_json;}\n    let iv_key = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.iv_key) {iv_key.set(INPUT.iv_key);}\n    let lv_type = new abap.types.String({qualifiedName: \"STRING\"});\n    let parsed = iv_json.value;\n    iv_json = new abap.types.String().set(iv_json.value + \"\");\n    lv_type.set(typeof parsed);\n    if (parsed === null) lv_type.set(\"null\");\n    let unique112 = lv_type;\n    if (abap.compare.eq(unique112, new abap.types.Character(6).set('string'))) {\n      lv_type.set(new abap.types.Character(3).set('str'));\n    } else if (abap.compare.eq(unique112, new abap.types.Character(6).set('number'))) {\n      lv_type.set(new abap.types.Character(3).set('num'));\n    } else if (abap.compare.eq(unique112, new abap.types.Character(7).set('boolean'))) {\n      lv_type.set(new abap.types.Character(4).set('bool'));\n    }\n    await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open, iv_name: lv_type, iv_key: iv_key});\n    if (abap.compare.ne(lv_type, new abap.types.Character(4).set('null'))) {\n      await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_value, iv_value: iv_json});\n    }\n    await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close, iv_name: lv_type});\n  }\n  async traverse_array(INPUT) {\n    let iv_json = new abap.types.Character(4);\n    if (INPUT && INPUT.iv_json) {iv_json = INPUT.iv_json;}\n    let iv_key = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.iv_key) {iv_key.set(INPUT.iv_key);}\n    let lv_value = new abap.types.String({qualifiedName: \"STRING\"});\n    let lv_length = new abap.types.Integer({qualifiedName: \"I\"});\n    let lv_index = new abap.types.Integer({qualifiedName: \"I\"});\n    let parsed = iv_json.value;\n    lv_length.set(parsed.length);\n    await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open, iv_name: new abap.types.Character(5).set('array'), iv_key: iv_key});\n    const indexBackup1 = abap.builtin.sy.get().index.get();\n    const unique113 = lv_length.get();\n    for (let unique114 = 0; unique114 < unique113; unique114++) {\n      abap.builtin.sy.get().index.set(unique114 + 1);\n      lv_index.set(abap.operators.minus(abap.builtin.sy.get().index,new abap.types.Integer().set(1)));\n      lv_value = {value: parsed[lv_index.get()]};\n      await this.traverse({iv_json: lv_value});\n    }\n    abap.builtin.sy.get().index.set(indexBackup1);\n    await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close, iv_name: new abap.types.Character(5).set('array')});\n  }\n  async traverse_object(INPUT) {\n    let iv_json = new abap.types.Character(4);\n    if (INPUT && INPUT.iv_json) {iv_json = INPUT.iv_json;}\n    let iv_key = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.iv_key) {iv_key.set(INPUT.iv_key);}\n    let lt_keys = abap.types.TableFactory.construct(new abap.types.String({qualifiedName: \"STRING\"}), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"\");\n    let lv_key = new abap.types.String({qualifiedName: \"STRING\"});\n    let lv_value = new abap.types.String({qualifiedName: \"STRING\"});\n    let parsed = iv_json.value;\n    Object.keys(parsed).forEach(k => lt_keys.append(k));\n    await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open, iv_name: new abap.types.Character(6).set('object'), iv_key: iv_key});\n    for await (const unique115 of abap.statements.loop(lt_keys)) {\n      lv_key.set(unique115);\n      lv_value = {value: parsed[lv_key.get()]};\n      await this.traverse({iv_json: lv_value, iv_key: lv_key});\n    }\n    await this.append({iv_type: abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close, iv_name: new abap.types.Character(6).set('object')});\n  }\n}\nabap.Classes['CLAS-CL_SXML_STRING_READER-LCL_JSON_PARSER'] = lcl_json_parser;\nlcl_json_parser.ty_node = new abap.types.Structure({\"type\": new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"}), \"name\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-NAME\"}), \"key\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-KEY\"}), \"value\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-VALUE\"})}, \"lcl_json_parser=>ty_node\");\nlcl_json_parser.ty_nodes = abap.types.TableFactory.construct(new abap.types.Structure({\"type\": new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"}), \"name\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-NAME\"}), \"key\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-KEY\"}), \"value\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-VALUE\"})}, \"lcl_json_parser=>ty_node\"), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_json_parser=>ty_nodes\");\nclass lcl_attribute {\n  static INTERNAL_TYPE = 'CLAS';\n  static INTERNAL_NAME = 'CLAS-CL_SXML_STRING_READER-LCL_ATTRIBUTE';\n  static IMPLEMENTED_INTERFACES = [\"IF_SXML_ATTRIBUTE\"];\n  static ATTRIBUTES = {\"MV_VALUE\": {\"type\": () => {return new abap.types.String({qualifiedName: \"STRING\"});}, \"visibility\": \"I\", \"is_constant\": \" \", \"is_class\": \" \"},\n  \"IF_SXML_ATTRIBUTE~QNAME\": {\"type\": () => {return new abap.types.Structure({\"name\": new abap.types.String({qualifiedName: \"STRING\"})}, undefined);}, \"visibility\": \"U\", \"is_constant\": \" \", \"is_class\": \" \"},\n  \"IF_SXML_ATTRIBUTE~VALUE_TYPE\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_VALUE=>VALUE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \" \", \"is_class\": \" \"}};\n  constructor() {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mv_value = new abap.types.String({qualifiedName: \"STRING\"});\n    if (this.if_sxml_attribute$qname === undefined) this.if_sxml_attribute$qname = new abap.types.Structure({\"name\": new abap.types.String({qualifiedName: \"STRING\"})}, undefined);\n    if (this.if_sxml_attribute$value_type === undefined) this.if_sxml_attribute$value_type = new abap.types.Integer({qualifiedName: \"IF_SXML_VALUE=>VALUE_TYPE\"});\n  }\n  async constructor_(INPUT) {\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let value = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\n    let value_type = new abap.types.Integer({qualifiedName: \"IF_SXML_VALUE=>VALUE_TYPE\"});\n    if (INPUT && INPUT.value_type) {value_type.set(INPUT.value_type);}\n    this.if_sxml_attribute$qname.get().name.set(name);\n    this.if_sxml_attribute$value_type.set(value_type);\n    this.mv_value.set(value);\n    return this;\n  }\n  async if_sxml_attribute$get_value() {\n    let value = new abap.types.String({qualifiedName: \"STRING\"});\n    value.set(this.mv_value);\n    return value;\n  }\n}\nabap.Classes['CLAS-CL_SXML_STRING_READER-LCL_ATTRIBUTE'] = lcl_attribute;\nclass lcl_open_node {\n  static INTERNAL_TYPE = 'CLAS';\n  static INTERNAL_NAME = 'CLAS-CL_SXML_STRING_READER-LCL_OPEN_NODE';\n  static IMPLEMENTED_INTERFACES = [\"IF_SXML_OPEN_ELEMENT\",\"IF_SXML_NODE\"];\n  static ATTRIBUTES = {\"MT_ATTRIBUTES\": {\"type\": () => {return abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: \"IF_SXML_ATTRIBUTE\", RTTIName: \"\\\\INTERFACE=IF_SXML_ATTRIBUTE\"}), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"if_sxml_attribute=>attributes\");}, \"visibility\": \"I\", \"is_constant\": \" \", \"is_class\": \" \"},\n  \"IF_SXML_OPEN_ELEMENT~QNAME\": {\"type\": () => {return new abap.types.Structure({\"name\": new abap.types.String({qualifiedName: \"STRING\"})}, undefined);}, \"visibility\": \"U\", \"is_constant\": \" \", \"is_class\": \" \"},\n  \"IF_SXML_NODE~TYPE\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \" \", \"is_class\": \" \"},\n  \"IF_SXML_NODE~CO_NT_ELEMENT_OPEN\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \"X\", \"is_class\": \"X\"},\n  \"IF_SXML_NODE~CO_NT_ELEMENT_CLOSE\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \"X\", \"is_class\": \"X\"},\n  \"IF_SXML_NODE~CO_NT_VALUE\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \"X\", \"is_class\": \"X\"},\n  \"IF_SXML_NODE~CO_NT_ATTRIBUTE\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \"X\", \"is_class\": \"X\"},\n  \"IF_SXML_NODE~CO_NT_FINAL\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \"X\", \"is_class\": \"X\"}};\n  constructor() {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mt_attributes = abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: \"IF_SXML_ATTRIBUTE\", RTTIName: \"\\\\INTERFACE=IF_SXML_ATTRIBUTE\"}), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"if_sxml_attribute=>attributes\");\n    if (this.if_sxml_open_element$qname === undefined) this.if_sxml_open_element$qname = new abap.types.Structure({\"name\": new abap.types.String({qualifiedName: \"STRING\"})}, undefined);\n    this.if_sxml_node$co_nt_element_open = abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open;\n    this.if_sxml_node$co_nt_element_close = abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close;\n    this.if_sxml_node$co_nt_value = abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_value;\n    this.if_sxml_node$co_nt_attribute = abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_attribute;\n    this.if_sxml_node$co_nt_final = abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_final;\n    if (this.if_sxml_node$type === undefined) this.if_sxml_node$type = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\n  }\n  async constructor_(INPUT) {\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    let attributes = abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: \"IF_SXML_ATTRIBUTE\", RTTIName: \"\\\\INTERFACE=IF_SXML_ATTRIBUTE\"}), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"if_sxml_attribute=>attributes\");\n    if (INPUT && INPUT.attributes) {attributes.set(INPUT.attributes);}\n    this.if_sxml_node$type.set(abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open);\n    this.if_sxml_open_element$qname.get().name.set(name);\n    this.mt_attributes.set(attributes);\n    return this;\n  }\n  async if_sxml_open_element$get_attributes() {\n    let attr = abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: \"IF_SXML_ATTRIBUTE\", RTTIName: \"\\\\INTERFACE=IF_SXML_ATTRIBUTE\"}), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"if_sxml_attribute=>attributes\");\n    attr.set(this.mt_attributes);\n    return attr;\n  }\n}\nabap.Classes['CLAS-CL_SXML_STRING_READER-LCL_OPEN_NODE'] = lcl_open_node;\nlcl_open_node.if_sxml_node$co_nt_element_open = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\nlcl_open_node.if_sxml_node$co_nt_element_open.set(1);\nlcl_open_node.if_sxml_node$co_nt_element_close = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\nlcl_open_node.if_sxml_node$co_nt_element_close.set(2);\nlcl_open_node.if_sxml_node$co_nt_value = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\nlcl_open_node.if_sxml_node$co_nt_value.set(4);\nlcl_open_node.if_sxml_node$co_nt_attribute = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\nlcl_open_node.if_sxml_node$co_nt_attribute.set(32);\nlcl_open_node.if_sxml_node$co_nt_final = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\nlcl_open_node.if_sxml_node$co_nt_final.set(128);\nclass lcl_close_node {\n  static INTERNAL_TYPE = 'CLAS';\n  static INTERNAL_NAME = 'CLAS-CL_SXML_STRING_READER-LCL_CLOSE_NODE';\n  static IMPLEMENTED_INTERFACES = [\"IF_SXML_CLOSE_ELEMENT\",\"IF_SXML_NODE\"];\n  static ATTRIBUTES = {\"IF_SXML_CLOSE_ELEMENT~QNAME\": {\"type\": () => {return new abap.types.Structure({\"name\": new abap.types.String({qualifiedName: \"STRING\"})}, undefined);}, \"visibility\": \"U\", \"is_constant\": \" \", \"is_class\": \" \"},\n  \"IF_SXML_NODE~TYPE\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \" \", \"is_class\": \" \"},\n  \"IF_SXML_NODE~CO_NT_ELEMENT_OPEN\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \"X\", \"is_class\": \"X\"},\n  \"IF_SXML_NODE~CO_NT_ELEMENT_CLOSE\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \"X\", \"is_class\": \"X\"},\n  \"IF_SXML_NODE~CO_NT_VALUE\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \"X\", \"is_class\": \"X\"},\n  \"IF_SXML_NODE~CO_NT_ATTRIBUTE\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \"X\", \"is_class\": \"X\"},\n  \"IF_SXML_NODE~CO_NT_FINAL\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \"X\", \"is_class\": \"X\"}};\n  constructor() {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    if (this.if_sxml_close_element$qname === undefined) this.if_sxml_close_element$qname = new abap.types.Structure({\"name\": new abap.types.String({qualifiedName: \"STRING\"})}, undefined);\n    this.if_sxml_node$co_nt_element_open = abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open;\n    this.if_sxml_node$co_nt_element_close = abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close;\n    this.if_sxml_node$co_nt_value = abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_value;\n    this.if_sxml_node$co_nt_attribute = abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_attribute;\n    this.if_sxml_node$co_nt_final = abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_final;\n    if (this.if_sxml_node$type === undefined) this.if_sxml_node$type = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\n  }\n  async constructor_(INPUT) {\n    let name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.name) {name.set(INPUT.name);}\n    this.if_sxml_node$type.set(abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close);\n    this.if_sxml_close_element$qname.get().name.set(name);\n    return this;\n  }\n}\nabap.Classes['CLAS-CL_SXML_STRING_READER-LCL_CLOSE_NODE'] = lcl_close_node;\nlcl_close_node.if_sxml_node$co_nt_element_open = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\nlcl_close_node.if_sxml_node$co_nt_element_open.set(1);\nlcl_close_node.if_sxml_node$co_nt_element_close = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\nlcl_close_node.if_sxml_node$co_nt_element_close.set(2);\nlcl_close_node.if_sxml_node$co_nt_value = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\nlcl_close_node.if_sxml_node$co_nt_value.set(4);\nlcl_close_node.if_sxml_node$co_nt_attribute = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\nlcl_close_node.if_sxml_node$co_nt_attribute.set(32);\nlcl_close_node.if_sxml_node$co_nt_final = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\nlcl_close_node.if_sxml_node$co_nt_final.set(128);\nclass lcl_value_node {\n  static INTERNAL_TYPE = 'CLAS';\n  static INTERNAL_NAME = 'CLAS-CL_SXML_STRING_READER-LCL_VALUE_NODE';\n  static IMPLEMENTED_INTERFACES = [\"IF_SXML_VALUE_NODE\",\"IF_SXML_NODE\"];\n  static ATTRIBUTES = {\"MV_VALUE\": {\"type\": () => {return new abap.types.String({qualifiedName: \"STRING\"});}, \"visibility\": \"I\", \"is_constant\": \" \", \"is_class\": \" \"},\n  \"IF_SXML_NODE~TYPE\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \" \", \"is_class\": \" \"},\n  \"IF_SXML_NODE~CO_NT_ELEMENT_OPEN\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \"X\", \"is_class\": \"X\"},\n  \"IF_SXML_NODE~CO_NT_ELEMENT_CLOSE\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \"X\", \"is_class\": \"X\"},\n  \"IF_SXML_NODE~CO_NT_VALUE\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \"X\", \"is_class\": \"X\"},\n  \"IF_SXML_NODE~CO_NT_ATTRIBUTE\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \"X\", \"is_class\": \"X\"},\n  \"IF_SXML_NODE~CO_NT_FINAL\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \"X\", \"is_class\": \"X\"}};\n  constructor() {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mv_value = new abap.types.String({qualifiedName: \"STRING\"});\n    this.if_sxml_node$co_nt_element_open = abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open;\n    this.if_sxml_node$co_nt_element_close = abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close;\n    this.if_sxml_node$co_nt_value = abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_value;\n    this.if_sxml_node$co_nt_attribute = abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_attribute;\n    this.if_sxml_node$co_nt_final = abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_final;\n    if (this.if_sxml_node$type === undefined) this.if_sxml_node$type = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\n  }\n  async constructor_(INPUT) {\n    let value = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.value) {value.set(INPUT.value);}\n    this.if_sxml_node$type.set(abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_value);\n    this.mv_value.set(value);\n    return this;\n  }\n  async if_sxml_value_node$get_value() {\n    let val = new abap.types.String({qualifiedName: \"STRING\"});\n    val.set(this.mv_value);\n    return val;\n  }\n}\nabap.Classes['CLAS-CL_SXML_STRING_READER-LCL_VALUE_NODE'] = lcl_value_node;\nlcl_value_node.if_sxml_node$co_nt_element_open = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\nlcl_value_node.if_sxml_node$co_nt_element_open.set(1);\nlcl_value_node.if_sxml_node$co_nt_element_close = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\nlcl_value_node.if_sxml_node$co_nt_element_close.set(2);\nlcl_value_node.if_sxml_node$co_nt_value = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\nlcl_value_node.if_sxml_node$co_nt_value.set(4);\nlcl_value_node.if_sxml_node$co_nt_attribute = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\nlcl_value_node.if_sxml_node$co_nt_attribute.set(32);\nlcl_value_node.if_sxml_node$co_nt_final = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\nlcl_value_node.if_sxml_node$co_nt_final.set(128);\nclass lcl_reader {\n  static INTERNAL_TYPE = 'CLAS';\n  static INTERNAL_NAME = 'CLAS-CL_SXML_STRING_READER-LCL_READER';\n  static IMPLEMENTED_INTERFACES = [\"IF_SXML_READER\"];\n  static ATTRIBUTES = {\"MV_JSON\": {\"type\": () => {return new abap.types.String({qualifiedName: \"STRING\"});}, \"visibility\": \"I\", \"is_constant\": \" \", \"is_class\": \" \"},\n  \"MT_NODES\": {\"type\": () => {return abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: \"IF_SXML_NODE\", RTTIName: \"\\\\INTERFACE=IF_SXML_NODE\"}), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_reader=>ty_nodes\");}, \"visibility\": \"I\", \"is_constant\": \" \", \"is_class\": \" \"},\n  \"MV_POINTER\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"I\"});}, \"visibility\": \"I\", \"is_constant\": \" \", \"is_class\": \" \"},\n  \"IF_SXML_READER~NODE_TYPE\": {\"type\": () => {return new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});}, \"visibility\": \"U\", \"is_constant\": \" \", \"is_class\": \" \"},\n  \"IF_SXML_READER~NAME\": {\"type\": () => {return new abap.types.String({qualifiedName: \"STRING\"});}, \"visibility\": \"U\", \"is_constant\": \" \", \"is_class\": \" \"},\n  \"IF_SXML_READER~VALUE\": {\"type\": () => {return new abap.types.String({qualifiedName: \"STRING\"});}, \"visibility\": \"U\", \"is_constant\": \" \", \"is_class\": \" \"}};\n  constructor() {\n    this.me = new abap.types.ABAPObject();\n    this.me.set(this);\n    this.mv_json = new abap.types.String({qualifiedName: \"STRING\"});\n    this.mt_nodes = abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: \"IF_SXML_NODE\", RTTIName: \"\\\\INTERFACE=IF_SXML_NODE\"}), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_reader=>ty_nodes\");\n    this.mv_pointer = new abap.types.Integer({qualifiedName: \"I\"});\n    if (this.if_sxml_reader$node_type === undefined) this.if_sxml_reader$node_type = new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"});\n    if (this.if_sxml_reader$name === undefined) this.if_sxml_reader$name = new abap.types.String({qualifiedName: \"STRING\"});\n    if (this.if_sxml_reader$value === undefined) this.if_sxml_reader$value = new abap.types.String({qualifiedName: \"STRING\"});\n  }\n  async constructor_(INPUT) {\n    let iv_json = new abap.types.String({qualifiedName: \"STRING\"});\n    if (INPUT && INPUT.iv_json) {iv_json.set(INPUT.iv_json);}\n    this.mv_json.set(iv_json);\n    return this;\n  }\n  async initialize() {\n    let lo_json = new abap.types.ABAPObject({qualifiedName: \"LCL_JSON_PARSER\", RTTIName: \"\\\\CLASS-POOL=CL_SXML_STRING_READER\\\\CLASS=LCL_JSON_PARSER\"});\n    let lt_parsed = abap.types.TableFactory.construct(new abap.types.Structure({\"type\": new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"}), \"name\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-NAME\"}), \"key\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-KEY\"}), \"value\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-VALUE\"})}, \"lcl_json_parser=>ty_node\"), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_json_parser=>ty_nodes\");\n    let ls_parsed = new abap.types.Structure({\"type\": new abap.types.Integer({qualifiedName: \"IF_SXML_NODE=>NODE_TYPE\"}), \"name\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-NAME\"}), \"key\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-KEY\"}), \"value\": new abap.types.String({qualifiedName: \"LCL_JSON_PARSER=>TY_NODE-VALUE\"})}, \"lcl_json_parser=>ty_node\");\n    let li_node = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_NODE\", RTTIName: \"\\\\INTERFACE=IF_SXML_NODE\"});\n    let lt_attributes = abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: \"IF_SXML_ATTRIBUTE\", RTTIName: \"\\\\INTERFACE=IF_SXML_ATTRIBUTE\"}), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"if_sxml_attribute=>attributes\");\n    let li_attribute = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_ATTRIBUTE\", RTTIName: \"\\\\INTERFACE=IF_SXML_ATTRIBUTE\"});\n    if (abap.compare.initial(this.mv_json)) {\n      return;\n    }\n    lo_json.set(await (new abap.Classes['CLAS-CL_SXML_STRING_READER-LCL_JSON_PARSER']()).constructor_());\n    lt_parsed.set((await lo_json.get().parse({iv_json: this.mv_json})));\n    abap.statements.clear(lo_json);\n    for await (const unique116 of abap.statements.loop(lt_parsed)) {\n      ls_parsed.set(unique116);\n      let unique117 = ls_parsed.get().type;\n      if (abap.compare.eq(unique117, abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open)) {\n        abap.statements.clear(lt_attributes);\n        if (abap.compare.initial(ls_parsed.get().key) === false) {\n          li_attribute.set(await (new abap.Classes['CLAS-CL_SXML_STRING_READER-LCL_ATTRIBUTE']()).constructor_({name: new abap.types.Character(4).set('name'), value: ls_parsed.get().key, value_type: abap.Classes['IF_SXML_VALUE'].if_sxml_value$co_vt_text}));\n          abap.statements.append({source: li_attribute, target: lt_attributes});\n        }\n        li_node.set(await (new abap.Classes['CLAS-CL_SXML_STRING_READER-LCL_OPEN_NODE']()).constructor_({name: ls_parsed.get().name, attributes: lt_attributes}));\n      } else if (abap.compare.eq(unique117, abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close)) {\n        li_node.set(await (new abap.Classes['CLAS-CL_SXML_STRING_READER-LCL_CLOSE_NODE']()).constructor_({name: ls_parsed.get().name}));\n      } else if (abap.compare.eq(unique117, abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_value)) {\n        li_node.set(await (new abap.Classes['CLAS-CL_SXML_STRING_READER-LCL_VALUE_NODE']()).constructor_({value: ls_parsed.get().value}));\n      } else {\n        abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Integer().set(2)));\n      }\n      abap.statements.append({source: li_node, target: this.mt_nodes});\n    }\n    abap.statements.clear(this.mv_json);\n    this.mv_pointer.set(new abap.types.Integer().set(1));\n  }\n  async if_sxml_reader$next_attribute(INPUT) {\n    let value_type = new abap.types.Integer({qualifiedName: \"IF_SXML_VALUE=>VALUE_TYPE\"});\n    if (INPUT && INPUT.value_type) {value_type.set(INPUT.value_type);}\n    abap.statements.assert(abap.compare.eq(new abap.types.Integer().set(1), new abap.types.Character(4).set('todo')));\n  }\n  async if_sxml_reader$next_node(INPUT) {\n    let value_type = new abap.types.Integer({qualifiedName: \"IF_SXML_VALUE=>VALUE_TYPE\"});\n    if (INPUT && INPUT.value_type) {value_type.set(INPUT.value_type);}\n    if (INPUT === undefined || INPUT.value_type === undefined) {value_type = abap.Classes['IF_SXML_VALUE'].if_sxml_value$co_vt_text;}\n    let node = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_NODE\", RTTIName: \"\\\\INTERFACE=IF_SXML_NODE\"});\n    let open = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_OPEN_ELEMENT\", RTTIName: \"\\\\INTERFACE=IF_SXML_OPEN_ELEMENT\"});\n    let close = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_CLOSE_ELEMENT\", RTTIName: \"\\\\INTERFACE=IF_SXML_CLOSE_ELEMENT\"});\n    let value = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_VALUE_NODE\", RTTIName: \"\\\\INTERFACE=IF_SXML_VALUE_NODE\"});\n    await this.initialize();\n    abap.statements.readTable(this.mt_nodes,{index: this.mv_pointer,\n      into: node});\n    this.mv_pointer.set(abap.operators.add(this.mv_pointer,new abap.types.Integer().set(1)));\n    this.if_sxml_reader$node_type.set(node.get().if_sxml_node$type);\n    abap.statements.clear(this.if_sxml_reader$name);\n    let unique118 = this.if_sxml_reader$node_type;\n    if (abap.compare.eq(unique118, abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_open)) {\n      await abap.statements.cast(open, node);\n      this.if_sxml_reader$name.set(open.get().if_sxml_open_element$qname.get().name);\n    } else if (abap.compare.eq(unique118, abap.Classes['IF_SXML_NODE'].if_sxml_node$co_nt_element_close)) {\n      await abap.statements.cast(close, node);\n      this.if_sxml_reader$name.set(close.get().if_sxml_close_element$qname.get().name);\n    }\n  }\n  async if_sxml_reader$skip_node(INPUT) {\n    let writer = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_WRITER\", RTTIName: \"\\\\INTERFACE=IF_SXML_WRITER\"});\n    if (INPUT && INPUT.writer) {writer.set(INPUT.writer);}\n  }\n  async if_sxml_reader$read_next_node() {\n    let node = new abap.types.ABAPObject({qualifiedName: \"IF_SXML_NODE\", RTTIName: \"\\\\INTERFACE=IF_SXML_NODE\"});\n    await this.initialize();\n    abap.statements.readTable(this.mt_nodes,{index: this.mv_pointer,\n      into: node});\n    this.mv_pointer.set(abap.operators.add(this.mv_pointer,new abap.types.Integer().set(1)));\n    return node;\n  }\n}\nabap.Classes['CLAS-CL_SXML_STRING_READER-LCL_READER'] = lcl_reader;\nlcl_reader.ty_nodes = abap.types.TableFactory.construct(new abap.types.ABAPObject({qualifiedName: \"IF_SXML_NODE\", RTTIName: \"\\\\INTERFACE=IF_SXML_NODE\"}), {\"withHeader\":false,\"keyType\":\"DEFAULT\",\"primaryKey\":{\"name\":\"primary_key\",\"type\":\"STANDARD\",\"isUnique\":false,\"keyFields\":[]},\"secondary\":[]}, \"lcl_reader=>ty_nodes\");\n\n//# sourceMappingURL=cl_sxml_string_reader.clas.locals.mjs.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://open-table-maintenance/./output/cl_sxml_string_reader.clas.locals.mjs?");

/***/ })

}]);