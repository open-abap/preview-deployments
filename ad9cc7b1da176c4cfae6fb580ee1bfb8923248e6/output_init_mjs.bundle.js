"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkopen_table_maintenance"] = self["webpackChunkopen_table_maintenance"] || []).push([["output_init_mjs"],{

/***/ "./output/init.mjs":
/*!*************************!*\
  !*** ./output/init.mjs ***!
  \*************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"initializeABAP\": () => (/* binding */ initializeABAP)\n/* harmony export */ });\n/* harmony import */ var _abaplint_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @abaplint/runtime */ \"./node_modules/@abaplint/runtime/build/src/index.js\");\n/* eslint-disable import/newline-after-import */\n\nglobalThis.abap = new _abaplint_runtime__WEBPACK_IMPORTED_MODULE_0__.ABAP();\nawait __webpack_require__.e(/*! import() */ \"_d19c\").then(__webpack_require__.t.bind(__webpack_require__, /*! ./%23ui2%23cl_json.clas.mjs */ \"?d19c\", 19));\nawait __webpack_require__.e(/*! import() */ \"output_abap_boolean_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./abap_boolean.dtel.mjs */ \"./output/abap_boolean.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_abap_callstack_ttyp_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./abap_callstack.ttyp.mjs */ \"./output/abap_callstack.ttyp.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_abap_callstack_line_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./abap_callstack_line.tabl.mjs */ \"./output/abap_callstack_line.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_char1_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./char1.dtel.mjs */ \"./output/char1.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_char10_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./char10.dtel.mjs */ \"./output/char10.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_char_utilities_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_char_utilities.clas.mjs */ \"./output/cl_abap_char_utilities.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_classdescr_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_classdescr.clas.mjs */ \"./output/cl_abap_classdescr.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_codepage_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_codepage.clas.mjs */ \"./output/cl_abap_codepage.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_complexdescr_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_complexdescr.clas.mjs */ \"./output/cl_abap_complexdescr.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_conv_codepage_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_conv_codepage.clas.mjs */ \"./output/cl_abap_conv_codepage.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_conv_in_ce_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_conv_in_ce.clas.mjs */ \"./output/cl_abap_conv_in_ce.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_conv_out_ce_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_conv_out_ce.clas.mjs */ \"./output/cl_abap_conv_out_ce.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_datadescr_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_datadescr.clas.mjs */ \"./output/cl_abap_datadescr.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_elemdescr_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_elemdescr.clas.mjs */ \"./output/cl_abap_elemdescr.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_enumdescr_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_enumdescr.clas.mjs */ \"./output/cl_abap_enumdescr.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_exceptional_values_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_exceptional_values.clas.mjs */ \"./output/cl_abap_exceptional_values.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_format_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_format.clas.mjs */ \"./output/cl_abap_format.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_gzip_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_gzip.clas.mjs */ \"./output/cl_abap_gzip.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_hmac_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_hmac.clas.mjs */ \"./output/cl_abap_hmac.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_intfdescr_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_intfdescr.clas.mjs */ \"./output/cl_abap_intfdescr.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_matcher_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_matcher.clas.mjs */ \"./output/cl_abap_matcher.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_math_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_math.clas.mjs */ \"./output/cl_abap_math.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_objectdescr_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_objectdescr.clas.mjs */ \"./output/cl_abap_objectdescr.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_random_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_random.clas.mjs */ \"./output/cl_abap_random.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_refdescr_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_refdescr.clas.mjs */ \"./output/cl_abap_refdescr.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_regex_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_regex.clas.mjs */ \"./output/cl_abap_regex.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_structdescr_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_structdescr.clas.mjs */ \"./output/cl_abap_structdescr.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_tabledescr_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_tabledescr.clas.mjs */ \"./output/cl_abap_tabledescr.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_tstmp_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_tstmp.clas.mjs */ \"./output/cl_abap_tstmp.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_typedescr_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_typedescr.clas.mjs */ \"./output/cl_abap_typedescr.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_unit_assert_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_unit_assert.clas.mjs */ \"./output/cl_abap_unit_assert.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_abap_zip_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_abap_zip.clas.mjs */ \"./output/cl_abap_zip.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_apc_tcp_client_manager_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_apc_tcp_client_manager.clas.mjs */ \"./output/cl_apc_tcp_client_manager.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_bcs_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_bcs.clas.mjs */ \"./output/cl_bcs.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_bcs_convert_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_bcs_convert.clas.mjs */ \"./output/cl_bcs_convert.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_cam_address_bcs_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_cam_address_bcs.clas.mjs */ \"./output/cl_cam_address_bcs.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_demo_output_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_demo_output.clas.mjs */ \"./output/cl_demo_output.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_document_bcs_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_document_bcs.clas.mjs */ \"./output/cl_document_bcs.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_express_icf_shim_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_express_icf_shim.clas.mjs */ \"./output/cl_express_icf_shim.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_gdt_conversion_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_gdt_conversion.clas.mjs */ \"./output/cl_gdt_conversion.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_gui_cfw_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_gui_cfw.clas.mjs */ \"./output/cl_gui_cfw.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_gui_container_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_gui_container.clas.mjs */ \"./output/cl_gui_container.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_gui_frontend_services_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_gui_frontend_services.clas.mjs */ \"./output/cl_gui_frontend_services.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_http_client_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_http_client.clas.mjs */ \"./output/cl_http_client.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_http_entity_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_http_entity.clas.mjs */ \"./output/cl_http_entity.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_http_server_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_http_server.clas.mjs */ \"./output/cl_http_server.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_http_utility_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_http_utility.clas.mjs */ \"./output/cl_http_utility.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_i18n_languages_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_i18n_languages.clas.mjs */ \"./output/cl_i18n_languages.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_ixml_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_ixml.clas.mjs */ \"./output/cl_ixml.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_message_helper_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_message_helper.clas.mjs */ \"./output/cl_message_helper.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_numberrange_runtime_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_numberrange_runtime.clas.mjs */ \"./output/cl_numberrange_runtime.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_oo_factory_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_oo_factory.clas.mjs */ \"./output/cl_oo_factory.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_progress_indicator_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_progress_indicator.clas.mjs */ \"./output/cl_progress_indicator.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_salv_column_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_salv_column.clas.mjs */ \"./output/cl_salv_column.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_salv_columns_table_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_salv_columns_table.clas.mjs */ \"./output/cl_salv_columns_table.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_salv_events_table_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_salv_events_table.clas.mjs */ \"./output/cl_salv_events_table.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_salv_functions_list_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_salv_functions_list.clas.mjs */ \"./output/cl_salv_functions_list.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_salv_table_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_salv_table.clas.mjs */ \"./output/cl_salv_table.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_shm_area_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_shm_area.clas.mjs */ \"./output/cl_shm_area.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_shm_service_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_shm_service.clas.mjs */ \"./output/cl_shm_service.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_sxml_string_reader_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_sxml_string_reader.clas.mjs */ \"./output/cl_sxml_string_reader.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_sxml_string_writer_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_sxml_string_writer.clas.mjs */ \"./output/cl_sxml_string_writer.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cl_system_uuid_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cl_system_uuid.clas.mjs */ \"./output/cl_system_uuid.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_abap_message_digest_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_abap_message_digest.clas.mjs */ \"./output/cx_abap_message_digest.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_apc_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_apc_error.clas.mjs */ \"./output/cx_apc_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_bcs_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_bcs.clas.mjs */ \"./output/cx_bcs.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_dynamic_check_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_dynamic_check.clas.mjs */ \"./output/cx_dynamic_check.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_gdt_conversion_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_gdt_conversion.clas.mjs */ \"./output/cx_gdt_conversion.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_no_check_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_no_check.clas.mjs */ \"./output/cx_no_check.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_oo_clif_not_exists_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_oo_clif_not_exists.clas.mjs */ \"./output/cx_oo_clif_not_exists.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_parameter_invalid_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_parameter_invalid.clas.mjs */ \"./output/cx_parameter_invalid.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_parameter_invalid_range_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_parameter_invalid_range.clas.mjs */ \"./output/cx_parameter_invalid_range.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_parameter_invalid_type_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_parameter_invalid_type.clas.mjs */ \"./output/cx_parameter_invalid_type.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_root_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_root.clas.mjs */ \"./output/cx_root.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_salv_access_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_salv_access_error.clas.mjs */ \"./output/cx_salv_access_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_salv_data_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_salv_data_error.clas.mjs */ \"./output/cx_salv_data_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_salv_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_salv_error.clas.mjs */ \"./output/cx_salv_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_salv_msg_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_salv_msg.clas.mjs */ \"./output/cx_salv_msg.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_salv_not_found_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_salv_not_found.clas.mjs */ \"./output/cx_salv_not_found.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_salv_static_check_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_salv_static_check.clas.mjs */ \"./output/cx_salv_static_check.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shm_already_detached_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_already_detached.clas.mjs */ \"./output/cx_shm_already_detached.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shm_attach_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_attach_error.clas.mjs */ \"./output/cx_shm_attach_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shm_build_failed_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_build_failed.clas.mjs */ \"./output/cx_shm_build_failed.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shm_change_lock_active_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_change_lock_active.clas.mjs */ \"./output/cx_shm_change_lock_active.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shm_completion_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_completion_error.clas.mjs */ \"./output/cx_shm_completion_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shm_detach_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_detach_error.clas.mjs */ \"./output/cx_shm_detach_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shm_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_error.clas.mjs */ \"./output/cx_shm_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shm_event_execution_failed_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_event_execution_failed.clas.mjs */ \"./output/cx_shm_event_execution_failed.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shm_exclusive_lock_active_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_exclusive_lock_active.clas.mjs */ \"./output/cx_shm_exclusive_lock_active.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shm_general_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_general_error.clas.mjs */ \"./output/cx_shm_general_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shm_inconsistent_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_inconsistent.clas.mjs */ \"./output/cx_shm_inconsistent.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shm_initial_reference_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_initial_reference.clas.mjs */ \"./output/cx_shm_initial_reference.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shm_no_active_version_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_no_active_version.clas.mjs */ \"./output/cx_shm_no_active_version.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shm_parameter_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_parameter_error.clas.mjs */ \"./output/cx_shm_parameter_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shm_pending_lock_removed_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_pending_lock_removed.clas.mjs */ \"./output/cx_shm_pending_lock_removed.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shm_read_lock_active_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_read_lock_active.clas.mjs */ \"./output/cx_shm_read_lock_active.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shm_secondary_commit_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_secondary_commit.clas.mjs */ \"./output/cx_shm_secondary_commit.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shm_version_limit_exceeded_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_version_limit_exceeded.clas.mjs */ \"./output/cx_shm_version_limit_exceeded.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shm_wrong_handle_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shm_wrong_handle.clas.mjs */ \"./output/cx_shm_wrong_handle.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shma_dynamic_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shma_dynamic.clas.mjs */ \"./output/cx_shma_dynamic.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shma_inconsistent_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shma_inconsistent.clas.mjs */ \"./output/cx_shma_inconsistent.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_shma_not_configured_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_shma_not_configured.clas.mjs */ \"./output/cx_shma_not_configured.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_static_check_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_static_check.clas.mjs */ \"./output/cx_static_check.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sxml_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sxml_error.clas.mjs */ \"./output/cx_sxml_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sxml_illegal_argument_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sxml_illegal_argument_error.clas.mjs */ \"./output/cx_sxml_illegal_argument_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sxml_name_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sxml_name_error.clas.mjs */ \"./output/cx_sxml_name_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sxml_parse_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sxml_parse_error.clas.mjs */ \"./output/cx_sxml_parse_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sxml_state_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sxml_state_error.clas.mjs */ \"./output/cx_sxml_state_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_buffer_overflow_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_buffer_overflow.clas.mjs */ \"./output/cx_sy_buffer_overflow.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_codepage_converter_init_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_codepage_converter_init.clas.mjs */ \"./output/cx_sy_codepage_converter_init.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_compression_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_compression_error.clas.mjs */ \"./output/cx_sy_compression_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_conversion_codepage_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_conversion_codepage.clas.mjs */ \"./output/cx_sy_conversion_codepage.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_conversion_data_loss_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_conversion_data_loss.clas.mjs */ \"./output/cx_sy_conversion_data_loss.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_conversion_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_conversion_error.clas.mjs */ \"./output/cx_sy_conversion_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_conversion_no_number_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_conversion_no_number.clas.mjs */ \"./output/cx_sy_conversion_no_number.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_conversion_overflow_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_conversion_overflow.clas.mjs */ \"./output/cx_sy_conversion_overflow.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_create_data_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_create_data_error.clas.mjs */ \"./output/cx_sy_create_data_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_create_object_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_create_object_error.clas.mjs */ \"./output/cx_sy_create_object_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_data_access_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_data_access_error.clas.mjs */ \"./output/cx_sy_data_access_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_dyn_call_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_dyn_call_error.clas.mjs */ \"./output/cx_sy_dyn_call_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_dyn_call_illegal_class_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_dyn_call_illegal_class.clas.mjs */ \"./output/cx_sy_dyn_call_illegal_class.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_dyn_call_illegal_method_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_dyn_call_illegal_method.clas.mjs */ \"./output/cx_sy_dyn_call_illegal_method.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_dyn_call_param_not_found_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_dyn_call_param_not_found.clas.mjs */ \"./output/cx_sy_dyn_call_param_not_found.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_dyn_call_parameter_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_dyn_call_parameter_error.clas.mjs */ \"./output/cx_sy_dyn_call_parameter_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_dynamic_osql_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_dynamic_osql_error.clas.mjs */ \"./output/cx_sy_dynamic_osql_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_dynamic_osql_semantics_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_dynamic_osql_semantics.clas.mjs */ \"./output/cx_sy_dynamic_osql_semantics.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_itab_line_not_found_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_itab_line_not_found.clas.mjs */ \"./output/cx_sy_itab_line_not_found.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_message_illegal_text_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_message_illegal_text.clas.mjs */ \"./output/cx_sy_message_illegal_text.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_move_cast_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_move_cast_error.clas.mjs */ \"./output/cx_sy_move_cast_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_open_sql_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_open_sql_error.clas.mjs */ \"./output/cx_sy_open_sql_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_range_out_of_bounds_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_range_out_of_bounds.clas.mjs */ \"./output/cx_sy_range_out_of_bounds.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_ref_is_initial_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_ref_is_initial.clas.mjs */ \"./output/cx_sy_ref_is_initial.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_sy_sql_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_sy_sql_error.clas.mjs */ \"./output/cx_sy_sql_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_transformation_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_transformation_error.clas.mjs */ \"./output/cx_transformation_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_uuid_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_uuid_error.clas.mjs */ \"./output/cx_uuid_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_xslt_format_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_xslt_format_error.clas.mjs */ \"./output/cx_xslt_format_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_cx_xslt_runtime_error_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./cx_xslt_runtime_error.clas.mjs */ \"./output/cx_xslt_runtime_error.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_ddfields_ttyp_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./ddfields.ttyp.mjs */ \"./output/ddfields.ttyp.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_devclass_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./devclass.dtel.mjs */ \"./output/devclass.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_dfies_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./dfies.tabl.mjs */ \"./output/dfies.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_doku_obj_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./doku_obj.dtel.mjs */ \"./output/doku_obj.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_dynprofld_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./dynprofld.dtel.mjs */ \"./output/dynprofld.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_file_table_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./file_table.tabl.mjs */ \"./output/file_table.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_filetable_ttyp_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./filetable.ttyp.mjs */ \"./output/filetable.ttyp.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_flag_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./flag.dtel.mjs */ \"./output/flag.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_funcname_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./funcname.dtel.mjs */ \"./output/funcname.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_abap_channel_types_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_abap_channel_types.intf.mjs */ \"./output/if_abap_channel_types.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_abap_conv_in_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_abap_conv_in.intf.mjs */ \"./output/if_abap_conv_in.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_abap_conv_out_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_abap_conv_out.intf.mjs */ \"./output/if_abap_conv_out.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_abap_unit_constant_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_abap_unit_constant.intf.mjs */ \"./output/if_abap_unit_constant.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_apc_tcp_frame_types_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_apc_tcp_frame_types.intf.mjs */ \"./output/if_apc_tcp_frame_types.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_apc_wsp_client_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_apc_wsp_client.intf.mjs */ \"./output/if_apc_wsp_client.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_apc_wsp_event_handler_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_apc_wsp_event_handler.intf.mjs */ \"./output/if_apc_wsp_event_handler.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_apc_wsp_message_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_apc_wsp_message.intf.mjs */ \"./output/if_apc_wsp_message.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_apc_wsp_message_manager_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_apc_wsp_message_manager.intf.mjs */ \"./output/if_apc_wsp_message_manager.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_aunit_constants_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_aunit_constants.intf.mjs */ \"./output/if_aunit_constants.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_document_bcs_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_document_bcs.intf.mjs */ \"./output/if_document_bcs.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_http_client_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_http_client.intf.mjs */ \"./output/if_http_client.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_http_extension_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_http_extension.intf.mjs */ \"./output/if_http_extension.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_http_request_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_http_request.intf.mjs */ \"./output/if_http_request.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_http_response_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_http_response.intf.mjs */ \"./output/if_http_response.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_http_server_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_http_server.intf.mjs */ \"./output/if_http_server.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_ixml_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_ixml.intf.mjs */ \"./output/if_ixml.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_ixml_attribute_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_ixml_attribute.intf.mjs */ \"./output/if_ixml_attribute.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_ixml_document_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_ixml_document.intf.mjs */ \"./output/if_ixml_document.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_ixml_element_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_ixml_element.intf.mjs */ \"./output/if_ixml_element.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_ixml_encoding_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_ixml_encoding.intf.mjs */ \"./output/if_ixml_encoding.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_ixml_istream_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_ixml_istream.intf.mjs */ \"./output/if_ixml_istream.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_ixml_named_node_map_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_ixml_named_node_map.intf.mjs */ \"./output/if_ixml_named_node_map.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_ixml_node_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_ixml_node.intf.mjs */ \"./output/if_ixml_node.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_ixml_node_iterator_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_ixml_node_iterator.intf.mjs */ \"./output/if_ixml_node_iterator.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_ixml_node_list_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_ixml_node_list.intf.mjs */ \"./output/if_ixml_node_list.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_ixml_ostream_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_ixml_ostream.intf.mjs */ \"./output/if_ixml_ostream.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_ixml_parse_error_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_ixml_parse_error.intf.mjs */ \"./output/if_ixml_parse_error.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_ixml_parser_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_ixml_parser.intf.mjs */ \"./output/if_ixml_parser.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_ixml_renderer_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_ixml_renderer.intf.mjs */ \"./output/if_ixml_renderer.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_ixml_stream_factory_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_ixml_stream_factory.intf.mjs */ \"./output/if_ixml_stream_factory.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_ixml_unknown_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_ixml_unknown.intf.mjs */ \"./output/if_ixml_unknown.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_message_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_message.intf.mjs */ \"./output/if_message.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_oo_adt_classrun_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_oo_adt_classrun.intf.mjs */ \"./output/if_oo_adt_classrun.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_oo_adt_classrun_out_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_oo_adt_classrun_out.intf.mjs */ \"./output/if_oo_adt_classrun_out.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_oo_clif_source_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_oo_clif_source.intf.mjs */ \"./output/if_oo_clif_source.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_recipient_bcs_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_recipient_bcs.intf.mjs */ \"./output/if_recipient_bcs.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_salv_c_bool_sap_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_salv_c_bool_sap.intf.mjs */ \"./output/if_salv_c_bool_sap.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_salv_c_selection_mode_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_salv_c_selection_mode.intf.mjs */ \"./output/if_salv_c_selection_mode.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_sender_bcs_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_sender_bcs.intf.mjs */ \"./output/if_sender_bcs.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_shm_build_instance_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_shm_build_instance.intf.mjs */ \"./output/if_shm_build_instance.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_shm_trace_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_shm_trace.intf.mjs */ \"./output/if_shm_trace.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_sxml_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_sxml.intf.mjs */ \"./output/if_sxml.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_sxml_attribute_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_sxml_attribute.intf.mjs */ \"./output/if_sxml_attribute.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_sxml_close_element_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_sxml_close_element.intf.mjs */ \"./output/if_sxml_close_element.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_sxml_node_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_sxml_node.intf.mjs */ \"./output/if_sxml_node.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_sxml_open_element_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_sxml_open_element.intf.mjs */ \"./output/if_sxml_open_element.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_sxml_reader_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_sxml_reader.intf.mjs */ \"./output/if_sxml_reader.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_sxml_value_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_sxml_value.intf.mjs */ \"./output/if_sxml_value.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_sxml_value_node_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_sxml_value_node.intf.mjs */ \"./output/if_sxml_value_node.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_sxml_writer_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_sxml_writer.intf.mjs */ \"./output/if_sxml_writer.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_system_uuid_rfc4122_static_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_system_uuid_rfc4122_static.intf.mjs */ \"./output/if_system_uuid_rfc4122_static.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_system_uuid_static_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_system_uuid_static.intf.mjs */ \"./output/if_system_uuid_static.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_t100_dyn_msg_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_t100_dyn_msg.intf.mjs */ \"./output/if_t100_dyn_msg.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_if_t100_message_intf_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./if_t100_message.intf.mjs */ \"./output/if_t100_message.intf.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_ihttpnvp_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./ihttpnvp.tabl.mjs */ \"./output/ihttpnvp.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_int1_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./int1.dtel.mjs */ \"./output/int1.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_int2_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./int2.dtel.mjs */ \"./output/int2.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_int4_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./int4.dtel.mjs */ \"./output/int4.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_kernel_call_transformation_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./kernel_call_transformation.clas.mjs */ \"./output/kernel_call_transformation.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_kernel_cx_assert_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./kernel_cx_assert.clas.mjs */ \"./output/kernel_cx_assert.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_kernel_fugr_test_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./kernel_fugr_test.clas.mjs */ \"./output/kernel_fugr_test.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_kernel_ixml_json_to_data_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./kernel_ixml_json_to_data.clas.mjs */ \"./output/kernel_ixml_json_to_data.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_kernel_ixml_xml_to_data_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./kernel_ixml_xml_to_data.clas.mjs */ \"./output/kernel_ixml_xml_to_data.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_kernel_json_to_ixml_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./kernel_json_to_ixml.clas.mjs */ \"./output/kernel_json_to_ixml.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_kernel_numberrange_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./kernel_numberrange.clas.mjs */ \"./output/kernel_numberrange.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_kernel_push_channels_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./kernel_push_channels.clas.mjs */ \"./output/kernel_push_channels.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_kernel_scan_abap_source_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./kernel_scan_abap_source.clas.mjs */ \"./output/kernel_scan_abap_source.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_kernel_unit_runner_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./kernel_unit_runner.clas.mjs */ \"./output/kernel_unit_runner.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_laiso_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./laiso.dtel.mjs */ \"./output/laiso.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_land1_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./land1.dtel.mjs */ \"./output/land1.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_langu_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./langu.dtel.mjs */ \"./output/langu.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_lvc_nokeyc_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./lvc_nokeyc.dtel.mjs */ \"./output/lvc_nokeyc.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_mandt_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./mandt.dtel.mjs */ \"./output/mandt.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_match_result_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./match_result.tabl.mjs */ \"./output/match_result.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_match_result_tab_ttyp_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./match_result_tab.ttyp.mjs */ \"./output/match_result_tab.ttyp.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_number_get_next_fugr_number_get_next_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./number_get_next.fugr.number_get_next.mjs */ \"./output/number_get_next.fugr.number_get_next.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_numc4_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./numc4.dtel.mjs */ \"./output/numc4.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_openabap_fugr_conversion_exit_alpha_input_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./openabap.fugr.conversion_exit_alpha_input.mjs */ \"./output/openabap.fugr.conversion_exit_alpha_input.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_openabap_fugr_conversion_exit_alpha_output_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./openabap.fugr.conversion_exit_alpha_output.mjs */ \"./output/openabap.fugr.conversion_exit_alpha_output.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_openabap_fugr_conversion_exit_isola_input_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./openabap.fugr.conversion_exit_isola_input.mjs */ \"./output/openabap.fugr.conversion_exit_isola_input.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_openabap_fugr_conversion_exit_isola_output_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./openabap.fugr.conversion_exit_isola_output.mjs */ \"./output/openabap.fugr.conversion_exit_isola_output.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_openabap_fugr_convert_itf_to_stream_text_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./openabap.fugr.convert_itf_to_stream_text.mjs */ \"./output/openabap.fugr.convert_itf_to_stream_text.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_openabap_fugr_docu_get_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./openabap.fugr.docu_get.mjs */ \"./output/openabap.fugr.docu_get.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_openabap_fugr_get_system_timezone_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./openabap.fugr.get_system_timezone.mjs */ \"./output/openabap.fugr.get_system_timezone.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_openabap_fugr_system_callstack_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./openabap.fugr.system_callstack.mjs */ \"./output/openabap.fugr.system_callstack.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_openabap_fugr_system_installed_languages_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./openabap.fugr.system_installed_languages.mjs */ \"./output/openabap.fugr.system_installed_languages.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_openabap_fugr_text_split_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./openabap.fugr.text_split.mjs */ \"./output/openabap.fugr.text_split.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_reposrc_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./reposrc.tabl.mjs */ \"./output/reposrc.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_scrtext_l_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./scrtext_l.dtel.mjs */ \"./output/scrtext_l.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_scrtext_m_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./scrtext_m.dtel.mjs */ \"./output/scrtext_m.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_scrtext_s_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./scrtext_s.dtel.mjs */ \"./output/scrtext_s.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_scx_attrname_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./scx_attrname.dtel.mjs */ \"./output/scx_attrname.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_scx_t100key_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./scx_t100key.tabl.mjs */ \"./output/scx_t100key.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_seoclsname_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./seoclsname.dtel.mjs */ \"./output/seoclsname.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_shm_affect_server_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./shm_affect_server.dtel.mjs */ \"./output/shm_affect_server.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_shm_area_name_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./shm_area_name.dtel.mjs */ \"./output/shm_area_name.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_shm_attach_mode_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./shm_attach_mode.dtel.mjs */ \"./output/shm_attach_mode.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_shm_auto_build_class_name_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./shm_auto_build_class_name.dtel.mjs */ \"./output/shm_auto_build_class_name.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_shm_client_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./shm_client.dtel.mjs */ \"./output/shm_client.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_shm_constr_invocation_mode_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./shm_constr_invocation_mode.dtel.mjs */ \"./output/shm_constr_invocation_mode.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_shm_inst_infos_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./shm_inst_infos.dtel.mjs */ \"./output/shm_inst_infos.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_shm_inst_name_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./shm_inst_name.dtel.mjs */ \"./output/shm_inst_name.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_shm_life_context_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./shm_life_context.dtel.mjs */ \"./output/shm_life_context.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_shm_properties_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./shm_properties.tabl.mjs */ \"./output/shm_properties.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_shm_rc_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./shm_rc.dtel.mjs */ \"./output/shm_rc.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_shma_attributes_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./shma_attributes.tabl.mjs */ \"./output/shma_attributes.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_shma_client_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./shma_client.dtel.mjs */ \"./output/shma_client.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_shmm_trc_variant_name_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./shmm_trc_variant_name.dtel.mjs */ \"./output/shmm_trc_variant_name.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_so_raw255_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./so_raw255.dtel.mjs */ \"./output/so_raw255.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_so_text255_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./so_text255.dtel.mjs */ \"./output/so_text255.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_soli_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./soli.tabl.mjs */ \"./output/soli.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_soli_tab_ttyp_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./soli_tab.ttyp.mjs */ \"./output/soli_tab.ttyp.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_solix_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./solix.tabl.mjs */ \"./output/solix.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_solix_tab_ttyp_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./solix_tab.ttyp.mjs */ \"./output/solix_tab.ttyp.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_sotr_conc_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./sotr_conc.dtel.mjs */ \"./output/sotr_conc.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_spras_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./spras.dtel.mjs */ \"./output/spras.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_ssfapplssl_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./ssfapplssl.dtel.mjs */ \"./output/ssfapplssl.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_sstmnt_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./sstmnt.tabl.mjs */ \"./output/sstmnt.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_stokesx_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./stokesx.tabl.mjs */ \"./output/stokesx.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_string_table_ttyp_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./string_table.ttyp.mjs */ \"./output/string_table.ttyp.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_submatch_result_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./submatch_result.tabl.mjs */ \"./output/submatch_result.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_submatch_result_tab_ttyp_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./submatch_result_tab.ttyp.mjs */ \"./output/submatch_result_tab.ttyp.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_symsg_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./symsg.tabl.mjs */ \"./output/symsg.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_symsgid_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./symsgid.dtel.mjs */ \"./output/symsgid.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_symsgno_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./symsgno.dtel.mjs */ \"./output/symsgno.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_symsgty_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./symsgty.dtel.mjs */ \"./output/symsgty.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_symsgv_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./symsgv.dtel.mjs */ \"./output/symsgv.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_sysubrc_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./sysubrc.dtel.mjs */ \"./output/sysubrc.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_sysuuid_c36_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./sysuuid_c36.dtel.mjs */ \"./output/sysuuid_c36.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_sysuuid_x16_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./sysuuid_x16.dtel.mjs */ \"./output/sysuuid_x16.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_syuname_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./syuname.dtel.mjs */ \"./output/syuname.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_t000_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./t000.tabl.mjs */ \"./output/t000.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_t100_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./t100.tabl.mjs */ \"./output/t100.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_tabfdpos_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./tabfdpos.dtel.mjs */ \"./output/tabfdpos.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_tabname_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./tabname.dtel.mjs */ \"./output/tabname.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_tadir_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./tadir.tabl.mjs */ \"./output/tadir.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_tdevc_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./tdevc.tabl.mjs */ \"./output/tdevc.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_tdline_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./tdline.dtel.mjs */ \"./output/tdline.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_text255_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./text255.dtel.mjs */ \"./output/text255.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_text80_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./text80.dtel.mjs */ \"./output/text80.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_textpool_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./textpool.tabl.mjs */ \"./output/textpool.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_tfdir_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./tfdir.tabl.mjs */ \"./output/tfdir.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_tihttpnvp_ttyp_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./tihttpnvp.ttyp.mjs */ \"./output/tihttpnvp.ttyp.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_timestamp_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./timestamp.dtel.mjs */ \"./output/timestamp.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_timestampl_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./timestampl.dtel.mjs */ \"./output/timestampl.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_timezone_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./timezone.dtel.mjs */ \"./output/timezone.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_tline_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./tline.tabl.mjs */ \"./output/tline.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_tline_tab_ttyp_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./tline_tab.ttyp.mjs */ \"./output/tline_tab.ttyp.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_trfunction_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./trfunction.dtel.mjs */ \"./output/trfunction.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_trkorr_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./trkorr.dtel.mjs */ \"./output/trkorr.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_tzntstmpl_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./tzntstmpl.dtel.mjs */ \"./output/tzntstmpl.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_w3mime_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./w3mime.tabl.mjs */ \"./output/w3mime.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_wwwdatatab_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./wwwdatatab.tabl.mjs */ \"./output/wwwdatatab.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_wwwparams_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./wwwparams.tabl.mjs */ \"./output/wwwparams.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_xsdboolean_dtel_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./xsdboolean.dtel.mjs */ \"./output/xsdboolean.dtel.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_zcl_http_handler_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./zcl_http_handler.clas.mjs */ \"./output/zcl_http_handler.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_zcl_otm_table_maintenance_clas_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./zcl_otm_table_maintenance.clas.mjs */ \"./output/zcl_otm_table_maintenance.clas.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_zopentest_tabl_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./zopentest.tabl.mjs */ \"./output/zopentest.tabl.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_zw3mi_fugr_wwwdata_export_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./zw3mi.fugr.wwwdata_export.mjs */ \"./output/zw3mi.fugr.wwwdata_export.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_zw3mi_fugr_wwwdata_import_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./zw3mi.fugr.wwwdata_import.mjs */ \"./output/zw3mi.fugr.wwwdata_import.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_zw3mi_fugr_wwwparams_insert_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./zw3mi.fugr.wwwparams_insert.mjs */ \"./output/zw3mi.fugr.wwwparams_insert.mjs\"));\nawait __webpack_require__.e(/*! import() */ \"output_zw3mi_fugr_wwwparams_read_mjs\").then(__webpack_require__.bind(__webpack_require__, /*! ./zw3mi.fugr.wwwparams_read.mjs */ \"./output/zw3mi.fugr.wwwparams_read.mjs\"));\n\nasync function initializeABAP() {\n  const sqlite = [];\nsqlite.push(`CREATE TABLE zopentest ('keyfield' NCHAR(4), 'valuefield' NCHAR(10), 'boolean' NCHAR(1), PRIMARY KEY('keyfield'));`);\nsqlite.push(`CREATE TABLE t000 ('mandt' NCHAR(3), 'cccategory' NCHAR(1), 'ccnocliind' NCHAR(1), PRIMARY KEY('mandt'));`);\nsqlite.push(`CREATE TABLE t100 ('sprsl' NCHAR(1), 'arbgb' NCHAR(20), 'msgnr' NCHAR(3), 'text' NCHAR(73), PRIMARY KEY('sprsl','arbgb','msgnr'));`);\nsqlite.push(`CREATE TABLE tdevc ('devclass' NCHAR(30), 'dlvunit' NCHAR(30), 'component' NCHAR(20), 'parentcl' NCHAR(30), PRIMARY KEY('devclass'));`);\nsqlite.push(`CREATE TABLE tfdir ('funcname' NCHAR(30), PRIMARY KEY('funcname'));`);\nsqlite.push(`CREATE TABLE reposrc ('progname' NCHAR(40), 'data' TEXT, PRIMARY KEY('progname'));`);\n  const hdb = `todo`;\n  const pg = `todo`;\n  const schemas = {sqlite, hdb, pg};\n  const insert = [];\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('ZCL_HTTP_HANDLER', 'CLASS zcl_http_handler DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    INTERFACES if_http_extension.\nENDCLASS.\n\nCLASS zcl_http_handler IMPLEMENTATION.\n\n  METHOD if_http_extension~handle_request.\n\n    DATA temp1 TYPE zcl_otm_table_maintenance=>ty_request.\n    DATA result TYPE zcl_otm_table_maintenance=>ty_http.\n    DATA temp3 TYPE REF TO zcl_otm_table_maintenance.\n    DATA temp2 TYPE string.\n    CLEAR temp1.\n    temp1-method = server->request->get_method( ).\n    temp1-path = server->request->get_header_field( ''~path'' ).\n    temp1-body = server->request->get_data( ).\n    \n    \n    CREATE OBJECT temp3 TYPE zcl_otm_table_maintenance EXPORTING IV_TABLE = ''ZOPENTEST''.\n    result = temp3->serve( temp1 ).\n\n    server->response->set_data( result-body ).\n    server->response->set_content_type( result-content_type ).\n    \n    temp2 = result-status.\n    server->response->set_status(\n      code   = result-status\n      reason = temp2 ).\n\n  ENDMETHOD.\n\nENDCLASS.\n');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('ZCL_OTM_TABLE_MAINTENANCE', 'CLASS zcl_otm_table_maintenance DEFINITION\n  PUBLIC\n  CREATE PUBLIC .\n\n  PUBLIC SECTION.\n* MIT License, Copyright (c) 2021 open-abap\n* https://github.com/open-abap/open-table-maintenance\n\n    TYPES:\n      BEGIN OF ty_request,\n        method TYPE string,\n        path   TYPE string,\n        body   TYPE xstring,\n      END OF ty_request.\n    TYPES:\n      BEGIN OF ty_http,\n        status       TYPE i,\n        content_type TYPE string,\n        body         TYPE xstring,\n      END OF ty_http .\n\n    METHODS constructor\n      IMPORTING\n        !iv_table TYPE tabname .\n    METHODS serve\n      IMPORTING\n        !is_request    TYPE ty_request\n      RETURNING\n        VALUE(rs_http) TYPE ty_http .\n  PROTECTED SECTION.\n  PRIVATE SECTION.\n\n    TYPES:\n      ty_names TYPE STANDARD TABLE OF abap_compname WITH DEFAULT KEY .\n    TYPES:\n* there is no common released type for both steampunk and on-prem, workaround:\n      BEGIN OF ty_fixvalue,\n        low        TYPE c LENGTH 10,\n        high       TYPE c LENGTH 10,\n        option     TYPE c LENGTH 2,\n        ddlanguage TYPE c LENGTH 1,\n        ddtext     TYPE c LENGTH 60,\n      END OF ty_fixvalue .\n    TYPES:\n      ty_fixvalues TYPE STANDARD TABLE OF ty_fixvalue WITH DEFAULT KEY .\n    TYPES:\n      BEGIN OF ty_fielddata,\n        name      TYPE abap_compname,\n        key       TYPE abap_bool,\n        type_kind TYPE abap_typekind,\n        length    TYPE i,\n        fixvalues TYPE ty_fixvalues,\n      END OF ty_fielddata .\n    TYPES:\n      ty_metadata TYPE STANDARD TABLE OF ty_fielddata WITH DEFAULT KEY .\n\n    DATA mv_table TYPE tabname .\n\n    METHODS from_xstring\n      IMPORTING\n        !xstring      TYPE xstring\n      RETURNING\n        VALUE(string) TYPE string .\n    METHODS get_html\n      RETURNING\n        VALUE(rv_html) TYPE string .\n    METHODS read_table\n      RETURNING\n        VALUE(rv_json) TYPE string .\n    METHODS save_table\n      IMPORTING\n        !iv_json TYPE string\n      RAISING\n        cx_sy_conversion_data_loss .\n    METHODS to_json\n      IMPORTING\n        !ref           TYPE REF TO data\n      RETURNING\n        VALUE(rv_json) TYPE string .\n    METHODS to_xstring\n      IMPORTING\n        !string        TYPE string\n      RETURNING\n        VALUE(xstring) TYPE xstring .\n    METHODS list_key_fields\n      RETURNING\n        VALUE(names) TYPE ty_names .\n    METHODS build_metadata\n      RETURNING\n        VALUE(rt_metadata) TYPE ty_metadata .\nENDCLASS.\n\n\n\nCLASS ZCL_OTM_TABLE_MAINTENANCE IMPLEMENTATION.\n\n\n  METHOD build_metadata.\n    DATA lv_key TYPE abap_bool.\n    DATA lo_element TYPE REF TO cl_abap_elemdescr.\n    DATA lt_values TYPE ty_fixvalues.\n\n    DATA lt_key_fields TYPE zcl_otm_table_maintenance=>ty_names.\n    DATA temp1 TYPE REF TO cl_abap_structdescr.\n    DATA lt_components TYPE abap_component_tab.\n    DATA ls_component LIKE LINE OF lt_components.\n      DATA temp2 TYPE zcl_otm_table_maintenance=>ty_fielddata.\n    lt_key_fields = list_key_fields( ).\n    \n    temp1 ?= cl_abap_typedescr=>describe_by_name( mv_table ).\n    \n    lt_components = temp1->get_components( ).\n\n    \n    LOOP AT lt_components INTO ls_component.\n\n      lo_element ?= ls_component-type.\n      lt_values = lo_element->get_ddic_fixed_values( ).\n\n      READ TABLE lt_key_fields WITH KEY table_line = ls_component-name TRANSPORTING NO FIELDS.\n      lv_key = boolc( sy-subrc = 0 ).\n      \n      CLEAR temp2.\n      temp2-name = ls_component-name.\n      temp2-key = lv_key.\n      temp2-type_kind = ls_component-type->type_kind.\n      temp2-length = ls_component-type->length.\n      temp2-fixvalues = lt_values.\n      APPEND temp2 TO rt_metadata.\n    ENDLOOP.\n\n  ENDMETHOD.\n\n\n  METHOD constructor.\n    ASSERT iv_table IS NOT INITIAL.\n    mv_table = iv_table.\n  ENDMETHOD.\n\n\n  METHOD from_xstring.\n\n    DATA conv TYPE REF TO object.\n        DATA conv_in_class TYPE c LENGTH 18.\n\n    TRY.\n        CALL METHOD (''CL_ABAP_CONV_CODEPAGE'')=>create_in\n          RECEIVING\n            instance = conv.\n\n        CALL METHOD conv->(''IF_ABAP_CONV_IN~CONVERT'')\n          EXPORTING\n            source = xstring\n          RECEIVING\n            result = string.\n      CATCH cx_sy_dyn_call_illegal_class.\n        \n        conv_in_class = ''CL_ABAP_CONV_IN_CE''.\n        CALL METHOD (conv_in_class)=>create\n          EXPORTING\n            encoding = ''UTF-8''\n          RECEIVING\n            conv     = conv.\n\n        CALL METHOD conv->(''CONVERT'')\n          EXPORTING\n            input = xstring\n          IMPORTING\n            data  = string.\n    ENDTRY.\n\n  ENDMETHOD.\n\n\n  METHOD get_html.\n    rv_html = |<!DOCTYPE html>\\\\n| &&\n      |<html>\\\\n| &&\n      |<head>\\\\n| &&\n      |<title>open-table-maintenance</title>\\\\n| &&\n      |<script src=\"https://bossanova.uk/jspreadsheet/v4/jexcel.js\" async></script>\\\\n| &&\n      |<script src=\"https://jsuites.net/v4/jsuites.js\" async></script>\\\\n| &&\n      |<link rel=\"stylesheet\" href=\"https://jsuites.net/v4/jsuites.css\" type=\"text/css\" />\\\\n| &&\n      |<link rel=\"stylesheet\" href=\"https://bossanova.uk/jspreadsheet/v4/jexcel.css\" type=\"text/css\" />\\\\n| &&\n      |<script>\\\\n| &&\n      ''let jtable;'' && |\\\\n| &&\n      ''let columnNames;'' && |\\\\n| &&\n      ''const url = window.location.pathname + \"/rest\";'' && |\\\\n| &&\n      ''function run() {'' && |\\\\n| &&\n      ''  fetch(url).then((response) => {'' && |\\\\n| &&\n      ''    return response.json();'' && |\\\\n| &&\n      ''    }).then((parsed) => {'' && |\\\\n| &&\n      ''    document.getElementById(\"tablename\").innerHTML = '' && |\\\\n| &&\n      ''      \"<h1 style=\\\\\"display:inline\\\\\">\" + parsed.TABLENAME + \"</h1>&nbsp;<tt>\" + '' && |\\\\n| &&\n      ''       parsed.SY.SYSID + \"-\" + parsed.SY.MANDT + \"</tt>\";'' && |\\\\n| &&\n      ''    const data = parsed.DATA;'' && |\\\\n| &&\n      ''    if (data.length === 0) { '' && |\\\\n| &&\n      ''       const obj = {};'' && |\\\\n| &&\n      ''       obj[parsed.META[0][\"NAME\"]] = \"_\";'' && |\\\\n| &&\n      ''       data.push(obj);'' && |\\\\n| &&\n      ''    }'' && |\\\\n| &&\n      ''    columnNames = parsed.META.map(n => n.NAME);'' && |\\\\n| &&\n      ''    document.getElementById(\"content\").innerHTML = \"\";'' && |\\\\n| &&\n      ''    let columnSettings = parsed.META.map(n => {return {'' && |\\\\n| &&\n      ''      \"type\": n.FIXVALUES.length > 0 ? \"dropdown\" : undefined,'' && |\\\\n| &&\n      ''      \"title\": n.NAME,'' && |\\\\n| &&\n      ''      \"source\": n.FIXVALUES.map(f => f.LOW),'' && |\\\\n| &&\n      ''      \"width\": Math.min(200, n.LENGTH * 20)'' && |\\\\n| &&\n      ''    };});'' && |\\\\n| &&\n      ''    jtable = jspreadsheet(document.getElementById(\"content\"), {'' && |\\\\n| &&\n      ''      defaultColAlign:\"left\",'' && |\\\\n| &&\n      ''      allowInsertRow:true,'' && |\\\\n| &&\n      ''      allowManualInsertRow:true,'' && |\\\\n| &&\n      ''      allowInsertColumn:false,'' && |\\\\n| &&\n      ''      allowManualInsertColumn:false,'' && |\\\\n| &&\n      ''      allowDeleteRow:true,'' && |\\\\n| &&\n      ''      allowRenameColumn:false,'' && |\\\\n| &&\n      ''      allowDeleteColumn:false,'' && |\\\\n| &&\n      ''      data: data,'' && |\\\\n| &&\n      ''      onload: function(instance) {'' && |\\\\n| &&\n      ''        const keyCount = parsed.META.filter(n => n.KEY === \"X\").length;'' && |\\\\n| &&\n      ''        for (let i = 0; i < keyCount; i++) {'' && |\\\\n| &&\n      ''          instance.jexcel.colgroup[i].style.backgroundColor=\"#F8F8F8\";'' && |\\\\n| &&\n      ''        }'' && |\\\\n| &&\n      ''      },'' && |\\\\n| &&\n      ''      columns: columnSettings});'' && |\\\\n| &&\n      ''  });'' && |\\\\n| &&\n      ''}'' && |\\\\n| &&\n      ''function toObject(row) {'' && |\\\\n| &&\n      ''  let ret = {};'' && |\\\\n| &&\n      ''  for (let i = 0; i < columnNames.length; i++) {'' && |\\\\n| &&\n      ''    ret[columnNames[i]] = row[i];'' && |\\\\n| &&\n      ''  }'' && |\\\\n| &&\n      ''  return ret;'' && |\\\\n| &&\n      ''}'' && |\\\\n| &&\n      ''function save() {'' && |\\\\n| &&\n      ''  const body = {\"DATA\": jtable.getData().map(toObject)};'' && |\\\\n| &&\n      ''  fetch(url, {method: \"POST\", body: JSON.stringify(body)}).then(() => {alert(\"data saved\");});'' && |\\\\n| &&\n      ''}'' && |\\\\n| &&\n      |</script>\\\\n| &&\n      |</head>\\\\n| &&\n      |<body onload=\"run()\">\\\\n| &&\n      |<div id=\"tablename\"><h1>open-table-maintenance</h1></div>\\\\n| &&\n      |<button type=\"button\" onclick=\"save()\">Save</button><br>\\\\n| &&\n      |<div id=\"content\">loading</div><br>\\\\n| &&\n      |</body>\\\\n| &&\n      |</html>|.\n  ENDMETHOD.\n\n\n  METHOD list_key_fields.\n    DATA obj TYPE REF TO object.\n    DATA lv_tabname TYPE c LENGTH 16.\n    DATA lr_ddfields TYPE REF TO data.\n    FIELD-SYMBOLS <any> TYPE any.\n    FIELD-SYMBOLS <field> TYPE simple.\n    FIELD-SYMBOLS <ddfields> TYPE ANY TABLE.\n        DATA workaround TYPE c LENGTH 8.\n        DATA temp3 TYPE REF TO cl_abap_structdescr.\n\n* convert to correct type,\n    lv_tabname = mv_table.\n\n    TRY.\n        CALL METHOD (''XCO_CP_ABAP_DICTIONARY'')=>database_table\n          EXPORTING\n            iv_name           = lv_tabname\n          RECEIVING\n            ro_database_table = obj.\n        ASSIGN obj->(''IF_XCO_DATABASE_TABLE~FIELDS->IF_XCO_DBT_FIELDS_FACTORY~KEY'') TO <any>.\n        ASSERT sy-subrc = 0.\n        obj = <any>.\n        CALL METHOD obj->(''IF_XCO_DBT_FIELDS~GET_NAMES'')\n          RECEIVING\n            rt_names = names.\n      CATCH cx_sy_dyn_call_illegal_class.\n        \n        workaround = ''DDFIELDS''.\n        CREATE DATA lr_ddfields TYPE (workaround).\n        ASSIGN lr_ddfields->* TO <ddfields>.\n        ASSERT sy-subrc = 0.\n        \n        temp3 ?= cl_abap_typedescr=>describe_by_name( lv_tabname ).\n        <ddfields> = temp3->get_ddic_field_list( ).\n        LOOP AT <ddfields> ASSIGNING <any>.\n          ASSIGN COMPONENT ''KEYFLAG'' OF STRUCTURE <any> TO <field>.\n          IF sy-subrc <> 0 OR <field> <> abap_true.\n            CONTINUE.\n          ENDIF.\n          ASSIGN COMPONENT ''FIELDNAME'' OF STRUCTURE <any> TO <field>.\n          ASSERT sy-subrc = 0.\n          APPEND <field> TO names.\n        ENDLOOP.\n    ENDTRY.\n\n  ENDMETHOD.\n\n\n  METHOD read_table.\n\n    FIELD-SYMBOLS <fs> TYPE STANDARD TABLE.\n    DATA dref TYPE REF TO data.\n    CREATE DATA dref TYPE STANDARD TABLE OF (mv_table) WITH DEFAULT KEY.\n    ASSIGN dref->* TO <fs>.\n    ASSERT sy-subrc = 0.\n\n    \" dont check SUBRC, the table might be empty\n    SELECT * FROM (mv_table) ORDER BY PRIMARY KEY INTO TABLE <fs> ##SUBRC_OK.\n\n    rv_json = to_json( dref ).\n\n  ENDMETHOD.\n\n\n  METHOD save_table.\n\n    FIELD-SYMBOLS <fs> TYPE STANDARD TABLE.\n    DATA dref TYPE REF TO data.\n    CREATE DATA dref TYPE STANDARD TABLE OF (mv_table) WITH DEFAULT KEY.\n    ASSIGN dref->* TO <fs>.\n    ASSERT sy-subrc = 0.\n\n    CALL TRANSFORMATION id SOURCE XML iv_json RESULT data = <fs>.\n\n    MODIFY (mv_table) FROM TABLE <fs> ##SUBRC_OK.\n\n  ENDMETHOD.\n\n\n  METHOD serve.\n            DATA lv_body TYPE string.\n\n    TRY.\n        rs_http-status = 200.\n        IF is_request-path CP ''*/rest''.\n          IF is_request-method = ''GET''.\n            \n            lv_body = read_table( ).\n            rs_http-content_type = ''application/json''.\n          ELSEIF is_request-method = ''POST''.\n            save_table( from_xstring( is_request-body ) ).\n          ELSE.\n            ASSERT 1 = 2.\n          ENDIF.\n        ELSE.\n          lv_body = get_html( ).\n          rs_http-content_type = ''text/html''.\n        ENDIF.\n        rs_http-body = to_xstring( lv_body ).\n      CATCH cx_root.\n        rs_http-status = 500.\n        rs_http-body   = to_xstring( |Exception occurred| ).\n    ENDTRY.\n\n  ENDMETHOD.\n\n\n  METHOD to_json.\n\n    FIELD-SYMBOLS <fs> TYPE STANDARD TABLE.\n    DATA meta TYPE zcl_otm_table_maintenance=>ty_metadata.\n    DATA writer TYPE REF TO cl_sxml_string_writer.\n    ASSIGN ref->* TO <fs>.\n    ASSERT sy-subrc = 0.\n\n    \n    meta = build_metadata( ).\n    \n    writer = cl_sxml_string_writer=>create( if_sxml=>co_xt_json ).\n    CALL TRANSFORMATION id\n      SOURCE\n        data      = <fs>\n        meta      = meta\n        tablename = mv_table\n        sy        = sy\n      RESULT XML writer.\n    rv_json = from_xstring( writer->get_output( ) ).\n\n  ENDMETHOD.\n\n\n  METHOD to_xstring.\n\n    DATA conv TYPE REF TO object.\n        DATA conv_out_class TYPE c LENGTH 19.\n\n    TRY.\n        CALL METHOD (''CL_ABAP_CONV_CODEPAGE'')=>create_out\n          RECEIVING\n            instance = conv.\n\n        CALL METHOD conv->(''IF_ABAP_CONV_OUT~CONVERT'')\n          EXPORTING\n            source = string\n          RECEIVING\n            result = xstring.\n      CATCH cx_sy_dyn_call_illegal_class.\n        \n        conv_out_class = ''CL_ABAP_CONV_OUT_CE''.\n        CALL METHOD (conv_out_class)=>create\n          EXPORTING\n            encoding = ''UTF-8''\n          RECEIVING\n            conv     = conv.\n\n        CALL METHOD conv->(''CONVERT'')\n          EXPORTING\n            data   = string\n          IMPORTING\n            buffer = xstring.\n    ENDTRY.\n\n  ENDMETHOD.\nENDCLASS.\n');`);\ninsert.push(`INSERT INTO t100 ('SPRSL', 'ARBGB', 'MSGNR', 'TEXT') VALUES ('E', '00', '001', '&1&2&3&4');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_BCS', 'CLASS cl_bcs DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS create_persistent\n      RETURNING\n        VALUE(result) TYPE REF TO cl_bcs\n      RAISING\n        cx_bcs.\n\n    METHODS add_recipient\n      IMPORTING\n        i_recipient  TYPE REF TO if_recipient_bcs\n        i_express    TYPE abap_bool OPTIONAL\n        i_copy       TYPE abap_bool OPTIONAL\n        i_blind_copy TYPE abap_bool OPTIONAL\n        i_no_forward TYPE abap_bool OPTIONAL\n      RAISING\n        cx_bcs.\n\n    METHODS set_sender\n      IMPORTING\n        i_sender TYPE REF TO if_sender_bcs\n      RAISING\n        cx_bcs.\n\n    METHODS set_document\n      IMPORTING\n        i_document TYPE REF TO if_document_bcs\n      RAISING\n        cx_bcs.\n\n    METHODS set_message_subject\n      IMPORTING\n        ip_subject TYPE string\n      RAISING\n        cx_bcs.\n\n    METHODS send\n      IMPORTING\n        i_with_error_screen TYPE abap_bool DEFAULT abap_false\n      RETURNING\n        VALUE(result) TYPE abap_bool\n      RAISING\n        cx_bcs.\n\n    METHODS set_send_immediately\n      IMPORTING\n        i_send_immediately TYPE abap_bool\n      RAISING\n        cx_bcs.\nENDCLASS.\n\nCLASS cl_bcs IMPLEMENTATION.\n\n  METHOD set_document.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD set_send_immediately.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD set_message_subject.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD set_sender.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD send.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD create_persistent.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD add_recipient.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_BCS_CONVERT', 'CLASS cl_bcs_convert DEFINITION PUBLIC.\n  PUBLIC SECTION.\n\n    CLASS-METHODS string_to_soli\n      IMPORTING\n        iv_string      TYPE string\n      RETURNING\n        VALUE(et_soli) TYPE soli_tab.\n\n    CLASS-METHODS xstring_to_solix\n      IMPORTING\n        iv_xstring TYPE xstring\n      RETURNING\n        VALUE(et_solix) TYPE solix_tab.\n\nENDCLASS.\n\nCLASS cl_bcs_convert IMPLEMENTATION.\n\n  METHOD string_to_soli.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD xstring_to_solix.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_CAM_ADDRESS_BCS', 'CLASS cl_cam_address_bcs DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    INTERFACES if_recipient_bcs.\n\n    CLASS-METHODS create_internet_address\n      IMPORTING\n        i_address_string TYPE clike\n        i_address_name   TYPE clike OPTIONAL\n        i_incl_sapuser   TYPE abap_bool OPTIONAL\n      RETURNING\n        VALUE(result) TYPE REF TO cl_cam_address_bcs\n      RAISING\n        cx_bcs.\n\nENDCLASS.\n\nCLASS cl_cam_address_bcs IMPLEMENTATION.\n\n  METHOD create_internet_address.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_DOCUMENT_BCS', 'CLASS cl_document_bcs DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    INTERFACES if_document_bcs.\n\n    CLASS-METHODS create_document\n      IMPORTING\n        i_type    TYPE string\n        i_subject TYPE string\n        i_text    TYPE any OPTIONAL\n      RETURNING\n        VALUE(result) TYPE REF TO cl_document_bcs\n      RAISING\n        cx_bcs.\n\n    METHODS add_attachment\n      IMPORTING\n        i_attachment_type    TYPE string\n        i_attachment_subject TYPE string\n        i_attachment_size    TYPE i OPTIONAL\n        i_att_content_text   TYPE any OPTIONAL\n        i_att_content_hex    TYPE any OPTIONAL\n        i_attachment_header  TYPE soli_tab OPTIONAL\n      RAISING\n        cx_bcs.\n\nENDCLASS.\n\nCLASS cl_document_bcs IMPLEMENTATION.\n\n  METHOD create_document.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD add_attachment.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_BCS', 'CLASS cx_bcs DEFINITION PUBLIC INHERITING FROM cx_static_check.\n\nENDCLASS.\n\nCLASS cx_bcs IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_DOCUMENT_BCS', 'INTERFACE if_document_bcs PUBLIC.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_RECIPIENT_BCS', 'INTERFACE if_recipient_bcs PUBLIC.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SENDER_BCS', 'INTERFACE if_sender_bcs PUBLIC.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_CHAR_UTILITIES', 'CLASS cl_abap_char_utilities DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CONSTANTS:\n* https://en.wikipedia.org/wiki/Byte_order_mark, 0xEF,0xBB,0xBF\n      byte_order_mark_utf8 TYPE x LENGTH 3 VALUE ''EFBBBF'',\n      byte_order_mark_big TYPE x LENGTH 2 VALUE ''FEFF'',\n      byte_order_mark_little TYPE x LENGTH 2 VALUE ''FFFE'',\n      cr_lf TYPE c LENGTH 2 VALUE ''__'',\n      charsize TYPE i VALUE 2,\n      horizontal_tab TYPE c LENGTH 1 VALUE ''_'',\n      vertical_tab TYPE c LENGTH 1 VALUE ''_'',\n      form_feed TYPE c LENGTH 1 VALUE ''_'',\n      backspace TYPE c LENGTH 1 VALUE ''_'',\n      newline TYPE c LENGTH 1 VALUE ''_''.\n\n    CLASS-METHODS class_constructor.\n\n    CLASS-METHODS get_simple_spaces_for_cur_cp\n      RETURNING\n        VALUE(s_str) TYPE string.\nENDCLASS.\n\nCLASS cl_abap_char_utilities IMPLEMENTATION.\n\n  METHOD class_constructor.\n    WRITE ''@KERNEL cl_abap_char_utilities.cr_lf.set(\"\\\\r\\\\n\");''.\n    WRITE ''@KERNEL cl_abap_char_utilities.horizontal_tab.set(\"\\\\t\");''.\n    WRITE ''@KERNEL cl_abap_char_utilities.vertical_tab.set(\"\\\\v\");''.\n    WRITE ''@KERNEL cl_abap_char_utilities.form_feed.set(\"\\\\f\");''.\n    WRITE ''@KERNEL cl_abap_char_utilities.backspace.set(\"\\\\b\");''.\n    WRITE ''@KERNEL cl_abap_char_utilities.newline.set(\"\\\\n\");''.\n  ENDMETHOD.\n\n  METHOD get_simple_spaces_for_cur_cp.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_EXCEPTIONAL_VALUES', 'CLASS cl_abap_exceptional_values DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS get_max_value\n      IMPORTING\n        in_ TYPE any\n      RETURNING\n        VALUE(out) TYPE REF TO data.\n\n    CLASS-METHODS get_min_value\n      IMPORTING\n        in_ TYPE any\n      RETURNING\n        VALUE(out) TYPE REF TO data.\nENDCLASS.\n\nCLASS cl_abap_exceptional_values IMPLEMENTATION.\n\n  METHOD get_max_value.\n    DATA lv_type TYPE c LENGTH 1.\n\n    DESCRIBE FIELD in_ TYPE lv_type.\n\n    CASE lv_type.\n      WHEN cl_abap_typedescr=>typekind_int.\n        GET REFERENCE OF cl_abap_math=>max_int4 INTO out.\n      WHEN OTHERS.\n        ASSERT 1 = ''todo''.\n    ENDCASE.\n  ENDMETHOD.\n\n  METHOD get_min_value.\n    DATA lv_type TYPE c LENGTH 1.\n\n    DESCRIBE FIELD in_ TYPE lv_type.\n\n    CASE lv_type.\n      WHEN cl_abap_typedescr=>typekind_int.\n        GET REFERENCE OF cl_abap_math=>min_int4 INTO out.\n      WHEN OTHERS.\n        ASSERT 1 = ''todo''.\n    ENDCASE.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_FORMAT', 'CLASS cl_abap_format DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CONSTANTS e_html_attr TYPE i VALUE 5.\n    CONSTANTS e_html_text TYPE i VALUE 4.\n    CONSTANTS e_json_string TYPE i VALUE 24.\n    CONSTANTS e_url TYPE i VALUE 12.\nENDCLASS.\n\nCLASS cl_abap_format IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_GZIP', 'CLASS cl_abap_gzip DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS\n      decompress_binary\n        IMPORTING\n          gzip_in     TYPE xstring\n        EXPORTING\n          raw_out     TYPE xstring\n          raw_out_len TYPE i.\n\n    CLASS-METHODS\n      compress_binary\n        IMPORTING\n          compress_level TYPE i OPTIONAL\n          raw_in         TYPE xstring\n        EXPORTING\n          gzip_out       TYPE xstring\n          gzip_out_len   TYPE i.\nENDCLASS.\n\nCLASS cl_abap_gzip IMPLEMENTATION.\n  METHOD decompress_binary.\n    WRITE ''@KERNEL const zlib = await import(\"zlib\");''.\n    WRITE ''@KERNEL const buf = Buffer.from(gzip_in.get(), \"hex\");''.\n    WRITE ''@KERNEL const decompress = zlib.inflateRawSync(buf).toString(\"hex\").toUpperCase();''.\n\n    WRITE ''@KERNEL raw_out.set(decompress);''.\n    raw_out_len = xstrlen( raw_out ).\n  ENDMETHOD.\n\n  METHOD compress_binary.\n* todo, input parameter COMPRESS_LEVEL corresponds to \"level\" in \"options\" for Node?\n    WRITE ''@KERNEL const zlib = await import(\"zlib\");''.\n    WRITE ''@KERNEL const buf = Buffer.from(raw_in.get(), \"hex\");''.\n    WRITE ''@KERNEL const gzi = zlib.deflateRawSync(buf).toString(\"hex\").toUpperCase();''.\n\n    WRITE ''@KERNEL gzip_out.set(gzi);''.\n    gzip_out_len = xstrlen( gzip_out ).\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_HMAC', 'CLASS cl_abap_hmac DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS calculate_hmac_for_raw\n      IMPORTING\n        if_algorithm   TYPE string DEFAULT ''SHA1''\n        if_key         TYPE xstring\n        if_data        TYPE xstring\n      EXPORTING\n        ef_hmacstring  TYPE string\n        ef_hmacxstring TYPE xstring\n      RAISING\n        cx_abap_message_digest.\n    CLASS-METHODS calculate_hmac_for_char\n      IMPORTING\n        if_algorithm   TYPE string DEFAULT ''SHA1''\n        if_key         TYPE xstring\n        if_data        TYPE string\n      EXPORTING\n        ef_hmacstring  TYPE string\n        ef_hmacxstring TYPE xstring\n      RAISING\n        cx_abap_message_digest.\nENDCLASS.\n\nCLASS cl_abap_hmac IMPLEMENTATION.\n  METHOD calculate_hmac_for_raw.\n\n    DATA lv_algorithm TYPE string.\n\n    CLEAR ef_hmacstring.\n    CLEAR ef_hmacxstring.\n\n    lv_algorithm = to_lower( if_algorithm ).\n    ASSERT lv_algorithm = ''sha1'' OR lv_algorithm = ''md5'' OR lv_algorithm = ''sha256''.\n\n* todo, this doesnt work in browser?\n    WRITE ''@KERNEL const crypto = await import(\"crypto\");''.\n    IF if_key IS INITIAL.\n      WRITE ''@KERNEL var shasum = crypto.createHash(lv_algorithm.get());''.\n      WRITE ''@KERNEL shasum.update(if_data.get(), \"hex\");''.\n      WRITE ''@KERNEL ef_hmacstring.set(shasum.digest(\"hex\").toUpperCase());''.\n    ELSE.\n      WRITE ''@KERNEL let hmac = crypto.createHmac(lv_algorithm.get(), Buffer.from(if_key.get(), \"hex\")).update(if_data.get(), \"hex\").digest(\"hex\").toUpperCase();''.\n      WRITE ''@KERNEL ef_hmacstring.set(hmac);''.\n    ENDIF.\n\n    ef_hmacxstring = ef_hmacstring.\n\n  ENDMETHOD.\n\n  METHOD calculate_hmac_for_char.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_MATH', 'CLASS cl_abap_math DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CONSTANTS min_int4 TYPE i VALUE -2147483648.\n    CONSTANTS max_int4 TYPE i VALUE 2147483647.\n\n    CONSTANTS round_ceiling   TYPE i VALUE 0.\n    CONSTANTS round_up        TYPE i VALUE 1.\n    CONSTANTS round_half_up   TYPE i VALUE 2.\n    CONSTANTS round_half_even TYPE i VALUE 3.\n    CONSTANTS round_half_down TYPE i VALUE 4.\n    CONSTANTS round_down      TYPE i VALUE 5.\n    CONSTANTS round_floor     TYPE i VALUE 6.\nENDCLASS.\n\nCLASS cl_abap_math IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_RANDOM', 'CLASS cl_abap_random DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS create\n      IMPORTING\n        seed TYPE i OPTIONAL\n      RETURNING\n        VALUE(ro_random) TYPE REF TO cl_abap_random.\n    METHODS int RETURNING VALUE(rv_integer) TYPE i.\n    METHODS intinrange\n      IMPORTING\n        low  TYPE i\n        high TYPE i\n      RETURNING\n        VALUE(rv_integer) TYPE i.\n    CLASS-METHODS seed RETURNING VALUE(rv_seed) TYPE i.\n* todo, use \"crypto.\" instead, see cl_abap_hmac which also uses crypto\nENDCLASS.\n\nCLASS cl_abap_random IMPLEMENTATION.\n  METHOD create.\n    CREATE OBJECT ro_random.\n  ENDMETHOD.\n\n  METHOD int.\n* todo, currently only positive integers are returned\n    WRITE ''@KERNEL rv_integer.set(Math.floor(Math.random() * 2147483647));''.\n  ENDMETHOD.\n\n  METHOD seed.\n    WRITE ''@KERNEL rv_seed.set(Math.floor(Math.random() * 2147483647));''.\n  ENDMETHOD.\n\n  METHOD intinrange.\n* including \"low\" and \"high\" numbers\n    DATA lv_interval TYPE i.\n    ASSERT high > low.\n    ASSERT low >= 0.\n    lv_interval = high - low + 1.\n    rv_integer = abs( int( ) ).\n    rv_integer = rv_integer MOD lv_interval.\n    rv_integer = rv_integer + low.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_TSTMP', 'CLASS cl_abap_tstmp DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS subtract\n      IMPORTING\n        tstmp1 TYPE p\n        tstmp2 TYPE p\n      RETURNING\n        VALUE(r_secs) TYPE i.\n\n    CLASS-METHODS add\n      IMPORTING\n        tstmp   TYPE p\n        secs    TYPE i\n      RETURNING\n        VALUE(time) TYPE timestamp.\n\n    CLASS-METHODS subtractsecs\n      IMPORTING\n        tstmp   TYPE p\n        secs    TYPE i\n      RETURNING\n        VALUE(time) TYPE timestamp.\n\n    CLASS-METHODS td_add\n      IMPORTING\n        date     TYPE d\n        time     TYPE t\n        secs     TYPE numeric\n      EXPORTING\n        res_date TYPE d\n        res_time TYPE t.\n\n    CLASS-METHODS move\n      IMPORTING\n        tstmp_src   TYPE p\n      EXPORTING\n        tstmp_tgt TYPE p.\n\n    CLASS-METHODS systemtstmp_syst2utc\n      IMPORTING\n        syst_date TYPE d\n        syst_time TYPE t\n      EXPORTING\n        utc_tstmp TYPE p.\nENDCLASS.\n\nCLASS cl_abap_tstmp IMPLEMENTATION.\n\n  METHOD td_add.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD move.\n* todo, this is most likely wrong, but will also work in some cases\n    tstmp_tgt = tstmp_src.\n\n  ENDMETHOD.\n\n  METHOD systemtstmp_syst2utc.\n* system timezone is always UTC for open-abap, so no conversion needed\n    utc_tstmp = |{ syst_date }{ syst_time }|.\n  ENDMETHOD.\n\n  METHOD subtract.\n    DATA str TYPE string.\n    str = |{ tstmp1 TIMESTAMP = ISO }|.\n    WRITE ''@KERNEL let t1 = Date.parse(str.get());''.\n    str = |{ tstmp2 TIMESTAMP = ISO }|.\n    WRITE ''@KERNEL let t2 = Date.parse(str.get());''.\n    WRITE ''@KERNEL r_secs.set((t1 - t2)/1000);''.\n  ENDMETHOD.\n\n  METHOD add.\n    DATA str TYPE string.\n    str = |{ tstmp TIMESTAMP = ISO }|.\n    WRITE ''@KERNEL let t1 = new Date(Date.parse(str.get() + \"Z\"));''.\n    WRITE ''@KERNEL t1.setSeconds( t1.getSeconds() + secs.get() );''.\n    WRITE ''@KERNEL time.set(t1.toISOString().slice(0, 19).replace(/-/g, \"\").replace(/:/g, \"\").replace(\"T\", \"\"));''.\n  ENDMETHOD.\n\n  METHOD subtractsecs.\n    DATA lv_secs TYPE i.\n    lv_secs = secs * -1.\n    time = add(\n      tstmp = tstmp\n      secs  = lv_secs ).\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_ZIP', 'CLASS cl_abap_zip DEFINITION PUBLIC.\n\n  PUBLIC SECTION.\n    METHODS add\n      IMPORTING\n        name TYPE string\n        content TYPE xstring.\n\n    METHODS save RETURNING VALUE(val) TYPE xstring.\n\n    METHODS load IMPORTING zip TYPE xstring.\n\n    METHODS get\n      IMPORTING name TYPE string\n      EXPORTING content TYPE xstring.\n\n    CLASS-METHODS crc32\n      IMPORTING content TYPE xstring\n      RETURNING VALUE(crc) TYPE i.\n\n    TYPES: BEGIN OF t_file,\n             name TYPE string,\n           END OF t_file.\n    TYPES t_files TYPE STANDARD TABLE OF t_file WITH DEFAULT KEY.\n    DATA files TYPE t_files.\n\n  PRIVATE SECTION.\n    TYPES: BEGIN OF ty_contents,\n             name          TYPE string,\n             original_size TYPE i,\n* todo, optimize memory usage, dont store both compressed and original,\n             content       TYPE xstring,\n             compressed    TYPE xstring,\n           END OF ty_contents.\n    DATA mt_contents TYPE STANDARD TABLE OF ty_contents WITH DEFAULT KEY.\n\nENDCLASS.\n\nCLASS cl_abap_zip IMPLEMENTATION.\n\n  METHOD crc32.\n    DATA lo_stream TYPE REF TO lcl_stream.\n    CREATE OBJECT lo_stream.\n    crc = lo_stream->append_crc( content ).\n  ENDMETHOD.\n\n  METHOD get.\n    DATA:\n      ls_length TYPE i,\n      ls_contents LIKE LINE OF mt_contents.\n    READ TABLE mt_contents WITH KEY name = name INTO ls_contents.\n    cl_abap_gzip=>decompress_binary(\n        EXPORTING gzip_in = ls_contents-compressed\n        IMPORTING raw_out = content\n                  raw_out_len = ls_length ).\n  ENDMETHOD.\n\n  METHOD add.\n    DATA ls_contents LIKE LINE OF mt_contents.\n    ls_contents-name = name.\n    ls_contents-original_size = xstrlen( content ).\n    ls_contents-content = content.\n    cl_abap_gzip=>compress_binary(\n      EXPORTING\n        raw_in   = content\n      IMPORTING\n        gzip_out = ls_contents-compressed ).\n    INSERT ls_contents INTO TABLE mt_contents.\n  ENDMETHOD.\n\n  METHOD load.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD save.\n* https://en.wikipedia.org/wiki/ZIP_(file_format)\n\n    DATA lo_stream TYPE REF TO lcl_stream.\n    DATA ls_contents LIKE LINE OF mt_contents.\n    DATA lv_buffer TYPE xstring.\n    DATA lo_conv TYPE REF TO cl_abap_conv_out_ce.\n\n    CREATE OBJECT lo_stream.\n    lo_conv = cl_abap_conv_out_ce=>create( ).\n\n    LOOP AT mt_contents INTO ls_contents.\n* 0, 4, Local file header signature\n      lo_stream->append( ''504B0304'' ).\n* 4, 2, Version needed to extract (minimum)\n      lo_stream->append( ''1400'' ).\n* 6, 2, General purpose bit flag\n      lo_stream->append( ''0000'' ).\n* 8, 2, Compression method; e.g. none = 0, DEFLATE = 8 (or \"0x08 0x00\")\n      lo_stream->append( ''0800'' ).\n* 10, 2, File last modification time\n      lo_stream->append( ''0000'' ). \"lo_stream->append_time( sy-uzeit ).\n* 12, 2, File last modification date\n      lo_stream->append( ''0000'' ). \"lo_stream->append_date( sy-datum ).\n* 14, 4, CRC-32 of uncompressed data\n      lo_stream->append_crc( ls_contents-content ).\n* 18, 4, Compressed size (or 0xffffffff for ZIP64)\n      lo_stream->append_int4( xstrlen( ls_contents-compressed ) ).\n* 22, 4, Uncompressed size (or 0xffffffff for ZIP64)\n      lo_stream->append_int4( xstrlen( ls_contents-content ) ).\n* 26, 2, File name length (n)\n      lo_stream->append_int2( strlen( ls_contents-name ) ).\n* 28, 2, Extra field length (m)\n      lo_stream->append( ''0000'' ).\n* 30, n, File name\n      lo_conv->convert( EXPORTING data = ls_contents-name\n                        IMPORTING buffer = lv_buffer ).\n      lo_stream->append( lv_buffer ).\n* 30+n, m, Extra field\n* empty, no extra field\n* compressed data,\n      lo_stream->append( ls_contents-compressed ).\n    ENDLOOP.\n\n    val = lo_stream->get( ).\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_GDT_CONVERSION', 'CLASS cl_gdt_conversion DEFINITION PUBLIC.\n\n  PUBLIC SECTION.\n    CLASS-METHODS language_code_outbound\n      IMPORTING\n        im_value TYPE spras\n      EXPORTING\n        ex_value TYPE laiso.\n\n    CLASS-METHODS language_code_inbound\n      IMPORTING\n        im_value TYPE csequence\n      EXPORTING\n        ex_value TYPE spras\n      RAISING\n        cx_gdt_conversion.\n\n    CLASS-METHODS amount_outbound\n      IMPORTING\n        im_value         TYPE p\n        im_currency_code TYPE string\n      EXPORTING\n        ex_value         TYPE p\n      RAISING\n        cx_gdt_conversion.\n\n    CLASS-METHODS country_code_outbound\n      IMPORTING\n        im_value TYPE string\n      EXPORTING\n        ex_value TYPE csequence\n      RAISING\n        cx_gdt_conversion.\n\n    CLASS-METHODS date_time_inbound\n      IMPORTING\n        im_value       TYPE csequence\n      EXPORTING\n        ex_value_short TYPE timestamp\n      RAISING\n        cx_gdt_conversion.\n\n    CLASS-METHODS unit_code_inbound\n      IMPORTING\n        im_value TYPE csequence\n      EXPORTING\n        ex_value TYPE csequence\n      RAISING\n        cx_gdt_conversion.\n\n    CLASS-METHODS unit_code_outbound\n      IMPORTING\n        im_value TYPE csequence\n      EXPORTING\n        ex_value TYPE csequence\n      RAISING\n        cx_gdt_conversion.\n\nENDCLASS.\n\nCLASS cl_gdt_conversion IMPLEMENTATION.\n\n  METHOD amount_outbound.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD language_code_inbound.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD unit_code_outbound.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD country_code_outbound.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD date_time_inbound.\n    DATA lv_str TYPE string.\n\n    IF im_value NP ''*Z''.\n      ASSERT 1 = ''todo, only handles UTC for now''.\n    ENDIF.\n\n    lv_str = im_value.\n    REPLACE ALL OCCURRENCES OF ''-'' IN lv_str WITH ''''.\n    REPLACE ALL OCCURRENCES OF '':'' IN lv_str WITH ''''.\n    REPLACE ALL OCCURRENCES OF ''T'' IN lv_str WITH ''''.\n    REPLACE ALL OCCURRENCES OF ''Z'' IN lv_str WITH ''''.\n    ex_value_short = lv_str.\n  ENDMETHOD.\n\n  METHOD unit_code_inbound.\n\n* todo, first look up in database, if there is no database connected, fallback to below\n\n    CASE im_value.\n      WHEN ''MTR''.\n        ex_value = ''M''.\n      WHEN ''PCE''.\n        ex_value = ''PC''.\n      WHEN ''KGM''.\n        ex_value = ''KG''.\n      WHEN ''LTR''.\n        ex_value = ''L''.\n      WHEN OTHERS.\n        ASSERT 1 = ''todo''.\n    ENDCASE.\n\n  ENDMETHOD.\n\n  METHOD language_code_outbound.\n\n* todo, first look up in database, if there is no database connected, fallback to below\n\n    CASE im_value.\n      WHEN ''E''.\n        ex_value = ''en''.\n      WHEN ''K''.\n        ex_value = ''da''.\n      WHEN ''D''.\n        ex_value = ''de''.\n      WHEN OTHERS.\n        ASSERT 0 = 1.\n    ENDCASE.\n\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_I18N_LANGUAGES', 'CLASS cl_i18n_languages DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS sap1_to_sap2\n      IMPORTING\n        im_lang_sap1        TYPE sy-langu\n      RETURNING\n        VALUE(re_lang_sap2) TYPE string\n      EXCEPTIONS\n        no_assignment.\n\n    CLASS-METHODS sap2_to_iso639_1\n      IMPORTING\n        im_lang_sap2   TYPE string\n      EXPORTING\n        ex_lang_iso639 TYPE string\n        ex_country     TYPE land1\n      EXCEPTIONS\n        no_assignment.\nENDCLASS.\n\nCLASS cl_i18n_languages IMPLEMENTATION.\n  METHOD sap1_to_sap2.\n* todo, ideally this should look up in a database table first\n* if there is no database attached, fallback to the CASE below\n    CASE im_lang_sap1.\n      WHEN ''E''.\n        re_lang_sap2 = ''EN''.\n      WHEN ''D''.\n        re_lang_sap2 = ''DE''.\n      WHEN ''K''.\n        re_lang_sap2 = ''DA''.\n      WHEN OTHERS.\n* todo, raise classic exception\n        re_lang_sap2 = ''EN''.\n    ENDCASE.\n  ENDMETHOD.\n\n  METHOD sap2_to_iso639_1.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_MESSAGE_HELPER', 'CLASS cl_message_helper DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS set_msg_vars_for_if_msg\n      IMPORTING\n        text TYPE REF TO if_message\n      EXPORTING\n        VALUE(string) TYPE string.\n\n    CLASS-METHODS set_msg_vars_for_clike\n      IMPORTING\n        text TYPE clike.\n\n    CLASS-METHODS get_text_for_message\n      IMPORTING\n        text TYPE REF TO if_message\n      RETURNING\n        VALUE(result) TYPE string.\n  PRIVATE SECTION.\n    CONSTANTS gc_fallback TYPE string VALUE ''An exception was raised.''.\nENDCLASS.\n\nCLASS cl_message_helper IMPLEMENTATION.\n\n  METHOD get_text_for_message.\n\n    DATA lv_msgid LIKE sy-msgid.\n    DATA lv_msgno LIKE sy-msgno.\n    DATA lv_msgv1 LIKE sy-msgv1.\n    DATA lv_msgv2 LIKE sy-msgv2.\n    DATA lv_msgv3 LIKE sy-msgv3.\n    DATA lv_msgv4 LIKE sy-msgv4.\n\n* when the transpiler can do more, the below can be implemented in ABAP instead of using KERNEL,\n    WRITE ''@KERNEL if (text.get().if_t100_message$t100key === undefined) { result.set(this.gc_fallback); return result; };''.\n\n    WRITE ''@KERNEL lv_msgid.set(text.get().if_t100_message$t100key.get().msgid);''.\n    WRITE ''@KERNEL lv_msgno.set(text.get().if_t100_message$t100key.get().msgno);''.\n    WRITE ''@KERNEL lv_msgv1.set(text.get()[text.get().if_t100_message$t100key.get().attr1.get().toLowerCase().replace(\"~\", \"$\")] ? text.get()[text.get().if_t100_message$t100key.get().attr1.get().toLowerCase().replace(\"~\", \"$\")].get() : \"\");''.\n    WRITE ''@KERNEL lv_msgv2.set(text.get()[text.get().if_t100_message$t100key.get().attr2.get().toLowerCase().replace(\"~\", \"$\")] ? text.get()[text.get().if_t100_message$t100key.get().attr2.get().toLowerCase().replace(\"~\", \"$\")].get() : \"\");''.\n    WRITE ''@KERNEL lv_msgv3.set(text.get()[text.get().if_t100_message$t100key.get().attr3.get().toLowerCase().replace(\"~\", \"$\")] ? text.get()[text.get().if_t100_message$t100key.get().attr3.get().toLowerCase().replace(\"~\", \"$\")].get() : \"\");''.\n    WRITE ''@KERNEL lv_msgv4.set(text.get()[text.get().if_t100_message$t100key.get().attr4.get().toLowerCase().replace(\"~\", \"$\")] ? text.get()[text.get().if_t100_message$t100key.get().attr4.get().toLowerCase().replace(\"~\", \"$\")].get() : \"\");''.\n\n    MESSAGE ID lv_msgid TYPE ''I'' NUMBER lv_msgno WITH lv_msgv1 lv_msgv2 lv_msgv3 lv_msgv4 INTO result.\n\n  ENDMETHOD.\n\n  METHOD set_msg_vars_for_if_msg.\n    IF text IS INITIAL.\n      RAISE EXCEPTION TYPE cx_sy_message_illegal_text.\n    ENDIF.\n\n* first try if_t100_message\n    string = get_text_for_message( text ).\n    IF string <> gc_fallback.\n      CLEAR sy-msgty.\n      RETURN.\n    ENDIF.\n\n    string = text->get_text( ).\n    IF string IS INITIAL.\n      ASSERT 1 = ''todo''.\n    ENDIF.\n\n    set_msg_vars_for_clike( string ).\n  ENDMETHOD.\n\n  METHOD set_msg_vars_for_clike.\n    sy-msgid = ''00''.\n    sy-msgno = ''001''.\n    sy-msgv1 = text.\n    IF strlen( text ) > 50.\n      sy-msgv2 = text+50.\n    ENDIF.\n    IF strlen( text ) > 100.\n      sy-msgv3 = text+100.\n    ENDIF.\n    IF strlen( text ) > 150.\n      sy-msgv4 = text+150.\n    ENDIF.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_OO_ADT_CLASSRUN', 'INTERFACE if_oo_adt_classrun PUBLIC.\n  METHODS main IMPORTING out TYPE REF TO if_oo_adt_classrun_out.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_OO_ADT_CLASSRUN_OUT', 'INTERFACE if_oo_adt_classrun_out PUBLIC.\n\n  METHODS write\n    IMPORTING\n      data TYPE any\n      name TYPE string OPTIONAL\n    RETURNING\n      VALUE(output) TYPE REF TO if_oo_adt_classrun_out.\n\n  METHODS get\n    IMPORTING\n      data TYPE any OPTIONAL\n      name TYPE string OPTIONAL PREFERRED PARAMETER data\n    RETURNING\n      VALUE(output) TYPE string.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_CODEPAGE', 'CLASS cl_abap_codepage DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS convert_to\n      IMPORTING\n        codepage      TYPE string OPTIONAL\n        source        TYPE string\n      RETURNING\n        VALUE(output) TYPE xstring.\n\n    CLASS-METHODS convert_from\n      IMPORTING\n        codepage      TYPE string OPTIONAL\n        source        TYPE xstring\n      RETURNING\n        VALUE(output) TYPE string.\n\n    CLASS-METHODS sap_codepage\n      IMPORTING\n        encoding TYPE string\n      RETURNING\n        VALUE(codepage) TYPE abap_encoding.\nENDCLASS.\n\nCLASS cl_abap_codepage IMPLEMENTATION.\n  METHOD convert_to.\n    DATA conv TYPE REF TO cl_abap_conv_out_ce.\n    conv = cl_abap_conv_out_ce=>create( encoding = ''UTF-8'' ).\n    conv->convert( EXPORTING data   = source\n                   IMPORTING buffer = output ).\n  ENDMETHOD.\n\n  METHOD convert_from.\n    DATA conv TYPE REF TO cl_abap_conv_in_ce.\n    DATA data TYPE string.\n    conv = cl_abap_conv_in_ce=>create( encoding = ''UTF-8'' ).\n    conv->convert(\n      EXPORTING input = source\n      IMPORTING data = output ).\n  ENDMETHOD.\n\n  METHOD sap_codepage.\n    ASSERT encoding = ''UTF-16LE''.\n    codepage = ''4103''.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_CONV_CODEPAGE', 'CLASS cl_abap_conv_codepage DEFINITION PUBLIC FINAL CREATE PRIVATE.\n\n  PUBLIC SECTION.\n\n    CLASS-METHODS create_in\n      RETURNING\n        VALUE(instance) TYPE REF TO if_abap_conv_in\n      RAISING\n        cx_parameter_invalid_range.\n\n    CLASS-METHODS create_out\n      RETURNING\n        VALUE(instance) TYPE REF TO if_abap_conv_out\n      RAISING\n        cx_parameter_invalid_range.\n\nENDCLASS.\n\nCLASS cl_abap_conv_codepage IMPLEMENTATION.\n\n  METHOD create_in.\n    CREATE OBJECT instance TYPE lcl_in.\n  ENDMETHOD.\n\n  METHOD create_out.\n    CREATE OBJECT instance TYPE lcl_out.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_CONV_IN_CE', 'CLASS cl_abap_conv_in_ce DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS\n      create\n        IMPORTING\n          encoding TYPE abap_encoding DEFAULT ''UTF-8''\n          input TYPE xstring OPTIONAL\n        RETURNING\n          VALUE(ret) TYPE REF TO cl_abap_conv_in_ce.\n    CLASS-METHODS\n      uccpi\n        IMPORTING\n          value TYPE i\n        RETURNING\n          VALUE(ret) TYPE string.\n    METHODS\n      convert\n        IMPORTING\n          input TYPE xstring\n          n     TYPE i OPTIONAL\n        EXPORTING\n          data  TYPE string.\n    METHODS\n      read\n        IMPORTING\n          n     TYPE i OPTIONAL\n        EXPORTING\n          data  TYPE string.\n  PRIVATE SECTION.\n    DATA mv_input TYPE xstring.\n    DATA mv_js_encoding TYPE string.\nENDCLASS.\n\nCLASS cl_abap_conv_in_ce IMPLEMENTATION.\n  METHOD create.\n    CREATE OBJECT ret.\n\n    CASE encoding.\n      WHEN ''UTF-8''.\n        ret->mv_js_encoding = ''utf8''.\n      WHEN ''4103''.\n        ret->mv_js_encoding = ''utf16le''.\n      WHEN OTHERS.\n        ASSERT 1 = ''not supported''.\n    ENDCASE.\n\n    ret->mv_input = input.\n  ENDMETHOD.\n\n  METHOD uccpi.\n    DATA lv_hex TYPE x LENGTH 2.\n    DATA lo_in TYPE REF TO cl_abap_conv_in_ce.\n\n    lv_hex(1) = value MOD 255.\n    lv_hex+1(1) = value DIV 255.\n\n    lo_in = create( encoding = ''4103'' ).\n\n    lo_in->convert(\n      EXPORTING\n        input = lv_hex\n      IMPORTING\n        data  = ret ).\n  ENDMETHOD.\n\n  METHOD convert.\n    IF input IS INITIAL.\n      RETURN.\n    ENDIF.\n    ASSERT mv_js_encoding IS NOT INITIAL.\n    WRITE ''@KERNEL let result = Buffer.from(input.get(), \"hex\").toString(this.mv_js_encoding.get());''.\n    WRITE ''@KERNEL data.set(result);''.\n  ENDMETHOD.\n\n  METHOD read.\n    convert(\n      EXPORTING\n        input = mv_input\n        n     = n\n      IMPORTING\n        data  = data ).\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_CONV_OUT_CE', 'CLASS cl_abap_conv_out_ce DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS\n      create\n        IMPORTING\n          encoding    TYPE abap_encoding OPTIONAL\n          ignore_cerr TYPE abap_bool DEFAULT abap_false\n          endian      TYPE string OPTIONAL\n          replacement TYPE string OPTIONAL\n        RETURNING\n          VALUE(ret)  TYPE REF TO cl_abap_conv_out_ce.\n    CLASS-METHODS\n      uccpi\n        IMPORTING\n          value TYPE string\n        RETURNING\n          VALUE(ret) TYPE i.\n    METHODS\n      convert\n        IMPORTING\n          data   TYPE string\n          n      TYPE i OPTIONAL\n        EXPORTING\n          buffer TYPE xstring.\n    METHODS write\n      IMPORTING\n        data TYPE string.\n    METHODS get_buffer\n      RETURNING\n        VALUE(buffer) TYPE xstring.\n    METHODS reset.\n  PRIVATE SECTION.\n    DATA mv_js_encoding TYPE string.\n    DATA mv_buffer TYPE xstring.\nENDCLASS.\n\nCLASS cl_abap_conv_out_ce IMPLEMENTATION.\n  METHOD create.\n    CREATE OBJECT ret.\n    CASE encoding.\n      WHEN ''UTF-8'' OR ''''.\n        ret->mv_js_encoding = ''utf8''.\n      WHEN ''4103''.\n        ret->mv_js_encoding = ''utf16le''.\n      WHEN OTHERS.\n        ASSERT 1 = ''not supported''.\n    ENDCASE.\n  ENDMETHOD.\n\n  METHOD uccpi.\n    DATA lo_out TYPE REF TO cl_abap_conv_out_ce.\n    DATA lv_hex TYPE xstring.\n    lo_out = create( encoding = ''4103'' ).\n    lo_out->convert(\n      EXPORTING\n        data = value\n      IMPORTING\n        buffer = lv_hex ).\n    ASSERT xstrlen( lv_hex ) = 2.\n    ret = lv_hex(1).\n    ret = ret + lv_hex+1(1) * 255.\n  ENDMETHOD.\n\n  METHOD write.\n    DATA res TYPE xstring.\n    convert( EXPORTING data = data\n             IMPORTING buffer = res ).\n    CONCATENATE mv_buffer res INTO mv_buffer IN BYTE MODE.\n  ENDMETHOD.\n\n  METHOD get_buffer.\n    buffer = mv_buffer.\n  ENDMETHOD.\n\n  METHOD reset.\n    CLEAR mv_buffer.\n  ENDMETHOD.\n\n  METHOD convert.\n* todo, input parameter \"N\" not handled\n\n    WRITE ''@KERNEL let result = Buffer.from(data.get(), this.mv_js_encoding.get()).toString(\"hex\");''.\n    WRITE ''@KERNEL buffer.set(result.toUpperCase());''.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_ABAP_CONV_IN', 'INTERFACE if_abap_conv_in PUBLIC.\n\n  METHODS convert\n    IMPORTING\n      source TYPE xstring\n    RETURNING\n      VALUE(result) TYPE string\n    RAISING\n      cx_sy_conversion_codepage.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_ABAP_CONV_OUT', 'INTERFACE if_abap_conv_out PUBLIC.\n\n  METHODS convert\n    IMPORTING\n      source TYPE string\n    RETURNING\n      VALUE(result) TYPE xstring\n    RAISING\n      cx_sy_conversion_codepage.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_ABAP_MESSAGE_DIGEST', 'CLASS cx_abap_message_digest DEFINITION PUBLIC INHERITING FROM cx_static_check.\n\nENDCLASS.\n\nCLASS cx_abap_message_digest IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_DYNAMIC_CHECK', 'CLASS cx_dynamic_check DEFINITION ABSTRACT PUBLIC INHERITING FROM cx_root.\n\nENDCLASS.\n\nCLASS cx_dynamic_check IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_GDT_CONVERSION', 'CLASS cx_gdt_conversion DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_gdt_conversion IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_NO_CHECK', 'CLASS cx_no_check DEFINITION PUBLIC INHERITING FROM cx_root.\n\n  PUBLIC SECTION.\n    METHODS constructor\n      IMPORTING\n        previous TYPE REF TO cx_root OPTIONAL.\n\nENDCLASS.\n\nCLASS cx_no_check IMPLEMENTATION.\n\n  METHOD constructor.\n    super->constructor( previous = previous ).\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_PARAMETER_INVALID', 'CLASS cx_parameter_invalid DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_parameter_invalid IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_PARAMETER_INVALID_RANGE', 'CLASS cx_parameter_invalid_range DEFINITION PUBLIC INHERITING FROM cx_parameter_invalid.\n\nENDCLASS.\n\nCLASS cx_parameter_invalid_range IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_PARAMETER_INVALID_TYPE', 'CLASS cx_parameter_invalid_type DEFINITION PUBLIC INHERITING FROM cx_parameter_invalid.\n\nENDCLASS.\n\nCLASS cx_parameter_invalid_type IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_ROOT', 'CLASS cx_root DEFINITION ABSTRACT PUBLIC.\n\n  PUBLIC SECTION.\n    DATA previous TYPE REF TO cx_root.\n    DATA textid   TYPE c LENGTH 32.\n\n    METHODS constructor\n      IMPORTING\n        textid   LIKE textid OPTIONAL\n        previous TYPE REF TO cx_root OPTIONAL.\n\n    METHODS get_source_position\n      EXPORTING\n        program_name TYPE string\n        include_name TYPE string\n        source_line  TYPE string.\n\n    INTERFACES if_message.\n    ALIASES get_longtext FOR if_message~get_longtext.\n    ALIASES get_text FOR if_message~get_text.\n\nENDCLASS.\n\nCLASS cx_root IMPLEMENTATION.\n\n  METHOD constructor.\n    me->previous = previous.\n    me->textid = textid.\n  ENDMETHOD.\n\n  METHOD get_source_position.\n    ASSERT ''todo'' = 1.\n  ENDMETHOD.\n\n  METHOD if_message~get_longtext.\n    result = ''OpenAbapGetLongtextDummyValue''.\n  ENDMETHOD.\n\n  METHOD if_message~get_text.\n    result = cl_message_helper=>get_text_for_message( me ).\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_STATIC_CHECK', 'CLASS cx_static_check DEFINITION PUBLIC INHERITING FROM cx_root.\n\n  PUBLIC SECTION.\n    METHODS constructor\n      IMPORTING\n        textid   LIKE if_t100_message=>t100key OPTIONAL\n        previous TYPE REF TO cx_root OPTIONAL\n        msgv1    TYPE c OPTIONAL\n        msgv2    TYPE c OPTIONAL\n        msgv3    TYPE c OPTIONAL\n        msgv4    TYPE c OPTIONAL.\nENDCLASS.\n\nCLASS cx_static_check IMPLEMENTATION.\n\n  METHOD constructor.\n    super->constructor(\n      textid   = textid\n      previous = previous ).\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_BUFFER_OVERFLOW', 'CLASS cx_sy_buffer_overflow DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_sy_buffer_overflow IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_CODEPAGE_CONVERTER_INIT', 'CLASS cx_sy_codepage_converter_init DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_sy_codepage_converter_init IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_COMPRESSION_ERROR', 'CLASS cx_sy_compression_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_sy_compression_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_CONVERSION_CODEPAGE', 'CLASS cx_sy_conversion_codepage DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n  PUBLIC SECTION.\n    DATA source_extract TYPE xstring.\nENDCLASS.\n\nCLASS cx_sy_conversion_codepage IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_CONVERSION_DATA_LOSS', 'CLASS cx_sy_conversion_data_loss DEFINITION PUBLIC INHERITING FROM cx_sy_conversion_error.\n\nENDCLASS.\n\nCLASS cx_sy_conversion_data_loss IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_CONVERSION_ERROR', 'CLASS cx_sy_conversion_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_sy_conversion_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_CONVERSION_NO_NUMBER', 'CLASS cx_sy_conversion_no_number DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_sy_conversion_no_number IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_CONVERSION_OVERFLOW', 'CLASS cx_sy_conversion_overflow DEFINITION PUBLIC INHERITING FROM cx_sy_conversion_error.\n\nENDCLASS.\n\nCLASS cx_sy_conversion_overflow IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_CREATE_DATA_ERROR', 'CLASS cx_sy_create_data_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_sy_create_data_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_CREATE_OBJECT_ERROR', 'CLASS cx_sy_create_object_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_sy_create_object_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_DATA_ACCESS_ERROR', 'CLASS cx_sy_data_access_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_sy_data_access_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_DYN_CALL_ERROR', 'CLASS cx_sy_dyn_call_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_sy_dyn_call_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_DYN_CALL_ILLEGAL_CLASS', 'CLASS cx_sy_dyn_call_illegal_class DEFINITION PUBLIC INHERITING FROM cx_sy_dyn_call_error.\n\nENDCLASS.\n\nCLASS cx_sy_dyn_call_illegal_class IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_DYN_CALL_ILLEGAL_METHOD', 'CLASS cx_sy_dyn_call_illegal_method DEFINITION PUBLIC INHERITING FROM cx_sy_dyn_call_error.\n\n  PUBLIC SECTION.\n    CONSTANTS private_method TYPE c VALUE ''1''.\n\n    METHODS constructor\n      IMPORTING\n        textid     LIKE textid OPTIONAL\n        previous   LIKE previous OPTIONAL\n        classname  TYPE string OPTIONAL\n        methodname TYPE string OPTIONAL.\n\nENDCLASS.\n\nCLASS cx_sy_dyn_call_illegal_method IMPLEMENTATION.\n\n  METHOD constructor.\n    RETURN.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_DYN_CALL_PARAM_NOT_FOUND', 'CLASS cx_sy_dyn_call_param_not_found DEFINITION PUBLIC INHERITING FROM cx_sy_dyn_call_parameter_error.\n\nENDCLASS.\n\nCLASS cx_sy_dyn_call_param_not_found IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_DYN_CALL_PARAMETER_ERROR', 'CLASS cx_sy_dyn_call_parameter_error DEFINITION PUBLIC INHERITING FROM cx_sy_dyn_call_error.\n  PUBLIC SECTION.\n    DATA parameter TYPE string.\nENDCLASS.\n\nCLASS cx_sy_dyn_call_parameter_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_DYNAMIC_OSQL_ERROR', 'CLASS cx_sy_dynamic_osql_error DEFINITION PUBLIC INHERITING FROM cx_sy_open_sql_error.\n  PUBLIC SECTION.\n    METHODS constructor\n      IMPORTING\n        sqlmsg TYPE string OPTIONAL.\nENDCLASS.\n\nCLASS cx_sy_dynamic_osql_error IMPLEMENTATION.\n  METHOD constructor.\n    super->constructor( sqlmsg = sqlmsg ).\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_DYNAMIC_OSQL_SEMANTICS', 'CLASS cx_sy_dynamic_osql_semantics DEFINITION PUBLIC INHERITING FROM cx_sy_dynamic_osql_error.\n  PUBLIC SECTION.\n    METHODS constructor\n      IMPORTING\n        sqlmsg TYPE string OPTIONAL.\nENDCLASS.\n\nCLASS cx_sy_dynamic_osql_semantics IMPLEMENTATION.\n  METHOD constructor.\n    super->constructor( sqlmsg = sqlmsg ).\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_ITAB_LINE_NOT_FOUND', 'CLASS cx_sy_itab_line_not_found DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_sy_itab_line_not_found IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_MESSAGE_ILLEGAL_TEXT', 'CLASS cx_sy_message_illegal_text DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n  PUBLIC SECTION.\nENDCLASS.\n\nCLASS cx_sy_message_illegal_text IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_MOVE_CAST_ERROR', 'CLASS cx_sy_move_cast_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_sy_move_cast_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_OPEN_SQL_ERROR', 'CLASS cx_sy_open_sql_error DEFINITION PUBLIC INHERITING FROM cx_sy_sql_error.\n  PUBLIC SECTION.\n    METHODS constructor\n      IMPORTING\n        sqlmsg TYPE string OPTIONAL.\nENDCLASS.\n\nCLASS cx_sy_open_sql_error IMPLEMENTATION.\n  METHOD constructor.\n    super->constructor( sqlmsg = sqlmsg ).\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_RANGE_OUT_OF_BOUNDS', 'CLASS cx_sy_range_out_of_bounds DEFINITION PUBLIC INHERITING FROM cx_sy_data_access_error.\n\nENDCLASS.\n\nCLASS cx_sy_range_out_of_bounds IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_REF_IS_INITIAL', 'CLASS cx_sy_ref_is_initial DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_sy_ref_is_initial IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SY_SQL_ERROR', 'CLASS cx_sy_sql_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n  PUBLIC SECTION.\n    DATA sqlmsg TYPE string.\n\n    METHODS constructor\n      IMPORTING\n        sqlmsg TYPE string OPTIONAL.\nENDCLASS.\n\nCLASS cx_sy_sql_error IMPLEMENTATION.\n  METHOD constructor.\n    me->sqlmsg = sqlmsg.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_TRANSFORMATION_ERROR', 'CLASS cx_transformation_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_transformation_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_XSLT_FORMAT_ERROR', 'CLASS cx_xslt_format_error DEFINITION PUBLIC INHERITING FROM cx_transformation_error.\n\nENDCLASS.\n\nCLASS cx_xslt_format_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_XSLT_RUNTIME_ERROR', 'CLASS cx_xslt_runtime_error DEFINITION PUBLIC INHERITING FROM cx_transformation_error.\n\nENDCLASS.\n\nCLASS cx_xslt_runtime_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_MESSAGE', 'INTERFACE if_message PUBLIC.\n\n  METHODS get_text RETURNING VALUE(result) TYPE string.\n\n  METHODS get_longtext\n    IMPORTING preserve_newlines TYPE abap_bool OPTIONAL\n    RETURNING VALUE(result) TYPE string.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_T100_DYN_MSG', 'INTERFACE if_t100_dyn_msg PUBLIC.\n\n  DATA msgty TYPE symsgty.\n\n  DATA msgv1 TYPE symsgv.\n  DATA msgv2 TYPE symsgv.\n  DATA msgv3 TYPE symsgv.\n  DATA msgv4 TYPE symsgv.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_T100_MESSAGE', 'INTERFACE if_t100_message PUBLIC.\n\n  DATA t100key TYPE scx_t100key.\n\n  CONSTANTS:\n    BEGIN OF default_textid,\n      msgid TYPE symsgid VALUE ''AB'',\n      msgno TYPE symsgno VALUE ''123'',\n      attr1 TYPE scx_attrname VALUE '''',\n      attr2 TYPE scx_attrname VALUE '''',\n      attr3 TYPE scx_attrname VALUE '''',\n      attr4 TYPE scx_attrname VALUE '''',\n    END OF default_textid.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_FUGR_TEST', 'CLASS kernel_fugr_test DEFINITION PUBLIC.\n  PUBLIC SECTION.\nENDCLASS.\n\nCLASS kernel_fugr_test IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_DEMO_OUTPUT', 'CLASS cl_demo_output DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS write\n      IMPORTING\n        data TYPE any\n        name TYPE string OPTIONAL.\n    CLASS-METHODS clear.\n    CLASS-METHODS display\n      IMPORTING\n      data TYPE any OPTIONAL\n      name TYPE string OPTIONAL PREFERRED PARAMETER data.\nENDCLASS.\n\nCLASS cl_demo_output IMPLEMENTATION.\n  METHOD write.\n    ASSERT 1 = ''not supported''.\n  ENDMETHOD.\n\n  METHOD clear.\n    ASSERT 1 = ''not supported''.\n  ENDMETHOD.\n\n  METHOD display.\n    ASSERT 1 = ''not supported''.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_GUI_CFW', 'CLASS cl_gui_cfw DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS\n      compute_pixel_from_metric\n        IMPORTING\n          x_or_y TYPE c\n          in_     TYPE i\n        RETURNING\n          VALUE(val) TYPE i.\n\n    CLASS-METHODS flush.\nENDCLASS.\n\nCLASS cl_gui_cfw IMPLEMENTATION.\n  METHOD compute_pixel_from_metric.\n    val = 1.\n  ENDMETHOD.\n\n  METHOD flush.\n    RETURN.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_GUI_CONTAINER', 'CLASS cl_gui_container DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CONSTANTS screen0 TYPE string VALUE ''screen0''.\n    CONSTANTS visible_true TYPE c LENGTH 1 VALUE ''1''.\n    CONSTANTS visible_false TYPE c LENGTH 1 VALUE ''0''.\nENDCLASS.\n\nCLASS cl_gui_container IMPLEMENTATION.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_GUI_FRONTEND_SERVICES', 'CLASS cl_gui_frontend_services DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CONSTANTS filetype_all TYPE string VALUE ''abc''.\n    CONSTANTS action_cancel TYPE i VALUE 1.\n    CONSTANTS action_ok TYPE i VALUE 1.\n\n    CONSTANTS platform_nt351 TYPE i VALUE 1.\n    CONSTANTS platform_nt40 TYPE i VALUE 2.\n    CONSTANTS platform_nt50 TYPE i VALUE 3.\n    CONSTANTS platform_windows95 TYPE i VALUE 4.\n    CONSTANTS platform_windows98 TYPE i VALUE 5.\n    CONSTANTS platform_windowsxp TYPE i VALUE 6.\n\n    CLASS-METHODS\n      gui_download\n        IMPORTING\n          bin_filesize          TYPE i OPTIONAL\n          filename              TYPE string\n          filetype              TYPE string OPTIONAL\n          write_lf              TYPE abap_bool OPTIONAL\n          write_field_separator TYPE char1 OPTIONAL\n        CHANGING\n          data_tab TYPE any.\n\n    CLASS-METHODS\n      directory_list_files\n        IMPORTING\n          directory  TYPE string\n        CHANGING\n          file_table TYPE any\n          count      TYPE i.\n\n    CLASS-METHODS\n      gui_upload\n        IMPORTING\n          filename TYPE string\n          filetype TYPE string OPTIONAL\n        EXPORTING\n          filelength TYPE i\n        CHANGING\n          data_tab TYPE any.\n\n    CLASS-METHODS\n      file_open_dialog\n        IMPORTING\n          window_title     TYPE string OPTIONAL\n          default_filename TYPE string OPTIONAL\n          multiselection   TYPE abap_bool OPTIONAL\n          file_filter      TYPE string OPTIONAL\n        CHANGING\n          file_table  TYPE filetable\n          rc          TYPE i\n          user_action TYPE i OPTIONAL.\n\n    CLASS-METHODS\n      get_platform\n        RETURNING\n          VALUE(platform) TYPE i.\n\n    CLASS-METHODS\n      file_save_dialog\n        IMPORTING\n          window_title         TYPE string OPTIONAL\n          default_extension    TYPE string OPTIONAL\n          default_file_name    TYPE string OPTIONAL\n          file_filter          TYPE string OPTIONAL\n        CHANGING\n          filename             TYPE string\n          path                 TYPE string\n          fullpath             TYPE string\n          user_action          TYPE i OPTIONAL.\n\n    CLASS-METHODS\n      directory_browse\n        IMPORTING\n          window_title    TYPE string\n          initial_folder  TYPE string\n        CHANGING\n          selected_folder TYPE string.\n\n    CLASS-METHODS\n      execute\n        IMPORTING\n          document          TYPE string OPTIONAL\n          application       TYPE string OPTIONAL\n          parameter         TYPE string OPTIONAL\n          default_directory TYPE string OPTIONAL\n          maximized         TYPE string OPTIONAL\n          minimized         TYPE string OPTIONAL\n          synchronous       TYPE string OPTIONAL\n          operation         TYPE string DEFAULT ''OPEN''.\n\n    CLASS-METHODS\n      get_file_separator\n        CHANGING\n          file_separator TYPE string.\n\n    CLASS-METHODS\n      directory_exist\n        IMPORTING\n          directory TYPE string\n        RETURNING\n          VALUE(result) TYPE abap_bool.\n\n    CLASS-METHODS\n      directory_create\n        IMPORTING\n          directory TYPE string\n        CHANGING\n          rc TYPE i.\n\n    CLASS-METHODS\n      clipboard_export\n        IMPORTING\n          no_auth_check TYPE abap_bool OPTIONAL\n        EXPORTING\n          data TYPE any\n        CHANGING\n          rc TYPE i.\n\n    CLASS-METHODS\n      get_system_directory\n        CHANGING\n          system_directory TYPE string.\n\n    CLASS-METHODS\n      get_gui_version\n        CHANGING\n          version_table TYPE filetable\n          rc            TYPE i.\n\n    CLASS-METHODS clipboard_import\n      EXPORTING\n        data   TYPE STANDARD TABLE\n        length TYPE i.\n\nENDCLASS.\n\nCLASS cl_gui_frontend_services IMPLEMENTATION.\n  METHOD directory_exist.\n    ASSERT 1 = ''directory_exist not supported''.\n  ENDMETHOD.\n\n  METHOD clipboard_import.\n    ASSERT 1 = ''clipboard_import not supported''.\n  ENDMETHOD.\n\n  METHOD directory_list_files.\n    ASSERT 1 = ''directory_list_files not supported''.\n  ENDMETHOD.\n\n  METHOD directory_create.\n    ASSERT 1 = ''directory_create not supported''.\n  ENDMETHOD.\n\n  METHOD gui_download.\n    ASSERT 1 = ''gui_download not supported''.\n  ENDMETHOD.\n\n  METHOD get_file_separator.\n    ASSERT 1 = ''get_file_separator not supported''.\n  ENDMETHOD.\n\n  METHOD execute.\n    ASSERT 1 = ''execute not supported''.\n  ENDMETHOD.\n\n  METHOD directory_browse.\n    ASSERT 1 = ''directory_browse not supported''.\n  ENDMETHOD.\n\n  METHOD gui_upload.\n    ASSERT 1 = ''gui_upload not supported''.\n  ENDMETHOD.\n\n  METHOD file_open_dialog.\n    ASSERT 1 = ''file_open_dialog not supported''.\n  ENDMETHOD.\n\n  METHOD file_save_dialog.\n    ASSERT 1 = ''file_save_dialog not supported''.\n  ENDMETHOD.\n\n  METHOD get_platform.\n    platform = platform_windowsxp.\n  ENDMETHOD.\n\n  METHOD clipboard_export.\n    ASSERT 1 = ''clipboard_export not supported''.\n  ENDMETHOD.\n\n  METHOD get_system_directory.\n    ASSERT 1 = ''get_system_directory not supported''.\n  ENDMETHOD.\n\n  METHOD get_gui_version.\n    ASSERT 1 = ''get_gui_verison not supported''.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_PROGRESS_INDICATOR', 'CLASS cl_progress_indicator DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS progress_indicate\n      IMPORTING\n        i_text               TYPE any OPTIONAL\n        i_processed          TYPE sy-tabix OPTIONAL\n        i_total              TYPE sy-tabix OPTIONAL\n        i_output_immediately TYPE abap_bool OPTIONAL\n      EXPORTING\n        e_progress_sent      TYPE abap_bool.\nENDCLASS.\n\nCLASS cl_progress_indicator IMPLEMENTATION.\n  METHOD progress_indicate.\n* do nothing, gui is not supported, but background logic might indicatoe progress\n    RETURN.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SALV_COLUMN', 'CLASS cl_salv_column DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    METHODS set_technical IMPORTING value TYPE abap_bool DEFAULT abap_true.\n    METHODS set_short_text IMPORTING value TYPE string.\n    METHODS set_medium_text IMPORTING value TYPE string.\n    METHODS set_long_text IMPORTING value TYPE string.\nENDCLASS.\n\nCLASS cl_salv_column IMPLEMENTATION.\n  METHOD set_technical.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD set_short_text.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD set_medium_text.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD set_long_text.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SALV_COLUMNS_TABLE', 'CLASS cl_salv_columns_table DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    METHODS set_cell_type_column\n      IMPORTING value TYPE string.\n    METHODS set_optimize\n      IMPORTING value TYPE abap_bool DEFAULT abap_true.\n    METHODS set_color_column\n      IMPORTING value TYPE string.\n    METHODS get_column\n      IMPORTING columnname TYPE string\n      RETURNING VALUE(value) TYPE REF TO cl_salv_column.\n    METHODS get\n      RETURNING VALUE(value) TYPE any.\nENDCLASS.\n\nCLASS cl_salv_columns_table IMPLEMENTATION.\n  METHOD get_column.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD set_cell_type_column.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD set_optimize.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD get.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD set_color_column.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SALV_EVENTS_TABLE', 'CLASS cl_salv_events_table DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    EVENTS double_click\n      EXPORTING\n        VALUE(row)    TYPE i\n        VALUE(column) TYPE string.\n\n    EVENTS added_function\n      EXPORTING\n        VALUE(e_salv_function) TYPE string OPTIONAL.\n\n    EVENTS link_click\n      EXPORTING\n        VALUE(row) TYPE i\n        VALUE(column) TYPE string.\n\nENDCLASS.\n\nCLASS cl_salv_events_table IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SALV_FUNCTIONS_LIST', 'CLASS cl_salv_functions_list DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    METHODS set_all.\nENDCLASS.\n\nCLASS cl_salv_functions_list IMPLEMENTATION.\n  METHOD set_all.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SALV_TABLE', 'CLASS cl_salv_table DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CONSTANTS c_functions_all TYPE i VALUE 1.\n    TYPES ty_rows TYPE STANDARD TABLE OF i WITH DEFAULT KEY.\n\n    CLASS-METHODS factory\n      IMPORTING\n        r_container TYPE any OPTIONAL\n      EXPORTING\n        r_salv_table TYPE any\n      CHANGING\n        t_table TYPE any.\n    METHODS get_selections RETURNING VALUE(val) TYPE REF TO cl_salv_table.\n    METHODS set_selection_mode IMPORTING val TYPE i.\n    METHODS get_selected_rows RETURNING VALUE(rows) TYPE ty_rows.\n    METHODS close_screen.\n    METHODS refresh.\n    METHODS display.\n    METHODS is_offline RETURNING VALUE(value) TYPE abap_bool.\n    METHODS get_metadata.\n    METHODS set_screen_status\n      IMPORTING\n        pfstatus      TYPE any\n        set_functions TYPE any OPTIONAL\n        report        TYPE any.\n    METHODS set_screen_popup\n      IMPORTING\n        start_column TYPE i\n        end_column   TYPE i\n        start_line   TYPE i\n        end_line     TYPE i.\n    METHODS get_event\n      RETURNING VALUE(val) TYPE REF TO cl_salv_events_table.\n    METHODS get_display_settings\n      RETURNING VALUE(val) TYPE REF TO cl_salv_table.\n    METHODS set_striped_pattern IMPORTING val TYPE any.\n    METHODS set_list_header IMPORTING val TYPE any.\n    METHODS set_top_of_list IMPORTING val TYPE any.\n    METHODS get_columns RETURNING VALUE(val) TYPE REF TO cl_salv_columns_table.\n    METHODS get_functions RETURNING VALUE(val) TYPE REF TO cl_salv_functions_list.\nENDCLASS.\n\nCLASS cl_salv_table IMPLEMENTATION.\n  METHOD get_functions.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD get_selected_rows.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD get_metadata.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD set_selection_mode.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD set_striped_pattern.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD set_list_header.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD factory.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD is_offline.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD get_selections.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD close_screen.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD refresh.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD display.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD set_screen_status.\n    ASSERT 1 = ''TODO''.\n  ENDMETHOD.\n\n  METHOD set_screen_popup.\n    ASSERT 1 = ''TODO''.\n  ENDMETHOD.\n\n  METHOD get_event.\n    ASSERT 1 = ''TODO''.\n  ENDMETHOD.\n\n  METHOD get_display_settings.\n    ASSERT 1 = ''TODO''.\n  ENDMETHOD.\n\n  METHOD set_top_of_list.\n    ASSERT 1 = ''TODO''.\n  ENDMETHOD.\n\n  METHOD get_columns.\n    ASSERT 1 = ''TODO''.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SALV_ACCESS_ERROR', 'CLASS cx_salv_access_error DEFINITION PUBLIC INHERITING FROM cx_salv_static_check.\n\nENDCLASS.\n\nCLASS cx_salv_access_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SALV_DATA_ERROR', 'CLASS cx_salv_data_error DEFINITION PUBLIC INHERITING FROM cx_salv_static_check.\n\nENDCLASS.\n\nCLASS cx_salv_data_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SALV_ERROR', 'CLASS cx_salv_error DEFINITION PUBLIC INHERITING FROM cx_static_check.\n\nENDCLASS.\n\nCLASS cx_salv_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SALV_MSG', 'CLASS cx_salv_msg DEFINITION PUBLIC INHERITING FROM cx_salv_error.\n\nENDCLASS.\n\nCLASS cx_salv_msg IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SALV_NOT_FOUND', 'CLASS cx_salv_not_found DEFINITION PUBLIC INHERITING FROM cx_salv_access_error.\n\nENDCLASS.\n\nCLASS cx_salv_not_found IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SALV_STATIC_CHECK', 'CLASS cx_salv_static_check DEFINITION PUBLIC INHERITING FROM cx_salv_error.\n\nENDCLASS.\n\nCLASS cx_salv_static_check IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SALV_C_BOOL_SAP', 'INTERFACE if_salv_c_bool_sap PUBLIC.\n  CONSTANTS true_ TYPE abap_bool VALUE abap_true.\n  CONSTANTS false_ TYPE abap_bool VALUE abap_false.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SALV_C_SELECTION_MODE', 'INTERFACE if_salv_c_selection_mode PUBLIC.\n  CONSTANTS cell       TYPE i VALUE 1.\n  CONSTANTS multiple   TYPE i VALUE 2.\n  CONSTANTS none       TYPE i VALUE 3.\n  CONSTANTS row_column TYPE i VALUE 4.\n  CONSTANTS single     TYPE i VALUE 5.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_HTTP_CLIENT', 'CLASS cl_http_client DEFINITION PUBLIC CREATE PRIVATE.\n  PUBLIC SECTION.\n    INTERFACES if_http_client.\n\n    CLASS-METHODS create_by_url\n      IMPORTING\n        url           TYPE string\n        ssl_id        TYPE ssfapplssl OPTIONAL\n        proxy_host    TYPE string OPTIONAL\n        proxy_service TYPE string OPTIONAL\n      EXPORTING\n        VALUE(client) TYPE REF TO if_http_client.\n* todo, add classic exceptions\n\n    CLASS-METHODS create_by_destination\n      IMPORTING\n        destination   TYPE string\n      EXPORTING\n        VALUE(client) TYPE REF TO if_http_client.\n* todo, add classic exceptions\n\n    METHODS constructor\n      IMPORTING\n        url TYPE string.\n\n  PRIVATE SECTION.\n    DATA mv_host TYPE string.\n\nENDCLASS.\n\nCLASS cl_http_client IMPLEMENTATION.\n\n  METHOD constructor.\n* SSL_ID and proxies are currently ignored\n\n    DATA lv_uri TYPE string.\n    DATA lv_query TYPE string.\n\n    CREATE OBJECT if_http_client~response TYPE cl_http_entity.\n\n    FIND REGEX ''\\\\w(\\\\/[\\\\w\\\\d\\\\.\\\\-\\\\/]+)'' IN url SUBMATCHES lv_uri.\n    mv_host = url.\n*    WRITE ''@KERNEL console.dir(this.mv_host.get());''.\n*    WRITE ''@KERNEL console.dir(lv_uri.get());''.\n    REPLACE FIRST OCCURRENCE OF lv_uri IN mv_host WITH ''''.\n\n    CREATE OBJECT if_http_client~request TYPE cl_http_entity.\n    if_http_client~request->set_header_field(\n      name = ''~request_uri''\n      value = lv_uri ).\n\n    FIND REGEX ''\\\\?(.*)'' IN url SUBMATCHES lv_query.\n    IF sy-subrc = 0.\n      cl_http_utility=>set_query(\n        request = if_http_client~request\n        query   = lv_query ).\n    ENDIF.\n\n  ENDMETHOD.\n\n  METHOD create_by_url.\n    CREATE OBJECT client TYPE cl_http_client\n      EXPORTING\n        url = url.\n    sy-subrc = 0. \" todo\n  ENDMETHOD.\n\n  METHOD if_http_client~authenticate.\n    DATA lv_base64 TYPE string.\n    lv_base64 = cl_http_utility=>encode_base64( |{ username }:{ password }| ).\n    if_http_client~request->set_header_field(\n      name = ''authorization''\n      value = |Basic { lv_base64 }| ).\n  ENDMETHOD.\n\n  METHOD if_http_client~close.\n* todo\n    RETURN.\n  ENDMETHOD.\n\n  METHOD create_by_destination.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD if_http_client~send.\n    DATA lv_method        TYPE string.\n    DATA lv_url           TYPE string.\n    DATA lv_body          TYPE string.\n    DATA lv_name          TYPE string.\n    DATA lv_value         TYPE string.\n    DATA lt_form_fields   TYPE tihttpnvp.\n    DATA lt_header_fields TYPE tihttpnvp.\n    DATA ls_field         LIKE LINE OF lt_header_fields.\n\n    lv_method = if_http_client~request->get_method( ).\n    IF lv_method IS INITIAL.\n      lv_method = ''GET''.\n    ENDIF.\n\n* default user-agent if not set\n    IF if_http_client~request->get_header_field( ''user-agent'' ) IS INITIAL.\n      if_http_client~request->set_header_field(\n        name  = ''user-agent''\n        value = ''open-abap-http'' ).\n    ENDIF.\n\n* building URL\n    lv_url = if_http_client~request->get_header_field( ''~request_uri'' ).\n    REPLACE FIRST OCCURRENCE OF mv_host IN lv_url WITH ''''.\n    lv_url = mv_host && lv_url.\n    if_http_client~request->get_form_fields( CHANGING fields = lt_form_fields ).\n    IF lines( lt_form_fields ) > 0.\n      lv_url = lv_url && ''?'' && cl_http_utility=>fields_to_string( lt_form_fields ).\n    ENDIF.\n    \" WRITE ''@KERNEL console.dir(lv_url.get());''.\n\n* building headers\n    if_http_client~request->get_header_fields( CHANGING fields = lt_header_fields ).\n    WRITE ''@KERNEL let headers = {};''.\n    LOOP AT lt_header_fields INTO ls_field WHERE name <> ''~request_uri''.\n      WRITE ''@KERNEL headers[ls_field.get().name.get()] = ls_field.get().value.get();''.\n    ENDLOOP.\n*    WRITE ''@KERNEL console.dir(headers);''.\n\n    lv_body = if_http_client~request->get_cdata( ).\n\n    WRITE ''@KERNEL const https = await import(\"https\");''.\n    WRITE ''@KERNEL const http = await import(\"http\");''.\n    WRITE ''@KERNEL function postData(url, options, requestBody) {''.\n    WRITE ''@KERNEL   return new Promise((resolve, reject) => {''.\n    WRITE ''@KERNEL     const prot = url.startsWith(\"http://\") ? http : https;''.\n    WRITE ''@KERNEL     const req = prot.request(url, options,''.\n    WRITE ''@KERNEL       (res) => {''.\n    WRITE ''@KERNEL         let chunks = [];''.\n    WRITE ''@KERNEL         res.on(\"data\", (chunk) => {chunks.push(chunk);});''.\n    WRITE ''@KERNEL         res.on(\"error\", reject);''.\n    WRITE ''@KERNEL         res.on(\"end\", () => {''.\n*    WRITE ''@KERNEL           console.dir(res.statusCode + \" \" + res.headers[\"content-type\"]);''.\n    WRITE ''@KERNEL           if (res.statusCode >= 200 && res.statusCode <= 299) {''.\n    WRITE ''@KERNEL             resolve({statusCode: res.statusCode, headers: res.headers, body: Buffer.concat(chunks)});''.\n    WRITE ''@KERNEL           } else {''.\n    WRITE ''@KERNEL             reject(\"Request failed. status: \" + res.statusCode + \", body: \" + Buffer.concat(chunks).toString());''.\n    WRITE ''@KERNEL           }''.\n    WRITE ''@KERNEL         });''.\n    WRITE ''@KERNEL       });''.\n    WRITE ''@KERNEL     req.on(\"error\", reject);''.\n    WRITE ''@KERNEL     req.write(requestBody, \"binary\");''.\n    WRITE ''@KERNEL     req.end();''.\n    WRITE ''@KERNEL   });''.\n    WRITE ''@KERNEL }''.\n\n    WRITE ''@KERNEL const prot = lv_url.get().startsWith(\"http://\") ? http : https;''.\n    WRITE ''@KERNEL if (this.agent === undefined) {this.agent = new prot.Agent({keepAlive: true, maxSockets: 1});}''.\n    WRITE ''@KERNEL let response = await postData(lv_url.get(), {method: lv_method.get(), headers: headers, agent: this.agent}, lv_body.get());''.\n\n    \" WRITE ''@KERNEL console.dir(response);''.\n    \" WRITE ''@KERNEL console.dir(response.headers);''.\n\n    WRITE ''@KERNEL for (const h in response.headers) {''.\n    WRITE ''@KERNEL   lv_name.set(h);''.\n    WRITE ''@KERNEL   lv_value.set(response.headers[h]);''.\n    if_http_client~response->set_header_field(\n      name  = lv_name\n      value = lv_value ).\n    WRITE ''@KERNEL }''.\n\n\n    WRITE ''@KERNEL this.if_http_client$response.get().content_type.set(response.headers[\"content-type\"] || \"\");''.\n    WRITE ''@KERNEL this.if_http_client$response.get().mv_status.set(response.statusCode);''.\n    WRITE ''@KERNEL this.if_http_client$response.get().mv_data.set(response.body.toString(\"hex\").toUpperCase());''.\n\n* workaround for classic exceptions, this should work sometime in the transpiler instead\n    sy-subrc = 0.\n\n  ENDMETHOD.\n\n  METHOD if_http_client~receive.\n* handled in send()\n\n* workaround for classic exceptions, this should work sometime in the transpiler instead\n    sy-subrc = 0.\n\n  ENDMETHOD.\n\n  METHOD if_http_client~get_last_error.\n    if_http_client~response->get_status( IMPORTING code = code ).\n    message = ''todo_open_abap''. \" get from one of the response headers?\n  ENDMETHOD.\n\n  METHOD if_http_client~send_sap_logon_ticket.\n    ASSERT 2 = ''not supported''.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_HTTP_ENTITY', 'CLASS cl_http_entity DEFINITION PUBLIC CREATE PRIVATE.\n  PUBLIC SECTION.\n    INTERFACES if_http_response.\n    INTERFACES if_http_request.\n  PRIVATE SECTION.\n    DATA mv_status TYPE i.\n    DATA mv_reason TYPE string.\n    DATA content_type TYPE string.\n    DATA mv_method TYPE string.\n    DATA mv_data TYPE xstring.\n    DATA mt_headers TYPE tihttpnvp.\n    DATA mt_form_fields TYPE tihttpnvp.\nENDCLASS.\n\nCLASS cl_http_entity IMPLEMENTATION.\n\n  METHOD if_http_response~set_header_field.\n    DATA ls_header LIKE LINE OF mt_headers.\n    FIELD-SYMBOLS <ls_header> LIKE LINE OF mt_headers.\n    READ TABLE mt_headers WITH KEY name = to_lower( name ) ASSIGNING <ls_header>.\n    IF sy-subrc = 0.\n      <ls_header>-value = value.\n    ELSE.\n      ls_header-name = to_lower( name ).\n      ls_header-value = value.\n      APPEND ls_header TO mt_headers.\n    ENDIF.\n  ENDMETHOD.\n\n  METHOD if_http_response~get_header_field.\n    DATA ls_header LIKE LINE OF mt_headers.\n    READ TABLE mt_headers WITH KEY name = to_lower( name ) INTO ls_header.\n    IF sy-subrc = 0.\n      value = ls_header-value.\n    ENDIF.\n  ENDMETHOD.\n\n  METHOD if_http_response~get_header_fields.\n    fields = mt_headers.\n  ENDMETHOD.\n\n  METHOD if_http_response~get_status.\n    code = mv_status.\n    reason = mv_reason.\n  ENDMETHOD.\n\n  METHOD if_http_response~get_cdata.\n    cl_abap_conv_in_ce=>create( encoding = ''UTF-8'' )->convert(\n      EXPORTING input = mv_data\n      IMPORTING data = data ).\n  ENDMETHOD.\n\n  METHOD if_http_response~set_status.\n    mv_status = code.\n    mv_reason = reason.\n  ENDMETHOD.\n\n  METHOD if_http_response~set_cdata.\n    cl_abap_conv_out_ce=>create( encoding = ''UTF-8'' )->convert(\n      EXPORTING data = data\n      IMPORTING buffer = mv_data ).\n  ENDMETHOD.\n\n  METHOD if_http_response~get_content_type.\n    val = content_type.\n  ENDMETHOD.\n\n  METHOD if_http_response~set_content_type.\n    content_type = val.\n  ENDMETHOD.\n\n  METHOD if_http_request~set_content_type.\n    content_type = val.\n  ENDMETHOD.\n\n  METHOD if_http_response~get_data.\n    val = mv_data.\n  ENDMETHOD.\n\n  METHOD if_http_response~set_data.\n    mv_data = val.\n  ENDMETHOD.\n\n*****************************************\n\n  METHOD if_http_request~set_form_fields.\n    mt_form_fields = fields.\n  ENDMETHOD.\n\n  METHOD if_http_request~get_form_fields.\n    fields = mt_form_fields.\n  ENDMETHOD.\n\n  METHOD if_http_request~get_form_field.\n    DATA ls_field LIKE LINE OF mt_form_fields.\n    READ TABLE mt_form_fields INTO ls_field WITH KEY name = to_lower( name ).\n    IF sy-subrc = 0.\n      value = ls_field-value.\n    ENDIF.\n  ENDMETHOD.\n\n  METHOD if_http_request~set_header_field.\n    DATA ls_header LIKE LINE OF mt_headers.\n    FIELD-SYMBOLS <ls_header> LIKE LINE OF mt_headers.\n    READ TABLE mt_headers WITH KEY name = to_lower( name ) ASSIGNING <ls_header>.\n    IF sy-subrc = 0.\n      <ls_header>-value = value.\n    ELSE.\n      ls_header-name = to_lower( name ).\n      ls_header-value = value.\n      APPEND ls_header TO mt_headers.\n    ENDIF.\n    IF name = ''~request_method''.\n      if_http_request~set_method( value ).\n    ENDIF.\n  ENDMETHOD.\n\n  METHOD if_http_request~get_header_field.\n    DATA ls_header LIKE LINE OF mt_headers.\n    READ TABLE mt_headers WITH KEY name = to_lower( name ) INTO ls_header.\n    IF sy-subrc = 0.\n      value = ls_header-value.\n    ENDIF.\n  ENDMETHOD.\n\n  METHOD if_http_request~set_method.\n    mv_method = method.\n  ENDMETHOD.\n\n  METHOD if_http_request~get_method.\n    meth = mv_method.\n  ENDMETHOD.\n\n  METHOD if_http_request~set_version.\n    ASSERT 2 = ''todo''.\n  ENDMETHOD.\n\n  METHOD if_http_request~set_data.\n    mv_data = data.\n  ENDMETHOD.\n\n  METHOD if_http_request~get_data.\n    data = mv_data.\n  ENDMETHOD.\n\n  METHOD if_http_request~set_cdata.\n    cl_abap_conv_out_ce=>create( encoding = ''UTF-8'' )->convert(\n      EXPORTING data = data\n      IMPORTING buffer = mv_data ).\n  ENDMETHOD.\n\n  METHOD if_http_request~get_cdata.\n    cl_abap_conv_in_ce=>create( encoding = ''UTF-8'' )->convert(\n      EXPORTING input = mv_data\n      IMPORTING data = data ).\n  ENDMETHOD.\n\n  METHOD if_http_request~set_form_field.\n    DATA ls_field LIKE LINE OF mt_form_fields.\n    ls_field-name = name.\n    ls_field-value = value.\n    APPEND ls_field TO mt_form_fields.\n  ENDMETHOD.\n\n  METHOD if_http_request~get_header_fields.\n    fields = mt_headers.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_HTTP_SERVER', 'CLASS cl_http_server DEFINITION PUBLIC CREATE PRIVATE.\n  PUBLIC SECTION.\n    CLASS-METHODS get_location\n      EXPORTING\n        host TYPE string.\nENDCLASS.\n\nCLASS cl_http_server IMPLEMENTATION.\n  METHOD get_location.\n    host = ''open-abap.org''.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_HTTP_UTILITY', 'CLASS cl_http_utility DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS decode_x_base64\n      IMPORTING\n        encoded TYPE string\n      RETURNING\n        VALUE(decoded) TYPE xstring.\n\n    CLASS-METHODS unescape_url\n      IMPORTING\n        escaped TYPE string\n      RETURNING\n        VALUE(unescaped) TYPE string.\n\n    CLASS-METHODS escape_url\n      IMPORTING\n        unescaped TYPE string\n      RETURNING\n        VALUE(escaped) TYPE string.\n\n    CLASS-METHODS encode_base64\n      IMPORTING\n        data TYPE string\n      RETURNING\n        VALUE(encoded) TYPE string.\n\n    CLASS-METHODS encode_x_base64\n      IMPORTING\n        data           TYPE xstring\n      RETURNING\n        VALUE(encoded) TYPE string.\n\n    CLASS-METHODS fields_to_string\n      IMPORTING\n        fields TYPE tihttpnvp\n      RETURNING\n        VALUE(string) TYPE string.\n\n    CLASS-METHODS string_to_fields\n      IMPORTING\n        string TYPE string\n      RETURNING\n        VALUE(fields) TYPE tihttpnvp.\n\n    CLASS-METHODS set_query\n      IMPORTING\n        request TYPE REF TO if_http_request\n        query   TYPE string.\n\nENDCLASS.\n\nCLASS cl_http_utility IMPLEMENTATION.\n\n  METHOD string_to_fields.\n    DATA tab TYPE STANDARD TABLE OF string.\n    DATA str LIKE LINE OF tab.\n    DATA ls_field LIKE LINE OF fields.\n\n    SPLIT string AT ''&'' INTO TABLE tab.\n    LOOP AT tab INTO str.\n      SPLIT str AT ''='' INTO ls_field-name ls_field-value.\n      APPEND ls_field TO fields.\n    ENDLOOP.\n  ENDMETHOD.\n\n  METHOD set_query.\n    request->set_form_fields( string_to_fields( query ) ).\n  ENDMETHOD.\n\n  METHOD fields_to_string.\n    DATA tab TYPE STANDARD TABLE OF string.\n    DATA str TYPE string.\n    DATA ls_field LIKE LINE OF fields.\n\n    LOOP AT fields INTO ls_field.\n      str = ls_field-name && ''='' && ls_field-value.\n      APPEND str TO tab.\n    ENDLOOP.\n    string = concat_lines_of( table = tab sep = ''&'' ).\n  ENDMETHOD.\n\n  METHOD encode_x_base64.\n    WRITE ''@KERNEL let buffer = Buffer.from(data.get(), \"hex\");''.\n    WRITE ''@KERNEL encoded.set(buffer.toString(\"base64\"));''.\n  ENDMETHOD.\n\n  METHOD decode_x_base64.\n    WRITE ''@KERNEL let buffer = Buffer.from(encoded.get(), \"base64\");''.\n    WRITE ''@KERNEL decoded.set(buffer.toString(\"hex\").toUpperCase());''.\n  ENDMETHOD.\n\n  METHOD unescape_url.\n    \" todo, this can probably be done in ABAP with a few regex''es\n    WRITE ''@KERNEL unescaped.set(decodeURI(escaped.get()));''.\n  ENDMETHOD.\n\n  METHOD escape_url.\n    WRITE ''@KERNEL escaped.set(encodeURIComponent(unescaped.get()));''.\n  ENDMETHOD.\n\n  METHOD encode_base64.\n    WRITE ''@KERNEL let buffer = Buffer.from(data.get());''.\n    WRITE ''@KERNEL encoded.set(buffer.toString(\"base64\"));''.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_HTTP_CLIENT', 'INTERFACE if_http_client PUBLIC.\n  DATA request TYPE REF TO if_http_request.\n  DATA response TYPE REF TO if_http_response.\n  DATA propertytype_logon_popup TYPE i.\n  DATA propertytype_accept_cookie TYPE i.\n\n  CONSTANTS co_disabled TYPE i VALUE 0.\n  CONSTANTS co_enabled TYPE i VALUE 1.\n\n  METHODS authenticate\n    IMPORTING\n      proxy_authentication TYPE abap_bool OPTIONAL\n      username             TYPE string\n      password             TYPE string.\n\n  METHODS close.\n  METHODS send\n    EXCEPTIONS\n      http_communication_failure\n      http_invalid_state\n      http_processing_failed\n      http_invalid_timeout.\n  METHODS receive\n    EXCEPTIONS\n      http_communication_failure\n      http_invalid_state\n      http_processing_failed.\n  METHODS send_sap_logon_ticket.\n\n  METHODS get_last_error\n    EXPORTING\n      code    TYPE i\n      message TYPE string.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_HTTP_EXTENSION', 'INTERFACE if_http_extension PUBLIC.\n\n  METHODS handle_request IMPORTING server TYPE REF TO if_http_server.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_HTTP_REQUEST', 'INTERFACE if_http_request PUBLIC.\n\n  CONSTANTS:\n    co_protocol_version_1_1 TYPE string VALUE ''VER11'',\n    co_protocol_version_1_0 TYPE string VALUE ''VER10'',\n    co_request_method_get TYPE string VALUE ''GET'',\n    co_request_method_post TYPE string VALUE ''POST''.\n\n  METHODS\n    set_header_field\n      IMPORTING\n        name TYPE string\n        value TYPE string.\n\n  METHODS\n    get_header_field\n      IMPORTING\n        name TYPE string\n      RETURNING\n        VALUE(value) TYPE string.\n\n  METHODS get_header_fields CHANGING fields TYPE tihttpnvp.\n  METHODS get_form_fields CHANGING fields TYPE tihttpnvp.\n  METHODS get_form_field\n    IMPORTING name TYPE string\n    RETURNING VALUE(value) TYPE string.\n  METHODS set_form_fields IMPORTING fields TYPE tihttpnvp.\n\n  METHODS set_method IMPORTING method TYPE string.\n  METHODS get_method RETURNING VALUE(meth) TYPE string.\n\n  METHODS set_version\n    IMPORTING\n      version TYPE string.\n\n  METHODS set_data IMPORTING data TYPE xstring.\n  METHODS get_data RETURNING VALUE(data) TYPE xstring.\n  METHODS set_cdata IMPORTING data TYPE string.\n  METHODS get_cdata RETURNING VALUE(data) TYPE string.\n\n  METHODS set_content_type\n    IMPORTING\n      val TYPE string.\n\n  METHODS set_form_field\n    IMPORTING\n      name TYPE string\n      value TYPE string.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_HTTP_RESPONSE', 'INTERFACE if_http_response PUBLIC.\n\n  METHODS get_header_field\n    IMPORTING\n      name TYPE string\n    RETURNING\n      VALUE(value) TYPE string.\n\n  METHODS get_status\n    EXPORTING\n      code   TYPE i\n      reason TYPE string.\n\n  METHODS get_cdata\n    RETURNING\n      VALUE(data) TYPE string.\n\n  METHODS get_content_type\n    RETURNING\n      VALUE(val) TYPE string.\n  METHODS set_content_type\n    IMPORTING\n      val TYPE string.\n\n  METHODS get_data\n    RETURNING VALUE(val) TYPE xstring.\n\n  METHODS set_data\n    IMPORTING val TYPE xstring.\n\n  METHODS get_header_fields\n    CHANGING\n      fields TYPE tihttpnvp.\n\n  METHODS\n    set_header_field\n      IMPORTING\n        name TYPE string\n        value TYPE string.\n\n  METHODS\n    set_status\n      IMPORTING\n        code   TYPE i\n        reason TYPE string.\n\n  METHODS set_cdata IMPORTING data TYPE string.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_HTTP_SERVER', 'INTERFACE if_http_server PUBLIC.\n\n  DATA response TYPE REF TO if_http_response.\n  DATA request TYPE REF TO if_http_request.\n\n  METHODS:\n    logoff IMPORTING redirect_url TYPE string OPTIONAL,\n    set_session_stateful.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_IXML', 'CLASS cl_ixml DEFINITION PUBLIC CREATE PRIVATE.\n  PUBLIC SECTION.\n    INTERFACES if_ixml.\n    CLASS-METHODS\n      create\n        RETURNING\n          VALUE(xml) TYPE REF TO if_ixml.\nENDCLASS.\n\nCLASS cl_ixml IMPLEMENTATION.\n  METHOD create.\n    CREATE OBJECT xml TYPE cl_ixml.\n  ENDMETHOD.\n\n  METHOD if_ixml~create_encoding.\n    CREATE OBJECT rval TYPE lcl_encoding.\n  ENDMETHOD.\n\n  METHOD if_ixml~create_document.\n    CREATE OBJECT doc TYPE lcl_document.\n  ENDMETHOD.\n\n  METHOD if_ixml~create_stream_factory.\n    CREATE OBJECT stream TYPE lcl_stream_factory.\n  ENDMETHOD.\n\n  METHOD if_ixml~create_renderer.\n    CREATE OBJECT renderer TYPE lcl_renderer\n      EXPORTING\n        ostream  = ostream\n        document = document.\n  ENDMETHOD.\n\n  METHOD if_ixml~create_parser.\n    CREATE OBJECT parser TYPE lcl_parser\n      EXPORTING\n        istream  = istream\n        document = document.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML', 'INTERFACE if_ixml PUBLIC.\n  METHODS create_document\n    RETURNING\n      VALUE(doc) TYPE REF TO if_ixml_document.\n  METHODS create_stream_factory\n    RETURNING\n      VALUE(stream) TYPE REF TO if_ixml_stream_factory.\n  METHODS create_renderer\n    IMPORTING\n      ostream  TYPE REF TO if_ixml_ostream\n      document TYPE REF TO if_ixml_document\n    RETURNING\n      VALUE(renderer) TYPE REF TO if_ixml_renderer.\n  METHODS create_parser\n    IMPORTING\n      stream_factory  TYPE REF TO if_ixml_stream_factory\n      istream  TYPE REF TO if_ixml_istream\n      document TYPE REF TO if_ixml_document\n    RETURNING\n      VALUE(parser) TYPE REF TO if_ixml_parser.\n  METHODS create_encoding\n    IMPORTING\n      byte_order    TYPE string\n      character_set TYPE string\n    RETURNING\n      VALUE(rval) TYPE REF TO if_ixml_encoding.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_ATTRIBUTE', 'INTERFACE if_ixml_attribute PUBLIC.\n  INTERFACES if_ixml_node.\n  METHODS get_value RETURNING VALUE(val) TYPE string.\n  METHODS set_value IMPORTING value TYPE string.\n  METHODS get_name RETURNING VALUE(val) TYPE string.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_DOCUMENT', 'INTERFACE if_ixml_document PUBLIC.\n  INTERFACES if_ixml_node.\n\n  METHODS:\n    set_encoding\n      IMPORTING\n        encoding TYPE REF TO object,\n    set_standalone\n      IMPORTING\n        standalone TYPE abap_bool,\n    set_namespace_prefix\n      IMPORTING\n        prefix TYPE string,\n    append_child\n      IMPORTING\n        new_child TYPE REF TO if_ixml_node,\n    get_first_child\n      RETURNING\n        VALUE(child) TYPE REF TO if_ixml_node,\n    create_attribute_ns\n      IMPORTING\n        name TYPE string\n        prefix TYPE string OPTIONAL\n      RETURNING\n        VALUE(element) TYPE REF TO if_ixml_attribute,\n    create_element_ns\n      IMPORTING\n        name TYPE string\n        prefix TYPE string OPTIONAL\n      RETURNING\n        VALUE(element) TYPE REF TO if_ixml_element,\n    create_element\n      IMPORTING\n        name TYPE string\n      RETURNING\n        VALUE(element) TYPE REF TO if_ixml_element,\n    create_iterator_filtered\n      IMPORTING input TYPE any\n      RETURNING VALUE(val) TYPE REF TO if_ixml_node_iterator,\n    create_filter_and\n      IMPORTING\n        filter1 TYPE any\n        filter2 TYPE any\n      RETURNING\n        VALUE(val) TYPE any,\n    create_iterator\n      RETURNING VALUE(rval) TYPE REF TO if_ixml_node_iterator,\n    create_filter_node_type\n      IMPORTING typ TYPE string\n      RETURNING VALUE(val) TYPE any,\n    create_simple_element_ns\n      IMPORTING\n        name       TYPE string\n        parent     TYPE REF TO if_ixml_node\n        prefix     TYPE string OPTIONAL\n      RETURNING\n        VALUE(val) TYPE REF TO if_ixml_element,\n    create_filter_attribute\n      IMPORTING name TYPE string\n      RETURNING VALUE(val) TYPE any,\n    create_simple_element\n      IMPORTING\n        name       TYPE string\n        parent     TYPE REF TO if_ixml_node\n      RETURNING\n        VALUE(val) TYPE REF TO if_ixml_element,\n    find_from_name\n      IMPORTING\n        name TYPE string\n        namespace TYPE string OPTIONAL\n      RETURNING\n        VALUE(element) TYPE REF TO if_ixml_element,\n    find_from_name_ns\n      IMPORTING\n        depth TYPE i OPTIONAL\n        uri   TYPE string OPTIONAL\n        name  TYPE string\n      RETURNING\n        VALUE(element) TYPE REF TO if_ixml_element,\n    find_from_path\n      IMPORTING\n        path TYPE string\n      RETURNING\n        VALUE(val) TYPE REF TO if_ixml_element,\n    get_elements_by_tag_name_ns\n      IMPORTING\n        name TYPE string\n        namespace TYPE string OPTIONAL\n        uri TYPE string OPTIONAL\n      RETURNING VALUE(val) TYPE any,\n    get_elements_by_tag_name\n      IMPORTING\n        depth     TYPE i OPTIONAL\n        name      TYPE string\n        namespace TYPE string OPTIONAL\n      RETURNING VALUE(val) TYPE any,\n    get_root RETURNING VALUE(node) TYPE REF TO if_ixml_node,\n    get_root_element RETURNING VALUE(root) TYPE REF TO if_ixml_element.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_ELEMENT', 'INTERFACE if_ixml_element PUBLIC.\n  INTERFACES if_ixml_node.\n\n  METHODS:\n    remove_attribute_ns\n      IMPORTING foo TYPE string,\n    get_attributes\n      RETURNING VALUE(attr) TYPE REF TO if_ixml_named_node_map,\n    get_next\n      RETURNING VALUE(next) TYPE REF TO if_ixml_element,\n    get_name\n      RETURNING VALUE(name) TYPE string,\n    append_child\n      IMPORTING\n        new_child TYPE REF TO if_ixml_node\n      RETURNING\n        VALUE(rc) TYPE i,\n    clone\n      RETURNING VALUE(val) TYPE REF TO if_ixml_node,\n    create_filter_node_type\n      IMPORTING name TYPE string\n      RETURNING VALUE(val) TYPE REF TO any,\n    create_iterator\n      RETURNING VALUE(val) TYPE REF TO if_ixml_node_iterator,\n    find_from_name_ns\n      IMPORTING\n        name      TYPE string\n        namespace TYPE string OPTIONAL\n        uri       TYPE string OPTIONAL\n        depth     TYPE i OPTIONAL\n      RETURNING VALUE(val) TYPE REF TO if_ixml_element,\n    find_from_name\n      IMPORTING\n        name      TYPE string\n        namespace TYPE string OPTIONAL\n        depth     TYPE i OPTIONAL\n      RETURNING VALUE(val) TYPE REF TO if_ixml_element,\n    get_attribute_node\n      IMPORTING name TYPE string\n      RETURNING VALUE(val) TYPE REF TO if_ixml_attribute,\n    get_attribute_ns\n      IMPORTING\n        name TYPE string\n        uri TYPE string OPTIONAL\n      RETURNING\n        VALUE(val) TYPE string,\n    get_attribute\n      IMPORTING\n        name TYPE string\n        namespace TYPE string OPTIONAL\n      RETURNING VALUE(val) TYPE string,\n    get_children\n      RETURNING VALUE(val) TYPE REF TO if_ixml_node_list,\n    get_elements_by_tag_name\n      IMPORTING name TYPE string\n      RETURNING VALUE(val) TYPE any,\n    get_elements_by_tag_name_ns\n      IMPORTING\n        name TYPE string\n        uri  TYPE string OPTIONAL\n      RETURNING\n        VALUE(val) TYPE any,\n    get_attribute_node_ns\n        IMPORTING\n        name TYPE string\n        uri  TYPE string OPTIONAL\n      RETURNING\n        VALUE(val) TYPE REF TO if_ixml_attribute,\n    get_first_child\n      RETURNING VALUE(val) TYPE REF TO if_ixml_node,\n    get_value\n      RETURNING VALUE(val) TYPE string,\n    remove_attribute\n      IMPORTING name TYPE string,\n    remove_node,\n    render\n      IMPORTING\n        ostream TYPE REF TO if_ixml_ostream,\n    set_attribute_node_ns\n      IMPORTING\n        attr TYPE any,\n    set_attribute\n      IMPORTING\n        name      TYPE string\n        namespace TYPE string OPTIONAL\n        value     TYPE string OPTIONAL,\n    set_attribute_ns\n      IMPORTING\n        name   TYPE string\n        prefix TYPE string OPTIONAL\n        value  TYPE string OPTIONAL,\n    set_value\n      IMPORTING\n        value TYPE string\n      RETURNING VALUE(rc) TYPE i.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_ENCODING', 'INTERFACE if_ixml_encoding PUBLIC.\n  CONSTANTS co_platform_endian TYPE string VALUE ''a''.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_ISTREAM', 'INTERFACE if_ixml_istream PUBLIC.\n  METHODS close.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_NAMED_NODE_MAP', 'INTERFACE if_ixml_named_node_map PUBLIC.\n  METHODS:\n    create_iterator\n      RETURNING VALUE(iterator) TYPE REF TO if_ixml_node_iterator,\n    get_length\n      RETURNING VALUE(val) TYPE i,\n    get_named_item_ns\n      IMPORTING name TYPE string\n      RETURNING VALUE(val) TYPE REF TO if_ixml_node,\n    get_named_item\n      IMPORTING name TYPE string\n      RETURNING VALUE(val) TYPE REF TO if_ixml_node,\n    set_named_item_ns\n      IMPORTING node TYPE REF TO if_ixml_node,\n    remove_named_item\n      IMPORTING name TYPE string.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_NODE', 'INTERFACE if_ixml_node PUBLIC.\n  CONSTANTS:\n    co_node_element TYPE i VALUE 0,\n    co_node_text TYPE i VALUE 0.\n  METHODS:\n    append_child IMPORTING new_child TYPE REF TO if_ixml_node,\n    get_attributes RETURNING VALUE(map) TYPE REF TO if_ixml_named_node_map,\n    get_first_child RETURNING VALUE(node) TYPE REF TO if_ixml_node,\n    get_children RETURNING VALUE(val) TYPE REF TO if_ixml_node_list,\n    query_interface\n      IMPORTING foo         TYPE string\n      RETURNING VALUE(rval) TYPE REF TO if_ixml_unknown,\n    remove_node,\n    get_parent RETURNING VALUE(val) TYPE REF TO if_ixml_node,\n    replace_child IMPORTING\n      new_child TYPE string\n      old_child TYPE string,\n    get_name RETURNING VALUE(val) TYPE string,\n    get_depth RETURNING VALUE(val) TYPE i,\n    is_leaf RETURNING VALUE(val) TYPE abap_bool,\n    get_namespace RETURNING VALUE(val) TYPE string,\n    get_value RETURNING VALUE(val) TYPE string,\n    get_type RETURNING VALUE(val) TYPE string,\n    set_name IMPORTING name TYPE string,\n    set_namespace_prefix IMPORTING val TYPE string,\n    remove_child IMPORTING child TYPE REF TO if_ixml_node,\n    set_value IMPORTING value TYPE string.\n  METHODS get_namespace_prefix\n    RETURNING\n      VALUE(rv_prefix) TYPE string.\n  METHODS get_namespace_uri\n    RETURNING\n      VALUE(rval) TYPE string.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_NODE_ITERATOR', 'INTERFACE if_ixml_node_iterator PUBLIC.\n\n  METHODS reset.\n\n  METHODS get_next\n    RETURNING\n      VALUE(rval) TYPE REF TO if_ixml_node.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_NODE_LIST', 'INTERFACE if_ixml_node_list PUBLIC.\n\n  METHODS:\n    get_length\n      RETURNING\n        VALUE(length) TYPE i,\n    create_iterator\n      RETURNING VALUE(rval) TYPE REF TO if_ixml_node_iterator,\n    get_item\n      IMPORTING\n        index TYPE i\n      RETURNING\n        VALUE(val) TYPE REF TO if_ixml_node,\n    create_rev_iterator_filtered\n      IMPORTING\n        filter TYPE any\n      RETURNING\n        VALUE(val) TYPE REF TO if_ixml_node_iterator.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_OSTREAM', 'INTERFACE if_ixml_ostream PUBLIC.\n  METHODS write_string\n    IMPORTING\n      string      TYPE string\n    RETURNING\n      VALUE(rval) TYPE i.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_PARSE_ERROR', 'INTERFACE if_ixml_parse_error PUBLIC.\n  METHODS get_reason\n    RETURNING\n      VALUE(reason) TYPE string.\n  METHODS get_line\n    RETURNING\n      VALUE(line) TYPE i.\n  METHODS get_column\n    RETURNING\n      VALUE(column) TYPE i.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_PARSER', 'INTERFACE if_ixml_parser PUBLIC.\n  CONSTANTS co_no_validation TYPE i VALUE 0.\n\n  METHODS parse RETURNING VALUE(subrc) TYPE i.\n  METHODS set_normalizing IMPORTING normal TYPE abap_bool.\n  METHODS num_errors RETURNING VALUE(errors) TYPE i.\n  METHODS add_strip_space_element.\n  METHODS get_error\n    IMPORTING\n      index TYPE i\n    RETURNING\n      VALUE(error) TYPE REF TO if_ixml_parse_error.\n  METHODS set_validating\n    IMPORTING\n      mode TYPE i OPTIONAL\n    RETURNING\n      VALUE(rval) TYPE abap_bool.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_RENDERER', 'INTERFACE if_ixml_renderer PUBLIC.\n  METHODS render.\n  METHODS set_normalizing IMPORTING normal TYPE abap_bool.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_STREAM_FACTORY', 'INTERFACE if_ixml_stream_factory PUBLIC.\n  METHODS create_ostream_cstring\n    IMPORTING\n      string TYPE string\n    RETURNING\n      VALUE(stream) TYPE REF TO if_ixml_ostream.\n\n  METHODS create_ostream_xstring\n    IMPORTING\n      string TYPE xstring\n    RETURNING\n      VALUE(stream) TYPE REF TO if_ixml_ostream.\n\n  METHODS create_istream_string\n    IMPORTING\n      xml TYPE string\n    RETURNING\n      VALUE(stream) TYPE REF TO if_ixml_istream.\n\n  METHODS create_istream_xstring\n    IMPORTING\n      xml TYPE xstring\n    RETURNING\n      VALUE(stream) TYPE REF TO if_ixml_istream.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_IXML_UNKNOWN', 'INTERFACE if_ixml_unknown PUBLIC.\n  METHODS query_interface\n    IMPORTING\n      iid         TYPE i\n    RETURNING\n      VALUE(rval) TYPE REF TO if_ixml_unknown.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('/UI2/CL_JSON', 'CLASS /ui2/cl_json DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CONSTANTS: BEGIN OF pretty_mode,\n                 low_case   TYPE string VALUE ''low_case'',\n                 camel_case TYPE string VALUE ''camel_case'',\n               END OF pretty_mode.\n\n    TYPES tribool TYPE c LENGTH 1.\n\n    CLASS-METHODS deserialize\n      IMPORTING\n        json             TYPE string OPTIONAL\n        jsonx            TYPE xstring OPTIONAL\n        pretty_name      TYPE string OPTIONAL\n        assoc_arrays     TYPE abap_bool OPTIONAL\n        assoc_arrays_opt TYPE abap_bool OPTIONAL\n      CHANGING\n        data             TYPE data.\n\n    CLASS-METHODS serialize\n      IMPORTING\n        data          TYPE data\n        compress      TYPE abap_bool OPTIONAL\n        pretty_name   TYPE string OPTIONAL\n        assoc_arrays  TYPE abap_bool OPTIONAL\n      RETURNING\n        VALUE(r_json) TYPE string.\n\n  PRIVATE SECTION.\n    CLASS-DATA mo_parsed TYPE REF TO lcl_parser.\n    CLASS-METHODS _deserialize\n      IMPORTING\n        prefix      TYPE string\n        pretty_name TYPE string OPTIONAL\n      CHANGING\n        data        TYPE data.\nENDCLASS.\n\nCLASS /ui2/cl_json IMPLEMENTATION.\n\n  METHOD serialize.\n    DATA lo_type       TYPE REF TO cl_abap_typedescr.\n    DATA lo_struct     TYPE REF TO cl_abap_structdescr.\n    DATA lt_components TYPE cl_abap_structdescr=>component_table.\n    DATA ls_component  LIKE LINE OF lt_components.\n    DATA ref           TYPE REF TO data.\n    DATA lv_index      TYPE i.\n\n    FIELD-SYMBOLS <any> TYPE any.\n    FIELD-SYMBOLS <tab> TYPE ANY TABLE.\n\n    lo_type = cl_abap_typedescr=>describe_by_data( data ).\n    CASE lo_type->kind.\n      WHEN cl_abap_typedescr=>kind_elem.\n        CASE lo_type->type_kind.\n          WHEN cl_abap_typedescr=>typekind_char\n              OR cl_abap_typedescr=>typekind_string.\n            r_json = ''\"'' && data && ''\"''.\n          WHEN OTHERS.\n            r_json = data.\n        ENDCASE.\n      WHEN cl_abap_typedescr=>kind_table.\n        r_json = ''[''.\n        ASSIGN data TO <tab>.\n        LOOP AT <tab> ASSIGNING <any>.\n          lv_index = sy-tabix.\n          r_json = r_json && serialize( <any> ).\n          IF lines( data ) <> lv_index.\n            r_json = r_json && '',''.\n          ENDIF.\n        ENDLOOP.\n        r_json = r_json && '']''.\n      WHEN cl_abap_typedescr=>kind_struct.\n        lo_struct ?= lo_type.\n        lt_components = lo_struct->get_components( ).\n        r_json = ''{''.\n        LOOP AT lt_components INTO ls_component.\n          lv_index = sy-tabix.\n          ASSIGN COMPONENT ls_component-name OF STRUCTURE data TO <any>.\n          ASSERT sy-subrc = 0.\n          r_json = r_json && |\"{ ls_component-name }\":| && serialize( <any> ).\n          IF lines( lt_components ) <> lv_index.\n            r_json = r_json && '',''.\n          ENDIF.\n        ENDLOOP.\n        r_json = r_json && ''}''.\n      WHEN OTHERS.\n        ASSERT 1 = ''cl_json, unknown kind''.\n    ENDCASE.\n  ENDMETHOD.\n\n  METHOD deserialize.\n    CREATE OBJECT mo_parsed.\n    ASSERT jsonx IS INITIAL. \" todo\n    mo_parsed->parse( json ).\n\n    CLEAR data.\n\n    _deserialize(\n      EXPORTING\n        prefix      = ''''\n        pretty_name = pretty_name\n      CHANGING\n        data        = data ).\n  ENDMETHOD.\n\n  METHOD _deserialize.\n    DATA lo_type       TYPE REF TO cl_abap_typedescr.\n    DATA lo_struct     TYPE REF TO cl_abap_structdescr.\n    DATA lt_components TYPE cl_abap_structdescr=>component_table.\n    DATA ls_component  LIKE LINE OF lt_components.\n    DATA lt_members    TYPE string_table.\n    DATA ref           TYPE REF TO data.\n    DATA lv_name       TYPE string.\n    DATA lv_member     LIKE LINE OF lt_members.\n\n    FIELD-SYMBOLS <any> TYPE any.\n\n    lo_type = cl_abap_typedescr=>describe_by_data( data ).\n*    WRITE ''@KERNEL console.dir(lo_type.get());''.\n    CASE lo_type->kind.\n      WHEN cl_abap_typedescr=>kind_elem.\n*        WRITE ''@KERNEL console.dir(lo_type.get().absolute_name);''.\n        IF lo_type->absolute_name = ''\\\\TYPE-POOL=ABAP\\\\TYPE=ABAP_BOOL''\n            OR lo_type->absolute_name = ''\\\\TYPE=FLAG''.\n          data = boolc( mo_parsed->value_string( prefix ) = ''true'' ).\n        ELSE.\n          data = mo_parsed->value_string( prefix ).\n        ENDIF.\n      WHEN cl_abap_typedescr=>kind_table.\n        lt_members = mo_parsed->members( prefix && ''/'' ).\n        LOOP AT lt_members INTO lv_member.\n*          WRITE ''@KERNEL console.dir(lv_member.get());''.\n          CREATE DATA ref LIKE LINE OF data.\n          ASSIGN ref->* TO <any>.\n          _deserialize(\n            EXPORTING\n              prefix      = prefix && ''/'' && lv_member\n              pretty_name = pretty_name\n            CHANGING\n              data        = <any> ).\n*          WRITE ''@KERNEL console.dir(fs_row_);''.\n          INSERT <any> INTO TABLE data.\n        ENDLOOP.\n      WHEN cl_abap_typedescr=>kind_struct.\n        lo_struct ?= lo_type.\n        lt_components = lo_struct->get_components( ).\n        LOOP AT lt_components INTO ls_component.\n          ASSIGN COMPONENT ls_component-name OF STRUCTURE data TO <any>.\n          ASSERT sy-subrc = 0.\n          CASE pretty_name.\n            WHEN pretty_mode-camel_case.\n              lv_name = to_mixed( to_lower( ls_component-name ) ).\n            WHEN OTHERS.\n              lv_name = to_lower( ls_component-name ).\n          ENDCASE.\n*          WRITE ''@KERNEL console.dir(lv_name.get());''.\n          _deserialize(\n            EXPORTING\n              prefix      = prefix && ''/'' && lv_name\n              pretty_name = pretty_name\n            CHANGING\n              data        = <any> ).\n        ENDLOOP.\n      WHEN OTHERS.\n        ASSERT 1 = ''cl_json, unknown kind''.\n    ENDCASE.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_CALL_TRANSFORMATION', 'CLASS kernel_call_transformation DEFINITION PUBLIC.\n* handling of ABAP statement CALL TRANSFORMATION\n  PUBLIC SECTION.\n    CLASS-METHODS call IMPORTING input TYPE any.\n  PRIVATE SECTION.\n    CLASS-DATA mi_doc TYPE REF TO if_ixml_document.\n    CLASS-DATA mi_writer TYPE REF TO if_sxml_writer.\n\n    CLASS-METHODS parse_xml IMPORTING iv_xml TYPE string.\n    CLASS-METHODS traverse_write\n      IMPORTING iv_ref TYPE REF TO data.\n    CLASS-METHODS traverse_write_type\n      IMPORTING iv_ref TYPE REF TO data\n      RETURNING VALUE(rv_type) TYPE string.\nENDCLASS.\n\nCLASS kernel_call_transformation IMPLEMENTATION.\n\n  METHOD call.\n* first convert SOURCE to internal format stored in \"MI_DOC\"?\n* then output to RESULT\n\n    DATA lv_name   TYPE string.\n    DATA lv_source TYPE string.\n    DATA result    TYPE REF TO data.\n    DATA lt_rtab   TYPE abap_trans_resbind_tab.\n    DATA ls_rtab   LIKE LINE OF lt_rtab.\n    DATA lv_type   TYPE string.\n\n    CLEAR mi_doc.\n    CLEAR mi_writer.\n\n*    WRITE ''@KERNEL console.dir(INPUT);''.\n\n* only the ID transformation is implemented\n    WRITE ''@KERNEL lv_name.set(INPUT.name.toUpperCase());''.\n    ASSERT lv_name = ''ID''.\n\n* Handle input SOURCE\n    WRITE ''@KERNEL if (INPUT.sourceXML?.constructor.name === \"ABAPObject\") this.mi_doc.set(INPUT.sourceXML);''.\n    WRITE ''@KERNEL if (INPUT.sourceXML?.constructor.name === \"String\") lv_source.set(INPUT.sourceXML);''.\n    IF lv_source IS NOT INITIAL.\n      IF lv_source(1) = ''<''.\n        lv_type = ''XML''.\n        parse_xml( lv_source ).\n      ELSEIF lv_source(1) = ''{'' OR lv_source(1) = ''[''.\n        lv_type = ''JSON''.\n        mi_doc = kernel_json_to_ixml=>build( lv_source ).\n      ELSE.\n        RAISE EXCEPTION TYPE cx_xslt_format_error.\n      ENDIF.\n    ENDIF.\n\n* todo, rewrite this part,\n    WRITE ''@KERNEL if (typeof INPUT.source === \"object\" && INPUT.resultXML?.constructor.name === \"ABAPObject\") {''.\n    WRITE ''@KERNEL   this.mi_writer.set(INPUT.resultXML);''.\n    WRITE ''@KERNEL }''.\n*    WRITE ''@KERNEL console.dir(INPUT);''.\n    IF mi_writer IS NOT INITIAL.\n* input is object and write to sxml output\n* todo, rewrite\n      mi_writer->open_element( name = ''object'' ).\n      WRITE ''@KERNEL for (const name in INPUT.source) {''.\n      WRITE ''@KERNEL   lv_name.set(name);''.\n      WRITE ''@KERNEL   if (INPUT.source[name].constructor.name === \"FieldSymbol\") {''.\n      WRITE ''@KERNEL     result.assign(INPUT.source[name].getPointer());''.\n      WRITE ''@KERNEL   } else {''.\n      WRITE ''@KERNEL     result.assign(INPUT.source[name]);''.\n      WRITE ''@KERNEL   }''.\n      mi_writer->open_element( name = ''str'' ).\n      mi_writer->write_attribute( name = ''name'' value = to_upper( lv_name ) ).\n      traverse_write( result ).\n      mi_writer->close_element( ).\n      WRITE ''@KERNEL }''.\n      mi_writer->close_element( ).\n      RETURN.\n    ENDIF.\n\n    IF lv_source IS INITIAL AND mi_doc IS INITIAL.\n      RAISE EXCEPTION TYPE cx_xslt_runtime_error.\n    ENDIF.\n\n    WRITE ''@KERNEL if (INPUT.result.constructor.name === \"Table\") {''.\n* INPUT.result is an ABAP internal table, dynamic result parameter\n    WRITE ''@KERNEL lt_rtab = INPUT.result;''.\n    LOOP AT lt_rtab INTO ls_rtab.\n      kernel_ixml_xml_to_data=>build(\n        iv_name = ls_rtab-name\n        iv_ref  = ls_rtab-value\n        ii_doc  = mi_doc ).\n    ENDLOOP.\n    WRITE ''@KERNEL } else {''.\n* INPUT.result is a javascript structure\n    WRITE ''@KERNEL for (const name in INPUT.result) {''.\n    WRITE ''@KERNEL   lv_name.set(name.toUpperCase());''.\n    WRITE ''@KERNEL   if (INPUT.result[name].constructor.name === \"FieldSymbol\") {''.\n    WRITE ''@KERNEL     result.assign(INPUT.result[name].getPointer());''.\n    WRITE ''@KERNEL   } else {''.\n    WRITE ''@KERNEL     result.assign(INPUT.result[name]);''.\n    WRITE ''@KERNEL   }''.\n    IF lv_type = ''JSON''.\n      kernel_ixml_json_to_data=>build(\n        iv_name = lv_name\n        iv_ref  = result\n        ii_doc  = mi_doc ).\n    ELSE.\n      kernel_ixml_xml_to_data=>build(\n        iv_name = lv_name\n        iv_ref  = result\n        ii_doc  = mi_doc ).\n    ENDIF.\n    WRITE ''@KERNEL }''.\n    WRITE ''@KERNEL }''.\n\n*    WRITE ''@KERNEL console.dir(INPUT.result.data);''.\n\n  ENDMETHOD.\n\n  METHOD traverse_write_type.\n    DATA lo_type TYPE REF TO cl_abap_typedescr.\n    lo_type = cl_abap_typedescr=>describe_by_data( iv_ref->* ).\n    CASE lo_type->type_kind.\n      WHEN cl_abap_typedescr=>typekind_int\n          OR cl_abap_typedescr=>typekind_int1\n          OR cl_abap_typedescr=>typekind_int2\n          OR cl_abap_typedescr=>typekind_int8\n          OR cl_abap_typedescr=>typekind_decfloat\n          OR cl_abap_typedescr=>typekind_decfloat16\n          OR cl_abap_typedescr=>typekind_decfloat34.\n        rv_type = ''num''.\n      WHEN OTHERS.\n        rv_type = ''str''.\n    ENDCASE.\n  ENDMETHOD.\n\n  METHOD traverse_write.\n* TODO: refactor this method\n\n    DATA lo_type TYPE REF TO cl_abap_typedescr.\n    DATA lo_struc TYPE REF TO cl_abap_structdescr.\n    DATA lt_comps TYPE cl_abap_structdescr=>component_table.\n    DATA li_element TYPE REF TO if_ixml_element.\n    DATA li_sub TYPE REF TO if_ixml_element.\n    DATA ls_compo LIKE LINE OF lt_comps.\n    DATA lv_ref TYPE REF TO data.\n    FIELD-SYMBOLS <any> TYPE any.\n    FIELD-SYMBOLS <table> TYPE ANY TABLE.\n    FIELD-SYMBOLS <field> TYPE any.\n\n*     WRITE ''@KERNEL console.dir(iv_ref.getPointer());''.\n    lo_type = cl_abap_typedescr=>describe_by_data( iv_ref->* ).\n*    WRITE ''@KERNEL console.dir(lo_type.get().kind.get());''.\n    CASE lo_type->kind.\n      WHEN cl_abap_typedescr=>kind_struct.\n        mi_writer->open_element( name = ''object'' ).\n\n        lo_struc ?= lo_type.\n        lt_comps = lo_struc->get_components( ).\n        ASSIGN iv_ref->* TO <any>.\n        LOOP AT lt_comps INTO ls_compo.\n          ASSIGN COMPONENT ls_compo-name OF STRUCTURE <any> TO <field>.\n          GET REFERENCE OF <field> INTO lv_ref.\n          mi_writer->open_element( name = traverse_write_type( lv_ref ) ).\n          mi_writer->write_attribute( name = ''name'' value = to_upper( ls_compo-name ) ).\n          traverse_write( lv_ref ).\n          mi_writer->close_element( ).\n        ENDLOOP.\n\n        mi_writer->close_element( ).\n      WHEN cl_abap_typedescr=>kind_elem.\n        mi_writer->write_value( iv_ref->* ).\n      WHEN cl_abap_typedescr=>kind_table.\n        mi_writer->open_element( name = ''array'' ).\n\n        ASSIGN iv_ref->* TO <table>.\n        LOOP AT <table> ASSIGNING <any>.\n          GET REFERENCE OF <any> INTO lv_ref.\n          IF cl_abap_typedescr=>describe_by_data( lv_ref->* )->kind = cl_abap_typedescr=>kind_elem.\n            mi_writer->open_element( name = traverse_write_type( lv_ref ) ).\n          ENDIF.\n          traverse_write( lv_ref ).\n          IF cl_abap_typedescr=>describe_by_data( lv_ref->* )->kind = cl_abap_typedescr=>kind_elem.\n            mi_writer->close_element( ).\n          ENDIF.\n        ENDLOOP.\n\n        mi_writer->close_element( ).\n      WHEN OTHERS.\n        ASSERT 1 = ''todo_traverse_write''.\n    ENDCASE.\n\n  ENDMETHOD.\n\n  METHOD parse_xml.\n\n    DATA li_factory TYPE REF TO if_ixml_stream_factory.\n    DATA li_istream TYPE REF TO if_ixml_istream.\n    DATA li_parser  TYPE REF TO if_ixml_parser.\n    DATA li_ixml    TYPE REF TO if_ixml.\n    DATA lv_subrc   TYPE i.\n\n    li_ixml = cl_ixml=>create( ).\n    mi_doc  = li_ixml->create_document( ).\n\n    li_factory = li_ixml->create_stream_factory( ).\n    li_istream = li_factory->create_istream_string( iv_xml ).\n    li_parser = li_ixml->create_parser( stream_factory = li_factory\n                                        istream        = li_istream\n                                        document       = mi_doc ).\n    li_parser->add_strip_space_element( ).\n    lv_subrc = li_parser->parse( ).\n    li_istream->close( ).\n\n    ASSERT lv_subrc = 0.\n\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_IXML_JSON_TO_DATA', 'CLASS kernel_ixml_json_to_data DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS build\n      IMPORTING\n        iv_name TYPE string\n        iv_ref  TYPE REF TO data\n        ii_doc  TYPE REF TO if_ixml_document.\n  PRIVATE SECTION.\n    CLASS-METHODS get_field_name\n      IMPORTING ii_node TYPE REF TO if_ixml_node\n      RETURNING VALUE(rv_name) TYPE string.\n    CLASS-METHODS traverse\n      IMPORTING\n        ii_node TYPE REF TO if_ixml_node\n        iv_ref  TYPE REF TO data.\nENDCLASS.\n\nCLASS kernel_ixml_json_to_data IMPLEMENTATION.\n\n  METHOD get_field_name.\n    DATA li_aiterator TYPE REF TO if_ixml_node_iterator.\n    DATA li_anode TYPE REF TO if_ixml_node.\n    DATA attr TYPE REF TO if_ixml_named_node_map.\n\n    attr = ii_node->get_attributes( ).\n    IF attr IS NOT INITIAL.\n      li_aiterator = attr->create_iterator( ).\n      DO.\n        li_anode = li_aiterator->get_next( ).\n        IF li_anode IS INITIAL.\n          EXIT. \" current loop\n        ENDIF.\n* assume its the name,\n        rv_name = li_anode->get_value( ).\n        RETURN.\n      ENDDO.\n    ENDIF.\n  ENDMETHOD.\n\n  METHOD build.\n* assumptions: the top level element is an object containing iv_name\n\n    DATA li_first TYPE REF TO if_ixml_node.\n    DATA li_node TYPE REF TO if_ixml_node.\n    DATA lv_name TYPE string.\n    DATA li_iterator TYPE REF TO if_ixml_node_iterator.\n\n    li_first = ii_doc->get_root( )->get_first_child( ).\n    ASSERT li_first->get_name( ) = ''object''.\n\n    li_iterator = li_first->get_children( )->create_iterator( ).\n    DO.\n      li_node = li_iterator->get_next( ).\n      IF li_node IS INITIAL.\n        EXIT. \" current loop\n      ENDIF.\n\n      lv_name = get_field_name( li_node ).\n      IF lv_name = iv_name.\n*        WRITE ''@KERNEL console.dir(\"found\");''.\n        traverse(\n          iv_ref  = iv_ref\n          ii_node = li_node ).\n        RETURN.\n      ENDIF.\n    ENDDO.\n  ENDMETHOD.\n\n  METHOD traverse.\n\n    DATA lo_type TYPE REF TO cl_abap_typedescr.\n    DATA li_child TYPE REF TO if_ixml_node.\n    DATA lv_name TYPE string.\n    DATA li_iterator TYPE REF TO if_ixml_node_iterator.\n    DATA lv_ref TYPE REF TO data.\n    FIELD-SYMBOLS <any> TYPE any.\n    FIELD-SYMBOLS <field> TYPE any.\n    FIELD-SYMBOLS <tab> TYPE ANY TABLE.\n\n    lo_type = cl_abap_typedescr=>describe_by_data( iv_ref->* ).\n    CASE lo_type->kind.\n      WHEN cl_abap_typedescr=>kind_struct.\n        ASSERT ii_node->get_name( ) = ''object''.\n        ASSIGN iv_ref->* TO <any>.\n        li_iterator = ii_node->get_children( )->create_iterator( ).\n        DO.\n          li_child = li_iterator->get_next( ).\n          IF li_child IS INITIAL.\n            EXIT. \" current loop\n          ENDIF.\n          lv_name = get_field_name( li_child ).\n          ASSIGN COMPONENT lv_name OF STRUCTURE <any> TO <field>.\n          IF sy-subrc = 0.\n            GET REFERENCE OF <field> INTO lv_ref.\n            traverse( ii_node = li_child\n                      iv_ref  = lv_ref ).\n          ENDIF.\n        ENDDO.\n      WHEN cl_abap_typedescr=>kind_elem.\n        li_child = ii_node->get_first_child( ).\n        ASSERT li_child->get_name( ) = ''#text''.\n        ASSIGN iv_ref->* TO <any>.\n        <any> = li_child->get_value( ).\n      WHEN cl_abap_typedescr=>kind_table.\n        ASSERT ii_node->get_name( ) = ''array''.\n        ASSIGN iv_ref->* TO <tab>.\n        li_iterator = ii_node->get_children( )->create_iterator( ).\n        DO.\n          li_child = li_iterator->get_next( ).\n          IF li_child IS INITIAL.\n            EXIT. \" current loop\n          ENDIF.\n          CREATE DATA lv_ref LIKE LINE OF <tab>.\n          ASSIGN lv_ref->* TO <any>.\n          traverse( ii_node = li_child\n                  iv_ref  = lv_ref ).\n          INSERT <any> INTO TABLE <tab>.\n        ENDDO.\n      WHEN OTHERS.\n        WRITE ''@KERNEL console.dir(lo_type.get().kind.get());''.\n    ENDCASE.\n\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_IXML_XML_TO_DATA', 'CLASS kernel_ixml_xml_to_data DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS build\n      IMPORTING\n        iv_name TYPE string\n        iv_ref  TYPE REF TO data\n        ii_doc  TYPE REF TO if_ixml_document.\n  PRIVATE SECTION.\n    CLASS-METHODS traverse\n      IMPORTING\n        ii_node TYPE REF TO if_ixml_node\n        iv_ref  TYPE REF TO data.\nENDCLASS.\n\nCLASS kernel_ixml_xml_to_data IMPLEMENTATION.\n\n  METHOD build.\n\n    DATA li_first TYPE REF TO if_ixml_element.\n    DATA li_node TYPE REF TO if_ixml_node.\n    DATA lv_name TYPE string.\n    DATA li_iterator TYPE REF TO if_ixml_node_iterator.\n\n    li_first ?= ii_doc->get_root( )->get_first_child( ).\n\n    li_node = li_first->find_from_name_ns(\n      name      = iv_name\n      depth     = 0\n      namespace = '''' ).\n    IF li_node IS NOT INITIAL.\n*      WRITE ''@KERNEL console.dir(\"found\");''.\n      traverse( ii_node = li_node\n                iv_ref  = iv_ref ).\n*    ELSE.\n*      WRITE ''@KERNEL console.dir(\"nah\");''.\n    ENDIF.\n\n  ENDMETHOD.\n\n  METHOD traverse.\n\n    DATA lo_type TYPE REF TO cl_abap_typedescr.\n    DATA li_child TYPE REF TO if_ixml_node.\n    DATA lv_name TYPE string.\n    DATA li_iterator TYPE REF TO if_ixml_node_iterator.\n    DATA lv_ref TYPE REF TO data.\n    FIELD-SYMBOLS <any> TYPE any.\n    FIELD-SYMBOLS <field> TYPE any.\n    FIELD-SYMBOLS <tab> TYPE ANY TABLE.\n\n    lo_type = cl_abap_typedescr=>describe_by_data( iv_ref->* ).\n    CASE lo_type->kind.\n      WHEN cl_abap_typedescr=>kind_struct.\n        ASSIGN iv_ref->* TO <any>.\n        li_iterator = ii_node->get_children( )->create_iterator( ).\n        DO.\n          li_child = li_iterator->get_next( ).\n          IF li_child IS INITIAL.\n            EXIT. \" current loop\n          ENDIF.\n          lv_name = li_child->get_name( ).\n          ASSIGN COMPONENT lv_name OF STRUCTURE <any> TO <field>.\n          IF sy-subrc = 0.\n            GET REFERENCE OF <field> INTO lv_ref.\n            traverse( ii_node = li_child\n                      iv_ref  = lv_ref ).\n          ENDIF.\n        ENDDO.\n      WHEN cl_abap_typedescr=>kind_elem.\n        li_child = ii_node->get_first_child( ).\n        ASSIGN iv_ref->* TO <any>.\n        <any> = li_child->get_value( ).\n      WHEN cl_abap_typedescr=>kind_table.\n        ASSIGN iv_ref->* TO <tab>.\n        li_iterator = ii_node->get_children( )->create_iterator( ).\n        DO.\n          li_child = li_iterator->get_next( ).\n          IF li_child IS INITIAL.\n            EXIT. \" current loop\n          ENDIF.\n          CREATE DATA lv_ref LIKE LINE OF <tab>.\n          ASSIGN lv_ref->* TO <any>.\n          traverse( ii_node = li_child\n                  iv_ref  = lv_ref ).\n          INSERT <any> INTO TABLE <tab>.\n        ENDDO.\n      WHEN OTHERS.\n        WRITE ''@KERNEL console.dir(lo_type.get().kind.get());''.\n    ENDCASE.\n\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_JSON_TO_IXML', 'CLASS kernel_json_to_ixml DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS build\n      IMPORTING iv_json TYPE string\n      RETURNING VALUE(ri_doc) TYPE REF TO if_ixml_document.\nENDCLASS.\n\nCLASS kernel_json_to_ixml IMPLEMENTATION.\n\n  METHOD build.\n* build IXML by calling SXML json parser and then converting :)\n\n    DATA li_reader TYPE REF TO if_sxml_reader.\n    DATA li_node TYPE REF TO if_sxml_node.\n    DATA li_close TYPE REF TO if_sxml_close_element.\n    DATA li_open TYPE REF TO if_sxml_open_element.\n    DATA li_value TYPE REF TO if_sxml_value_node.\n    DATA lt_attributes TYPE if_sxml_attribute=>attributes.\n    DATA li_attribute TYPE REF TO if_sxml_attribute.\n    DATA li_current TYPE REF TO if_ixml_node.\n    DATA lv_name TYPE string.\n    DATA li_map TYPE REF TO if_ixml_named_node_map.\n    DATA li_new TYPE REF TO if_ixml_node.\n    DATA li_element TYPE REF TO if_ixml_element.\n\n    li_reader = cl_sxml_string_reader=>create( cl_abap_codepage=>convert_to( iv_json ) ).\n\n    ri_doc = cl_ixml=>create( )->create_document( ).\n    li_current = ri_doc->get_root( ).\n\n    DO.\n      li_node = li_reader->read_next_node( ).\n      IF li_node IS INITIAL.\n        EXIT.\n      ENDIF.\n\n      CASE li_node->type.\n        WHEN if_sxml_node=>co_nt_element_open.\n          li_open ?= li_node.\n*          WRITE: / ''open: '', li_open->qname-name.\n\n          CLEAR lv_name.\n          lt_attributes = li_open->get_attributes( ).\n          LOOP AT lt_attributes INTO li_attribute.\n*            WRITE / li_attribute->get_value( ).\n            lv_name = li_attribute->get_value( ).\n          ENDLOOP.\n\n          li_element = ri_doc->create_element_ns( li_open->qname-name ).\n          li_new ?= li_element.\n          li_current->append_child( li_new ).\n          li_current = li_new.\n*            WRITE ''@KERNEL console.dir(li_element);''.\n\n          IF lv_name IS NOT INITIAL.\n            li_element = ri_doc->create_element_ns( ''name'' ).\n            li_new ?= li_element.\n            li_new->set_value( lv_name ).\n\n            li_map = li_current->get_attributes( ).\n            li_map->set_named_item_ns( li_new ).\n          ENDIF.\n\n        WHEN if_sxml_node=>co_nt_element_close.\n          li_close ?= li_node.\n*          WRITE: / ''close: '', li_close->qname-name.\n*          IF li_close->qname-name = ''object'' OR li_close->qname-name = ''array''.\n          li_current = li_current->get_parent( ).\n*          ENDIF.\n        WHEN if_sxml_node=>co_nt_value.\n          li_value ?= li_node.\n*          WRITE / li_value->get_value( ).\n*          li_current->set_value( li_value->get_value( ) ).\n\n          li_element = ri_doc->create_element_ns( ''#text'' ).\n          li_element->set_value( li_value->get_value( ) ).\n          li_new ?= li_element.\n          li_current->append_child( li_new ).\n\n      ENDCASE.\n    ENDDO.\n\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_PUSH_CHANNELS', 'CLASS kernel_push_channels DEFINITION PUBLIC.\n* handling of ABAP statement WAIT FOR PUSH CHANNELS\n  PUBLIC SECTION.\n    CLASS-METHODS wait.\n  PRIVATE SECTION.\nENDCLASS.\n\nCLASS kernel_push_channels IMPLEMENTATION.\n\n  METHOD wait.\n* todo, await up to some seconds\n    WRITE ''@KERNEL await new Promise(resolve => setTimeout(resolve, 1000));''.\n* todo, check condition\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_SCAN_ABAP_SOURCE', 'CLASS kernel_scan_abap_source DEFINITION PUBLIC.\n* handling of ABAP statement SCAN ABAP-SOURCE\n  PUBLIC SECTION.\n    CLASS-METHODS call IMPORTING input TYPE any.\n    TYPES ty_stokesx TYPE STANDARD TABLE OF stokesx WITH DEFAULT KEY.\n    TYPES ty_sstmnt TYPE STANDARD TABLE OF sstmnt WITH DEFAULT KEY.\n  PRIVATE SECTION.\n    CONSTANTS: BEGIN OF gc_token,\n                 comment    TYPE c LENGTH 1 VALUE ''C'',\n                 identifier TYPE c LENGTH 1 VALUE ''I'',\n                 list       TYPE c LENGTH 1 VALUE ''L'',\n                 literal    TYPE c LENGTH 1 VALUE ''S'',\n                 pragma     TYPE c LENGTH 1 VALUE ''P'',\n               END OF gc_token.\n\n    CONSTANTS: BEGIN OF gc_statement,\n                 comment          TYPE c LENGTH 1 VALUE ''P'',\n                 comment_in_stmnt TYPE c LENGTH 1 VALUE ''S'',\n                 compute_direct   TYPE c LENGTH 1 VALUE ''C'',\n                 empty            TYPE c LENGTH 1 VALUE ''N'',\n                 macro_call       TYPE c LENGTH 1 VALUE ''D'',\n                 macro_definition TYPE c LENGTH 1 VALUE ''M'',\n                 method_direct    TYPE c LENGTH 1 VALUE ''A'',\n                 native_sql       TYPE c LENGTH 1 VALUE ''E'',\n                 pragma           TYPE c LENGTH 1 VALUE ''G'',\n                 standard         TYPE c LENGTH 1 VALUE ''K'',\n               END OF gc_statement.\n\n    CLASS-METHODS pass1\n      IMPORTING\n        source        TYPE string\n      EXPORTING\n        et_tokens     TYPE ty_stokesx\n        et_statements TYPE ty_sstmnt.\n\n    CLASS-METHODS pass2\n      CHANGING\n        ct_tokens     TYPE ty_stokesx\n        ct_statements TYPE ty_sstmnt.\nENDCLASS.\n\nCLASS kernel_scan_abap_source IMPLEMENTATION.\n\n  METHOD call.\n\n    DATA source TYPE string.\n    FIELD-SYMBOLS <tokens>     TYPE ty_stokesx.\n    FIELD-SYMBOLS <statements> TYPE ty_sstmnt.\n\n    WRITE ''@KERNEL source.set(INPUT.scan_abap_source.array ? INPUT.scan_abap_source.array().map(e => e.get()).join(\"\\\\n\") : INPUT.scan_abap_source.get());''.\n    WRITE ''@KERNEL fs_tokens_.assign(INPUT.tokens_into);''.\n    WRITE ''@KERNEL fs_statements_.assign(INPUT.statements_into);''.\n\n* non-goal: good performance\n\n* build tokens in sequence of occurence in the source\n* take care of chained statements\n    pass1(\n      EXPORTING\n        source        = source\n      IMPORTING\n        et_tokens     = <tokens>\n        et_statements = <statements> ).\n\n* move comment tokens and add/change statements to comment type\n    pass2(\n      CHANGING\n        ct_tokens     = <tokens>\n        ct_statements = <statements> ).\n\n  ENDMETHOD.\n\n  METHOD pass1.\n    CONSTANTS: BEGIN OF c_mode,\n                 normal  TYPE i VALUE 1,\n                 comment TYPE i VALUE 2,\n               END OF c_mode.\n\n    DATA character    TYPE c LENGTH 1.\n    DATA row          TYPE i VALUE 1.\n    DATA column       TYPE i.\n    DATA index        TYPE i.\n    DATA sfrom        TYPE i VALUE 1.\n    DATA mode         TYPE i.\n    DATA chain_tokens TYPE ty_stokesx.\n\n    FIELD-SYMBOLS <trow> LIKE LINE OF et_tokens.\n    FIELD-SYMBOLS <srow> LIKE LINE OF et_statements.\n\n    mode = c_mode-normal.\n    WHILE source IS NOT INITIAL.\n      character = source(1).\n      source = source+1.\n\n      IF <trow> IS NOT ASSIGNED AND character <> '''' AND character <> |\\\\n|.\n        APPEND INITIAL LINE TO et_tokens ASSIGNING <trow>.\n        <trow>-row = row.\n        <trow>-col = column.\n        <trow>-type = gc_token-identifier.\n      ELSEIF mode = c_mode-normal AND ( character = '''' OR character CA |.,| ).\n        UNASSIGN <trow>.\n\"         IF character = '',''.\n\" *          WRITE ''@KERNEL console.dir(\"before\");''.\n\"           APPEND LINES OF chain_tokens TO et_tokens.\n\" *          WRITE ''@KERNEL console.dir(\"after\");''.\n\" *          WRITE lines( <tokens> ).\n\"         ENDIF.\n      ELSEIF mode = c_mode-normal AND character = '':''.\n        CLEAR chain_tokens.\n        APPEND LINES OF et_tokens FROM sfrom TO chain_tokens.\n        DELETE chain_tokens WHERE type = gc_token-comment.\n*        WRITE ''@KERNEL console.dir(chain_tokens);''.\n      ENDIF.\n\n      IF ( mode = c_mode-normal AND character CA |.,| )\n          OR source = ''''.\n        APPEND INITIAL LINE TO et_statements ASSIGNING <srow>.\n        <srow>-terminator = character.\n        <srow>-from = sfrom.\n        <srow>-to = lines( et_tokens ).\n        sfrom = <srow>-to + 1.\n\n        IF character = '',''.\n*          WRITE ''@KERNEL console.dir(\"before\");''.\n          APPEND LINES OF chain_tokens TO et_tokens.\n*          WRITE ''@KERNEL console.dir(\"after\");''.\n*          WRITE lines( <tokens> ).\n        ENDIF.\n      ENDIF.\n\n      IF character = |\\\\n|.\n        mode = c_mode-normal.\n        UNASSIGN <trow>.\n        row = row + 1.\n        column = 0.\n      ELSE.\n        IF <trow> IS ASSIGNED.\n          IF ( character = ''*'' AND column = 0 ) OR character = ''\"''.\n            mode = c_mode-comment.\n            <trow>-type = gc_token-comment.\n          ENDIF.\n          IF mode = c_mode-comment.\n            <trow>-type = gc_token-comment.\n            <trow>-str = <trow>-str && |{ character }|.\n          ELSEIF character <> '':''.\n            <trow>-str = <trow>-str && to_upper( |{ character }| ).\n          ENDIF.\n        ENDIF.\n        column = column + 1.\n      ENDIF.\n\n    ENDWHILE.\n\n  ENDMETHOD.\n\n  METHOD pass2.\n    FIELD-SYMBOLS <ls_statement> LIKE LINE OF ct_statements.\n    DATA ls_statement       LIKE LINE OF ct_statements.\n    DATA ls_token           LIKE LINE OF ct_tokens.\n    DATA contains_comment   TYPE abap_bool.\n    DATA contains_normal    TYPE abap_bool.\n    DATA lv_count           TYPE i.\n    DATA lv_statement_index TYPE i.\n    DATA lt_insert          LIKE ct_tokens.\n    DATA lt_delete          TYPE STANDARD TABLE OF i WITH DEFAULT KEY.\n    DATA lv_index           LIKE LINE OF lt_delete.\n\n    LOOP AT ct_statements ASSIGNING <ls_statement>.\n      lv_statement_index = sy-tabix.\n\n*      WRITE ''@KERNEL console.dir(\"statement\");''.\n      contains_comment = abap_false.\n      contains_normal = abap_false.\n      LOOP AT ct_tokens INTO ls_token FROM <ls_statement>-from TO <ls_statement>-to.\n        IF ls_token-type = gc_token-comment.\n          contains_comment = abap_true.\n        ELSE.\n          contains_normal = abap_true.\n        ENDIF.\n*        WRITE ''@KERNEL console.dir(ls_token.get().str.get());''.\n      ENDLOOP.\n\n      IF contains_comment = abap_true AND contains_normal = abap_true.\n* its a mix, move comments to the front as separate statement\n*        WRITE ''@KERNEL console.dir(\"from: \" + fs_ls_statement_.get().from.get());''.\n*        WRITE ''@KERNEL console.dir(\"to: \" + fs_ls_statement_.get().to.get());''.\n        lv_count = 0.\n        CLEAR lt_insert.\n        CLEAR lt_delete.\n        LOOP AT ct_tokens INTO ls_token FROM <ls_statement>-from TO <ls_statement>-to.\n*          WRITE ''@KERNEL console.dir(\"token: \" + ls_token.get().str.get() + \" \" + abap.builtin.sy.get().tabix.get());''.\n          IF ls_token-type = gc_token-comment.\n            INSERT sy-tabix INTO lt_delete INDEX 1.\n            INSERT ls_token INTO lt_insert INDEX 1.\n            lv_count = lv_count + 1.\n          ENDIF.\n        ENDLOOP.\n        LOOP AT lt_delete INTO lv_index.\n          DELETE ct_tokens INDEX lv_index.\n        ENDLOOP.\n        LOOP AT lt_insert INTO ls_token.\n          INSERT ls_token INTO ct_tokens INDEX <ls_statement>-from.\n        ENDLOOP.\n\n        CLEAR ls_statement.\n        ls_statement-from = <ls_statement>-from.\n        ls_statement-to = <ls_statement>-from + lv_count - 1.\n        ls_statement-type = gc_statement-comment.\n\n        <ls_statement>-from = <ls_statement>-from + lv_count.\n\n        INSERT ls_statement INTO ct_statements INDEX lv_statement_index.\n      ELSEIF contains_comment = abap_true.\n        <ls_statement>-type = gc_statement-comment.\n      ELSE.\n        <ls_statement>-type = gc_statement-standard.\n      ENDIF.\n    ENDLOOP.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_NUMBERRANGE_RUNTIME', 'CLASS cl_numberrange_runtime DEFINITION PUBLIC.\n  PUBLIC SECTION.\n\n    TYPES nr_interval TYPE c LENGTH 2.\n    TYPES nr_object   TYPE c LENGTH 10.\n    TYPES nr_number   TYPE n LENGTH 20.\n\n    CLASS-METHODS number_get\n      IMPORTING\n        nr_range_nr TYPE nr_interval\n        object      TYPE nr_object\n      EXPORTING\n        number      TYPE nr_number\n      RAISING\n        cx_static_check.\nENDCLASS.\n\nCLASS cl_numberrange_runtime IMPLEMENTATION.\n\n  METHOD number_get.\n\n    CALL FUNCTION ''NUMBER_GET_NEXT''\n      EXPORTING\n        nr_range_nr             = nr_range_nr\n        object                  = object\n      IMPORTING\n        number                  = number\n      EXCEPTIONS\n        interval_not_found      = 1\n        number_range_not_intern = 2\n        object_not_found        = 3\n        quantity_is_0           = 4\n        quantity_is_not_1       = 5\n        interval_overflow       = 6\n        buffer_overflow         = 7\n        OTHERS                  = 8.\n    IF sy-subrc <> 0.\n      RETURN. \" todo\n    ENDIF.\n\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_NUMBERRANGE', 'CLASS kernel_numberrange DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS number_get\n      IMPORTING\n        nr_range_nr TYPE cl_numberrange_runtime=>nr_interval\n        object      TYPE cl_numberrange_runtime=>nr_object\n      EXPORTING\n        number      TYPE cl_numberrange_runtime=>nr_number\n      RAISING\n        cx_static_check.\n  PRIVATE SECTION.\n    TYPES: BEGIN OF ty_status,\n             nr_range_nr TYPE cl_numberrange_runtime=>nr_interval,\n             object      TYPE cl_numberrange_runtime=>nr_object,\n             number      TYPE cl_numberrange_runtime=>nr_number,\n           END OF ty_status.\n    CLASS-DATA status TYPE STANDARD TABLE OF ty_status WITH DEFAULT KEY.\nENDCLASS.\n\nCLASS kernel_numberrange IMPLEMENTATION.\n\n  METHOD number_get.\n* for now, only in memory for the current session\n    FIELD-SYMBOLS <row> LIKE LINE OF status.\n    READ TABLE status WITH KEY nr_range_nr = nr_range_nr object = object ASSIGNING <row>.\n    IF sy-subrc = 0.\n      <row>-number = <row>-number + 1.\n    ELSE.\n      APPEND INITIAL LINE TO status ASSIGNING <row>.\n      <row>-nr_range_nr = nr_range_nr.\n      <row>-object = object.\n      <row>-number = 1.\n    ENDIF.\n    number = <row>-number.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_OO_FACTORY', 'CLASS cl_oo_factory DEFINITION PUBLIC CREATE PRIVATE.\n  PUBLIC SECTION.\n    INTERFACES if_oo_clif_source.\n\n    CLASS-METHODS create_instance\n      RETURNING\n        VALUE(result) TYPE REF TO cl_oo_factory.\n\n    METHODS create_clif_source\n      IMPORTING\n        clif_name     TYPE csequence\n      RETURNING\n        VALUE(result) TYPE REF TO if_oo_clif_source\n      RAISING\n        cx_oo_clif_not_exists.\n\n  PRIVATE SECTION.\n    DATA mv_name TYPE string.\nENDCLASS.\n\nCLASS cl_oo_factory IMPLEMENTATION.\n  METHOD create_instance.\n    CREATE OBJECT result.\n  ENDMETHOD.\n\n  METHOD create_clif_source.\n* todo, this not correct, should return a new instance, but will work for now\n    result = me.\n    mv_name = to_upper( clif_name ).\n  ENDMETHOD.\n\n  METHOD if_oo_clif_source~get_source.\n    DATA ls_data TYPE reposrc.\n    SELECT SINGLE * FROM reposrc INTO ls_data WHERE progname = mv_name.\n    SPLIT ls_data-data AT |\\\\n| INTO TABLE source.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_OO_CLIF_NOT_EXISTS', 'CLASS cx_oo_clif_not_exists DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_oo_clif_not_exists IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_OO_CLIF_SOURCE', 'INTERFACE if_oo_clif_source PUBLIC.\n  METHODS get_source\n    EXPORTING\n      source TYPE string_table.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_MATCHER', 'CLASS cl_abap_matcher DEFINITION PUBLIC.\n\n  PUBLIC SECTION.\n    METHODS constructor\n      IMPORTING\n        pattern TYPE clike\n        ignore_case TYPE abap_bool\n        text TYPE clike.\n\n    METHODS find_all\n      RETURNING\n        VALUE(rt_matches) TYPE match_result_tab.\n\n    METHODS find_next\n      RETURNING\n        VALUE(found) TYPE abap_bool.\n\n    METHODS get_submatch\n      IMPORTING\n        index TYPE i\n      RETURNING\n        VALUE(match) TYPE string.\n\n    METHODS get_offset\n      RETURNING\n        VALUE(offset) TYPE i.\n\n    METHODS match\n      RETURNING\n        VALUE(success) TYPE abap_bool.\n\n    METHODS get_length\n      RETURNING\n        VALUE(length) TYPE i.\n\n  PRIVATE SECTION.\n    DATA mt_matches TYPE match_result_tab.\n    DATA mv_index TYPE i.\n    DATA mv_text TYPE string.\n    DATA mv_pattern TYPE string.\n\nENDCLASS.\n\nCLASS cl_abap_matcher IMPLEMENTATION.\n\n  METHOD constructor.\n    IF ignore_case = abap_true.\n      FIND ALL OCCURRENCES OF REGEX pattern IN text RESULTS mt_matches IGNORING CASE.\n    ELSE.\n      FIND ALL OCCURRENCES OF REGEX pattern IN text RESULTS mt_matches.\n    ENDIF.\n    mv_pattern = pattern.\n    mv_text = text.\n  ENDMETHOD.\n\n  METHOD match.\n    FIND ALL OCCURRENCES OF REGEX |^{ mv_pattern }$| IN mv_text.\n    success = boolc( sy-subrc = 0 ).\n  ENDMETHOD.\n\n  METHOD find_all.\n    rt_matches = mt_matches.\n  ENDMETHOD.\n\n  METHOD find_next.\n    mv_index = mv_index + 1.\n    READ TABLE mt_matches INDEX mv_index TRANSPORTING NO FIELDS.\n    found = boolc( sy-subrc = 0 ).\n  ENDMETHOD.\n\n  METHOD get_submatch.\n    DATA ls_match LIKE LINE OF mt_matches.\n    DATA ls_submatch LIKE LINE OF ls_match-submatches.\n    READ TABLE mt_matches INDEX mv_index INTO ls_match.\n    READ TABLE ls_match-submatches INDEX index INTO ls_submatch.\n    IF sy-subrc = 0.\n      match = mv_text+ls_submatch-offset(ls_submatch-length).\n    ENDIF.\n  ENDMETHOD.\n\n  METHOD get_offset.\n    DATA ls_match LIKE LINE OF mt_matches.\n    READ TABLE mt_matches INDEX mv_index INTO ls_match.\n    offset = ls_match-offset.\n  ENDMETHOD.\n\n  METHOD get_length.\n    DATA ls_match LIKE LINE OF mt_matches.\n    READ TABLE mt_matches INDEX mv_index INTO ls_match.\n    length = ls_match-length.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_REGEX', 'CLASS cl_abap_regex DEFINITION PUBLIC.\n\n  PUBLIC SECTION.\n    METHODS constructor\n      IMPORTING\n        pattern     TYPE clike\n        ignore_case TYPE abap_bool.\n\n    METHODS create_matcher\n      IMPORTING\n        text              TYPE clike\n      RETURNING\n        VALUE(ro_matcher) TYPE REF TO cl_abap_matcher.\n\n    CLASS-METHODS create_pcre\n      IMPORTING\n        pattern      TYPE clike\n        ignore_case  TYPE abap_bool DEFAULT abap_false\n      RETURNING\n        VALUE(regex) TYPE REF TO cl_abap_regex.\n\n  PRIVATE SECTION.\n    DATA mv_pattern     TYPE string.\n    DATA mv_ignore_case TYPE abap_bool.\n\nENDCLASS.\n\nCLASS cl_abap_regex IMPLEMENTATION.\n\n  METHOD constructor.\n    mv_pattern = pattern.\n    mv_ignore_case = ignore_case.\n  ENDMETHOD.\n\n  METHOD create_pcre.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD create_matcher.\n    CREATE OBJECT ro_matcher\n      EXPORTING\n        pattern     = mv_pattern\n        ignore_case = mv_ignore_case\n        text        = text.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_CLASSDESCR', 'CLASS cl_abap_classdescr DEFINITION PUBLIC INHERITING FROM cl_abap_objectdescr.\n  PUBLIC SECTION.\n    CLASS-METHODS get_class_name\n      IMPORTING\n        p_object TYPE REF TO object\n      RETURNING\n        VALUE(p_name) TYPE abap_abstypename.\nENDCLASS.\n\nCLASS cl_abap_classdescr IMPLEMENTATION.\n  METHOD get_class_name.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_COMPLEXDESCR', 'CLASS cl_abap_complexdescr DEFINITION PUBLIC INHERITING FROM cl_abap_datadescr.\n  PUBLIC SECTION.\nENDCLASS.\n\nCLASS cl_abap_complexdescr IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_DATADESCR', 'CLASS cl_abap_datadescr DEFINITION PUBLIC INHERITING FROM cl_abap_typedescr.\n  PUBLIC SECTION.\n    CLASS-METHODS get_data_type_kind\n      IMPORTING\n        p_data             TYPE data\n      RETURNING\n        VALUE(p_type_kind) TYPE abap_typekind.\nENDCLASS.\n\nCLASS cl_abap_datadescr IMPLEMENTATION.\n\n  METHOD get_data_type_kind.\n    DATA descr TYPE REF TO cl_abap_typedescr.\n    descr = cl_abap_typedescr=>describe_by_data( p_data ).\n    p_type_kind = descr->type_kind.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_ELEMDESCR', 'CLASS cl_abap_elemdescr DEFINITION PUBLIC INHERITING FROM cl_abap_datadescr.\n  PUBLIC SECTION.\n    TYPES:\n      BEGIN OF fixvalue,\n        low        TYPE c LENGTH 10,\n        high       TYPE c LENGTH 10,\n        option     TYPE c LENGTH 2,\n        ddlanguage TYPE c,\n        ddtext     TYPE c LENGTH 60,\n      END OF fixvalue.\n    TYPES fixvalues TYPE STANDARD TABLE OF fixvalue WITH DEFAULT KEY.\n\n    DATA output_length TYPE i READ-ONLY.\n    DATA edit_mask TYPE abap_editmask READ-ONLY.\n\n    METHODS get_ddic_fixed_values\n      RETURNING\n        VALUE(p_fixed_values) TYPE fixvalues.\n\n    METHODS get_ddic_field\n      IMPORTING\n        p_langu TYPE sy-langu DEFAULT sy-langu\n      RETURNING\n        VALUE(p_flddescr) TYPE dfies\n      EXCEPTIONS\n        not_found\n        no_ddic_type.\n\n    CLASS-METHODS get_i RETURNING VALUE(r_result) TYPE REF TO cl_abap_elemdescr.\n    CLASS-METHODS get_f RETURNING VALUE(r_result) TYPE REF TO cl_abap_elemdescr.\n    CLASS-METHODS get_d RETURNING VALUE(r_result) TYPE REF TO cl_abap_elemdescr.\n    CLASS-METHODS get_t RETURNING VALUE(r_result) TYPE REF TO cl_abap_elemdescr.\n\nENDCLASS.\n\nCLASS cl_abap_elemdescr IMPLEMENTATION.\n\n  METHOD get_ddic_field.\n    p_flddescr-tabname  = absolute_name.\n    p_flddescr-inttype  = type_kind.\n    p_flddescr-langu    = sy-langu.\n    p_flddescr-position = 1.\n    p_flddescr-leng     = length.\n    p_flddescr-decimals = decimals.\n* todo, dfies-convexit\n  ENDMETHOD.\n\n  METHOD get_i.\n    DATA foo TYPE i.\n    r_result ?= cl_abap_typedescr=>describe_by_data( foo ).\n  ENDMETHOD.\n\n  METHOD get_f.\n    DATA foo TYPE f.\n    r_result ?= cl_abap_typedescr=>describe_by_data( foo ).\n  ENDMETHOD.\n\n  METHOD get_d.\n    DATA foo TYPE d.\n    r_result ?= cl_abap_typedescr=>describe_by_data( foo ).\n  ENDMETHOD.\n\n  METHOD get_t.\n    DATA foo TYPE t.\n    r_result ?= cl_abap_typedescr=>describe_by_data( foo ).\n  ENDMETHOD.\n\n  METHOD get_ddic_fixed_values.\n\n    DATA lv_dummy TYPE string.\n    DATA lv_name  TYPE string.\n    DATA ls_row   LIKE LINE OF p_fixed_values.\n\n    SPLIT absolute_name AT ''='' INTO lv_dummy lv_name.\n\n    WRITE ''@KERNEL for (const f of abap.DDIC[lv_name.get()]?.fixedValues || []) {''.\n    CLEAR ls_row.\n    WRITE ''@KERNEL   ls_row.get().low.set(f.low || \"\");''.\n    WRITE ''@KERNEL   ls_row.get().high.set(f.high || \"\");''.\n    WRITE ''@KERNEL   ls_row.get().option.set(f.option || \"\");''.\n    WRITE ''@KERNEL   ls_row.get().ddlanguage.set(f.ddlanguage || \"\");''.\n    WRITE ''@KERNEL   ls_row.get().ddtext.set(f.ddtext || \"\");''.\n    APPEND ls_row TO p_fixed_values.\n    WRITE ''@KERNEL }''.\n\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_ENUMDESCR', 'CLASS cl_abap_enumdescr DEFINITION PUBLIC INHERITING FROM cl_abap_elemdescr.\n  PUBLIC SECTION.\n    TYPES: BEGIN OF member,\n             name  TYPE c LENGTH 30,\n             value TYPE string,\n           END OF member.\n    TYPES member_table TYPE STANDARD TABLE OF member WITH KEY name.\n    DATA members TYPE member_table READ-ONLY.\nENDCLASS.\n\nCLASS cl_abap_enumdescr IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_INTFDESCR', 'CLASS cl_abap_intfdescr DEFINITION PUBLIC INHERITING FROM cl_abap_objectdescr.\n  PUBLIC SECTION.\nENDCLASS.\n\nCLASS cl_abap_intfdescr IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_OBJECTDESCR', 'CLASS cl_abap_objectdescr DEFINITION PUBLIC INHERITING FROM cl_abap_typedescr.\n  PUBLIC SECTION.\n    METHODS get_attribute_type\n      IMPORTING\n        p_name TYPE any\n      RETURNING\n        VALUE(p_descr_ref) TYPE REF TO cl_abap_datadescr.\n\n    CONSTANTS changing TYPE abap_parmkind VALUE ''C''.\n    CONSTANTS exporting TYPE abap_parmkind VALUE ''E''.\n    CONSTANTS importing TYPE abap_parmkind VALUE ''I''.\n    CONSTANTS receiving TYPE abap_parmkind VALUE ''R''.\n    CONSTANTS returning TYPE abap_parmkind VALUE ''R''.\n\n    CONSTANTS private_ TYPE abap_visibility VALUE ''I''.\n    CONSTANTS protected TYPE abap_visibility VALUE ''O''.\n    CONSTANTS public_ TYPE abap_visibility VALUE ''U''.\n\n  PROTECTED SECTION.\n    DATA mv_object_name TYPE string.\n    DATA mv_object_type TYPE string.\nENDCLASS.\n\nCLASS cl_abap_objectdescr IMPLEMENTATION.\n  METHOD get_attribute_type.\n    DATA lv_name TYPE string.\n    DATA l_sub   TYPE string.\n    DATA l_any   TYPE string.\n\n    lv_name = p_name.\n\n    WRITE ''@KERNEL let foo = abap.Classes[this.mv_object_name.get()];''.\n\n    CONCATENATE mv_object_name ''$'' lv_name INTO l_sub.\n    l_sub = to_lower( l_sub ).\n\n    \" note that the typing here is misused\n    WRITE ''@KERNEL l_any = foo[l_sub.get()];''.\n\n    p_descr_ref ?= describe_by_data( l_any ).\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_REFDESCR', 'CLASS cl_abap_refdescr DEFINITION PUBLIC INHERITING FROM cl_abap_datadescr.\n  PUBLIC SECTION.\n    METHODS get_referenced_type RETURNING VALUE(type) TYPE REF TO cl_abap_typedescr.\nENDCLASS.\n\nCLASS cl_abap_refdescr IMPLEMENTATION.\n  METHOD get_referenced_type.\n    CREATE OBJECT type.\n    type->absolute_name = ''CLASS_NAME_TODO''.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_STRUCTDESCR', 'CLASS cl_abap_structdescr DEFINITION PUBLIC INHERITING FROM cl_abap_complexdescr.\n\n  PUBLIC SECTION.\n    METHODS\n      constructor\n        IMPORTING data TYPE any.\n\n    TYPES component TYPE abap_componentdescr.\n    TYPES component_table TYPE abap_component_tab.\n\n    METHODS\n      get_components\n        RETURNING\n          VALUE(rt_components) TYPE component_table.\n\n    METHODS:\n      get_ddic_field_list RETURNING VALUE(rt_components) TYPE ddfields,\n      is_ddic_type RETURNING VALUE(bool) TYPE abap_bool,\n      get_component_type\n        IMPORTING\n          p_name TYPE any\n        RETURNING\n          VALUE(p_descr_ref) TYPE REF TO cl_abap_datadescr\n        EXCEPTIONS\n          component_not_found\n          unsupported_input_type.\n\n    CLASS-METHODS create\n      IMPORTING\n        p_components TYPE component_table\n        p_strict     TYPE abap_bool OPTIONAL\n      RETURNING\n        VALUE(ref)   TYPE REF TO cl_abap_structdescr.\n\n    DATA components TYPE abap_compdescr_tab.\n    DATA struct_kind TYPE abap_structkind READ-ONLY.\n\n  PRIVATE SECTION.\n    TYPES: BEGIN OF ty_refs,\n             name TYPE string,\n             ref  TYPE REF TO cl_abap_datadescr,\n           END OF ty_refs.\n    DATA mt_refs TYPE STANDARD TABLE OF ty_refs.\nENDCLASS.\n\nCLASS cl_abap_structdescr IMPLEMENTATION.\n\n  METHOD create.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD get_ddic_field_list.\n\n    DATA lt_components TYPE component_table.\n    DATA ls_component  LIKE LINE OF lt_components.\n    DATA ls_return     LIKE LINE OF rt_components.\n    DATA lv_name       TYPE string.\n    DATA lv_keyfield   TYPE string.\n    DATA lo_elemdescr  TYPE REF TO cl_abap_elemdescr.\n    FIELD-SYMBOLS <component> LIKE LINE OF rt_components.\n\n    lt_components = get_components( ).\n\n    ASSERT absolute_name CP ''+TYPE=*''.\n    lv_name = absolute_name+6.\n\n    LOOP AT lt_components INTO ls_component.\n      CLEAR ls_return.\n      ls_return-tabname = lv_name.\n      ls_return-fieldname = ls_component-name.\n      IF ls_component-type->kind = cl_abap_typedescr=>kind_elem.\n        lo_elemdescr ?= ls_component-type.\n        ls_return-leng = lo_elemdescr->output_length.\n      ENDIF.\n* todo, fill more fields in ls_return\n      APPEND ls_return TO rt_components.\n    ENDLOOP.\n\n*    WRITE ''@KERNEL console.dir(abap.DDIC[lv_name.get()]?.keyFields);''.\n    WRITE ''@KERNEL for (const keyfield of abap.DDIC[lv_name.get()]?.keyFields || [] ) {''.\n    WRITE ''@KERNEL lv_keyfield.set(keyfield);''.\n*    WRITE ''@KERNEL console.dir(rt_components.array()[0].get());''.\n    READ TABLE rt_components ASSIGNING <component> WITH KEY fieldname = lv_keyfield.\n    ASSERT sy-subrc = 0.\n    <component>-keyflag = abap_true.\n    WRITE ''@KERNEL }''.\n*    ASSERT 1 = ''todo''.\n\n  ENDMETHOD.\n\n  METHOD is_ddic_type.\n    bool = ddic.\n  ENDMETHOD.\n\n  METHOD constructor.\n    DATA lv_name      TYPE string.\n    DATA ls_component LIKE LINE OF components.\n    DATA ls_ref       LIKE LINE OF mt_refs.\n    DATA lo_datadescr TYPE REF TO cl_abap_datadescr.\n\n    FIELD-SYMBOLS <fs> TYPE any.\n\n* todo, fail if input is not a structure?\n    WRITE ''@KERNEL for (const name of Object.keys(INPUT.data.value)) {''.\n    WRITE ''@KERNEL   lv_name.set(name.toUpperCase());''.\n    CLEAR ls_component.\n    ls_component-name = lv_name.\n    ASSIGN COMPONENT lv_name OF STRUCTURE data TO <fs>.\n    lo_datadescr ?= cl_abap_typedescr=>describe_by_data( <fs> ).\n    ls_component-type_kind = lo_datadescr->type_kind.\n    APPEND ls_component TO components.\n\n    ls_ref-name = lv_name.\n    ls_ref-ref = lo_datadescr.\n    APPEND ls_ref TO mt_refs.\n    WRITE ''@KERNEL }''.\n  ENDMETHOD.\n\n  METHOD get_components.\n    DATA ls_component LIKE LINE OF components.\n    DATA ret          LIKE LINE OF rt_components.\n    DATA ls_ref       LIKE LINE OF mt_refs.\n\n    LOOP AT components INTO ls_component.\n      CLEAR ret.\n      ret-name = ls_component-name.\n      READ TABLE mt_refs INTO ls_ref WITH KEY name = ls_component-name.\n      IF sy-subrc = 0.\n        ret-type = ls_ref-ref.\n        ret-type_kind = ret-type->type_kind.\n      ENDIF.\n      \" as_include type abap_bool,\n      \" suffix     type string,\n      APPEND ret TO rt_components.\n    ENDLOOP.\n  ENDMETHOD.\n\n  METHOD get_component_type.\n    DATA line LIKE LINE OF mt_refs.\n    READ TABLE mt_refs INTO line WITH KEY name = p_name.\n    IF sy-subrc <> 0.\n* todo, RAISE component_not_found, classic exceptions doesnt work with transpiler as of today\n      ASSERT 1 = ''todo''.\n    ELSE.\n      p_descr_ref = line-ref.\n    ENDIF.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_TABLEDESCR', 'CLASS cl_abap_tabledescr DEFINITION PUBLIC INHERITING FROM cl_abap_datadescr.\n  PUBLIC SECTION.\n    METHODS\n      constructor\n        IMPORTING data TYPE any.\n    METHODS get_table_line_type\n      RETURNING\n        VALUE(type) TYPE REF TO cl_abap_datadescr.\n    CLASS-METHODS get\n      IMPORTING type TYPE REF TO cl_abap_typedescr\n      RETURNING VALUE(val) TYPE REF TO cl_abap_tabledescr.\n    CLASS-METHODS get_with_keys\n      IMPORTING\n        p_line_type TYPE REF TO cl_abap_datadescr\n        p_keys TYPE any\n      RETURNING VALUE(val) TYPE REF TO cl_abap_tabledescr.\n    CLASS-METHODS create\n      IMPORTING type TYPE REF TO cl_abap_typedescr\n      RETURNING VALUE(ref) TYPE REF TO cl_abap_tabledescr.\n\n    DATA table_kind TYPE c LENGTH 1.\n    DATA has_unique_key TYPE abap_bool READ-ONLY.\n\n    CONSTANTS tablekind_any TYPE c LENGTH 1 VALUE ''A''.\n    CONSTANTS tablekind_std TYPE c LENGTH 1 VALUE ''S''.\n    CONSTANTS tablekind_index TYPE c LENGTH 1 VALUE ''I''.\n    CONSTANTS tablekind_hashed TYPE c LENGTH 1 VALUE ''H''.\n    CONSTANTS tablekind_sorted TYPE c LENGTH 1 VALUE ''O''.\n    CONSTANTS keydefkind_default TYPE c LENGTH 1 VALUE ''D''.\n    CONSTANTS keydefkind_tableline TYPE c LENGTH 1 VALUE ''L''.\n    CONSTANTS keydefkind_user TYPE c LENGTH 1 VALUE ''U''.\n    CONSTANTS keydefkind_empty TYPE c LENGTH 1 VALUE ''E''.\n\n  PRIVATE SECTION.\n    DATA lo_type TYPE REF TO cl_abap_typedescr.\nENDCLASS.\n\nCLASS cl_abap_tabledescr IMPLEMENTATION.\n  METHOD create.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD get_with_keys.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD get.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD constructor.\n    DATA lv_dummy TYPE i.\n    DATA lv_flag TYPE abap_bool.\n*    WRITE ''@KERNEL console.dir(data);''.\n\n    WRITE ''@KERNEL lv_flag.set(data.getOptions().isUnique === true ? \"X\" : \"\");''.\n    has_unique_key = lv_flag.\n\n    WRITE ''@KERNEL lv_dummy = data.getRowType();''.\n    lo_type = cl_abap_typedescr=>describe_by_data( lv_dummy ).\n  ENDMETHOD.\n\n  METHOD get_table_line_type.\n    type ?= lo_type.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_TYPEDESCR', 'CLASS cl_abap_typedescr DEFINITION PUBLIC.\n* todo, this class should be ABSTRACT\n  PUBLIC SECTION.\n    CLASS-METHODS\n      describe_by_data\n        IMPORTING p_data TYPE any\n        RETURNING VALUE(type) TYPE REF TO cl_abap_typedescr.\n    CLASS-METHODS\n      describe_by_name\n        IMPORTING p_name TYPE clike\n        RETURNING VALUE(type) TYPE REF TO cl_abap_typedescr.\n    CLASS-METHODS\n      describe_by_data_ref\n        IMPORTING data TYPE REF TO data\n        RETURNING VALUE(type) TYPE REF TO cl_abap_typedescr.\n    CLASS-METHODS\n      describe_by_object_ref\n        IMPORTING data TYPE REF TO object\n        RETURNING VALUE(type) TYPE REF TO cl_abap_typedescr.\n\n    METHODS\n      get_relative_name\n        RETURNING\n          VALUE(name) TYPE string.\n    METHODS\n      is_ddic_type\n        RETURNING\n          VALUE(p_abap_bool) TYPE abap_bool.\n\n    DATA type_kind     TYPE abap_typekind.\n    DATA kind          TYPE c LENGTH 1.\n    DATA ddic          TYPE abap_bool.\n    DATA length        TYPE i.\n    DATA decimals      TYPE i.\n    DATA absolute_name TYPE string.\n    DATA relative_name TYPE string.\n\n    CONSTANTS typekind_any TYPE abap_typekind VALUE ''~''.\n    CONSTANTS typekind_char TYPE abap_typekind VALUE ''C''.\n    CONSTANTS typekind_class TYPE abap_typekind VALUE ''*''.\n    CONSTANTS typekind_intf TYPE abap_typekind VALUE ''+''.\n    CONSTANTS typekind_clike TYPE abap_typekind VALUE ''&''.\n    CONSTANTS typekind_csequence TYPE abap_typekind VALUE ''?''.\n    CONSTANTS typekind_date TYPE abap_typekind VALUE ''D''.\n    CONSTANTS typekind_decfloat TYPE abap_typekind VALUE ''/''.\n    CONSTANTS typekind_decfloat16 TYPE abap_typekind VALUE ''a''.\n    CONSTANTS typekind_decfloat34 TYPE abap_typekind VALUE ''e''.\n    CONSTANTS typekind_dref TYPE abap_typekind VALUE ''l''.\n    CONSTANTS typekind_enum TYPE abap_typekind VALUE ''k''.\n    CONSTANTS typekind_float TYPE abap_typekind VALUE ''F''.\n    CONSTANTS typekind_hex TYPE abap_typekind VALUE ''X''.\n    CONSTANTS typekind_int TYPE abap_typekind VALUE ''I''.\n    CONSTANTS typekind_int1 TYPE abap_typekind VALUE ''b''.\n    CONSTANTS typekind_int2 TYPE abap_typekind VALUE ''s''.\n    CONSTANTS typekind_int8 TYPE abap_typekind VALUE ''8''.\n    CONSTANTS typekind_num TYPE abap_typekind VALUE ''N''.\n    CONSTANTS typekind_numeric TYPE abap_typekind VALUE ''%''.\n    CONSTANTS typekind_oref TYPE abap_typekind VALUE ''r''.\n    CONSTANTS typekind_packed TYPE abap_typekind VALUE ''P''.\n    CONSTANTS typekind_string TYPE abap_typekind VALUE ''g''.\n    CONSTANTS typekind_struct1 TYPE abap_typekind VALUE ''u''.\n    CONSTANTS typekind_struct2 TYPE abap_typekind VALUE ''v''.\n    CONSTANTS typekind_table TYPE abap_typekind VALUE ''h''.\n    CONSTANTS typekind_time TYPE abap_typekind VALUE ''T''.\n    CONSTANTS typekind_utclong TYPE abap_typekind VALUE ''p''.\n    CONSTANTS typekind_w TYPE abap_typekind VALUE ''w''.\n    CONSTANTS typekind_xstring TYPE abap_typekind VALUE ''y''.\n\n    CONSTANTS kind_elem   TYPE c LENGTH 1 VALUE ''E''.\n    CONSTANTS kind_struct TYPE c LENGTH 1 VALUE ''S''.\n    CONSTANTS kind_table  TYPE c LENGTH 1 VALUE ''T''.\n    CONSTANTS kind_ref    TYPE c LENGTH 1 VALUE ''R''.\n    CONSTANTS kind_class  TYPE c LENGTH 1 VALUE ''C''.\n    CONSTANTS kind_intf   TYPE c LENGTH 1 VALUE ''I''.\nENDCLASS.\n\nCLASS cl_abap_typedescr IMPLEMENTATION.\n\n  METHOD describe_by_name.\n    DATA ref     TYPE REF TO data.\n    DATA objectdescr TYPE REF TO cl_abap_objectdescr.\n    DATA oo_type TYPE string.\n\n    WRITE ''@KERNEL oo_type.set(abap.Classes[p_name.get().toUpperCase()]?.INTERNAL_TYPE || \"\");''.\n\n    CASE oo_type.\n      WHEN ''INTF''.\n        CREATE OBJECT type TYPE cl_abap_intfdescr.\n        type->type_kind = typekind_intf.\n        type->kind = kind_intf.\n        objectdescr ?= type.\n        objectdescr->mv_object_name = to_upper( p_name ). \" todo, this should give syntax error, as they are not friends\n        objectdescr->mv_object_type = oo_type. \" todo, this should give syntax error, as they are not friends\n      WHEN ''CLAS''.\n        CREATE OBJECT type TYPE cl_abap_classdescr.\n        type->type_kind = typekind_class.\n        type->kind = kind_class.\n        objectdescr ?= type.\n        objectdescr->mv_object_name = to_upper( p_name ). \" todo, this should give syntax error, as they are not friends\n        objectdescr->mv_object_type = oo_type. \" todo, this should give syntax error, as they are not friends\n      WHEN OTHERS.\n        CREATE DATA ref TYPE (p_name).\n        type = describe_by_data_ref( ref ).\n    ENDCASE.\n  ENDMETHOD.\n\n  METHOD get_relative_name.\n    name = relative_name.\n  ENDMETHOD.\n\n  METHOD is_ddic_type.\n    p_abap_bool = ddic.\n  ENDMETHOD.\n\n  METHOD describe_by_data_ref.\n    FIELD-SYMBOLS <ref> TYPE any.\n    ASSIGN data->* TO <ref>.\n    type = describe_by_data( <ref> ).\n  ENDMETHOD.\n\n  METHOD describe_by_object_ref.\n    CREATE OBJECT type TYPE cl_abap_classdescr.\n    type->type_kind = typekind_class.\n    type->kind = kind_class.\n    type->relative_name = ''CLASS_NAME_TODO''.\n    type->absolute_name = ''CLASS_NAME_TODO''.\n  ENDMETHOD.\n\n  METHOD describe_by_data.\n\n    DATA lv_name   TYPE string.\n    DATA lv_prefix TYPE string.\n    DATA lv_length TYPE i.\n    DATA lo_elem   TYPE REF TO cl_abap_elemdescr.\n    WRITE ''@KERNEL lv_name.set(p_data.constructor.name);''.\n    WRITE ''@KERNEL lv_length.set(p_data.getLength ? p_data.getLength() : 0);''.\n\n* These are the constructor names from the js runtime\n    CASE lv_name.\n      WHEN ''Integer''.\n        CREATE OBJECT type TYPE cl_abap_elemdescr.\n        type->type_kind = typekind_int.\n        type->kind = kind_elem.\n        type->length = 4.\n        lo_elem ?= type.\n        lo_elem->output_length = 11.\n      WHEN ''Numc''.\n        CREATE OBJECT type TYPE cl_abap_elemdescr.\n        type->type_kind = typekind_num.\n        type->kind = kind_elem.\n        type->length = lv_length * 2.\n        lo_elem ?= type.\n        lo_elem->output_length = lv_length.\n      WHEN ''Hex''.\n        CREATE OBJECT type TYPE cl_abap_elemdescr.\n        type->type_kind = typekind_hex.\n        type->kind = kind_elem.\n        type->length = lv_length.\n        lo_elem ?= type.\n        lo_elem->output_length = lv_length * 2.\n      WHEN ''Date''.\n        CREATE OBJECT type TYPE cl_abap_elemdescr.\n        type->type_kind = typekind_date.\n        type->kind = kind_elem.\n        type->length = 16.\n        lo_elem ?= type.\n        lo_elem->output_length = 8.\n      WHEN ''Packed''.\n        CREATE OBJECT type TYPE cl_abap_elemdescr.\n        type->type_kind = typekind_packed.\n        type->kind = kind_elem.\n        type->length = lv_length.\n      WHEN ''Time''.\n        CREATE OBJECT type TYPE cl_abap_elemdescr.\n        type->type_kind = typekind_time.\n        type->kind = kind_elem.\n        type->length = 12.\n        lo_elem ?= type.\n        lo_elem->output_length = 6.\n      WHEN ''Float''.\n        CREATE OBJECT type TYPE cl_abap_elemdescr.\n        type->type_kind = typekind_float.\n        type->kind = kind_elem.\n      WHEN ''Structure''.\n        CREATE OBJECT type TYPE cl_abap_structdescr\n          EXPORTING\n            data = p_data.\n        type->type_kind = typekind_struct2.\n        type->kind = kind_struct.\n      WHEN ''Table''.\n        CREATE OBJECT type TYPE cl_abap_tabledescr\n          EXPORTING\n            data = p_data.\n        type->type_kind = typekind_table.\n        type->kind = kind_table.\n      WHEN ''XString''.\n        CREATE OBJECT type TYPE cl_abap_elemdescr.\n        type->type_kind = typekind_xstring.\n        type->kind = kind_elem.\n        type->length = 8.\n      WHEN ''String''.\n        CREATE OBJECT type TYPE cl_abap_elemdescr.\n        type->type_kind = typekind_string.\n        type->kind = kind_elem.\n        type->length = 8.\n      WHEN ''Character''.\n        CREATE OBJECT type TYPE cl_abap_elemdescr.\n        type->type_kind = typekind_char.\n        type->kind = kind_elem.\n        type->length = lv_length * 2.\n        lo_elem ?= type.\n        lo_elem->output_length = lv_length.\n      WHEN ''FieldSymbol''.\n        WRITE ''@KERNEL lv_name = p_data.getPointer();''.\n        type = describe_by_data( lv_name ).\n        RETURN.\n      WHEN ''ABAPObject''.\n        CREATE OBJECT type TYPE cl_abap_refdescr.\n        type->type_kind = typekind_oref.\n        type->kind = kind_ref.\n      WHEN ''UTCLong''.\n        CREATE OBJECT type TYPE cl_abap_elemdescr.\n        type->type_kind = typekind_utclong.\n        type->kind = kind_elem.\n      WHEN ''DataReference''.\n        CREATE OBJECT type TYPE cl_abap_refdescr.\n        type->type_kind = typekind_dref.\n        type->kind = kind_ref.\n      WHEN OTHERS.\n        WRITE / lv_name.\n        ASSERT 1 = ''todo_cl_abap_typedescr''.\n    ENDCASE.\n\n    WRITE ''@KERNEL if(p_data.getQualifiedName && p_data.getQualifiedName() !== undefined) type.get().absolute_name.set(p_data.getQualifiedName());''.\n\n* this is not completely correct, local type names and ddic names might overlap, but will work for now,\n    WRITE ''@KERNEL if(abap.DDIC[type.get().absolute_name.get().toUpperCase()]) { type.get().ddic.set(\"X\"); }''.\n\n    IF type->absolute_name = ''ABAP_BOOL''.\n      type->relative_name = ''ABAP_BOOL''.\n      type->absolute_name = ''\\\\TYPE-POOL=ABAP\\\\TYPE=ABAP_BOOL''.\n    ELSEIF type->absolute_name IS INITIAL.\n      type->absolute_name = ''ABSOLUTE_NAME_TODO''.\n    ELSEIF type->absolute_name CS ''=>''.\n      SPLIT type->absolute_name AT ''=>'' INTO lv_prefix type->absolute_name.\n      type->relative_name = type->absolute_name.\n      type->absolute_name = ''\\\\CLASS='' && lv_prefix && ''\\\\TYPE='' && type->absolute_name.\n    ELSE.\n      type->relative_name = type->absolute_name.\n      type->absolute_name = ''\\\\TYPE='' && type->absolute_name.\n    ENDIF.\n\n    IF type->absolute_name = ''\\\\TYPE=sy-langu'' OR type->absolute_name CP ''*ty_original_language''.\n* todo, this is a hack for https://github.com/SAP/abap-file-formats-tools\n      lo_elem->edit_mask = ''==LANGU''.\n    ENDIF.\n\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SHM_AREA', 'CLASS cl_shm_area DEFINITION PUBLIC INHERITING FROM cx_shm_general_error ABSTRACT.\n  PUBLIC SECTION.\n    CONSTANTS default_instance TYPE shm_inst_name VALUE ''$DEFAULT_INSTANCE$''.\n    CONSTANTS invocation_mode_explicit TYPE shm_constr_invocation_mode VALUE 319200300.\n    CONSTANTS life_context_appserver TYPE shm_life_context VALUE 109200001.\n    CONSTANTS attach_mode_default TYPE shm_attach_mode VALUE 1302197000.\n    CONSTANTS attach_mode_wait TYPE shm_attach_mode VALUE 1302197002.\n    CONSTANTS affect_local_server TYPE shm_affect_server VALUE 281119720.\n\n    DATA properties TYPE shm_properties READ-ONLY.\n    DATA inst_name TYPE shm_inst_name READ-ONLY.\n    DATA client TYPE mandt READ-ONLY.\n\n    METHODS detach_commit\n      RAISING\n        cx_shm_wrong_handle\n        cx_shm_already_detached\n        cx_shm_secondary_commit\n        cx_shm_event_execution_failed\n        cx_shm_completion_error.\n\n    METHODS detach\n      RAISING\n        cx_shm_wrong_handle\n        cx_shm_already_detached.\n\n    METHODS get_root ABSTRACT\n      RETURNING\n        VALUE(root) TYPE REF TO object\n      RAISING\n        cx_shm_already_detached.\n\n    METHODS is_valid\n      RETURNING\n        VALUE(valid) TYPE abap_bool.\n\n  PROTECTED SECTION.\n    DATA inst_trace_active TYPE abap_bool VALUE abap_false.\n    DATA inst_trace_service TYPE REF TO if_shm_trace.\n    DATA _lock TYPE %_c_pointer.\n    CONSTANTS attach_mode_wait_2nd_try TYPE shm_attach_mode VALUE 1302197003.\n\n    METHODS _attach_read71\n      IMPORTING\n        sneak_mode   TYPE abap_bool DEFAULT abap_false\n        area_name    TYPE shm_area_name\n        life_context TYPE shm_life_context\n      EXPORTING\n        root         TYPE REF TO object\n      RAISING\n        cx_shm_inconsistent\n        cx_shm_no_active_version\n        cx_shm_read_lock_active\n        cx_shm_exclusive_lock_active\n        cx_shm_parameter_error\n        cx_shm_change_lock_active.\n\n    METHODS _attach_update70\n      IMPORTING\n        area_name TYPE shm_area_name\n        mode      TYPE shm_attach_mode\n      EXPORTING\n        root      TYPE REF TO object\n      CHANGING\n        wait_time TYPE i OPTIONAL\n      RAISING\n        cx_shm_inconsistent\n        cx_shm_exclusive_lock_active\n        cx_shm_change_lock_active\n        cx_shm_version_limit_exceeded\n        cx_shm_no_active_version\n        cx_shm_parameter_error\n        cx_shm_pending_lock_removed.\n\n    METHODS _attach_write70\n      IMPORTING\n        area_name TYPE shm_area_name\n        mode      TYPE shm_attach_mode\n      EXPORTING\n        root      TYPE REF TO object\n      CHANGING\n        wait_time TYPE i OPTIONAL\n      RAISING\n        cx_shm_version_limit_exceeded\n        cx_shm_exclusive_lock_active\n        cx_shm_change_lock_active\n        cx_shm_parameter_error\n        cx_shm_pending_lock_removed.\n\n    CLASS-METHODS _invalidate_area71\n      IMPORTING\n        area_name TYPE shm_area_name\n        client TYPE shm_client\n        client_supplied TYPE abap_bool DEFAULT abap_false\n        transactional TYPE abap_bool DEFAULT abap_false\n        client_dependent TYPE abap_bool DEFAULT abap_false\n        terminate_changer TYPE abap_bool\n        affect_server TYPE shm_affect_server\n        life_context TYPE shm_life_context DEFAULT life_context_appserver\n      RETURNING\n        VALUE(rc) TYPE shm_rc\n      RAISING\n        cx_shm_parameter_error.\n\n    CLASS-METHODS _invalidate_instance71\n      IMPORTING\n        area_name TYPE shm_area_name\n        inst_name TYPE shm_inst_name\n        client TYPE shm_client\n        client_supplied TYPE abap_bool DEFAULT abap_false\n        transactional TYPE abap_bool DEFAULT abap_false\n        client_dependent TYPE abap_bool DEFAULT abap_false\n        terminate_changer TYPE abap_bool\n        affect_server TYPE shm_affect_server\n        life_context TYPE shm_life_context DEFAULT life_context_appserver\n      RETURNING\n        VALUE(rc) TYPE shm_rc\n      RAISING\n        cx_shm_parameter_error.\n\n    METHODS _set_root\n      IMPORTING\n        root TYPE REF TO object\n      RAISING\n        cx_shm_wrong_handle\n        cx_shm_initial_reference.\n\n    CLASS-METHODS _detach_area71\n      IMPORTING\n        area_name        TYPE shm_area_name\n        client           TYPE shm_client\n        client_supplied  TYPE abap_bool\n        client_dependent TYPE abap_bool DEFAULT abap_false\n        life_context     TYPE shm_life_context\n      RETURNING\n        VALUE(rc)        TYPE shm_rc.\n\n    CLASS-METHODS _free_area71\n      IMPORTING\n        area_name TYPE shm_area_name\n        client TYPE shm_client\n        client_supplied TYPE abap_bool DEFAULT abap_false\n        transactional TYPE abap_bool DEFAULT abap_false\n        client_dependent TYPE abap_bool DEFAULT abap_false\n        terminate_changer TYPE abap_bool\n        affect_server TYPE shm_affect_server\n        life_context TYPE shm_life_context DEFAULT life_context_appserver\n      RETURNING\n        VALUE(rc) TYPE shm_rc\n      RAISING\n        cx_shm_parameter_error.\n\n    CLASS-METHODS _get_instance_infos71\n      IMPORTING\n        area_name        TYPE shm_area_name\n        client           TYPE shm_client\n        client_supplied  TYPE abap_bool DEFAULT abap_false\n        client_dependent TYPE abap_bool DEFAULT abap_false\n        life_context     TYPE shm_life_context\n      RETURNING\n        VALUE(infos)     TYPE shm_inst_infos.\n\n    CLASS-METHODS _free_instance71\n      IMPORTING\n        area_name         TYPE shm_area_name\n        inst_name         TYPE shm_inst_name\n        client            TYPE shm_client\n        client_supplied   TYPE abap_bool DEFAULT abap_false\n        transactional     TYPE abap_bool DEFAULT abap_false\n        client_dependent  TYPE abap_bool DEFAULT abap_false\n        terminate_changer TYPE abap_bool\n        affect_server     TYPE shm_affect_server\n        life_context      TYPE shm_life_context DEFAULT life_context_appserver\n      RETURNING\n        VALUE(rc)         TYPE shm_rc\n      RAISING\n        cx_shm_parameter_error.\nENDCLASS.\n\nCLASS cl_shm_area IMPLEMENTATION.\n\n  METHOD is_valid.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD _free_instance71.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD detach_commit.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD detach.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD _attach_read71.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD _get_instance_infos71.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD _detach_area71.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD _free_area71.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD _set_root.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD _invalidate_instance71.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD _invalidate_area71.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD _attach_update70.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD _attach_write70.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SHM_SERVICE', 'CLASS cl_shm_service DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS initialize\n      IMPORTING\n        area_name  TYPE shm_area_name\n        client     TYPE shma_client OPTIONAL\n      EXPORTING\n        attributes TYPE shma_attributes.\n\n    CLASS-METHODS get_auto_build_class_name\n      IMPORTING\n        area_name TYPE shm_area_name\n      RETURNING\n        VALUE(auto_build_class_name) TYPE shm_auto_build_class_name\n      RAISING\n        cx_shma_not_configured\n        cx_shma_inconsistent.\n\n    CLASS-METHODS trace_get_service\n      IMPORTING\n        !area_name TYPE shm_area_name OPTIONAL\n      RETURNING\n        VALUE(trace_service) TYPE REF TO if_shm_trace.\n\n    CLASS-METHODS trace_is_variant_active\n      IMPORTING\n        service_name     TYPE shmm_trc_variant_name\n      RETURNING\n        VALUE(is_active) TYPE abap_bool.\n\nENDCLASS.\n\nCLASS cl_shm_service IMPLEMENTATION.\n\n  METHOD initialize.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD get_auto_build_class_name.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD trace_get_service.\n* dont dump, this method is called from area CLASS_CONSTRUCTORs\n    RETURN.\n  ENDMETHOD.\n\n  METHOD trace_is_variant_active.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_ALREADY_DETACHED', 'CLASS cx_shm_already_detached DEFINITION PUBLIC INHERITING FROM cx_shm_general_error.\n\nENDCLASS.\n\nCLASS cx_shm_already_detached IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_ATTACH_ERROR', 'CLASS cx_shm_attach_error DEFINITION PUBLIC INHERITING FROM cx_shm_error.\n\nENDCLASS.\n\nCLASS cx_shm_attach_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_BUILD_FAILED', 'CLASS cx_shm_build_failed DEFINITION PUBLIC INHERITING FROM cx_shm_general_error.\n\nENDCLASS.\n\nCLASS cx_shm_build_failed IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_CHANGE_LOCK_ACTIVE', 'CLASS cx_shm_change_lock_active DEFINITION PUBLIC INHERITING FROM cx_shm_attach_error.\n\nENDCLASS.\n\nCLASS cx_shm_change_lock_active IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_COMPLETION_ERROR', 'CLASS cx_shm_completion_error DEFINITION PUBLIC INHERITING FROM cx_shm_detach_error.\n\nENDCLASS.\n\nCLASS cx_shm_completion_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_DETACH_ERROR', 'CLASS cx_shm_detach_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_shm_detach_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_ERROR', 'CLASS cx_shm_error DEFINITION PUBLIC INHERITING FROM cx_static_check.\n\nENDCLASS.\n\nCLASS cx_shm_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_EVENT_EXECUTION_FAILED', 'CLASS cx_shm_event_execution_failed DEFINITION PUBLIC INHERITING FROM cx_shm_completion_error.\n\nENDCLASS.\n\nCLASS cx_shm_event_execution_failed IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_EXCLUSIVE_LOCK_ACTIVE', 'CLASS cx_shm_exclusive_lock_active DEFINITION PUBLIC INHERITING FROM cx_shm_attach_error.\n\nENDCLASS.\n\nCLASS cx_shm_exclusive_lock_active IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_GENERAL_ERROR', 'CLASS cx_shm_general_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_shm_general_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_INCONSISTENT', 'CLASS cx_shm_inconsistent DEFINITION PUBLIC INHERITING FROM cx_shm_attach_error.\n\nENDCLASS.\n\nCLASS cx_shm_inconsistent IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_INITIAL_REFERENCE', 'CLASS cx_shm_initial_reference DEFINITION PUBLIC INHERITING FROM cx_shm_general_error.\n\nENDCLASS.\n\nCLASS cx_shm_initial_reference IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_NO_ACTIVE_VERSION', 'CLASS cx_shm_no_active_version DEFINITION PUBLIC INHERITING FROM cx_shm_attach_error.\n\nENDCLASS.\n\nCLASS cx_shm_no_active_version IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_PARAMETER_ERROR', 'CLASS cx_shm_parameter_error DEFINITION PUBLIC INHERITING FROM cx_shm_general_error.\n\nENDCLASS.\n\nCLASS cx_shm_parameter_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_PENDING_LOCK_REMOVED', 'CLASS cx_shm_pending_lock_removed DEFINITION PUBLIC INHERITING FROM cx_shm_attach_error.\n\nENDCLASS.\n\nCLASS cx_shm_pending_lock_removed IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_READ_LOCK_ACTIVE', 'CLASS cx_shm_read_lock_active DEFINITION PUBLIC INHERITING FROM cx_shm_attach_error.\n\nENDCLASS.\n\nCLASS cx_shm_read_lock_active IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_SECONDARY_COMMIT', 'CLASS cx_shm_secondary_commit DEFINITION PUBLIC INHERITING FROM cx_shm_detach_error.\n\nENDCLASS.\n\nCLASS cx_shm_secondary_commit IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_VERSION_LIMIT_EXCEEDED', 'CLASS cx_shm_version_limit_exceeded DEFINITION PUBLIC INHERITING FROM cx_shm_attach_error.\n\nENDCLASS.\n\nCLASS cx_shm_version_limit_exceeded IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHM_WRONG_HANDLE', 'CLASS cx_shm_wrong_handle DEFINITION PUBLIC INHERITING FROM cx_shm_general_error.\n\nENDCLASS.\n\nCLASS cx_shm_wrong_handle IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHMA_DYNAMIC', 'CLASS cx_shma_dynamic DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_shma_dynamic IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHMA_INCONSISTENT', 'CLASS cx_shma_inconsistent DEFINITION PUBLIC INHERITING FROM cx_shma_dynamic.\n\nENDCLASS.\n\nCLASS cx_shma_inconsistent IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SHMA_NOT_CONFIGURED', 'CLASS cx_shma_not_configured DEFINITION PUBLIC INHERITING FROM cx_shma_dynamic.\n\nENDCLASS.\n\nCLASS cx_shma_not_configured IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SHM_BUILD_INSTANCE', 'INTERFACE if_shm_build_instance PUBLIC.\n  CLASS-METHODS build\n    IMPORTING\n      inst_name       TYPE shm_inst_name              DEFAULT cl_shm_area=>default_instance\n      invocation_mode TYPE shm_constr_invocation_mode DEFAULT cl_shm_area=>invocation_mode_explicit\n    RAISING\n      cx_shm_build_failed.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SHM_TRACE', 'INTERFACE if_shm_trace PUBLIC.\n\n  DATA: BEGIN OF variant,\n          def_name         TYPE shmm_trc_variant_name,\n          attach_for_upd   TYPE abap_bool,\n          attach_for_read  TYPE abap_bool,\n          free_area        TYPE abap_bool,\n          detach_area      TYPE abap_bool,\n          set_root         TYPE abap_bool,\n          invalidate_inst  TYPE abap_bool,\n          get_instance_inf TYPE abap_bool,\n          free_instance    TYPE abap_bool,\n          invalidate_area  TYPE abap_bool,\n          build            TYPE abap_bool,\n          attach_for_write TYPE abap_bool,\n          get_root         TYPE abap_bool,\n        END OF variant.\n\n  METHODS trin_attach_for_write\n    IMPORTING\n      area_name TYPE shm_area_name\n      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance\n      client    TYPE shm_client DEFAULT sy-mandt\n      mode      TYPE shm_attach_mode DEFAULT cl_shm_area=>attach_mode_default\n      wait_time TYPE i DEFAULT 0.\n\n  METHODS trcx_attach_for_write\n    IMPORTING\n      area_name TYPE shm_area_name\n      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance\n      client    TYPE shm_client DEFAULT sy-mandt\n      mode      TYPE shm_attach_mode DEFAULT cl_shm_area=>attach_mode_default\n      wait_time TYPE i DEFAULT 0\n      cx        TYPE REF TO cx_root.\n\n  METHODS trin_attach_for_update\n    IMPORTING\n      area_name TYPE shm_area_name\n      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance\n      client    TYPE shm_client DEFAULT sy-mandt\n      mode      TYPE shm_attach_mode DEFAULT cl_shm_area=>attach_mode_default\n      wait_time TYPE i DEFAULT 0.\n\n  METHODS trcx_attach_for_update\n    IMPORTING\n      area_name TYPE shm_area_name\n      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance\n      client    TYPE shm_client DEFAULT sy-mandt\n      mode      TYPE shm_attach_mode DEFAULT cl_shm_area=>attach_mode_default\n      wait_time TYPE i DEFAULT 0\n      cx        TYPE REF TO cx_root.\n\n  METHODS trin_attach_for_read\n    IMPORTING\n      area_name TYPE shm_area_name\n      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance\n      client    TYPE shm_client DEFAULT sy-mandt.\n\n  METHODS trcx_attach_for_read\n    IMPORTING\n      area_name TYPE shm_area_name\n      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance\n      client    TYPE shm_client DEFAULT sy-mandt\n      cx        TYPE REF TO cx_root.\n\n  METHODS trin_build\n    IMPORTING\n      area_name TYPE shm_area_name\n      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance.\n\n  METHODS trcx_build\n    IMPORTING\n      area_name TYPE shm_area_name\n      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance\n      cx TYPE REF TO cx_root.\n\n  METHODS trin_set_root\n    IMPORTING\n      area_name TYPE shm_area_name\n      inst_name TYPE shm_inst_name\n      root TYPE REF TO object.\n\n  METHODS trcx_set_root\n    IMPORTING\n      area_name TYPE shm_area_name\n      inst_name TYPE shm_inst_name\n      root TYPE REF TO object\n      cx TYPE REF TO cx_root.\n\n  METHODS trin_detach_area\n    IMPORTING\n      area_name TYPE shm_area_name\n      client TYPE shm_client DEFAULT sy-mandt\n      rc TYPE shm_rc.\n\n  METHODS trin_free_area\n    IMPORTING\n      area_name         TYPE shm_area_name\n      client            TYPE shm_client DEFAULT sy-mandt\n      terminate_changer TYPE abap_bool DEFAULT abap_true\n      affect_server     TYPE shm_affect_server OPTIONAL\n      rc                TYPE shm_rc.\n\n  METHODS trin_free_instance\n    IMPORTING\n      area_name TYPE shm_area_name\n      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance\n      client TYPE shm_client DEFAULT sy-mandt\n      terminate_changer TYPE abap_bool DEFAULT abap_true\n      affect_server TYPE shm_affect_server OPTIONAL\n      rc TYPE shm_rc.\n\n  METHODS trin_get_instance_infos\n    IMPORTING\n      area_name TYPE shm_area_name\n      inst_name TYPE shm_inst_name OPTIONAL\n      client TYPE shm_client DEFAULT sy-mandt\n      infos TYPE shm_inst_infos.\n\n  METHODS trin_invalidate_area\n    IMPORTING\n      area_name TYPE shm_area_name\n      client TYPE shm_client DEFAULT sy-mandt\n      rc TYPE shm_rc\n      affect_server TYPE shm_affect_server OPTIONAL\n      terminate_changer TYPE abap_bool DEFAULT abap_true.\n\n  METHODS trin_invalidate_instance\n    IMPORTING\n      area_name TYPE shm_area_name\n      inst_name TYPE shm_inst_name DEFAULT cl_shm_area=>default_instance\n      client TYPE shm_client DEFAULT sy-mandt\n      terminate_changer TYPE abap_bool DEFAULT abap_true\n      affect_server TYPE shm_affect_server OPTIONAL\n      rc TYPE shm_rc.\n\n  METHODS trin_get_root\n    IMPORTING\n      area_name TYPE shm_area_name.\n\n  METHODS trcx_get_root\n    IMPORTING\n      area_name TYPE shm_area_name\n      cx        TYPE REF TO cx_root.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SXML_STRING_READER', 'CLASS cl_sxml_string_reader DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS create\n      IMPORTING data TYPE xstring\n      RETURNING VALUE(reader) TYPE REF TO if_sxml_reader.\nENDCLASS.\n\nCLASS cl_sxml_string_reader IMPLEMENTATION.\n  METHOD create.\n    CREATE OBJECT reader TYPE lcl_reader\n      EXPORTING\n        iv_json = cl_abap_codepage=>convert_from( data ).\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SXML_STRING_WRITER', 'CLASS cl_sxml_string_writer DEFINITION PUBLIC FINAL CREATE PRIVATE.\n\n  PUBLIC SECTION.\n    INTERFACES if_sxml_writer.\n\n    METHODS constructor\n      IMPORTING\n        type TYPE if_sxml=>xml_stream_type.\n\n    METHODS get_output\n      RETURNING\n        VALUE(output) TYPE xstring.\n\n    CLASS-METHODS create\n      IMPORTING\n        type                     TYPE if_sxml=>xml_stream_type DEFAULT if_sxml=>co_xt_xml10\n        ignore_conversion_errors TYPE abap_bool DEFAULT abap_false\n        normalizing              TYPE abap_bool DEFAULT abap_false\n        no_empty_elements        TYPE abap_bool DEFAULT abap_false\n        encoding                 TYPE string DEFAULT ''UTF-8''\n        PREFERRED PARAMETER type\n      RETURNING\n        VALUE(writer) TYPE REF TO cl_sxml_string_writer\n      RAISING\n        cx_sxml_illegal_argument_error.\n\n  PRIVATE SECTION.\n    DATA mv_output TYPE xstring.\n    DATA mv_type TYPE if_sxml=>xml_stream_type.\n    DATA mt_stack TYPE STANDARD TABLE OF string WITH DEFAULT KEY.\n\n    METHODS append_text IMPORTING text TYPE string.\n    METHODS get_text RETURNING VALUE(text) TYPE string.\n\n* stack operations\n    METHODS peek RETURNING VALUE(rv_name) TYPE string.\n    METHODS remove RETURNING VALUE(rv_name) TYPE string.\nENDCLASS.\n\nCLASS cl_sxml_string_writer IMPLEMENTATION.\n\n  METHOD constructor.\n    mv_type = type.\n  ENDMETHOD.\n\n  METHOD create.\n    CREATE OBJECT writer\n      EXPORTING\n        type = type.\n  ENDMETHOD.\n\n  METHOD if_sxml_writer~set_option.\n    ASSERT 1 = ''todo''.\n  ENDMETHOD.\n\n  METHOD get_output.\n    output = mv_output.\n  ENDMETHOD.\n\n  METHOD append_text.\n    DATA append TYPE xstring.\n    append = cl_abap_conv_codepage=>create_out( )->convert( text ).\n    CONCATENATE mv_output append INTO mv_output IN BYTE MODE.\n  ENDMETHOD.\n\n  METHOD get_text.\n    text = cl_abap_conv_codepage=>create_in( )->convert( mv_output ).\n  ENDMETHOD.\n\n  METHOD if_sxml_writer~open_element.\n    DATA parent TYPE string.\n    parent = peek( ).\n\n    IF parent = ''array'' AND get_text( ) NP ''*[''.\n      append_text( '','' ).\n    ENDIF.\n    IF parent = ''object'' AND get_text( ) NP ''*{''.\n      append_text( '','' ).\n    ENDIF.\n\n    APPEND name TO mt_stack.\n    CASE name.\n      WHEN ''object''.\n        append_text( ''{'' ).\n      WHEN ''array''.\n        append_text( ''['' ).\n    ENDCASE.\n  ENDMETHOD.\n\n  METHOD remove.\n    DATA index TYPE i.\n    index = lines( mt_stack ).\n    READ TABLE mt_stack INDEX index INTO rv_name.\n    DELETE mt_stack INDEX index.\n  ENDMETHOD.\n\n  METHOD if_sxml_writer~close_element.\n    DATA name TYPE string.\n    name = remove( ).\n    CASE name.\n      WHEN ''object''.\n        append_text( ''}'' ).\n      WHEN ''array''.\n        append_text( '']'' ).\n    ENDCASE.\n  ENDMETHOD.\n\n  METHOD if_sxml_writer~write_attribute.\n    append_text( ''\"'' ).\n    append_text( value ).\n    append_text( ''\":'' ).\n  ENDMETHOD.\n\n  METHOD peek.\n    DATA index TYPE i.\n    index = lines( mt_stack ).\n    READ TABLE mt_stack INDEX index INTO rv_name.\n  ENDMETHOD.\n\n  METHOD if_sxml_writer~write_value.\n    DATA name TYPE string.\n    name = peek( ).\n    CASE name.\n      WHEN ''str''.\n        append_text( ''\"'' ).\n        append_text( condense( value ) ).\n        append_text( ''\"'' ).\n      WHEN ''num''.\n        append_text( condense( value ) ).\n      WHEN OTHERS.\n        WRITE ''@KERNEL console.dir(name);''.\n        ASSERT 1 = ''todo_if_sxml_writer_write_value''.\n    ENDCASE.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SXML_ERROR', 'CLASS cx_sxml_error DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n\nENDCLASS.\n\nCLASS cx_sxml_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SXML_ILLEGAL_ARGUMENT_ERROR', 'CLASS cx_sxml_illegal_argument_error DEFINITION PUBLIC INHERITING FROM cx_sxml_error.\n  PUBLIC SECTION.\nENDCLASS.\n\nCLASS cx_sxml_illegal_argument_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SXML_NAME_ERROR', 'CLASS cx_sxml_name_error DEFINITION PUBLIC INHERITING FROM cx_sxml_error.\n  PUBLIC SECTION.\nENDCLASS.\n\nCLASS cx_sxml_name_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SXML_PARSE_ERROR', 'CLASS cx_sxml_parse_error DEFINITION PUBLIC INHERITING FROM cx_sxml_error.\n  PUBLIC SECTION.\n    METHODS constructor IMPORTING xml_offset TYPE i.\n    DATA xml_offset TYPE i.\nENDCLASS.\n\nCLASS cx_sxml_parse_error IMPLEMENTATION.\n  METHOD constructor.\n    me->xml_offset = xml_offset.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_SXML_STATE_ERROR', 'CLASS cx_sxml_state_error DEFINITION PUBLIC INHERITING FROM cx_sxml_error.\n  PUBLIC SECTION.\nENDCLASS.\n\nCLASS cx_sxml_state_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXML', 'INTERFACE if_sxml PUBLIC.\n\n  TYPES xml_stream_type TYPE i.\n\n  CONSTANTS co_xt_xml10 TYPE xml_stream_type VALUE 1.\n  CONSTANTS co_xt_binary TYPE xml_stream_type VALUE 2.\n  CONSTANTS co_xt_xop TYPE xml_stream_type VALUE 3.\n  CONSTANTS co_xt_json TYPE xml_stream_type VALUE 4.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXML_ATTRIBUTE', 'INTERFACE if_sxml_attribute PUBLIC.\n  TYPES attributes TYPE STANDARD TABLE OF REF TO if_sxml_attribute WITH DEFAULT KEY.\n  DATA: BEGIN OF qname,\n          name TYPE string,\n        END OF qname.\n  DATA value_type TYPE if_sxml_value=>value_type.\n  METHODS get_value RETURNING VALUE(value) TYPE string.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXML_CLOSE_ELEMENT', 'INTERFACE if_sxml_close_element PUBLIC.\n  INTERFACES if_sxml_node.\n\n  DATA: BEGIN OF qname,\n          name TYPE string,\n        END OF qname.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXML_NODE', 'INTERFACE if_sxml_node PUBLIC.\n  TYPES node_type TYPE i.\n  DATA type TYPE node_type.\n\n  CONSTANTS co_nt_element_open TYPE node_type VALUE 1.\n  CONSTANTS co_nt_element_close TYPE node_type VALUE 2.\n  CONSTANTS co_nt_value TYPE node_type VALUE 4.\n  CONSTANTS co_nt_attribute TYPE node_type VALUE 32.\n  CONSTANTS co_nt_final TYPE node_type VALUE 128.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXML_OPEN_ELEMENT', 'INTERFACE if_sxml_open_element PUBLIC.\n  INTERFACES if_sxml_node.\n\n  DATA: BEGIN OF qname,\n          name TYPE string,\n        END OF qname.\n\n  METHODS get_attributes\n    RETURNING\n      VALUE(attr) TYPE if_sxml_attribute=>attributes.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXML_READER', 'INTERFACE if_sxml_reader PUBLIC.\n  DATA node_type TYPE if_sxml_node=>node_type READ-ONLY.\n  DATA name TYPE string READ-ONLY.\n  DATA value TYPE string READ-ONLY.\n\n  METHODS\n    read_next_node\n      RETURNING VALUE(node) TYPE REF TO if_sxml_node.\n\n  METHODS\n    next_node\n      IMPORTING\n        value_type TYPE if_sxml_value=>value_type DEFAULT if_sxml_value=>co_vt_text\n      RAISING\n        cx_sxml_parse_error.\n\n  METHODS next_attribute\n    IMPORTING\n      value_type TYPE if_sxml_value=>value_type OPTIONAL.\n\n  METHODS\n    skip_node\n      IMPORTING\n        writer TYPE REF TO if_sxml_writer OPTIONAL\n      RAISING\n        cx_sxml_parse_error.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXML_VALUE', 'INTERFACE if_sxml_value PUBLIC.\n\n  TYPES value_type TYPE i.\n  CONSTANTS co_vt_text TYPE value_type VALUE 2.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXML_VALUE_NODE', 'INTERFACE if_sxml_value_node PUBLIC.\n  INTERFACES if_sxml_node.\n  METHODS get_value RETURNING VALUE(val) TYPE string.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SXML_WRITER', 'INTERFACE if_sxml_writer PUBLIC.\n\n  CONSTANTS co_opt_normalizing TYPE i VALUE 1.\n  CONSTANTS co_opt_no_empty TYPE i VALUE 2.\n  CONSTANTS co_opt_ignore_conv_errros TYPE i VALUE 3.\n  CONSTANTS co_opt_linebreaks TYPE i VALUE 4.\n  CONSTANTS co_opt_indent TYPE i VALUE 5.\n  CONSTANTS co_opt_illegal_char_reject TYPE i VALUE 6.\n  CONSTANTS co_opt_illegal_char_replace TYPE i VALUE 7.\n  CONSTANTS co_opt_illegal_char_replace_by TYPE i VALUE 8.\n  CONSTANTS co_opt_base64_no_lf TYPE i VALUE 9.\n\n  METHODS open_element\n    IMPORTING\n      name   TYPE string\n      nsuri  TYPE string OPTIONAL\n      prefix TYPE string OPTIONAL\n    RAISING\n      cx_sxml_state_error\n      cx_sxml_name_error.\n\n  METHODS close_element\n    RAISING\n      cx_sxml_state_error.\n\n  METHODS write_attribute\n    IMPORTING\n      name   TYPE string\n      nsuri  TYPE string OPTIONAL\n      prefix TYPE string OPTIONAL\n      value  TYPE string OPTIONAL\n    RAISING\n      cx_sxml_state_error\n      cx_sxml_name_error.\n\n  METHODS write_value\n    IMPORTING\n      value TYPE string\n    RAISING\n      cx_sxml_state_error.\n\n  METHODS set_option\n    IMPORTING\n      option TYPE i\n      value  TYPE abap_bool DEFAULT abap_true.\n\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_APC_TCP_CLIENT_MANAGER', 'CLASS cl_apc_tcp_client_manager DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS create\n      IMPORTING\n        i_host          TYPE string\n        i_port          TYPE string\n        i_frame         TYPE if_abap_channel_types=>ty_apc_tcp_frame\n        i_event_handler TYPE REF TO if_apc_wsp_event_handler\n      RETURNING\n        VALUE(ri_client) TYPE REF TO if_apc_wsp_client\n      RAISING\n        cx_apc_error.\nENDCLASS.\n\nCLASS cl_apc_tcp_client_manager IMPLEMENTATION.\n  METHOD create.\n    CREATE OBJECT ri_client TYPE lcl_client\n      EXPORTING\n        iv_host    = i_host\n        iv_port    = i_port\n        io_handler = i_event_handler.\n  ENDMETHOD.\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_APC_ERROR', 'CLASS cx_apc_error DEFINITION PUBLIC INHERITING FROM cx_static_check.\n\nENDCLASS.\n\nCLASS cx_apc_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_ABAP_CHANNEL_TYPES', 'INTERFACE if_abap_channel_types PUBLIC.\n  TYPES: BEGIN OF ty_apc_tcp_frame,\n           frame_type          TYPE i,\n           fixed_length        TYPE i,\n           terminator          TYPE string,\n           length_field_length TYPE i,\n           length_field_offset TYPE i,\n           length_field_header TYPE i,\n         END OF ty_apc_tcp_frame.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_APC_TCP_FRAME_TYPES', 'INTERFACE if_apc_tcp_frame_types PUBLIC.\n  CONSTANTS co_frame_type_fixed_length TYPE i VALUE 1.\n  CONSTANTS co_frame_type_terminator   TYPE i VALUE 2.\n  CONSTANTS co_frame_type_length_field TYPE i VALUE 3.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_APC_WSP_CLIENT', 'INTERFACE if_apc_wsp_client PUBLIC.\n  METHODS connect.\n  METHODS close.\n  METHODS get_message_manager\n    RETURNING\n      VALUE(ri_manager) TYPE REF TO if_apc_wsp_message_manager\n    RAISING\n      cx_apc_error.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_APC_WSP_EVENT_HANDLER', 'INTERFACE if_apc_wsp_event_handler PUBLIC.\n  METHODS on_open.\n  METHODS on_message\n    IMPORTING i_message TYPE REF TO if_apc_wsp_message.\n  METHODS on_close.\n  METHODS on_error.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_APC_WSP_MESSAGE', 'INTERFACE if_apc_wsp_message PUBLIC.\n  METHODS get_binary\n    RETURNING VALUE(rv_binary) TYPE xstring\n    RAISING cx_apc_error.\n  METHODS set_binary\n    IMPORTING iv_binary TYPE xsequence\n    RAISING cx_apc_error.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_APC_WSP_MESSAGE_MANAGER', 'INTERFACE if_apc_wsp_message_manager PUBLIC.\n  METHODS create_message\n    RETURNING\n      VALUE(ri_message) TYPE REF TO if_apc_wsp_message\n    RAISING\n      cx_apc_error.\n  METHODS send\n    IMPORTING\n      ii_message TYPE REF TO if_apc_wsp_message\n    RAISING\n      cx_apc_error.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_ABAP_UNIT_ASSERT', 'CLASS cl_abap_unit_assert DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS\n      assert_equals\n        IMPORTING\n          act   TYPE any\n          exp   TYPE any\n          msg   TYPE string OPTIONAL\n          tol   TYPE f OPTIONAL\n          quit  TYPE i OPTIONAL\n          level TYPE i OPTIONAL.\n\n    CLASS-METHODS\n      assert_differs\n        IMPORTING\n          act TYPE string\n          exp TYPE string\n          msg TYPE string OPTIONAL\n          quit TYPE i OPTIONAL\n          level TYPE i OPTIONAL.\n\n    CLASS-METHODS\n      assert_number_between\n        IMPORTING\n          lower  TYPE i\n          upper  TYPE i\n          number TYPE i\n          msg    TYPE string OPTIONAL\n          quit   TYPE i OPTIONAL\n          level  TYPE i OPTIONAL.\n\n    CLASS-METHODS\n      assert_not_initial\n        IMPORTING\n          act   TYPE any\n          msg   TYPE string OPTIONAL\n          quit  TYPE i OPTIONAL\n          level TYPE i OPTIONAL.\n\n    CLASS-METHODS\n      assert_initial\n        IMPORTING\n          act   TYPE any\n          msg   TYPE string OPTIONAL\n          quit  TYPE i OPTIONAL\n          level TYPE i OPTIONAL.\n\n    CLASS-METHODS\n      skip\n        IMPORTING\n          msg    TYPE csequence\n          detail TYPE csequence OPTIONAL.\n\n    CLASS-METHODS\n      fail\n        IMPORTING\n          msg    TYPE csequence OPTIONAL\n          quit   TYPE i OPTIONAL\n          level  TYPE i OPTIONAL\n          detail TYPE csequence OPTIONAL\n        PREFERRED PARAMETER msg.\n\n    CLASS-METHODS\n      assert_subrc\n        IMPORTING\n          exp TYPE i DEFAULT 0\n          msg TYPE string OPTIONAL\n          quit TYPE i OPTIONAL\n          level TYPE i OPTIONAL\n        PREFERRED PARAMETER act.\n\n    CLASS-METHODS\n      assert_true\n        IMPORTING\n          act TYPE abap_bool\n          msg TYPE string OPTIONAL\n          quit TYPE i OPTIONAL\n          level TYPE i OPTIONAL.\n\n    CLASS-METHODS\n      assert_false\n        IMPORTING\n          act TYPE abap_bool\n          msg TYPE string OPTIONAL\n          quit TYPE i OPTIONAL\n          level TYPE i OPTIONAL.\n\n    CLASS-METHODS\n      assert_char_cp\n        IMPORTING\n          act TYPE clike\n          exp TYPE clike\n          msg TYPE string OPTIONAL\n          quit TYPE i OPTIONAL\n          level TYPE i OPTIONAL.\n\n    CLASS-METHODS\n      assert_bound\n        IMPORTING\n          act TYPE any\n          msg TYPE string OPTIONAL\n          quit TYPE i OPTIONAL\n          level TYPE i OPTIONAL.\n\n    CLASS-METHODS\n      assert_not_bound\n        IMPORTING\n          act TYPE any\n          msg TYPE string OPTIONAL\n          quit TYPE i OPTIONAL\n          level TYPE i OPTIONAL.\n\nENDCLASS.\n\nCLASS cl_abap_unit_assert IMPLEMENTATION.\n\n  METHOD assert_bound.\n    IF act IS NOT BOUND.\n      RAISE EXCEPTION TYPE kernel_cx_assert\n        EXPORTING\n          msg = |Expected value to be bound|.\n    ENDIF.\n  ENDMETHOD.\n\n  METHOD assert_not_bound.\n    IF act IS BOUND.\n      RAISE EXCEPTION TYPE kernel_cx_assert\n        EXPORTING\n          msg = |Expected value to not be bound|.\n    ENDIF.\n  ENDMETHOD.\n\n  METHOD assert_char_cp.\n    IF act NP exp.\n      RAISE EXCEPTION TYPE kernel_cx_assert.\n    ENDIF.\n  ENDMETHOD.\n\n  METHOD fail.\n    RAISE EXCEPTION TYPE kernel_cx_assert\n      EXPORTING\n        msg = msg.\n  ENDMETHOD.\n\n  METHOD skip.\n    RETURN.\n  ENDMETHOD.\n\n  METHOD assert_differs.\n    IF act = exp.\n      RAISE EXCEPTION TYPE kernel_cx_assert\n        EXPORTING\n          msg = |Expected different values|\n          act     = act\n          exp     = exp.\n    ENDIF.\n  ENDMETHOD.\n\n  METHOD assert_true.\n    IF act <> abap_true.\n      RAISE EXCEPTION TYPE kernel_cx_assert\n        EXPORTING\n          msg = |Expected abap_true|.\n    ENDIF.\n  ENDMETHOD.\n\n  METHOD assert_false.\n    IF act <> abap_false.\n      RAISE EXCEPTION TYPE kernel_cx_assert\n        EXPORTING\n          msg = |Expected abap_false|.\n    ENDIF.\n  ENDMETHOD.\n\n  METHOD assert_equals.\n    DATA type1 TYPE c LENGTH 1.\n    DATA type2 TYPE c LENGTH 1.\n    DATA index TYPE i.\n    DATA diff TYPE f.\n    FIELD-SYMBOLS <tab1> TYPE INDEX TABLE.\n    FIELD-SYMBOLS <row1> TYPE any.\n    FIELD-SYMBOLS <tab2> TYPE INDEX TABLE.\n    FIELD-SYMBOLS <row2> TYPE any.\n\n    DESCRIBE FIELD act TYPE type1.\n    DESCRIBE FIELD exp TYPE type2.\n*    WRITE ''@KERNEL console.dir(type1.get());''.\n*    WRITE ''@KERNEL console.dir(type2.get());''.\n    IF type1 CA ''CgyIFPDTXN''. \" basic types\n      IF type2 IS NOT INITIAL.\n        IF type2 NA ''CgyIFPDTXN''.\n          RAISE EXCEPTION TYPE kernel_cx_assert\n            EXPORTING\n              msg = |Unexpected types|.\n        ENDIF.\n      ENDIF.\n    ELSEIF type1 IS NOT INITIAL AND type2 IS NOT INITIAL.\n* else check the types are identical\n      IF type1 <> type2.\n        RAISE EXCEPTION TYPE kernel_cx_assert\n          EXPORTING\n            msg = |Unexpected types|.\n      ENDIF.\n    ENDIF.\n\n    IF type1 = ''h''.\n      IF lines( act ) <> lines( exp ).\n        RAISE EXCEPTION TYPE kernel_cx_assert\n          EXPORTING\n            msg = |Expected table to contain { lines( exp ) } rows, got { lines( act ) }|.\n      ENDIF.\n      ASSIGN act TO <tab1>.\n      ASSIGN exp TO <tab2>.\n      DO lines( act ) TIMES.\n        index = sy-index.\n        READ TABLE <tab1> INDEX index ASSIGNING <row1>.\n        assert_subrc( ).\n        READ TABLE <tab2> INDEX index ASSIGNING <row2>.\n        assert_subrc( ).\n        assert_equals( act = <row1>\n                       exp = <row2> ).\n      ENDDO.\n    ELSEIF tol IS SUPPLIED.\n      diff = exp - act.\n*      WRITE ''@KERNEL console.dir(tol);''.\n*      WRITE ''@KERNEL console.dir(diff);''.\n      IF diff >= tol.\n        RAISE EXCEPTION TYPE kernel_cx_assert.\n      ENDIF.\n    ELSEIF act <> exp.\n      RAISE EXCEPTION TYPE kernel_cx_assert\n        EXPORTING\n          msg  = |Expected ''{ exp }'', got ''{ act }''|\n          actual   = act\n          expected = exp.\n    ENDIF.\n  ENDMETHOD.\n\n  METHOD assert_not_initial.\n    IF act IS INITIAL.\n      RAISE EXCEPTION TYPE kernel_cx_assert\n        EXPORTING\n          msg = |Expected non initial value|.\n    ENDIF.\n  ENDMETHOD.\n\n  METHOD assert_initial.\n    IF act IS NOT INITIAL.\n      RAISE EXCEPTION TYPE kernel_cx_assert\n        EXPORTING\n          msg = |Expected initial value|.\n    ENDIF.\n  ENDMETHOD.\n\n  METHOD assert_subrc.\n    IF sy-subrc <> exp.\n      RAISE EXCEPTION TYPE kernel_cx_assert\n        EXPORTING\n          msg = |Expected sy-subrc to equal { exp }, got { sy-subrc }|.\n    ENDIF.\n  ENDMETHOD.\n\n  METHOD assert_number_between.\n    IF number < lower OR number > upper.\n      RAISE EXCEPTION TYPE kernel_cx_assert.\n    ENDIF.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_ABAP_UNIT_CONSTANT', 'INTERFACE if_abap_unit_constant PUBLIC.\n  CONSTANTS:\n    BEGIN OF severity,\n      low               TYPE int1 VALUE 0,\n      medium            TYPE int1 VALUE 1,\n      high              TYPE int1 VALUE 2,\n    END OF severity.\n  CONSTANTS:\n    BEGIN OF quit,\n      test   TYPE int1 VALUE 1,\n      no     TYPE int1 VALUE 5,\n    END OF quit.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_AUNIT_CONSTANTS', 'INTERFACE if_aunit_constants PUBLIC.\n  CONSTANTS no TYPE i VALUE 0.\n  CONSTANTS critical TYPE i VALUE 1.\n  CONSTANTS fatal TYPE i VALUE 1.\n  CONSTANTS tolerable TYPE i VALUE 1.\n  CONSTANTS method TYPE i VALUE 1.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_CX_ASSERT', 'CLASS kernel_cx_assert DEFINITION PUBLIC INHERITING FROM cx_dynamic_check.\n  PUBLIC SECTION.\n    DATA actual TYPE string.\n    DATA expected TYPE string.\n    DATA msg TYPE string.\n\n    METHODS constructor\n      IMPORTING\n        msg      TYPE string\n        previous LIKE previous OPTIONAL\n        expected LIKE expected OPTIONAL\n        actual   LIKE actual OPTIONAL.\nENDCLASS.\n\nCLASS kernel_cx_assert IMPLEMENTATION.\n\n  METHOD constructor.\n    super->constructor( previous = previous ).\n    me->expected = expected.\n    me->actual = actual.\n    me->msg = msg.\n    IF me->msg IS INITIAL.\n      me->msg = |Unit test assertion failed|.\n    ENDIF.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('KERNEL_UNIT_RUNNER', 'CLASS kernel_unit_runner DEFINITION PUBLIC.\n  PUBLIC SECTION.\n* as of now, only global classes with local testclasses are supported\n    TYPES: BEGIN OF ty_input_item,\n             class_name     TYPE c LENGTH 30,\n             testclass_name TYPE c LENGTH 30,\n             method_name    TYPE c LENGTH 30,\n           END OF ty_input_item.\n    TYPES ty_input TYPE STANDARD TABLE OF ty_input_item WITH DEFAULT KEY.\n\n    TYPES ty_status TYPE string.\n    CONSTANTS: BEGIN OF gc_status,\n                success TYPE ty_status VALUE ''SUCCESS'',\n                failed  TYPE ty_status VALUE ''FAILED'',\n                skipped TYPE ty_status VALUE ''SKIPPED'',\n               END OF gc_status.\n\n    TYPES BEGIN OF ty_result_item.\n    INCLUDE TYPE ty_input_item.\n    TYPES: expected    TYPE string,\n             actual      TYPE string,\n             status      TYPE ty_status,\n             runtime     TYPE i,\n             message     TYPE string,\n             js_location TYPE string,\n           END OF ty_result_item.\n    TYPES: BEGIN OF ty_result,\n             list TYPE STANDARD TABLE OF ty_result_item WITH DEFAULT KEY,\n             json TYPE string,\n           END OF ty_result.\n\n    CLASS-METHODS run\n      IMPORTING\n        it_input TYPE ty_input\n      RETURNING\n        VALUE(rs_result) TYPE ty_result.\n  PRIVATE SECTION.\n    TYPES: BEGIN OF ty_class_item,\n             class_name     TYPE c LENGTH 30,\n             testclass_name TYPE c LENGTH 30,\n           END OF ty_class_item.\n    TYPES ty_classes TYPE STANDARD TABLE OF ty_class_item WITH DEFAULT KEY.\n\n    CLASS-METHODS unique_classes\n      IMPORTING\n       it_input TYPE ty_input\n      RETURNING\n        VALUE(rt_classes) TYPE ty_classes.\n\n    CLASS-METHODS to_json\n      IMPORTING it_list TYPE ty_result-list\n      RETURNING VALUE(rv_json) TYPE string.\n\n    CLASS-METHODS get_location\n      IMPORTING ix_error TYPE REF TO cx_root\n      RETURNING VALUE(rv_location) TYPE string.\nENDCLASS.\n\nCLASS kernel_unit_runner IMPLEMENTATION.\n\n  METHOD get_location.\n    DATA lv_stack TYPE string.\n    DATA lt_lines TYPE STANDARD TABLE OF string WITH DEFAULT KEY.\n    DATA lv_found TYPE abap_bool.\n    WRITE ''@KERNEL lv_stack.set(INPUT.ix_error.get().stack);''.\n    SPLIT lv_stack AT |\\\\n| INTO TABLE lt_lines.\n* find whatever comes after \"cl_abap_unit_assert\"\n    LOOP AT lt_lines INTO lv_stack.\n      IF lv_stack CP ''*cl_abap_unit_assert*''.\n        lv_found = abap_true.\n        CONTINUE.\n      ELSEIF lv_found = abap_true.\n        REPLACE FIRST OCCURRENCE OF |at | IN lv_stack WITH ''''.\n        rv_location = condense( lv_stack ).\n        EXIT.\n      ENDIF.\n    ENDLOOP.\n  ENDMETHOD.\n\n  METHOD to_json.\n* would like to keep the dependencies of this class minimal,\n* so not using CALL TRANSFORMATION or any other ABAP classes\n\n    DATA ls_list LIKE LINE OF it_list.\n    DATA lt_strings TYPE STANDARD TABLE OF string WITH DEFAULT KEY.\n    DATA lv_string LIKE LINE OF lt_strings.\n    DATA lv_message TYPE string.\n\n\n    LOOP AT it_list INTO ls_list.\n      lv_message = ls_list-message.\n      REPLACE ALL OCCURRENCES OF |\"| IN lv_message WITH |\\\\\"|.\n      lv_string = |\\\\{\"class_name\": \"{ ls_list-class_name\n        }\",\"testclass_name\": \"{ ls_list-testclass_name\n        }\",\"method_name\": \"{ ls_list-method_name\n        }\",\"expected\": \"{ ls_list-expected\n        }\",\"actual\": \"{ ls_list-actual\n        }\",\"status\": \"{ ls_list-status\n        }\",\"runtime\": { ls_list-runtime\n        },\"message\": \"{ lv_message\n        }\",\"js_location\": \"{ ls_list-js_location }\"\\\\}|.\n      APPEND lv_string TO lt_strings.\n    ENDLOOP.\n    CONCATENATE LINES OF lt_strings INTO rv_json SEPARATED BY '',''.\n    rv_json = ''['' && rv_json && '']''.\n  ENDMETHOD.\n\n  METHOD unique_classes.\n    DATA ls_input LIKE LINE OF it_input.\n    DATA ls_class LIKE LINE OF rt_classes.\n    LOOP AT it_input INTO ls_input.\n      MOVE-CORRESPONDING ls_input TO ls_class.\n      INSERT ls_class INTO TABLE rt_classes.\n    ENDLOOP.\n    SORT rt_classes.\n    DELETE ADJACENT DUPLICATES FROM rt_classes.\n  ENDMETHOD.\n\n  METHOD run.\n\n    DATA ls_input   LIKE LINE OF it_input.\n    DATA lv_time    TYPE i.\n    DATA lo_obj     TYPE REF TO object.\n    DATA lv_name    TYPE string.\n    DATA lt_classes TYPE ty_classes.\n    DATA ls_class   LIKE LINE OF lt_classes.\n    DATA lx_root    TYPE REF TO cx_root.\n    DATA lx_assert  TYPE REF TO kernel_cx_assert.\n    FIELD-SYMBOLS <ls_result> LIKE LINE OF rs_result-list.\n\n* todo, respect quit level, default = method?\n\n    lt_classes = unique_classes( it_input ).\n\n    LOOP AT lt_classes INTO ls_class.\n* this is special, and must match the runtime:\n      lv_name = |CLAS-{ ls_class-class_name }-{ ls_class-testclass_name }|.\n      CREATE OBJECT lo_obj TYPE (lv_name).\n\n      TRY.\n          CALL METHOD lo_obj->(''CLASS_SETUP'').\n        CATCH cx_sy_dyn_call_illegal_method.\n      ENDTRY.\n\n      LOOP AT it_input INTO ls_input WHERE class_name = ls_class-class_name AND testclass_name = ls_class-testclass_name.\n        APPEND INITIAL LINE TO rs_result-list ASSIGNING <ls_result>.\n        MOVE-CORRESPONDING ls_input TO <ls_result>.\n\n        TRY.\n            CALL METHOD lo_obj->(''SETUP'').\n          CATCH cx_sy_dyn_call_illegal_method.\n        ENDTRY.\n\n        GET RUN TIME FIELD lv_time.\n        TRY.\n            CALL METHOD lo_obj->(ls_input-method_name).\n            <ls_result>-status = gc_status-success.\n          CATCH kernel_cx_assert INTO lx_assert.\n            <ls_result>-status      = gc_status-failed.\n            <ls_result>-actual      = lx_assert->actual.\n            <ls_result>-expected    = lx_assert->expected.\n            <ls_result>-message     = lx_assert->msg.\n            <ls_result>-js_location = get_location( lx_assert ).\n          CATCH cx_root INTO lx_root.\n            <ls_result>-status  = gc_status-failed.\n            <ls_result>-message = |Some exception raised|. \" todo, use RTTI to find the class name?\n            <ls_result>-js_location = get_location( lx_root ).\n        ENDTRY.\n        GET RUN TIME FIELD lv_time.\n        <ls_result>-runtime = lv_time.\n\n        TRY.\n            CALL METHOD lo_obj->(''TEARDOWN'').\n          CATCH cx_sy_dyn_call_illegal_method.\n        ENDTRY.\n      ENDLOOP.\n\n      TRY.\n          CALL METHOD lo_obj->(''CLASS_TEARDOWN'').\n        CATCH cx_sy_dyn_call_illegal_method.\n      ENDTRY.\n\n    ENDLOOP.\n\n    rs_result-json = to_json( rs_result-list ).\n\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_SYSTEM_UUID', 'CLASS cl_system_uuid DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    INTERFACES if_system_uuid_rfc4122_static.\n    INTERFACES if_system_uuid_static.\nENDCLASS.\n\nCLASS cl_system_uuid IMPLEMENTATION.\n\n  METHOD if_system_uuid_static~create_uuid_x16.\n    WRITE ''@KERNEL const crypto = await import(\"crypto\");''.\n    WRITE ''@KERNEL uuid.set(crypto.randomBytes(16).toString(\"hex\").toUpperCase());''.\n  ENDMETHOD.\n\n  METHOD if_system_uuid_rfc4122_static~create_uuid_c36_by_version.\n    ASSERT version = 4.\n    WRITE ''@KERNEL const crypto = await import(\"crypto\");''.\n    WRITE ''@KERNEL uuid.set(crypto.randomUUID());''.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CX_UUID_ERROR', 'CLASS cx_uuid_error DEFINITION PUBLIC INHERITING FROM cx_static_check.\n\nENDCLASS.\n\nCLASS cx_uuid_error IMPLEMENTATION.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SYSTEM_UUID_RFC4122_STATIC', 'INTERFACE if_system_uuid_rfc4122_static PUBLIC.\n  CLASS-METHODS create_uuid_c36_by_version\n    IMPORTING\n      version TYPE i\n    RETURNING\n      VALUE(uuid) TYPE sysuuid_c36\n    RAISING\n      cx_uuid_error.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('IF_SYSTEM_UUID_STATIC', 'INTERFACE if_system_uuid_static PUBLIC.\n  CLASS-METHODS create_uuid_x16\n    RETURNING\n      VALUE(uuid) TYPE sysuuid_x16\n    RAISING\n      cx_uuid_error.\nENDINTERFACE.');`);\ninsert.push(`INSERT INTO reposrc ('PROGNAME', 'DATA') VALUES ('CL_EXPRESS_ICF_SHIM', 'CLASS cl_express_icf_shim DEFINITION PUBLIC.\n  PUBLIC SECTION.\n    CLASS-METHODS run\n      IMPORTING\n        express TYPE any.\nENDCLASS.\n\nCLASS cl_express_icf_shim IMPLEMENTATION.\n\n  METHOD run.\n    DATA lv_xstr TYPE xstring.\n    DATA lv_str TYPE string.\n    DATA lv_name TYPE string.\n    DATA lv_value TYPE string.\n    DATA lv_code TYPE i.\n    DATA lv_classname TYPE string.\n    DATA lv_content_type TYPE string.\n    DATA li_handler TYPE REF TO if_http_extension.\n    DATA li_server TYPE REF TO if_http_server.\n\n    WRITE ''@KERNEL lv_classname.set(INPUT.class);''.\n    TRANSLATE lv_classname TO UPPER CASE.\n    CREATE OBJECT li_handler TYPE (lv_classname).\n    CREATE OBJECT li_server TYPE lcl_server.\n\n    WRITE ''@KERNEL lv_xstr.set(INPUT.req.body.toString(\"hex\").toUpperCase());''.\n    li_server->request->set_data( lv_xstr ).\n    WRITE ''@KERNEL lv_str.set(INPUT.req.method);''.\n    li_server->request->set_method( lv_str ).\n    WRITE ''@KERNEL for (const h in INPUT.req.headers) {''.\n    WRITE ''@KERNEL   lv_name.set(h);''.\n    WRITE ''@KERNEL   lv_value.set(INPUT.req.headers[h]);''.\n    li_server->request->set_header_field(\n      name  = lv_name\n      value = lv_value ).\n    WRITE ''@KERNEL }''.\n\n    WRITE ''@KERNEL lv_value.set(INPUT.req.path);''.\n    li_server->request->set_header_field(\n      name  = ''~path''\n      value = lv_value ).\n\n* todo, req.query\n\n********************************************************\n\n    li_handler->handle_request( li_server ).\n\n********************************************************\n\n    lv_xstr = li_server->response->get_data( ).\n    li_server->response->get_status( IMPORTING code = lv_code ).\n\n    lv_content_type = li_server->response->get_content_type( ).\n    WRITE ''@KERNEL INPUT.res.append(\"Content-Type\", lv_content_type.get());''.\n\n    WRITE ''@KERNEL INPUT.res.status(lv_code.get()).send(Buffer.from(lv_xstr.get(), \"hex\"));''.\n  ENDMETHOD.\n\nENDCLASS.');`);\ninsert.push(`INSERT INTO t000 ('MANDT', 'CCCATEGORY', 'CCNOCLIIND') VALUES ('123', '', '');`);\n  const {setup} = await Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_crypto-browserify_index_js\"), __webpack_require__.e(\"vendors-node_modules_abaplint_database-sqlite_build_index_js\"), __webpack_require__.e(\"test_setup_mjs\")]).then(__webpack_require__.bind(__webpack_require__, /*! ../test/setup.mjs */ \"./test/setup.mjs\"));\n  await setup(globalThis.abap, schemas, insert);\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://open-table-maintenance/./output/init.mjs?");

/***/ })

}]);